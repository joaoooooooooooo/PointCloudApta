function ZG(n, e) {
  for (var t = 0; t < e.length; t++) {
    const r = e[t];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const a in r)
        if (a !== "default" && !(a in n)) {
          const s = Object.getOwnPropertyDescriptor(r, a);
          s && Object.defineProperty(n, a, s.get ? s : {
            enumerable: !0,
            get: () => r[a]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
function GE(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var pL = { exports: {} }, $1 = {}, iC = { exports: {} }, Ni = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jU;
function JG() {
  if (jU)
    return Ni;
  jU = 1;
  var n = Symbol.for("react.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), u = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), y = Symbol.for("react.memo"), _ = Symbol.for("react.lazy"), b = Symbol.iterator;
  function M(X) {
    return X === null || typeof X != "object" ? null : (X = b && X[b] || X["@@iterator"], typeof X == "function" ? X : null);
  }
  var C = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, D = Object.assign, U = {};
  function N(X, me, ce) {
    this.props = X, this.context = me, this.refs = U, this.updater = ce || C;
  }
  N.prototype.isReactComponent = {}, N.prototype.setState = function(X, me) {
    if (typeof X != "object" && typeof X != "function" && X != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, X, me, "setState");
  }, N.prototype.forceUpdate = function(X) {
    this.updater.enqueueForceUpdate(this, X, "forceUpdate");
  };
  function O() {
  }
  O.prototype = N.prototype;
  function I(X, me, ce) {
    this.props = X, this.context = me, this.refs = U, this.updater = ce || C;
  }
  var k = I.prototype = new O();
  k.constructor = I, D(k, N.prototype), k.isPureReactComponent = !0;
  var G = Array.isArray, j = Object.prototype.hasOwnProperty, Y = { current: null }, Z = { key: !0, ref: !0, __self: !0, __source: !0 };
  function te(X, me, ce) {
    var Ue, Oe = {}, Ze = null, je = null;
    if (me != null)
      for (Ue in me.ref !== void 0 && (je = me.ref), me.key !== void 0 && (Ze = "" + me.key), me)
        j.call(me, Ue) && !Z.hasOwnProperty(Ue) && (Oe[Ue] = me[Ue]);
    var Je = arguments.length - 2;
    if (Je === 1)
      Oe.children = ce;
    else if (1 < Je) {
      for (var at = Array(Je), xt = 0; xt < Je; xt++)
        at[xt] = arguments[xt + 2];
      Oe.children = at;
    }
    if (X && X.defaultProps)
      for (Ue in Je = X.defaultProps, Je)
        Oe[Ue] === void 0 && (Oe[Ue] = Je[Ue]);
    return { $$typeof: n, type: X, key: Ze, ref: je, props: Oe, _owner: Y.current };
  }
  function J(X, me) {
    return { $$typeof: n, type: X.type, key: me, ref: X.ref, props: X.props, _owner: X._owner };
  }
  function q(X) {
    return typeof X == "object" && X !== null && X.$$typeof === n;
  }
  function oe(X) {
    var me = { "=": "=0", ":": "=2" };
    return "$" + X.replace(/[=:]/g, function(ce) {
      return me[ce];
    });
  }
  var ye = /\/+/g;
  function de(X, me) {
    return typeof X == "object" && X !== null && X.key != null ? oe("" + X.key) : me.toString(36);
  }
  function xe(X, me, ce, Ue, Oe) {
    var Ze = typeof X;
    (Ze === "undefined" || Ze === "boolean") && (X = null);
    var je = !1;
    if (X === null)
      je = !0;
    else
      switch (Ze) {
        case "string":
        case "number":
          je = !0;
          break;
        case "object":
          switch (X.$$typeof) {
            case n:
            case e:
              je = !0;
          }
      }
    if (je)
      return je = X, Oe = Oe(je), X = Ue === "" ? "." + de(je, 0) : Ue, G(Oe) ? (ce = "", X != null && (ce = X.replace(ye, "$&/") + "/"), xe(Oe, me, ce, "", function(xt) {
        return xt;
      })) : Oe != null && (q(Oe) && (Oe = J(Oe, ce + (!Oe.key || je && je.key === Oe.key ? "" : ("" + Oe.key).replace(ye, "$&/") + "/") + X)), me.push(Oe)), 1;
    if (je = 0, Ue = Ue === "" ? "." : Ue + ":", G(X))
      for (var Je = 0; Je < X.length; Je++) {
        Ze = X[Je];
        var at = Ue + de(Ze, Je);
        je += xe(Ze, me, ce, at, Oe);
      }
    else if (at = M(X), typeof at == "function")
      for (X = at.call(X), Je = 0; !(Ze = X.next()).done; )
        Ze = Ze.value, at = Ue + de(Ze, Je++), je += xe(Ze, me, ce, at, Oe);
    else if (Ze === "object")
      throw me = String(X), Error("Objects are not valid as a React child (found: " + (me === "[object Object]" ? "object with keys {" + Object.keys(X).join(", ") + "}" : me) + "). If you meant to render a collection of children, use an array instead.");
    return je;
  }
  function Re(X, me, ce) {
    if (X == null)
      return X;
    var Ue = [], Oe = 0;
    return xe(X, Ue, "", "", function(Ze) {
      return me.call(ce, Ze, Oe++);
    }), Ue;
  }
  function Pe(X) {
    if (X._status === -1) {
      var me = X._result;
      me = me(), me.then(function(ce) {
        (X._status === 0 || X._status === -1) && (X._status = 1, X._result = ce);
      }, function(ce) {
        (X._status === 0 || X._status === -1) && (X._status = 2, X._result = ce);
      }), X._status === -1 && (X._status = 0, X._result = me);
    }
    if (X._status === 1)
      return X._result.default;
    throw X._result;
  }
  var Te = { current: null }, ue = { transition: null }, we = { ReactCurrentDispatcher: Te, ReactCurrentBatchConfig: ue, ReactCurrentOwner: Y };
  return Ni.Children = { map: Re, forEach: function(X, me, ce) {
    Re(X, function() {
      me.apply(this, arguments);
    }, ce);
  }, count: function(X) {
    var me = 0;
    return Re(X, function() {
      me++;
    }), me;
  }, toArray: function(X) {
    return Re(X, function(me) {
      return me;
    }) || [];
  }, only: function(X) {
    if (!q(X))
      throw Error("React.Children.only expected to receive a single React element child.");
    return X;
  } }, Ni.Component = N, Ni.Fragment = t, Ni.Profiler = a, Ni.PureComponent = I, Ni.StrictMode = r, Ni.Suspense = v, Ni.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = we, Ni.cloneElement = function(X, me, ce) {
    if (X == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + X + ".");
    var Ue = D({}, X.props), Oe = X.key, Ze = X.ref, je = X._owner;
    if (me != null) {
      if (me.ref !== void 0 && (Ze = me.ref, je = Y.current), me.key !== void 0 && (Oe = "" + me.key), X.type && X.type.defaultProps)
        var Je = X.type.defaultProps;
      for (at in me)
        j.call(me, at) && !Z.hasOwnProperty(at) && (Ue[at] = me[at] === void 0 && Je !== void 0 ? Je[at] : me[at]);
    }
    var at = arguments.length - 2;
    if (at === 1)
      Ue.children = ce;
    else if (1 < at) {
      Je = Array(at);
      for (var xt = 0; xt < at; xt++)
        Je[xt] = arguments[xt + 2];
      Ue.children = Je;
    }
    return { $$typeof: n, type: X.type, key: Oe, ref: Ze, props: Ue, _owner: je };
  }, Ni.createContext = function(X) {
    return X = { $$typeof: u, _currentValue: X, _currentValue2: X, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, X.Provider = { $$typeof: s, _context: X }, X.Consumer = X;
  }, Ni.createElement = te, Ni.createFactory = function(X) {
    var me = te.bind(null, X);
    return me.type = X, me;
  }, Ni.createRef = function() {
    return { current: null };
  }, Ni.forwardRef = function(X) {
    return { $$typeof: h, render: X };
  }, Ni.isValidElement = q, Ni.lazy = function(X) {
    return { $$typeof: _, _payload: { _status: -1, _result: X }, _init: Pe };
  }, Ni.memo = function(X, me) {
    return { $$typeof: y, type: X, compare: me === void 0 ? null : me };
  }, Ni.startTransition = function(X) {
    var me = ue.transition;
    ue.transition = {};
    try {
      X();
    } finally {
      ue.transition = me;
    }
  }, Ni.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, Ni.useCallback = function(X, me) {
    return Te.current.useCallback(X, me);
  }, Ni.useContext = function(X) {
    return Te.current.useContext(X);
  }, Ni.useDebugValue = function() {
  }, Ni.useDeferredValue = function(X) {
    return Te.current.useDeferredValue(X);
  }, Ni.useEffect = function(X, me) {
    return Te.current.useEffect(X, me);
  }, Ni.useId = function() {
    return Te.current.useId();
  }, Ni.useImperativeHandle = function(X, me, ce) {
    return Te.current.useImperativeHandle(X, me, ce);
  }, Ni.useInsertionEffect = function(X, me) {
    return Te.current.useInsertionEffect(X, me);
  }, Ni.useLayoutEffect = function(X, me) {
    return Te.current.useLayoutEffect(X, me);
  }, Ni.useMemo = function(X, me) {
    return Te.current.useMemo(X, me);
  }, Ni.useReducer = function(X, me, ce) {
    return Te.current.useReducer(X, me, ce);
  }, Ni.useRef = function(X) {
    return Te.current.useRef(X);
  }, Ni.useState = function(X) {
    return Te.current.useState(X);
  }, Ni.useSyncExternalStore = function(X, me, ce) {
    return Te.current.useSyncExternalStore(X, me, ce);
  }, Ni.useTransition = function() {
    return Te.current.useTransition();
  }, Ni.version = "18.2.0", Ni;
}
var uT = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
uT.exports;
var $U;
function e6() {
  return $U || ($U = 1, function(n, e) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = "18.2.0", r = Symbol.for("react.element"), a = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), u = Symbol.for("react.strict_mode"), h = Symbol.for("react.profiler"), v = Symbol.for("react.provider"), y = Symbol.for("react.context"), _ = Symbol.for("react.forward_ref"), b = Symbol.for("react.suspense"), M = Symbol.for("react.suspense_list"), C = Symbol.for("react.memo"), D = Symbol.for("react.lazy"), U = Symbol.for("react.offscreen"), N = Symbol.iterator, O = "@@iterator";
      function I(ne) {
        if (ne === null || typeof ne != "object")
          return null;
        var De = N && ne[N] || ne[O];
        return typeof De == "function" ? De : null;
      }
      var k = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, G = {
        transition: null
      }, j = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, Y = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, Z = {}, te = null;
      function J(ne) {
        te = ne;
      }
      Z.setExtraStackFrame = function(ne) {
        te = ne;
      }, Z.getCurrentStack = null, Z.getStackAddendum = function() {
        var ne = "";
        te && (ne += te);
        var De = Z.getCurrentStack;
        return De && (ne += De() || ""), ne;
      };
      var q = !1, oe = !1, ye = !1, de = !1, xe = !1, Re = {
        ReactCurrentDispatcher: k,
        ReactCurrentBatchConfig: G,
        ReactCurrentOwner: Y
      };
      Re.ReactDebugCurrentFrame = Z, Re.ReactCurrentActQueue = j;
      function Pe(ne) {
        {
          for (var De = arguments.length, st = new Array(De > 1 ? De - 1 : 0), yt = 1; yt < De; yt++)
            st[yt - 1] = arguments[yt];
          ue("warn", ne, st);
        }
      }
      function Te(ne) {
        {
          for (var De = arguments.length, st = new Array(De > 1 ? De - 1 : 0), yt = 1; yt < De; yt++)
            st[yt - 1] = arguments[yt];
          ue("error", ne, st);
        }
      }
      function ue(ne, De, st) {
        {
          var yt = Re.ReactDebugCurrentFrame, Zt = yt.getStackAddendum();
          Zt !== "" && (De += "%s", st = st.concat([Zt]));
          var Xn = st.map(function(mn) {
            return String(mn);
          });
          Xn.unshift("Warning: " + De), Function.prototype.apply.call(console[ne], console, Xn);
        }
      }
      var we = {};
      function X(ne, De) {
        {
          var st = ne.constructor, yt = st && (st.displayName || st.name) || "ReactClass", Zt = yt + "." + De;
          if (we[Zt])
            return;
          Te("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", De, yt), we[Zt] = !0;
        }
      }
      var me = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(ne) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(ne, De, st) {
          X(ne, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(ne, De, st, yt) {
          X(ne, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(ne, De, st, yt) {
          X(ne, "setState");
        }
      }, ce = Object.assign, Ue = {};
      Object.freeze(Ue);
      function Oe(ne, De, st) {
        this.props = ne, this.context = De, this.refs = Ue, this.updater = st || me;
      }
      Oe.prototype.isReactComponent = {}, Oe.prototype.setState = function(ne, De) {
        if (typeof ne != "object" && typeof ne != "function" && ne != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, ne, De, "setState");
      }, Oe.prototype.forceUpdate = function(ne) {
        this.updater.enqueueForceUpdate(this, ne, "forceUpdate");
      };
      {
        var Ze = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, je = function(ne, De) {
          Object.defineProperty(Oe.prototype, ne, {
            get: function() {
              Pe("%s(...) is deprecated in plain JavaScript React classes. %s", De[0], De[1]);
            }
          });
        };
        for (var Je in Ze)
          Ze.hasOwnProperty(Je) && je(Je, Ze[Je]);
      }
      function at() {
      }
      at.prototype = Oe.prototype;
      function xt(ne, De, st) {
        this.props = ne, this.context = De, this.refs = Ue, this.updater = st || me;
      }
      var $t = xt.prototype = new at();
      $t.constructor = xt, ce($t, Oe.prototype), $t.isPureReactComponent = !0;
      function Ht() {
        var ne = {
          current: null
        };
        return Object.seal(ne), ne;
      }
      var he = Array.isArray;
      function nt(ne) {
        return he(ne);
      }
      function et(ne) {
        {
          var De = typeof Symbol == "function" && Symbol.toStringTag, st = De && ne[Symbol.toStringTag] || ne.constructor.name || "Object";
          return st;
        }
      }
      function Rt(ne) {
        try {
          return gt(ne), !1;
        } catch {
          return !0;
        }
      }
      function gt(ne) {
        return "" + ne;
      }
      function Jt(ne) {
        if (Rt(ne))
          return Te("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", et(ne)), gt(ne);
      }
      function Kt(ne, De, st) {
        var yt = ne.displayName;
        if (yt)
          return yt;
        var Zt = De.displayName || De.name || "";
        return Zt !== "" ? st + "(" + Zt + ")" : st;
      }
      function qt(ne) {
        return ne.displayName || "Context";
      }
      function hn(ne) {
        if (ne == null)
          return null;
        if (typeof ne.tag == "number" && Te("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ne == "function")
          return ne.displayName || ne.name || null;
        if (typeof ne == "string")
          return ne;
        switch (ne) {
          case s:
            return "Fragment";
          case a:
            return "Portal";
          case h:
            return "Profiler";
          case u:
            return "StrictMode";
          case b:
            return "Suspense";
          case M:
            return "SuspenseList";
        }
        if (typeof ne == "object")
          switch (ne.$$typeof) {
            case y:
              var De = ne;
              return qt(De) + ".Consumer";
            case v:
              var st = ne;
              return qt(st._context) + ".Provider";
            case _:
              return Kt(ne, ne.render, "ForwardRef");
            case C:
              var yt = ne.displayName || null;
              return yt !== null ? yt : hn(ne.type) || "Memo";
            case D: {
              var Zt = ne, Xn = Zt._payload, mn = Zt._init;
              try {
                return hn(mn(Xn));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Rn = Object.prototype.hasOwnProperty, Yn = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, se, ae, Ke;
      Ke = {};
      function wt(ne) {
        if (Rn.call(ne, "ref")) {
          var De = Object.getOwnPropertyDescriptor(ne, "ref").get;
          if (De && De.isReactWarning)
            return !1;
        }
        return ne.ref !== void 0;
      }
      function _t(ne) {
        if (Rn.call(ne, "key")) {
          var De = Object.getOwnPropertyDescriptor(ne, "key").get;
          if (De && De.isReactWarning)
            return !1;
        }
        return ne.key !== void 0;
      }
      function Vt(ne, De) {
        var st = function() {
          se || (se = !0, Te("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", De));
        };
        st.isReactWarning = !0, Object.defineProperty(ne, "key", {
          get: st,
          configurable: !0
        });
      }
      function fn(ne, De) {
        var st = function() {
          ae || (ae = !0, Te("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", De));
        };
        st.isReactWarning = !0, Object.defineProperty(ne, "ref", {
          get: st,
          configurable: !0
        });
      }
      function Wt(ne) {
        if (typeof ne.ref == "string" && Y.current && ne.__self && Y.current.stateNode !== ne.__self) {
          var De = hn(Y.current.type);
          Ke[De] || (Te('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', De, ne.ref), Ke[De] = !0);
        }
      }
      var Ee = function(ne, De, st, yt, Zt, Xn, mn) {
        var qn = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: ne,
          key: De,
          ref: st,
          props: mn,
          // Record the component responsible for creating this element.
          _owner: Xn
        };
        return qn._store = {}, Object.defineProperty(qn._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(qn, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: yt
        }), Object.defineProperty(qn, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Zt
        }), Object.freeze && (Object.freeze(qn.props), Object.freeze(qn)), qn;
      };
      function Xe(ne, De, st) {
        var yt, Zt = {}, Xn = null, mn = null, qn = null, Nr = null;
        if (De != null) {
          wt(De) && (mn = De.ref, Wt(De)), _t(De) && (Jt(De.key), Xn = "" + De.key), qn = De.__self === void 0 ? null : De.__self, Nr = De.__source === void 0 ? null : De.__source;
          for (yt in De)
            Rn.call(De, yt) && !Yn.hasOwnProperty(yt) && (Zt[yt] = De[yt]);
        }
        var ri = arguments.length - 2;
        if (ri === 1)
          Zt.children = st;
        else if (ri > 1) {
          for (var Ti = Array(ri), Br = 0; Br < ri; Br++)
            Ti[Br] = arguments[Br + 2];
          Object.freeze && Object.freeze(Ti), Zt.children = Ti;
        }
        if (ne && ne.defaultProps) {
          var Qr = ne.defaultProps;
          for (yt in Qr)
            Zt[yt] === void 0 && (Zt[yt] = Qr[yt]);
        }
        if (Xn || mn) {
          var li = typeof ne == "function" ? ne.displayName || ne.name || "Unknown" : ne;
          Xn && Vt(Zt, li), mn && fn(Zt, li);
        }
        return Ee(ne, Xn, mn, qn, Nr, Y.current, Zt);
      }
      function St(ne, De) {
        var st = Ee(ne.type, De, ne.ref, ne._self, ne._source, ne._owner, ne.props);
        return st;
      }
      function Ut(ne, De, st) {
        if (ne == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + ne + ".");
        var yt, Zt = ce({}, ne.props), Xn = ne.key, mn = ne.ref, qn = ne._self, Nr = ne._source, ri = ne._owner;
        if (De != null) {
          wt(De) && (mn = De.ref, ri = Y.current), _t(De) && (Jt(De.key), Xn = "" + De.key);
          var Ti;
          ne.type && ne.type.defaultProps && (Ti = ne.type.defaultProps);
          for (yt in De)
            Rn.call(De, yt) && !Yn.hasOwnProperty(yt) && (De[yt] === void 0 && Ti !== void 0 ? Zt[yt] = Ti[yt] : Zt[yt] = De[yt]);
        }
        var Br = arguments.length - 2;
        if (Br === 1)
          Zt.children = st;
        else if (Br > 1) {
          for (var Qr = Array(Br), li = 0; li < Br; li++)
            Qr[li] = arguments[li + 2];
          Zt.children = Qr;
        }
        return Ee(ne.type, Xn, mn, qn, Nr, ri, Zt);
      }
      function Se(ne) {
        return typeof ne == "object" && ne !== null && ne.$$typeof === r;
      }
      var Ye = ".", bt = ":";
      function Tt(ne) {
        var De = /[=:]/g, st = {
          "=": "=0",
          ":": "=2"
        }, yt = ne.replace(De, function(Zt) {
          return st[Zt];
        });
        return "$" + yt;
      }
      var ge = !1, zt = /\/+/g;
      function Fe(ne) {
        return ne.replace(zt, "$&/");
      }
      function ft(ne, De) {
        return typeof ne == "object" && ne !== null && ne.key != null ? (Jt(ne.key), Tt("" + ne.key)) : De.toString(36);
      }
      function ln(ne, De, st, yt, Zt) {
        var Xn = typeof ne;
        (Xn === "undefined" || Xn === "boolean") && (ne = null);
        var mn = !1;
        if (ne === null)
          mn = !0;
        else
          switch (Xn) {
            case "string":
            case "number":
              mn = !0;
              break;
            case "object":
              switch (ne.$$typeof) {
                case r:
                case a:
                  mn = !0;
              }
          }
        if (mn) {
          var qn = ne, Nr = Zt(qn), ri = yt === "" ? Ye + ft(qn, 0) : yt;
          if (nt(Nr)) {
            var Ti = "";
            ri != null && (Ti = Fe(ri) + "/"), ln(Nr, De, Ti, "", function(hm) {
              return hm;
            });
          } else
            Nr != null && (Se(Nr) && (Nr.key && (!qn || qn.key !== Nr.key) && Jt(Nr.key), Nr = St(
              Nr,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              st + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (Nr.key && (!qn || qn.key !== Nr.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                Fe("" + Nr.key) + "/"
              ) : "") + ri
            )), De.push(Nr));
          return 1;
        }
        var Br, Qr, li = 0, $r = yt === "" ? Ye : yt + bt;
        if (nt(ne))
          for (var Cl = 0; Cl < ne.length; Cl++)
            Br = ne[Cl], Qr = $r + ft(Br, Cl), li += ln(Br, De, st, Qr, Zt);
        else {
          var rl = I(ne);
          if (typeof rl == "function") {
            var eu = ne;
            rl === eu.entries && (ge || Pe("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), ge = !0);
            for (var fh = rl.call(eu), tu, Rf = 0; !(tu = fh.next()).done; )
              Br = tu.value, Qr = $r + ft(Br, Rf++), li += ln(Br, De, st, Qr, Zt);
          } else if (Xn === "object") {
            var dh = String(ne);
            throw new Error("Objects are not valid as a React child (found: " + (dh === "[object Object]" ? "object with keys {" + Object.keys(ne).join(", ") + "}" : dh) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return li;
      }
      function zn(ne, De, st) {
        if (ne == null)
          return ne;
        var yt = [], Zt = 0;
        return ln(ne, yt, "", "", function(Xn) {
          return De.call(st, Xn, Zt++);
        }), yt;
      }
      function yr(ne) {
        var De = 0;
        return zn(ne, function() {
          De++;
        }), De;
      }
      function ti(ne, De, st) {
        zn(ne, function() {
          De.apply(this, arguments);
        }, st);
      }
      function rr(ne) {
        return zn(ne, function(De) {
          return De;
        }) || [];
      }
      function vr(ne) {
        if (!Se(ne))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return ne;
      }
      function Ai(ne) {
        var De = {
          $$typeof: y,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: ne,
          _currentValue2: ne,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        De.Provider = {
          $$typeof: v,
          _context: De
        };
        var st = !1, yt = !1, Zt = !1;
        {
          var Xn = {
            $$typeof: y,
            _context: De
          };
          Object.defineProperties(Xn, {
            Provider: {
              get: function() {
                return yt || (yt = !0, Te("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), De.Provider;
              },
              set: function(mn) {
                De.Provider = mn;
              }
            },
            _currentValue: {
              get: function() {
                return De._currentValue;
              },
              set: function(mn) {
                De._currentValue = mn;
              }
            },
            _currentValue2: {
              get: function() {
                return De._currentValue2;
              },
              set: function(mn) {
                De._currentValue2 = mn;
              }
            },
            _threadCount: {
              get: function() {
                return De._threadCount;
              },
              set: function(mn) {
                De._threadCount = mn;
              }
            },
            Consumer: {
              get: function() {
                return st || (st = !0, Te("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), De.Consumer;
              }
            },
            displayName: {
              get: function() {
                return De.displayName;
              },
              set: function(mn) {
                Zt || (Pe("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", mn), Zt = !0);
              }
            }
          }), De.Consumer = Xn;
        }
        return De._currentRenderer = null, De._currentRenderer2 = null, De;
      }
      var oi = -1, Ma = 0, Ji = 1, _l = 2;
      function ea(ne) {
        if (ne._status === oi) {
          var De = ne._result, st = De();
          if (st.then(function(Xn) {
            if (ne._status === Ma || ne._status === oi) {
              var mn = ne;
              mn._status = Ji, mn._result = Xn;
            }
          }, function(Xn) {
            if (ne._status === Ma || ne._status === oi) {
              var mn = ne;
              mn._status = _l, mn._result = Xn;
            }
          }), ne._status === oi) {
            var yt = ne;
            yt._status = Ma, yt._result = st;
          }
        }
        if (ne._status === Ji) {
          var Zt = ne._result;
          return Zt === void 0 && Te(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Zt), "default" in Zt || Te(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Zt), Zt.default;
        } else
          throw ne._result;
      }
      function _o(ne) {
        var De = {
          // We use these fields to store the result.
          _status: oi,
          _result: ne
        }, st = {
          $$typeof: D,
          _payload: De,
          _init: ea
        };
        {
          var yt, Zt;
          Object.defineProperties(st, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return yt;
              },
              set: function(Xn) {
                Te("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), yt = Xn, Object.defineProperty(st, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return Zt;
              },
              set: function(Xn) {
                Te("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Zt = Xn, Object.defineProperty(st, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return st;
      }
      function Eo(ne) {
        ne != null && ne.$$typeof === C ? Te("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof ne != "function" ? Te("forwardRef requires a render function but was given %s.", ne === null ? "null" : typeof ne) : ne.length !== 0 && ne.length !== 2 && Te("forwardRef render functions accept exactly two parameters: props and ref. %s", ne.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), ne != null && (ne.defaultProps != null || ne.propTypes != null) && Te("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var De = {
          $$typeof: _,
          render: ne
        };
        {
          var st;
          Object.defineProperty(De, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return st;
            },
            set: function(yt) {
              st = yt, !ne.name && !ne.displayName && (ne.displayName = yt);
            }
          });
        }
        return De;
      }
      var Le;
      Le = Symbol.for("react.module.reference");
      function Bt(ne) {
        return !!(typeof ne == "string" || typeof ne == "function" || ne === s || ne === h || xe || ne === u || ne === b || ne === M || de || ne === U || q || oe || ye || typeof ne == "object" && ne !== null && (ne.$$typeof === D || ne.$$typeof === C || ne.$$typeof === v || ne.$$typeof === y || ne.$$typeof === _ || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        ne.$$typeof === Le || ne.getModuleId !== void 0));
      }
      function en(ne, De) {
        Bt(ne) || Te("memo: The first argument must be a component. Instead received: %s", ne === null ? "null" : typeof ne);
        var st = {
          $$typeof: C,
          type: ne,
          compare: De === void 0 ? null : De
        };
        {
          var yt;
          Object.defineProperty(st, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return yt;
            },
            set: function(Zt) {
              yt = Zt, !ne.name && !ne.displayName && (ne.displayName = Zt);
            }
          });
        }
        return st;
      }
      function _n() {
        var ne = k.current;
        return ne === null && Te(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), ne;
      }
      function ve(ne) {
        var De = _n();
        if (ne._context !== void 0) {
          var st = ne._context;
          st.Consumer === ne ? Te("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : st.Provider === ne && Te("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return De.useContext(ne);
      }
      function $e(ne) {
        var De = _n();
        return De.useState(ne);
      }
      function qe(ne, De, st) {
        var yt = _n();
        return yt.useReducer(ne, De, st);
      }
      function ze(ne) {
        var De = _n();
        return De.useRef(ne);
      }
      function dt(ne, De) {
        var st = _n();
        return st.useEffect(ne, De);
      }
      function tn(ne, De) {
        var st = _n();
        return st.useInsertionEffect(ne, De);
      }
      function pn(ne, De) {
        var st = _n();
        return st.useLayoutEffect(ne, De);
      }
      function An(ne, De) {
        var st = _n();
        return st.useCallback(ne, De);
      }
      function Gn(ne, De) {
        var st = _n();
        return st.useMemo(ne, De);
      }
      function cr(ne, De, st) {
        var yt = _n();
        return yt.useImperativeHandle(ne, De, st);
      }
      function sn(ne, De) {
        {
          var st = _n();
          return st.useDebugValue(ne, De);
        }
      }
      function pr() {
        var ne = _n();
        return ne.useTransition();
      }
      function Pr(ne) {
        var De = _n();
        return De.useDeferredValue(ne);
      }
      function kn() {
        var ne = _n();
        return ne.useId();
      }
      function za(ne, De, st) {
        var yt = _n();
        return yt.useSyncExternalStore(ne, De, st);
      }
      var Ja = 0, Si, ir, Cr, fr, Di, wa, ni;
      function ss() {
      }
      ss.__reactDisabledLog = !0;
      function ta() {
        {
          if (Ja === 0) {
            Si = console.log, ir = console.info, Cr = console.warn, fr = console.error, Di = console.group, wa = console.groupCollapsed, ni = console.groupEnd;
            var ne = {
              configurable: !0,
              enumerable: !0,
              value: ss,
              writable: !0
            };
            Object.defineProperties(console, {
              info: ne,
              log: ne,
              warn: ne,
              error: ne,
              group: ne,
              groupCollapsed: ne,
              groupEnd: ne
            });
          }
          Ja++;
        }
      }
      function Vi() {
        {
          if (Ja--, Ja === 0) {
            var ne = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: ce({}, ne, {
                value: Si
              }),
              info: ce({}, ne, {
                value: ir
              }),
              warn: ce({}, ne, {
                value: Cr
              }),
              error: ce({}, ne, {
                value: fr
              }),
              group: ce({}, ne, {
                value: Di
              }),
              groupCollapsed: ce({}, ne, {
                value: wa
              }),
              groupEnd: ce({}, ne, {
                value: ni
              })
            });
          }
          Ja < 0 && Te("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Po = Re.ReactCurrentDispatcher, Ui;
      function El(ne, De, st) {
        {
          if (Ui === void 0)
            try {
              throw Error();
            } catch (Zt) {
              var yt = Zt.stack.trim().match(/\n( *(at )?)/);
              Ui = yt && yt[1] || "";
            }
          return `
` + Ui + ne;
        }
      }
      var Ds = !1, bl;
      {
        var Go = typeof WeakMap == "function" ? WeakMap : Map;
        bl = new Go();
      }
      function Mf(ne, De) {
        if (!ne || Ds)
          return "";
        {
          var st = bl.get(ne);
          if (st !== void 0)
            return st;
        }
        var yt;
        Ds = !0;
        var Zt = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Xn;
        Xn = Po.current, Po.current = null, ta();
        try {
          if (De) {
            var mn = function() {
              throw Error();
            };
            if (Object.defineProperty(mn.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(mn, []);
              } catch ($r) {
                yt = $r;
              }
              Reflect.construct(ne, [], mn);
            } else {
              try {
                mn.call();
              } catch ($r) {
                yt = $r;
              }
              ne.call(mn.prototype);
            }
          } else {
            try {
              throw Error();
            } catch ($r) {
              yt = $r;
            }
            ne();
          }
        } catch ($r) {
          if ($r && yt && typeof $r.stack == "string") {
            for (var qn = $r.stack.split(`
`), Nr = yt.stack.split(`
`), ri = qn.length - 1, Ti = Nr.length - 1; ri >= 1 && Ti >= 0 && qn[ri] !== Nr[Ti]; )
              Ti--;
            for (; ri >= 1 && Ti >= 0; ri--, Ti--)
              if (qn[ri] !== Nr[Ti]) {
                if (ri !== 1 || Ti !== 1)
                  do
                    if (ri--, Ti--, Ti < 0 || qn[ri] !== Nr[Ti]) {
                      var Br = `
` + qn[ri].replace(" at new ", " at ");
                      return ne.displayName && Br.includes("<anonymous>") && (Br = Br.replace("<anonymous>", ne.displayName)), typeof ne == "function" && bl.set(ne, Br), Br;
                    }
                  while (ri >= 1 && Ti >= 0);
                break;
              }
          }
        } finally {
          Ds = !1, Po.current = Xn, Vi(), Error.prepareStackTrace = Zt;
        }
        var Qr = ne ? ne.displayName || ne.name : "", li = Qr ? El(Qr) : "";
        return typeof ne == "function" && bl.set(ne, li), li;
      }
      function Qu(ne, De, st) {
        return Mf(ne, !1);
      }
      function fm(ne) {
        var De = ne.prototype;
        return !!(De && De.isReactComponent);
      }
      function Tl(ne, De, st) {
        if (ne == null)
          return "";
        if (typeof ne == "function")
          return Mf(ne, fm(ne));
        if (typeof ne == "string")
          return El(ne);
        switch (ne) {
          case b:
            return El("Suspense");
          case M:
            return El("SuspenseList");
        }
        if (typeof ne == "object")
          switch (ne.$$typeof) {
            case _:
              return Qu(ne.render);
            case C:
              return Tl(ne.type, De, st);
            case D: {
              var yt = ne, Zt = yt._payload, Xn = yt._init;
              try {
                return Tl(Xn(Zt), De, st);
              } catch {
              }
            }
          }
        return "";
      }
      var Kr = {}, Ml = Re.ReactDebugCurrentFrame;
      function Zu(ne) {
        if (ne) {
          var De = ne._owner, st = Tl(ne.type, ne._source, De ? De.type : null);
          Ml.setExtraStackFrame(st);
        } else
          Ml.setExtraStackFrame(null);
      }
      function ls(ne, De, st, yt, Zt) {
        {
          var Xn = Function.call.bind(Rn);
          for (var mn in ne)
            if (Xn(ne, mn)) {
              var qn = void 0;
              try {
                if (typeof ne[mn] != "function") {
                  var Nr = Error((yt || "React class") + ": " + st + " type `" + mn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ne[mn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Nr.name = "Invariant Violation", Nr;
                }
                qn = ne[mn](De, mn, yt, st, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ri) {
                qn = ri;
              }
              qn && !(qn instanceof Error) && (Zu(Zt), Te("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", yt || "React class", st, mn, typeof qn), Zu(null)), qn instanceof Error && !(qn.message in Kr) && (Kr[qn.message] = !0, Zu(Zt), Te("Failed %s type: %s", st, qn.message), Zu(null));
            }
        }
      }
      function jr(ne) {
        if (ne) {
          var De = ne._owner, st = Tl(ne.type, ne._source, De ? De.type : null);
          J(st);
        } else
          J(null);
      }
      var lo;
      lo = !1;
      function wf() {
        if (Y.current) {
          var ne = hn(Y.current.type);
          if (ne)
            return `

Check the render method of \`` + ne + "`.";
        }
        return "";
      }
      function lr(ne) {
        if (ne !== void 0) {
          var De = ne.fileName.replace(/^.*[\\\/]/, ""), st = ne.lineNumber;
          return `

Check your code at ` + De + ":" + st + ".";
        }
        return "";
      }
      function pd(ne) {
        return ne != null ? lr(ne.__source) : "";
      }
      var pa = {};
      function br(ne) {
        var De = wf();
        if (!De) {
          var st = typeof ne == "string" ? ne : ne.displayName || ne.name;
          st && (De = `

Check the top-level render call using <` + st + ">.");
        }
        return De;
      }
      function us(ne, De) {
        if (!(!ne._store || ne._store.validated || ne.key != null)) {
          ne._store.validated = !0;
          var st = br(De);
          if (!pa[st]) {
            pa[st] = !0;
            var yt = "";
            ne && ne._owner && ne._owner !== Y.current && (yt = " It was passed a child from " + hn(ne._owner.type) + "."), jr(ne), Te('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', st, yt), jr(null);
          }
        }
      }
      function Ls(ne, De) {
        if (typeof ne == "object") {
          if (nt(ne))
            for (var st = 0; st < ne.length; st++) {
              var yt = ne[st];
              Se(yt) && us(yt, De);
            }
          else if (Se(ne))
            ne._store && (ne._store.validated = !0);
          else if (ne) {
            var Zt = I(ne);
            if (typeof Zt == "function" && Zt !== ne.entries)
              for (var Xn = Zt.call(ne), mn; !(mn = Xn.next()).done; )
                Se(mn.value) && us(mn.value, De);
          }
        }
      }
      function Ca(ne) {
        {
          var De = ne.type;
          if (De == null || typeof De == "string")
            return;
          var st;
          if (typeof De == "function")
            st = De.propTypes;
          else if (typeof De == "object" && (De.$$typeof === _ || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          De.$$typeof === C))
            st = De.propTypes;
          else
            return;
          if (st) {
            var yt = hn(De);
            ls(st, ne.props, "prop", yt, ne);
          } else if (De.PropTypes !== void 0 && !lo) {
            lo = !0;
            var Zt = hn(De);
            Te("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Zt || "Unknown");
          }
          typeof De.getDefaultProps == "function" && !De.getDefaultProps.isReactClassApproved && Te("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function zi(ne) {
        {
          for (var De = Object.keys(ne.props), st = 0; st < De.length; st++) {
            var yt = De[st];
            if (yt !== "children" && yt !== "key") {
              jr(ne), Te("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", yt), jr(null);
              break;
            }
          }
          ne.ref !== null && (jr(ne), Te("Invalid attribute `ref` supplied to `React.Fragment`."), jr(null));
        }
      }
      function dm(ne, De, st) {
        var yt = Bt(ne);
        if (!yt) {
          var Zt = "";
          (ne === void 0 || typeof ne == "object" && ne !== null && Object.keys(ne).length === 0) && (Zt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Xn = pd(De);
          Xn ? Zt += Xn : Zt += wf();
          var mn;
          ne === null ? mn = "null" : nt(ne) ? mn = "array" : ne !== void 0 && ne.$$typeof === r ? (mn = "<" + (hn(ne.type) || "Unknown") + " />", Zt = " Did you accidentally export a JSX literal instead of a component?") : mn = typeof ne, Te("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", mn, Zt);
        }
        var qn = Xe.apply(this, arguments);
        if (qn == null)
          return qn;
        if (yt)
          for (var Nr = 2; Nr < arguments.length; Nr++)
            Ls(arguments[Nr], ne);
        return ne === s ? zi(qn) : Ca(qn), qn;
      }
      var si = !1;
      function uo(ne) {
        var De = dm.bind(null, ne);
        return De.type = ne, si || (si = !0, Pe("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(De, "type", {
          enumerable: !1,
          get: function() {
            return Pe("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: ne
            }), ne;
          }
        }), De;
      }
      function Ju(ne, De, st) {
        for (var yt = Ut.apply(this, arguments), Zt = 2; Zt < arguments.length; Zt++)
          Ls(arguments[Zt], yt.type);
        return Ca(yt), yt;
      }
      function ch(ne, De) {
        var st = G.transition;
        G.transition = {};
        var yt = G.transition;
        G.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          ne();
        } finally {
          if (G.transition = st, st === null && yt._updatedFibers) {
            var Zt = yt._updatedFibers.size;
            Zt > 10 && Pe("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), yt._updatedFibers.clear();
          }
        }
      }
      var Nc = !1, Eu = null;
      function wl(ne) {
        if (Eu === null)
          try {
            var De = ("require" + Math.random()).slice(0, 7), st = n && n[De];
            Eu = st.call(n, "timers").setImmediate;
          } catch {
            Eu = function(Zt) {
              Nc === !1 && (Nc = !0, typeof MessageChannel > "u" && Te("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var Xn = new MessageChannel();
              Xn.port1.onmessage = Zt, Xn.port2.postMessage(void 0);
            };
          }
        return Eu(ne);
      }
      var Jl = 0, Cf = !1;
      function Wo(ne) {
        {
          var De = Jl;
          Jl++, j.current === null && (j.current = []);
          var st = j.isBatchingLegacy, yt;
          try {
            if (j.isBatchingLegacy = !0, yt = ne(), !st && j.didScheduleLegacyUpdate) {
              var Zt = j.current;
              Zt !== null && (j.didScheduleLegacyUpdate = !1, tc(Zt));
            }
          } catch (Qr) {
            throw co(De), Qr;
          } finally {
            j.isBatchingLegacy = st;
          }
          if (yt !== null && typeof yt == "object" && typeof yt.then == "function") {
            var Xn = yt, mn = !1, qn = {
              then: function(Qr, li) {
                mn = !0, Xn.then(function($r) {
                  co(De), Jl === 0 ? Uc($r, Qr, li) : Qr($r);
                }, function($r) {
                  co(De), li($r);
                });
              }
            };
            return !Cf && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              mn || (Cf = !0, Te("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), qn;
          } else {
            var Nr = yt;
            if (co(De), Jl === 0) {
              var ri = j.current;
              ri !== null && (tc(ri), j.current = null);
              var Ti = {
                then: function(Qr, li) {
                  j.current === null ? (j.current = [], Uc(Nr, Qr, li)) : Qr(Nr);
                }
              };
              return Ti;
            } else {
              var Br = {
                then: function(Qr, li) {
                  Qr(Nr);
                }
              };
              return Br;
            }
          }
        }
      }
      function co(ne) {
        ne !== Jl - 1 && Te("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Jl = ne;
      }
      function Uc(ne, De, st) {
        {
          var yt = j.current;
          if (yt !== null)
            try {
              tc(yt), wl(function() {
                yt.length === 0 ? (j.current = null, De(ne)) : Uc(ne, De, st);
              });
            } catch (Zt) {
              st(Zt);
            }
          else
            De(ne);
        }
      }
      var ec = !1;
      function tc(ne) {
        if (!ec) {
          ec = !0;
          var De = 0;
          try {
            for (; De < ne.length; De++) {
              var st = ne[De];
              do
                st = st(!0);
              while (st !== null);
            }
            ne.length = 0;
          } catch (yt) {
            throw ne = ne.slice(De + 1), yt;
          } finally {
            ec = !1;
          }
        }
      }
      var md = dm, Os = Ju, op = uo, nl = {
        map: zn,
        forEach: ti,
        count: yr,
        toArray: rr,
        only: vr
      };
      e.Children = nl, e.Component = Oe, e.Fragment = s, e.Profiler = h, e.PureComponent = xt, e.StrictMode = u, e.Suspense = b, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Re, e.cloneElement = Os, e.createContext = Ai, e.createElement = md, e.createFactory = op, e.createRef = Ht, e.forwardRef = Eo, e.isValidElement = Se, e.lazy = _o, e.memo = en, e.startTransition = ch, e.unstable_act = Wo, e.useCallback = An, e.useContext = ve, e.useDebugValue = sn, e.useDeferredValue = Pr, e.useEffect = dt, e.useId = kn, e.useImperativeHandle = cr, e.useInsertionEffect = tn, e.useLayoutEffect = pn, e.useMemo = Gn, e.useReducer = qe, e.useRef = ze, e.useState = $e, e.useSyncExternalStore = za, e.useTransition = pr, e.version = t, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(uT, uT.exports)), uT.exports;
}
var YU;
function px() {
  return YU || (YU = 1, process.env.NODE_ENV === "production" ? iC.exports = JG() : iC.exports = e6()), iC.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XU;
function t6() {
  if (XU)
    return $1;
  XU = 1;
  var n = px(), e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, a = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function u(h, v, y) {
    var _, b = {}, M = null, C = null;
    y !== void 0 && (M = "" + y), v.key !== void 0 && (M = "" + v.key), v.ref !== void 0 && (C = v.ref);
    for (_ in v)
      r.call(v, _) && !s.hasOwnProperty(_) && (b[_] = v[_]);
    if (h && h.defaultProps)
      for (_ in v = h.defaultProps, v)
        b[_] === void 0 && (b[_] = v[_]);
    return { $$typeof: e, type: h, key: M, ref: C, props: b, _owner: a.current };
  }
  return $1.Fragment = t, $1.jsx = u, $1.jsxs = u, $1;
}
var Y1 = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qU;
function n6() {
  return qU || (qU = 1, process.env.NODE_ENV !== "production" && function() {
    var n = px(), e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), h = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), y = Symbol.for("react.suspense"), _ = Symbol.for("react.suspense_list"), b = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), C = Symbol.for("react.offscreen"), D = Symbol.iterator, U = "@@iterator";
    function N(Le) {
      if (Le === null || typeof Le != "object")
        return null;
      var Bt = D && Le[D] || Le[U];
      return typeof Bt == "function" ? Bt : null;
    }
    var O = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function I(Le) {
      {
        for (var Bt = arguments.length, en = new Array(Bt > 1 ? Bt - 1 : 0), _n = 1; _n < Bt; _n++)
          en[_n - 1] = arguments[_n];
        k("error", Le, en);
      }
    }
    function k(Le, Bt, en) {
      {
        var _n = O.ReactDebugCurrentFrame, ve = _n.getStackAddendum();
        ve !== "" && (Bt += "%s", en = en.concat([ve]));
        var $e = en.map(function(qe) {
          return String(qe);
        });
        $e.unshift("Warning: " + Bt), Function.prototype.apply.call(console[Le], console, $e);
      }
    }
    var G = !1, j = !1, Y = !1, Z = !1, te = !1, J;
    J = Symbol.for("react.module.reference");
    function q(Le) {
      return !!(typeof Le == "string" || typeof Le == "function" || Le === r || Le === s || te || Le === a || Le === y || Le === _ || Z || Le === C || G || j || Y || typeof Le == "object" && Le !== null && (Le.$$typeof === M || Le.$$typeof === b || Le.$$typeof === u || Le.$$typeof === h || Le.$$typeof === v || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Le.$$typeof === J || Le.getModuleId !== void 0));
    }
    function oe(Le, Bt, en) {
      var _n = Le.displayName;
      if (_n)
        return _n;
      var ve = Bt.displayName || Bt.name || "";
      return ve !== "" ? en + "(" + ve + ")" : en;
    }
    function ye(Le) {
      return Le.displayName || "Context";
    }
    function de(Le) {
      if (Le == null)
        return null;
      if (typeof Le.tag == "number" && I("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Le == "function")
        return Le.displayName || Le.name || null;
      if (typeof Le == "string")
        return Le;
      switch (Le) {
        case r:
          return "Fragment";
        case t:
          return "Portal";
        case s:
          return "Profiler";
        case a:
          return "StrictMode";
        case y:
          return "Suspense";
        case _:
          return "SuspenseList";
      }
      if (typeof Le == "object")
        switch (Le.$$typeof) {
          case h:
            var Bt = Le;
            return ye(Bt) + ".Consumer";
          case u:
            var en = Le;
            return ye(en._context) + ".Provider";
          case v:
            return oe(Le, Le.render, "ForwardRef");
          case b:
            var _n = Le.displayName || null;
            return _n !== null ? _n : de(Le.type) || "Memo";
          case M: {
            var ve = Le, $e = ve._payload, qe = ve._init;
            try {
              return de(qe($e));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var xe = Object.assign, Re = 0, Pe, Te, ue, we, X, me, ce;
    function Ue() {
    }
    Ue.__reactDisabledLog = !0;
    function Oe() {
      {
        if (Re === 0) {
          Pe = console.log, Te = console.info, ue = console.warn, we = console.error, X = console.group, me = console.groupCollapsed, ce = console.groupEnd;
          var Le = {
            configurable: !0,
            enumerable: !0,
            value: Ue,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Le,
            log: Le,
            warn: Le,
            error: Le,
            group: Le,
            groupCollapsed: Le,
            groupEnd: Le
          });
        }
        Re++;
      }
    }
    function Ze() {
      {
        if (Re--, Re === 0) {
          var Le = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: xe({}, Le, {
              value: Pe
            }),
            info: xe({}, Le, {
              value: Te
            }),
            warn: xe({}, Le, {
              value: ue
            }),
            error: xe({}, Le, {
              value: we
            }),
            group: xe({}, Le, {
              value: X
            }),
            groupCollapsed: xe({}, Le, {
              value: me
            }),
            groupEnd: xe({}, Le, {
              value: ce
            })
          });
        }
        Re < 0 && I("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var je = O.ReactCurrentDispatcher, Je;
    function at(Le, Bt, en) {
      {
        if (Je === void 0)
          try {
            throw Error();
          } catch (ve) {
            var _n = ve.stack.trim().match(/\n( *(at )?)/);
            Je = _n && _n[1] || "";
          }
        return `
` + Je + Le;
      }
    }
    var xt = !1, $t;
    {
      var Ht = typeof WeakMap == "function" ? WeakMap : Map;
      $t = new Ht();
    }
    function he(Le, Bt) {
      if (!Le || xt)
        return "";
      {
        var en = $t.get(Le);
        if (en !== void 0)
          return en;
      }
      var _n;
      xt = !0;
      var ve = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var $e;
      $e = je.current, je.current = null, Oe();
      try {
        if (Bt) {
          var qe = function() {
            throw Error();
          };
          if (Object.defineProperty(qe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(qe, []);
            } catch (sn) {
              _n = sn;
            }
            Reflect.construct(Le, [], qe);
          } else {
            try {
              qe.call();
            } catch (sn) {
              _n = sn;
            }
            Le.call(qe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (sn) {
            _n = sn;
          }
          Le();
        }
      } catch (sn) {
        if (sn && _n && typeof sn.stack == "string") {
          for (var ze = sn.stack.split(`
`), dt = _n.stack.split(`
`), tn = ze.length - 1, pn = dt.length - 1; tn >= 1 && pn >= 0 && ze[tn] !== dt[pn]; )
            pn--;
          for (; tn >= 1 && pn >= 0; tn--, pn--)
            if (ze[tn] !== dt[pn]) {
              if (tn !== 1 || pn !== 1)
                do
                  if (tn--, pn--, pn < 0 || ze[tn] !== dt[pn]) {
                    var An = `
` + ze[tn].replace(" at new ", " at ");
                    return Le.displayName && An.includes("<anonymous>") && (An = An.replace("<anonymous>", Le.displayName)), typeof Le == "function" && $t.set(Le, An), An;
                  }
                while (tn >= 1 && pn >= 0);
              break;
            }
        }
      } finally {
        xt = !1, je.current = $e, Ze(), Error.prepareStackTrace = ve;
      }
      var Gn = Le ? Le.displayName || Le.name : "", cr = Gn ? at(Gn) : "";
      return typeof Le == "function" && $t.set(Le, cr), cr;
    }
    function nt(Le, Bt, en) {
      return he(Le, !1);
    }
    function et(Le) {
      var Bt = Le.prototype;
      return !!(Bt && Bt.isReactComponent);
    }
    function Rt(Le, Bt, en) {
      if (Le == null)
        return "";
      if (typeof Le == "function")
        return he(Le, et(Le));
      if (typeof Le == "string")
        return at(Le);
      switch (Le) {
        case y:
          return at("Suspense");
        case _:
          return at("SuspenseList");
      }
      if (typeof Le == "object")
        switch (Le.$$typeof) {
          case v:
            return nt(Le.render);
          case b:
            return Rt(Le.type, Bt, en);
          case M: {
            var _n = Le, ve = _n._payload, $e = _n._init;
            try {
              return Rt($e(ve), Bt, en);
            } catch {
            }
          }
        }
      return "";
    }
    var gt = Object.prototype.hasOwnProperty, Jt = {}, Kt = O.ReactDebugCurrentFrame;
    function qt(Le) {
      if (Le) {
        var Bt = Le._owner, en = Rt(Le.type, Le._source, Bt ? Bt.type : null);
        Kt.setExtraStackFrame(en);
      } else
        Kt.setExtraStackFrame(null);
    }
    function hn(Le, Bt, en, _n, ve) {
      {
        var $e = Function.call.bind(gt);
        for (var qe in Le)
          if ($e(Le, qe)) {
            var ze = void 0;
            try {
              if (typeof Le[qe] != "function") {
                var dt = Error((_n || "React class") + ": " + en + " type `" + qe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Le[qe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw dt.name = "Invariant Violation", dt;
              }
              ze = Le[qe](Bt, qe, _n, en, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (tn) {
              ze = tn;
            }
            ze && !(ze instanceof Error) && (qt(ve), I("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", _n || "React class", en, qe, typeof ze), qt(null)), ze instanceof Error && !(ze.message in Jt) && (Jt[ze.message] = !0, qt(ve), I("Failed %s type: %s", en, ze.message), qt(null));
          }
      }
    }
    var Rn = Array.isArray;
    function Yn(Le) {
      return Rn(Le);
    }
    function se(Le) {
      {
        var Bt = typeof Symbol == "function" && Symbol.toStringTag, en = Bt && Le[Symbol.toStringTag] || Le.constructor.name || "Object";
        return en;
      }
    }
    function ae(Le) {
      try {
        return Ke(Le), !1;
      } catch {
        return !0;
      }
    }
    function Ke(Le) {
      return "" + Le;
    }
    function wt(Le) {
      if (ae(Le))
        return I("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", se(Le)), Ke(Le);
    }
    var _t = O.ReactCurrentOwner, Vt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, fn, Wt, Ee;
    Ee = {};
    function Xe(Le) {
      if (gt.call(Le, "ref")) {
        var Bt = Object.getOwnPropertyDescriptor(Le, "ref").get;
        if (Bt && Bt.isReactWarning)
          return !1;
      }
      return Le.ref !== void 0;
    }
    function St(Le) {
      if (gt.call(Le, "key")) {
        var Bt = Object.getOwnPropertyDescriptor(Le, "key").get;
        if (Bt && Bt.isReactWarning)
          return !1;
      }
      return Le.key !== void 0;
    }
    function Ut(Le, Bt) {
      if (typeof Le.ref == "string" && _t.current && Bt && _t.current.stateNode !== Bt) {
        var en = de(_t.current.type);
        Ee[en] || (I('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', de(_t.current.type), Le.ref), Ee[en] = !0);
      }
    }
    function Se(Le, Bt) {
      {
        var en = function() {
          fn || (fn = !0, I("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Bt));
        };
        en.isReactWarning = !0, Object.defineProperty(Le, "key", {
          get: en,
          configurable: !0
        });
      }
    }
    function Ye(Le, Bt) {
      {
        var en = function() {
          Wt || (Wt = !0, I("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Bt));
        };
        en.isReactWarning = !0, Object.defineProperty(Le, "ref", {
          get: en,
          configurable: !0
        });
      }
    }
    var bt = function(Le, Bt, en, _n, ve, $e, qe) {
      var ze = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: Le,
        key: Bt,
        ref: en,
        props: qe,
        // Record the component responsible for creating this element.
        _owner: $e
      };
      return ze._store = {}, Object.defineProperty(ze._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ze, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: _n
      }), Object.defineProperty(ze, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ve
      }), Object.freeze && (Object.freeze(ze.props), Object.freeze(ze)), ze;
    };
    function Tt(Le, Bt, en, _n, ve) {
      {
        var $e, qe = {}, ze = null, dt = null;
        en !== void 0 && (wt(en), ze = "" + en), St(Bt) && (wt(Bt.key), ze = "" + Bt.key), Xe(Bt) && (dt = Bt.ref, Ut(Bt, ve));
        for ($e in Bt)
          gt.call(Bt, $e) && !Vt.hasOwnProperty($e) && (qe[$e] = Bt[$e]);
        if (Le && Le.defaultProps) {
          var tn = Le.defaultProps;
          for ($e in tn)
            qe[$e] === void 0 && (qe[$e] = tn[$e]);
        }
        if (ze || dt) {
          var pn = typeof Le == "function" ? Le.displayName || Le.name || "Unknown" : Le;
          ze && Se(qe, pn), dt && Ye(qe, pn);
        }
        return bt(Le, ze, dt, ve, _n, _t.current, qe);
      }
    }
    var ge = O.ReactCurrentOwner, zt = O.ReactDebugCurrentFrame;
    function Fe(Le) {
      if (Le) {
        var Bt = Le._owner, en = Rt(Le.type, Le._source, Bt ? Bt.type : null);
        zt.setExtraStackFrame(en);
      } else
        zt.setExtraStackFrame(null);
    }
    var ft;
    ft = !1;
    function ln(Le) {
      return typeof Le == "object" && Le !== null && Le.$$typeof === e;
    }
    function zn() {
      {
        if (ge.current) {
          var Le = de(ge.current.type);
          if (Le)
            return `

Check the render method of \`` + Le + "`.";
        }
        return "";
      }
    }
    function yr(Le) {
      {
        if (Le !== void 0) {
          var Bt = Le.fileName.replace(/^.*[\\\/]/, ""), en = Le.lineNumber;
          return `

Check your code at ` + Bt + ":" + en + ".";
        }
        return "";
      }
    }
    var ti = {};
    function rr(Le) {
      {
        var Bt = zn();
        if (!Bt) {
          var en = typeof Le == "string" ? Le : Le.displayName || Le.name;
          en && (Bt = `

Check the top-level render call using <` + en + ">.");
        }
        return Bt;
      }
    }
    function vr(Le, Bt) {
      {
        if (!Le._store || Le._store.validated || Le.key != null)
          return;
        Le._store.validated = !0;
        var en = rr(Bt);
        if (ti[en])
          return;
        ti[en] = !0;
        var _n = "";
        Le && Le._owner && Le._owner !== ge.current && (_n = " It was passed a child from " + de(Le._owner.type) + "."), Fe(Le), I('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', en, _n), Fe(null);
      }
    }
    function Ai(Le, Bt) {
      {
        if (typeof Le != "object")
          return;
        if (Yn(Le))
          for (var en = 0; en < Le.length; en++) {
            var _n = Le[en];
            ln(_n) && vr(_n, Bt);
          }
        else if (ln(Le))
          Le._store && (Le._store.validated = !0);
        else if (Le) {
          var ve = N(Le);
          if (typeof ve == "function" && ve !== Le.entries)
            for (var $e = ve.call(Le), qe; !(qe = $e.next()).done; )
              ln(qe.value) && vr(qe.value, Bt);
        }
      }
    }
    function oi(Le) {
      {
        var Bt = Le.type;
        if (Bt == null || typeof Bt == "string")
          return;
        var en;
        if (typeof Bt == "function")
          en = Bt.propTypes;
        else if (typeof Bt == "object" && (Bt.$$typeof === v || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Bt.$$typeof === b))
          en = Bt.propTypes;
        else
          return;
        if (en) {
          var _n = de(Bt);
          hn(en, Le.props, "prop", _n, Le);
        } else if (Bt.PropTypes !== void 0 && !ft) {
          ft = !0;
          var ve = de(Bt);
          I("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ve || "Unknown");
        }
        typeof Bt.getDefaultProps == "function" && !Bt.getDefaultProps.isReactClassApproved && I("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ma(Le) {
      {
        for (var Bt = Object.keys(Le.props), en = 0; en < Bt.length; en++) {
          var _n = Bt[en];
          if (_n !== "children" && _n !== "key") {
            Fe(Le), I("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", _n), Fe(null);
            break;
          }
        }
        Le.ref !== null && (Fe(Le), I("Invalid attribute `ref` supplied to `React.Fragment`."), Fe(null));
      }
    }
    function Ji(Le, Bt, en, _n, ve, $e) {
      {
        var qe = q(Le);
        if (!qe) {
          var ze = "";
          (Le === void 0 || typeof Le == "object" && Le !== null && Object.keys(Le).length === 0) && (ze += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var dt = yr(ve);
          dt ? ze += dt : ze += zn();
          var tn;
          Le === null ? tn = "null" : Yn(Le) ? tn = "array" : Le !== void 0 && Le.$$typeof === e ? (tn = "<" + (de(Le.type) || "Unknown") + " />", ze = " Did you accidentally export a JSX literal instead of a component?") : tn = typeof Le, I("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", tn, ze);
        }
        var pn = Tt(Le, Bt, en, ve, $e);
        if (pn == null)
          return pn;
        if (qe) {
          var An = Bt.children;
          if (An !== void 0)
            if (_n)
              if (Yn(An)) {
                for (var Gn = 0; Gn < An.length; Gn++)
                  Ai(An[Gn], Le);
                Object.freeze && Object.freeze(An);
              } else
                I("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ai(An, Le);
        }
        return Le === r ? Ma(pn) : oi(pn), pn;
      }
    }
    function _l(Le, Bt, en) {
      return Ji(Le, Bt, en, !0);
    }
    function ea(Le, Bt, en) {
      return Ji(Le, Bt, en, !1);
    }
    var _o = ea, Eo = _l;
    Y1.Fragment = r, Y1.jsx = _o, Y1.jsxs = Eo;
  }()), Y1;
}
process.env.NODE_ENV === "production" ? pL.exports = t6() : pL.exports = n6();
var Or = pL.exports, mL = { exports: {} }, sd = {}, aC = { exports: {} }, r2 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KU;
function r6() {
  return KU || (KU = 1, function(n) {
    function e(ue, we) {
      var X = ue.length;
      ue.push(we);
      e:
        for (; 0 < X; ) {
          var me = X - 1 >>> 1, ce = ue[me];
          if (0 < a(ce, we))
            ue[me] = we, ue[X] = ce, X = me;
          else
            break e;
        }
    }
    function t(ue) {
      return ue.length === 0 ? null : ue[0];
    }
    function r(ue) {
      if (ue.length === 0)
        return null;
      var we = ue[0], X = ue.pop();
      if (X !== we) {
        ue[0] = X;
        e:
          for (var me = 0, ce = ue.length, Ue = ce >>> 1; me < Ue; ) {
            var Oe = 2 * (me + 1) - 1, Ze = ue[Oe], je = Oe + 1, Je = ue[je];
            if (0 > a(Ze, X))
              je < ce && 0 > a(Je, Ze) ? (ue[me] = Je, ue[je] = X, me = je) : (ue[me] = Ze, ue[Oe] = X, me = Oe);
            else if (je < ce && 0 > a(Je, X))
              ue[me] = Je, ue[je] = X, me = je;
            else
              break e;
          }
      }
      return we;
    }
    function a(ue, we) {
      var X = ue.sortIndex - we.sortIndex;
      return X !== 0 ? X : ue.id - we.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      n.unstable_now = function() {
        return s.now();
      };
    } else {
      var u = Date, h = u.now();
      n.unstable_now = function() {
        return u.now() - h;
      };
    }
    var v = [], y = [], _ = 1, b = null, M = 3, C = !1, D = !1, U = !1, N = typeof setTimeout == "function" ? setTimeout : null, O = typeof clearTimeout == "function" ? clearTimeout : null, I = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function k(ue) {
      for (var we = t(y); we !== null; ) {
        if (we.callback === null)
          r(y);
        else if (we.startTime <= ue)
          r(y), we.sortIndex = we.expirationTime, e(v, we);
        else
          break;
        we = t(y);
      }
    }
    function G(ue) {
      if (U = !1, k(ue), !D)
        if (t(v) !== null)
          D = !0, Pe(j);
        else {
          var we = t(y);
          we !== null && Te(G, we.startTime - ue);
        }
    }
    function j(ue, we) {
      D = !1, U && (U = !1, O(te), te = -1), C = !0;
      var X = M;
      try {
        for (k(we), b = t(v); b !== null && (!(b.expirationTime > we) || ue && !oe()); ) {
          var me = b.callback;
          if (typeof me == "function") {
            b.callback = null, M = b.priorityLevel;
            var ce = me(b.expirationTime <= we);
            we = n.unstable_now(), typeof ce == "function" ? b.callback = ce : b === t(v) && r(v), k(we);
          } else
            r(v);
          b = t(v);
        }
        if (b !== null)
          var Ue = !0;
        else {
          var Oe = t(y);
          Oe !== null && Te(G, Oe.startTime - we), Ue = !1;
        }
        return Ue;
      } finally {
        b = null, M = X, C = !1;
      }
    }
    var Y = !1, Z = null, te = -1, J = 5, q = -1;
    function oe() {
      return !(n.unstable_now() - q < J);
    }
    function ye() {
      if (Z !== null) {
        var ue = n.unstable_now();
        q = ue;
        var we = !0;
        try {
          we = Z(!0, ue);
        } finally {
          we ? de() : (Y = !1, Z = null);
        }
      } else
        Y = !1;
    }
    var de;
    if (typeof I == "function")
      de = function() {
        I(ye);
      };
    else if (typeof MessageChannel < "u") {
      var xe = new MessageChannel(), Re = xe.port2;
      xe.port1.onmessage = ye, de = function() {
        Re.postMessage(null);
      };
    } else
      de = function() {
        N(ye, 0);
      };
    function Pe(ue) {
      Z = ue, Y || (Y = !0, de());
    }
    function Te(ue, we) {
      te = N(function() {
        ue(n.unstable_now());
      }, we);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(ue) {
      ue.callback = null;
    }, n.unstable_continueExecution = function() {
      D || C || (D = !0, Pe(j));
    }, n.unstable_forceFrameRate = function(ue) {
      0 > ue || 125 < ue ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : J = 0 < ue ? Math.floor(1e3 / ue) : 5;
    }, n.unstable_getCurrentPriorityLevel = function() {
      return M;
    }, n.unstable_getFirstCallbackNode = function() {
      return t(v);
    }, n.unstable_next = function(ue) {
      switch (M) {
        case 1:
        case 2:
        case 3:
          var we = 3;
          break;
        default:
          we = M;
      }
      var X = M;
      M = we;
      try {
        return ue();
      } finally {
        M = X;
      }
    }, n.unstable_pauseExecution = function() {
    }, n.unstable_requestPaint = function() {
    }, n.unstable_runWithPriority = function(ue, we) {
      switch (ue) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ue = 3;
      }
      var X = M;
      M = ue;
      try {
        return we();
      } finally {
        M = X;
      }
    }, n.unstable_scheduleCallback = function(ue, we, X) {
      var me = n.unstable_now();
      switch (typeof X == "object" && X !== null ? (X = X.delay, X = typeof X == "number" && 0 < X ? me + X : me) : X = me, ue) {
        case 1:
          var ce = -1;
          break;
        case 2:
          ce = 250;
          break;
        case 5:
          ce = 1073741823;
          break;
        case 4:
          ce = 1e4;
          break;
        default:
          ce = 5e3;
      }
      return ce = X + ce, ue = { id: _++, callback: we, priorityLevel: ue, startTime: X, expirationTime: ce, sortIndex: -1 }, X > me ? (ue.sortIndex = X, e(y, ue), t(v) === null && ue === t(y) && (U ? (O(te), te = -1) : U = !0, Te(G, X - me))) : (ue.sortIndex = ce, e(v, ue), D || C || (D = !0, Pe(j))), ue;
    }, n.unstable_shouldYield = oe, n.unstable_wrapCallback = function(ue) {
      var we = M;
      return function() {
        var X = M;
        M = we;
        try {
          return ue.apply(this, arguments);
        } finally {
          M = X;
        }
      };
    };
  }(r2)), r2;
}
var i2 = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QU;
function i6() {
  return QU || (QU = 1, function(n) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, r = 5;
      function a(Ee, Xe) {
        var St = Ee.length;
        Ee.push(Xe), h(Ee, Xe, St);
      }
      function s(Ee) {
        return Ee.length === 0 ? null : Ee[0];
      }
      function u(Ee) {
        if (Ee.length === 0)
          return null;
        var Xe = Ee[0], St = Ee.pop();
        return St !== Xe && (Ee[0] = St, v(Ee, St, 0)), Xe;
      }
      function h(Ee, Xe, St) {
        for (var Ut = St; Ut > 0; ) {
          var Se = Ut - 1 >>> 1, Ye = Ee[Se];
          if (y(Ye, Xe) > 0)
            Ee[Se] = Xe, Ee[Ut] = Ye, Ut = Se;
          else
            return;
        }
      }
      function v(Ee, Xe, St) {
        for (var Ut = St, Se = Ee.length, Ye = Se >>> 1; Ut < Ye; ) {
          var bt = (Ut + 1) * 2 - 1, Tt = Ee[bt], ge = bt + 1, zt = Ee[ge];
          if (y(Tt, Xe) < 0)
            ge < Se && y(zt, Tt) < 0 ? (Ee[Ut] = zt, Ee[ge] = Xe, Ut = ge) : (Ee[Ut] = Tt, Ee[bt] = Xe, Ut = bt);
          else if (ge < Se && y(zt, Xe) < 0)
            Ee[Ut] = zt, Ee[ge] = Xe, Ut = ge;
          else
            return;
        }
      }
      function y(Ee, Xe) {
        var St = Ee.sortIndex - Xe.sortIndex;
        return St !== 0 ? St : Ee.id - Xe.id;
      }
      var _ = 1, b = 2, M = 3, C = 4, D = 5;
      function U(Ee, Xe) {
      }
      var N = typeof performance == "object" && typeof performance.now == "function";
      if (N) {
        var O = performance;
        n.unstable_now = function() {
          return O.now();
        };
      } else {
        var I = Date, k = I.now();
        n.unstable_now = function() {
          return I.now() - k;
        };
      }
      var G = 1073741823, j = -1, Y = 250, Z = 5e3, te = 1e4, J = G, q = [], oe = [], ye = 1, de = null, xe = M, Re = !1, Pe = !1, Te = !1, ue = typeof setTimeout == "function" ? setTimeout : null, we = typeof clearTimeout == "function" ? clearTimeout : null, X = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function me(Ee) {
        for (var Xe = s(oe); Xe !== null; ) {
          if (Xe.callback === null)
            u(oe);
          else if (Xe.startTime <= Ee)
            u(oe), Xe.sortIndex = Xe.expirationTime, a(q, Xe);
          else
            return;
          Xe = s(oe);
        }
      }
      function ce(Ee) {
        if (Te = !1, me(Ee), !Pe)
          if (s(q) !== null)
            Pe = !0, wt(Ue);
          else {
            var Xe = s(oe);
            Xe !== null && _t(ce, Xe.startTime - Ee);
          }
      }
      function Ue(Ee, Xe) {
        Pe = !1, Te && (Te = !1, Vt()), Re = !0;
        var St = xe;
        try {
          var Ut;
          if (!t)
            return Oe(Ee, Xe);
        } finally {
          de = null, xe = St, Re = !1;
        }
      }
      function Oe(Ee, Xe) {
        var St = Xe;
        for (me(St), de = s(q); de !== null && !e && !(de.expirationTime > St && (!Ee || qt())); ) {
          var Ut = de.callback;
          if (typeof Ut == "function") {
            de.callback = null, xe = de.priorityLevel;
            var Se = de.expirationTime <= St, Ye = Ut(Se);
            St = n.unstable_now(), typeof Ye == "function" ? de.callback = Ye : de === s(q) && u(q), me(St);
          } else
            u(q);
          de = s(q);
        }
        if (de !== null)
          return !0;
        var bt = s(oe);
        return bt !== null && _t(ce, bt.startTime - St), !1;
      }
      function Ze(Ee, Xe) {
        switch (Ee) {
          case _:
          case b:
          case M:
          case C:
          case D:
            break;
          default:
            Ee = M;
        }
        var St = xe;
        xe = Ee;
        try {
          return Xe();
        } finally {
          xe = St;
        }
      }
      function je(Ee) {
        var Xe;
        switch (xe) {
          case _:
          case b:
          case M:
            Xe = M;
            break;
          default:
            Xe = xe;
            break;
        }
        var St = xe;
        xe = Xe;
        try {
          return Ee();
        } finally {
          xe = St;
        }
      }
      function Je(Ee) {
        var Xe = xe;
        return function() {
          var St = xe;
          xe = Xe;
          try {
            return Ee.apply(this, arguments);
          } finally {
            xe = St;
          }
        };
      }
      function at(Ee, Xe, St) {
        var Ut = n.unstable_now(), Se;
        if (typeof St == "object" && St !== null) {
          var Ye = St.delay;
          typeof Ye == "number" && Ye > 0 ? Se = Ut + Ye : Se = Ut;
        } else
          Se = Ut;
        var bt;
        switch (Ee) {
          case _:
            bt = j;
            break;
          case b:
            bt = Y;
            break;
          case D:
            bt = J;
            break;
          case C:
            bt = te;
            break;
          case M:
          default:
            bt = Z;
            break;
        }
        var Tt = Se + bt, ge = {
          id: ye++,
          callback: Xe,
          priorityLevel: Ee,
          startTime: Se,
          expirationTime: Tt,
          sortIndex: -1
        };
        return Se > Ut ? (ge.sortIndex = Se, a(oe, ge), s(q) === null && ge === s(oe) && (Te ? Vt() : Te = !0, _t(ce, Se - Ut))) : (ge.sortIndex = Tt, a(q, ge), !Pe && !Re && (Pe = !0, wt(Ue))), ge;
      }
      function xt() {
      }
      function $t() {
        !Pe && !Re && (Pe = !0, wt(Ue));
      }
      function Ht() {
        return s(q);
      }
      function he(Ee) {
        Ee.callback = null;
      }
      function nt() {
        return xe;
      }
      var et = !1, Rt = null, gt = -1, Jt = r, Kt = -1;
      function qt() {
        var Ee = n.unstable_now() - Kt;
        return !(Ee < Jt);
      }
      function hn() {
      }
      function Rn(Ee) {
        if (Ee < 0 || Ee > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Ee > 0 ? Jt = Math.floor(1e3 / Ee) : Jt = r;
      }
      var Yn = function() {
        if (Rt !== null) {
          var Ee = n.unstable_now();
          Kt = Ee;
          var Xe = !0, St = !0;
          try {
            St = Rt(Xe, Ee);
          } finally {
            St ? se() : (et = !1, Rt = null);
          }
        } else
          et = !1;
      }, se;
      if (typeof X == "function")
        se = function() {
          X(Yn);
        };
      else if (typeof MessageChannel < "u") {
        var ae = new MessageChannel(), Ke = ae.port2;
        ae.port1.onmessage = Yn, se = function() {
          Ke.postMessage(null);
        };
      } else
        se = function() {
          ue(Yn, 0);
        };
      function wt(Ee) {
        Rt = Ee, et || (et = !0, se());
      }
      function _t(Ee, Xe) {
        gt = ue(function() {
          Ee(n.unstable_now());
        }, Xe);
      }
      function Vt() {
        we(gt), gt = -1;
      }
      var fn = hn, Wt = null;
      n.unstable_IdlePriority = D, n.unstable_ImmediatePriority = _, n.unstable_LowPriority = C, n.unstable_NormalPriority = M, n.unstable_Profiling = Wt, n.unstable_UserBlockingPriority = b, n.unstable_cancelCallback = he, n.unstable_continueExecution = $t, n.unstable_forceFrameRate = Rn, n.unstable_getCurrentPriorityLevel = nt, n.unstable_getFirstCallbackNode = Ht, n.unstable_next = je, n.unstable_pauseExecution = xt, n.unstable_requestPaint = fn, n.unstable_runWithPriority = Ze, n.unstable_scheduleCallback = at, n.unstable_shouldYield = qt, n.unstable_wrapCallback = Je, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(i2)), i2;
}
var ZU;
function CI() {
  return ZU || (ZU = 1, process.env.NODE_ENV === "production" ? aC.exports = r6() : aC.exports = i6()), aC.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JU;
function a6() {
  if (JU)
    return sd;
  JU = 1;
  var n = px(), e = CI();
  function t(c) {
    for (var d = "https://reactjs.org/docs/error-decoder.html?invariant=" + c, x = 1; x < arguments.length; x++)
      d += "&args[]=" + encodeURIComponent(arguments[x]);
    return "Minified React error #" + c + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), a = {};
  function s(c, d) {
    u(c, d), u(c + "Capture", d);
  }
  function u(c, d) {
    for (a[c] = d, c = 0; c < d.length; c++)
      r.add(d[c]);
  }
  var h = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), v = Object.prototype.hasOwnProperty, y = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, _ = {}, b = {};
  function M(c) {
    return v.call(b, c) ? !0 : v.call(_, c) ? !1 : y.test(c) ? b[c] = !0 : (_[c] = !0, !1);
  }
  function C(c, d, x, A) {
    if (x !== null && x.type === 0)
      return !1;
    switch (typeof d) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return A ? !1 : x !== null ? !x.acceptsBooleans : (c = c.toLowerCase().slice(0, 5), c !== "data-" && c !== "aria-");
      default:
        return !1;
    }
  }
  function D(c, d, x, A) {
    if (d === null || typeof d > "u" || C(c, d, x, A))
      return !0;
    if (A)
      return !1;
    if (x !== null)
      switch (x.type) {
        case 3:
          return !d;
        case 4:
          return d === !1;
        case 5:
          return isNaN(d);
        case 6:
          return isNaN(d) || 1 > d;
      }
    return !1;
  }
  function U(c, d, x, A, F, W, ie) {
    this.acceptsBooleans = d === 2 || d === 3 || d === 4, this.attributeName = A, this.attributeNamespace = F, this.mustUseProperty = x, this.propertyName = c, this.type = d, this.sanitizeURL = W, this.removeEmptyString = ie;
  }
  var N = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(c) {
    N[c] = new U(c, 0, !1, c, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(c) {
    var d = c[0];
    N[d] = new U(d, 1, !1, c[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(c) {
    N[c] = new U(c, 2, !1, c.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(c) {
    N[c] = new U(c, 2, !1, c, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(c) {
    N[c] = new U(c, 3, !1, c.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(c) {
    N[c] = new U(c, 3, !0, c, null, !1, !1);
  }), ["capture", "download"].forEach(function(c) {
    N[c] = new U(c, 4, !1, c, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(c) {
    N[c] = new U(c, 6, !1, c, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(c) {
    N[c] = new U(c, 5, !1, c.toLowerCase(), null, !1, !1);
  });
  var O = /[\-:]([a-z])/g;
  function I(c) {
    return c[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(c) {
    var d = c.replace(
      O,
      I
    );
    N[d] = new U(d, 1, !1, c, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(c) {
    var d = c.replace(O, I);
    N[d] = new U(d, 1, !1, c, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(c) {
    var d = c.replace(O, I);
    N[d] = new U(d, 1, !1, c, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(c) {
    N[c] = new U(c, 1, !1, c.toLowerCase(), null, !1, !1);
  }), N.xlinkHref = new U("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(c) {
    N[c] = new U(c, 1, !1, c.toLowerCase(), null, !0, !0);
  });
  function k(c, d, x, A) {
    var F = N.hasOwnProperty(d) ? N[d] : null;
    (F !== null ? F.type !== 0 : A || !(2 < d.length) || d[0] !== "o" && d[0] !== "O" || d[1] !== "n" && d[1] !== "N") && (D(d, x, F, A) && (x = null), A || F === null ? M(d) && (x === null ? c.removeAttribute(d) : c.setAttribute(d, "" + x)) : F.mustUseProperty ? c[F.propertyName] = x === null ? F.type === 3 ? !1 : "" : x : (d = F.attributeName, A = F.attributeNamespace, x === null ? c.removeAttribute(d) : (F = F.type, x = F === 3 || F === 4 && x === !0 ? "" : "" + x, A ? c.setAttributeNS(A, d, x) : c.setAttribute(d, x))));
  }
  var G = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, j = Symbol.for("react.element"), Y = Symbol.for("react.portal"), Z = Symbol.for("react.fragment"), te = Symbol.for("react.strict_mode"), J = Symbol.for("react.profiler"), q = Symbol.for("react.provider"), oe = Symbol.for("react.context"), ye = Symbol.for("react.forward_ref"), de = Symbol.for("react.suspense"), xe = Symbol.for("react.suspense_list"), Re = Symbol.for("react.memo"), Pe = Symbol.for("react.lazy"), Te = Symbol.for("react.offscreen"), ue = Symbol.iterator;
  function we(c) {
    return c === null || typeof c != "object" ? null : (c = ue && c[ue] || c["@@iterator"], typeof c == "function" ? c : null);
  }
  var X = Object.assign, me;
  function ce(c) {
    if (me === void 0)
      try {
        throw Error();
      } catch (x) {
        var d = x.stack.trim().match(/\n( *(at )?)/);
        me = d && d[1] || "";
      }
    return `
` + me + c;
  }
  var Ue = !1;
  function Oe(c, d) {
    if (!c || Ue)
      return "";
    Ue = !0;
    var x = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (d)
        if (d = function() {
          throw Error();
        }, Object.defineProperty(d.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(d, []);
          } catch (pt) {
            var A = pt;
          }
          Reflect.construct(c, [], d);
        } else {
          try {
            d.call();
          } catch (pt) {
            A = pt;
          }
          c.call(d.prototype);
        }
      else {
        try {
          throw Error();
        } catch (pt) {
          A = pt;
        }
        c();
      }
    } catch (pt) {
      if (pt && A && typeof pt.stack == "string") {
        for (var F = pt.stack.split(`
`), W = A.stack.split(`
`), ie = F.length - 1, Ae = W.length - 1; 1 <= ie && 0 <= Ae && F[ie] !== W[Ae]; )
          Ae--;
        for (; 1 <= ie && 0 <= Ae; ie--, Ae--)
          if (F[ie] !== W[Ae]) {
            if (ie !== 1 || Ae !== 1)
              do
                if (ie--, Ae--, 0 > Ae || F[ie] !== W[Ae]) {
                  var Ie = `
` + F[ie].replace(" at new ", " at ");
                  return c.displayName && Ie.includes("<anonymous>") && (Ie = Ie.replace("<anonymous>", c.displayName)), Ie;
                }
              while (1 <= ie && 0 <= Ae);
            break;
          }
      }
    } finally {
      Ue = !1, Error.prepareStackTrace = x;
    }
    return (c = c ? c.displayName || c.name : "") ? ce(c) : "";
  }
  function Ze(c) {
    switch (c.tag) {
      case 5:
        return ce(c.type);
      case 16:
        return ce("Lazy");
      case 13:
        return ce("Suspense");
      case 19:
        return ce("SuspenseList");
      case 0:
      case 2:
      case 15:
        return c = Oe(c.type, !1), c;
      case 11:
        return c = Oe(c.type.render, !1), c;
      case 1:
        return c = Oe(c.type, !0), c;
      default:
        return "";
    }
  }
  function je(c) {
    if (c == null)
      return null;
    if (typeof c == "function")
      return c.displayName || c.name || null;
    if (typeof c == "string")
      return c;
    switch (c) {
      case Z:
        return "Fragment";
      case Y:
        return "Portal";
      case J:
        return "Profiler";
      case te:
        return "StrictMode";
      case de:
        return "Suspense";
      case xe:
        return "SuspenseList";
    }
    if (typeof c == "object")
      switch (c.$$typeof) {
        case oe:
          return (c.displayName || "Context") + ".Consumer";
        case q:
          return (c._context.displayName || "Context") + ".Provider";
        case ye:
          var d = c.render;
          return c = c.displayName, c || (c = d.displayName || d.name || "", c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"), c;
        case Re:
          return d = c.displayName || null, d !== null ? d : je(c.type) || "Memo";
        case Pe:
          d = c._payload, c = c._init;
          try {
            return je(c(d));
          } catch {
          }
      }
    return null;
  }
  function Je(c) {
    var d = c.type;
    switch (c.tag) {
      case 24:
        return "Cache";
      case 9:
        return (d.displayName || "Context") + ".Consumer";
      case 10:
        return (d._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return c = d.render, c = c.displayName || c.name || "", d.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return d;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return je(d);
      case 8:
        return d === te ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof d == "function")
          return d.displayName || d.name || null;
        if (typeof d == "string")
          return d;
    }
    return null;
  }
  function at(c) {
    switch (typeof c) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return c;
      case "object":
        return c;
      default:
        return "";
    }
  }
  function xt(c) {
    var d = c.type;
    return (c = c.nodeName) && c.toLowerCase() === "input" && (d === "checkbox" || d === "radio");
  }
  function $t(c) {
    var d = xt(c) ? "checked" : "value", x = Object.getOwnPropertyDescriptor(c.constructor.prototype, d), A = "" + c[d];
    if (!c.hasOwnProperty(d) && typeof x < "u" && typeof x.get == "function" && typeof x.set == "function") {
      var F = x.get, W = x.set;
      return Object.defineProperty(c, d, { configurable: !0, get: function() {
        return F.call(this);
      }, set: function(ie) {
        A = "" + ie, W.call(this, ie);
      } }), Object.defineProperty(c, d, { enumerable: x.enumerable }), { getValue: function() {
        return A;
      }, setValue: function(ie) {
        A = "" + ie;
      }, stopTracking: function() {
        c._valueTracker = null, delete c[d];
      } };
    }
  }
  function Ht(c) {
    c._valueTracker || (c._valueTracker = $t(c));
  }
  function he(c) {
    if (!c)
      return !1;
    var d = c._valueTracker;
    if (!d)
      return !0;
    var x = d.getValue(), A = "";
    return c && (A = xt(c) ? c.checked ? "true" : "false" : c.value), c = A, c !== x ? (d.setValue(c), !0) : !1;
  }
  function nt(c) {
    if (c = c || (typeof document < "u" ? document : void 0), typeof c > "u")
      return null;
    try {
      return c.activeElement || c.body;
    } catch {
      return c.body;
    }
  }
  function et(c, d) {
    var x = d.checked;
    return X({}, d, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: x ?? c._wrapperState.initialChecked });
  }
  function Rt(c, d) {
    var x = d.defaultValue == null ? "" : d.defaultValue, A = d.checked != null ? d.checked : d.defaultChecked;
    x = at(d.value != null ? d.value : x), c._wrapperState = { initialChecked: A, initialValue: x, controlled: d.type === "checkbox" || d.type === "radio" ? d.checked != null : d.value != null };
  }
  function gt(c, d) {
    d = d.checked, d != null && k(c, "checked", d, !1);
  }
  function Jt(c, d) {
    gt(c, d);
    var x = at(d.value), A = d.type;
    if (x != null)
      A === "number" ? (x === 0 && c.value === "" || c.value != x) && (c.value = "" + x) : c.value !== "" + x && (c.value = "" + x);
    else if (A === "submit" || A === "reset") {
      c.removeAttribute("value");
      return;
    }
    d.hasOwnProperty("value") ? qt(c, d.type, x) : d.hasOwnProperty("defaultValue") && qt(c, d.type, at(d.defaultValue)), d.checked == null && d.defaultChecked != null && (c.defaultChecked = !!d.defaultChecked);
  }
  function Kt(c, d, x) {
    if (d.hasOwnProperty("value") || d.hasOwnProperty("defaultValue")) {
      var A = d.type;
      if (!(A !== "submit" && A !== "reset" || d.value !== void 0 && d.value !== null))
        return;
      d = "" + c._wrapperState.initialValue, x || d === c.value || (c.value = d), c.defaultValue = d;
    }
    x = c.name, x !== "" && (c.name = ""), c.defaultChecked = !!c._wrapperState.initialChecked, x !== "" && (c.name = x);
  }
  function qt(c, d, x) {
    (d !== "number" || nt(c.ownerDocument) !== c) && (x == null ? c.defaultValue = "" + c._wrapperState.initialValue : c.defaultValue !== "" + x && (c.defaultValue = "" + x));
  }
  var hn = Array.isArray;
  function Rn(c, d, x, A) {
    if (c = c.options, d) {
      d = {};
      for (var F = 0; F < x.length; F++)
        d["$" + x[F]] = !0;
      for (x = 0; x < c.length; x++)
        F = d.hasOwnProperty("$" + c[x].value), c[x].selected !== F && (c[x].selected = F), F && A && (c[x].defaultSelected = !0);
    } else {
      for (x = "" + at(x), d = null, F = 0; F < c.length; F++) {
        if (c[F].value === x) {
          c[F].selected = !0, A && (c[F].defaultSelected = !0);
          return;
        }
        d !== null || c[F].disabled || (d = c[F]);
      }
      d !== null && (d.selected = !0);
    }
  }
  function Yn(c, d) {
    if (d.dangerouslySetInnerHTML != null)
      throw Error(t(91));
    return X({}, d, { value: void 0, defaultValue: void 0, children: "" + c._wrapperState.initialValue });
  }
  function se(c, d) {
    var x = d.value;
    if (x == null) {
      if (x = d.children, d = d.defaultValue, x != null) {
        if (d != null)
          throw Error(t(92));
        if (hn(x)) {
          if (1 < x.length)
            throw Error(t(93));
          x = x[0];
        }
        d = x;
      }
      d == null && (d = ""), x = d;
    }
    c._wrapperState = { initialValue: at(x) };
  }
  function ae(c, d) {
    var x = at(d.value), A = at(d.defaultValue);
    x != null && (x = "" + x, x !== c.value && (c.value = x), d.defaultValue == null && c.defaultValue !== x && (c.defaultValue = x)), A != null && (c.defaultValue = "" + A);
  }
  function Ke(c) {
    var d = c.textContent;
    d === c._wrapperState.initialValue && d !== "" && d !== null && (c.value = d);
  }
  function wt(c) {
    switch (c) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function _t(c, d) {
    return c == null || c === "http://www.w3.org/1999/xhtml" ? wt(d) : c === "http://www.w3.org/2000/svg" && d === "foreignObject" ? "http://www.w3.org/1999/xhtml" : c;
  }
  var Vt, fn = function(c) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(d, x, A, F) {
      MSApp.execUnsafeLocalFunction(function() {
        return c(d, x, A, F);
      });
    } : c;
  }(function(c, d) {
    if (c.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in c)
      c.innerHTML = d;
    else {
      for (Vt = Vt || document.createElement("div"), Vt.innerHTML = "<svg>" + d.valueOf().toString() + "</svg>", d = Vt.firstChild; c.firstChild; )
        c.removeChild(c.firstChild);
      for (; d.firstChild; )
        c.appendChild(d.firstChild);
    }
  });
  function Wt(c, d) {
    if (d) {
      var x = c.firstChild;
      if (x && x === c.lastChild && x.nodeType === 3) {
        x.nodeValue = d;
        return;
      }
    }
    c.textContent = d;
  }
  var Ee = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Xe = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Ee).forEach(function(c) {
    Xe.forEach(function(d) {
      d = d + c.charAt(0).toUpperCase() + c.substring(1), Ee[d] = Ee[c];
    });
  });
  function St(c, d, x) {
    return d == null || typeof d == "boolean" || d === "" ? "" : x || typeof d != "number" || d === 0 || Ee.hasOwnProperty(c) && Ee[c] ? ("" + d).trim() : d + "px";
  }
  function Ut(c, d) {
    c = c.style;
    for (var x in d)
      if (d.hasOwnProperty(x)) {
        var A = x.indexOf("--") === 0, F = St(x, d[x], A);
        x === "float" && (x = "cssFloat"), A ? c.setProperty(x, F) : c[x] = F;
      }
  }
  var Se = X({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Ye(c, d) {
    if (d) {
      if (Se[c] && (d.children != null || d.dangerouslySetInnerHTML != null))
        throw Error(t(137, c));
      if (d.dangerouslySetInnerHTML != null) {
        if (d.children != null)
          throw Error(t(60));
        if (typeof d.dangerouslySetInnerHTML != "object" || !("__html" in d.dangerouslySetInnerHTML))
          throw Error(t(61));
      }
      if (d.style != null && typeof d.style != "object")
        throw Error(t(62));
    }
  }
  function bt(c, d) {
    if (c.indexOf("-") === -1)
      return typeof d.is == "string";
    switch (c) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Tt = null;
  function ge(c) {
    return c = c.target || c.srcElement || window, c.correspondingUseElement && (c = c.correspondingUseElement), c.nodeType === 3 ? c.parentNode : c;
  }
  var zt = null, Fe = null, ft = null;
  function ln(c) {
    if (c = Fs(c)) {
      if (typeof zt != "function")
        throw Error(t(280));
      var d = c.stateNode;
      d && (d = Kn(d), zt(c.stateNode, c.type, d));
    }
  }
  function zn(c) {
    Fe ? ft ? ft.push(c) : ft = [c] : Fe = c;
  }
  function yr() {
    if (Fe) {
      var c = Fe, d = ft;
      if (ft = Fe = null, ln(c), d)
        for (c = 0; c < d.length; c++)
          ln(d[c]);
    }
  }
  function ti(c, d) {
    return c(d);
  }
  function rr() {
  }
  var vr = !1;
  function Ai(c, d, x) {
    if (vr)
      return c(d, x);
    vr = !0;
    try {
      return ti(c, d, x);
    } finally {
      vr = !1, (Fe !== null || ft !== null) && (rr(), yr());
    }
  }
  function oi(c, d) {
    var x = c.stateNode;
    if (x === null)
      return null;
    var A = Kn(x);
    if (A === null)
      return null;
    x = A[d];
    e:
      switch (d) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (A = !A.disabled) || (c = c.type, A = !(c === "button" || c === "input" || c === "select" || c === "textarea")), c = !A;
          break e;
        default:
          c = !1;
      }
    if (c)
      return null;
    if (x && typeof x != "function")
      throw Error(t(231, d, typeof x));
    return x;
  }
  var Ma = !1;
  if (h)
    try {
      var Ji = {};
      Object.defineProperty(Ji, "passive", { get: function() {
        Ma = !0;
      } }), window.addEventListener("test", Ji, Ji), window.removeEventListener("test", Ji, Ji);
    } catch {
      Ma = !1;
    }
  function _l(c, d, x, A, F, W, ie, Ae, Ie) {
    var pt = Array.prototype.slice.call(arguments, 3);
    try {
      d.apply(x, pt);
    } catch (Yt) {
      this.onError(Yt);
    }
  }
  var ea = !1, _o = null, Eo = !1, Le = null, Bt = { onError: function(c) {
    ea = !0, _o = c;
  } };
  function en(c, d, x, A, F, W, ie, Ae, Ie) {
    ea = !1, _o = null, _l.apply(Bt, arguments);
  }
  function _n(c, d, x, A, F, W, ie, Ae, Ie) {
    if (en.apply(this, arguments), ea) {
      if (ea) {
        var pt = _o;
        ea = !1, _o = null;
      } else
        throw Error(t(198));
      Eo || (Eo = !0, Le = pt);
    }
  }
  function ve(c) {
    var d = c, x = c;
    if (c.alternate)
      for (; d.return; )
        d = d.return;
    else {
      c = d;
      do
        d = c, d.flags & 4098 && (x = d.return), c = d.return;
      while (c);
    }
    return d.tag === 3 ? x : null;
  }
  function $e(c) {
    if (c.tag === 13) {
      var d = c.memoizedState;
      if (d === null && (c = c.alternate, c !== null && (d = c.memoizedState)), d !== null)
        return d.dehydrated;
    }
    return null;
  }
  function qe(c) {
    if (ve(c) !== c)
      throw Error(t(188));
  }
  function ze(c) {
    var d = c.alternate;
    if (!d) {
      if (d = ve(c), d === null)
        throw Error(t(188));
      return d !== c ? null : c;
    }
    for (var x = c, A = d; ; ) {
      var F = x.return;
      if (F === null)
        break;
      var W = F.alternate;
      if (W === null) {
        if (A = F.return, A !== null) {
          x = A;
          continue;
        }
        break;
      }
      if (F.child === W.child) {
        for (W = F.child; W; ) {
          if (W === x)
            return qe(F), c;
          if (W === A)
            return qe(F), d;
          W = W.sibling;
        }
        throw Error(t(188));
      }
      if (x.return !== A.return)
        x = F, A = W;
      else {
        for (var ie = !1, Ae = F.child; Ae; ) {
          if (Ae === x) {
            ie = !0, x = F, A = W;
            break;
          }
          if (Ae === A) {
            ie = !0, A = F, x = W;
            break;
          }
          Ae = Ae.sibling;
        }
        if (!ie) {
          for (Ae = W.child; Ae; ) {
            if (Ae === x) {
              ie = !0, x = W, A = F;
              break;
            }
            if (Ae === A) {
              ie = !0, A = W, x = F;
              break;
            }
            Ae = Ae.sibling;
          }
          if (!ie)
            throw Error(t(189));
        }
      }
      if (x.alternate !== A)
        throw Error(t(190));
    }
    if (x.tag !== 3)
      throw Error(t(188));
    return x.stateNode.current === x ? c : d;
  }
  function dt(c) {
    return c = ze(c), c !== null ? tn(c) : null;
  }
  function tn(c) {
    if (c.tag === 5 || c.tag === 6)
      return c;
    for (c = c.child; c !== null; ) {
      var d = tn(c);
      if (d !== null)
        return d;
      c = c.sibling;
    }
    return null;
  }
  var pn = e.unstable_scheduleCallback, An = e.unstable_cancelCallback, Gn = e.unstable_shouldYield, cr = e.unstable_requestPaint, sn = e.unstable_now, pr = e.unstable_getCurrentPriorityLevel, Pr = e.unstable_ImmediatePriority, kn = e.unstable_UserBlockingPriority, za = e.unstable_NormalPriority, Ja = e.unstable_LowPriority, Si = e.unstable_IdlePriority, ir = null, Cr = null;
  function fr(c) {
    if (Cr && typeof Cr.onCommitFiberRoot == "function")
      try {
        Cr.onCommitFiberRoot(ir, c, void 0, (c.current.flags & 128) === 128);
      } catch {
      }
  }
  var Di = Math.clz32 ? Math.clz32 : ss, wa = Math.log, ni = Math.LN2;
  function ss(c) {
    return c >>>= 0, c === 0 ? 32 : 31 - (wa(c) / ni | 0) | 0;
  }
  var ta = 64, Vi = 4194304;
  function Po(c) {
    switch (c & -c) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return c & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return c;
    }
  }
  function Ui(c, d) {
    var x = c.pendingLanes;
    if (x === 0)
      return 0;
    var A = 0, F = c.suspendedLanes, W = c.pingedLanes, ie = x & 268435455;
    if (ie !== 0) {
      var Ae = ie & ~F;
      Ae !== 0 ? A = Po(Ae) : (W &= ie, W !== 0 && (A = Po(W)));
    } else
      ie = x & ~F, ie !== 0 ? A = Po(ie) : W !== 0 && (A = Po(W));
    if (A === 0)
      return 0;
    if (d !== 0 && d !== A && !(d & F) && (F = A & -A, W = d & -d, F >= W || F === 16 && (W & 4194240) !== 0))
      return d;
    if (A & 4 && (A |= x & 16), d = c.entangledLanes, d !== 0)
      for (c = c.entanglements, d &= A; 0 < d; )
        x = 31 - Di(d), F = 1 << x, A |= c[x], d &= ~F;
    return A;
  }
  function El(c, d) {
    switch (c) {
      case 1:
      case 2:
      case 4:
        return d + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return d + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Ds(c, d) {
    for (var x = c.suspendedLanes, A = c.pingedLanes, F = c.expirationTimes, W = c.pendingLanes; 0 < W; ) {
      var ie = 31 - Di(W), Ae = 1 << ie, Ie = F[ie];
      Ie === -1 ? (!(Ae & x) || Ae & A) && (F[ie] = El(Ae, d)) : Ie <= d && (c.expiredLanes |= Ae), W &= ~Ae;
    }
  }
  function bl(c) {
    return c = c.pendingLanes & -1073741825, c !== 0 ? c : c & 1073741824 ? 1073741824 : 0;
  }
  function Go() {
    var c = ta;
    return ta <<= 1, !(ta & 4194240) && (ta = 64), c;
  }
  function Mf(c) {
    for (var d = [], x = 0; 31 > x; x++)
      d.push(c);
    return d;
  }
  function Qu(c, d, x) {
    c.pendingLanes |= d, d !== 536870912 && (c.suspendedLanes = 0, c.pingedLanes = 0), c = c.eventTimes, d = 31 - Di(d), c[d] = x;
  }
  function fm(c, d) {
    var x = c.pendingLanes & ~d;
    c.pendingLanes = d, c.suspendedLanes = 0, c.pingedLanes = 0, c.expiredLanes &= d, c.mutableReadLanes &= d, c.entangledLanes &= d, d = c.entanglements;
    var A = c.eventTimes;
    for (c = c.expirationTimes; 0 < x; ) {
      var F = 31 - Di(x), W = 1 << F;
      d[F] = 0, A[F] = -1, c[F] = -1, x &= ~W;
    }
  }
  function Tl(c, d) {
    var x = c.entangledLanes |= d;
    for (c = c.entanglements; x; ) {
      var A = 31 - Di(x), F = 1 << A;
      F & d | c[A] & d && (c[A] |= d), x &= ~F;
    }
  }
  var Kr = 0;
  function Ml(c) {
    return c &= -c, 1 < c ? 4 < c ? c & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Zu, ls, jr, lo, wf, lr = !1, pd = [], pa = null, br = null, us = null, Ls = /* @__PURE__ */ new Map(), Ca = /* @__PURE__ */ new Map(), zi = [], dm = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function si(c, d) {
    switch (c) {
      case "focusin":
      case "focusout":
        pa = null;
        break;
      case "dragenter":
      case "dragleave":
        br = null;
        break;
      case "mouseover":
      case "mouseout":
        us = null;
        break;
      case "pointerover":
      case "pointerout":
        Ls.delete(d.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Ca.delete(d.pointerId);
    }
  }
  function uo(c, d, x, A, F, W) {
    return c === null || c.nativeEvent !== W ? (c = { blockedOn: d, domEventName: x, eventSystemFlags: A, nativeEvent: W, targetContainers: [F] }, d !== null && (d = Fs(d), d !== null && ls(d)), c) : (c.eventSystemFlags |= A, d = c.targetContainers, F !== null && d.indexOf(F) === -1 && d.push(F), c);
  }
  function Ju(c, d, x, A, F) {
    switch (d) {
      case "focusin":
        return pa = uo(pa, c, d, x, A, F), !0;
      case "dragenter":
        return br = uo(br, c, d, x, A, F), !0;
      case "mouseover":
        return us = uo(us, c, d, x, A, F), !0;
      case "pointerover":
        var W = F.pointerId;
        return Ls.set(W, uo(Ls.get(W) || null, c, d, x, A, F)), !0;
      case "gotpointercapture":
        return W = F.pointerId, Ca.set(W, uo(Ca.get(W) || null, c, d, x, A, F)), !0;
    }
    return !1;
  }
  function ch(c) {
    var d = $o(c.target);
    if (d !== null) {
      var x = ve(d);
      if (x !== null) {
        if (d = x.tag, d === 13) {
          if (d = $e(x), d !== null) {
            c.blockedOn = d, wf(c.priority, function() {
              jr(x);
            });
            return;
          }
        } else if (d === 3 && x.stateNode.current.memoizedState.isDehydrated) {
          c.blockedOn = x.tag === 3 ? x.stateNode.containerInfo : null;
          return;
        }
      }
    }
    c.blockedOn = null;
  }
  function Nc(c) {
    if (c.blockedOn !== null)
      return !1;
    for (var d = c.targetContainers; 0 < d.length; ) {
      var x = Os(c.domEventName, c.eventSystemFlags, d[0], c.nativeEvent);
      if (x === null) {
        x = c.nativeEvent;
        var A = new x.constructor(x.type, x);
        Tt = A, x.target.dispatchEvent(A), Tt = null;
      } else
        return d = Fs(x), d !== null && ls(d), c.blockedOn = x, !1;
      d.shift();
    }
    return !0;
  }
  function Eu(c, d, x) {
    Nc(c) && x.delete(d);
  }
  function wl() {
    lr = !1, pa !== null && Nc(pa) && (pa = null), br !== null && Nc(br) && (br = null), us !== null && Nc(us) && (us = null), Ls.forEach(Eu), Ca.forEach(Eu);
  }
  function Jl(c, d) {
    c.blockedOn === d && (c.blockedOn = null, lr || (lr = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, wl)));
  }
  function Cf(c) {
    function d(F) {
      return Jl(F, c);
    }
    if (0 < pd.length) {
      Jl(pd[0], c);
      for (var x = 1; x < pd.length; x++) {
        var A = pd[x];
        A.blockedOn === c && (A.blockedOn = null);
      }
    }
    for (pa !== null && Jl(pa, c), br !== null && Jl(br, c), us !== null && Jl(us, c), Ls.forEach(d), Ca.forEach(d), x = 0; x < zi.length; x++)
      A = zi[x], A.blockedOn === c && (A.blockedOn = null);
    for (; 0 < zi.length && (x = zi[0], x.blockedOn === null); )
      ch(x), x.blockedOn === null && zi.shift();
  }
  var Wo = G.ReactCurrentBatchConfig, co = !0;
  function Uc(c, d, x, A) {
    var F = Kr, W = Wo.transition;
    Wo.transition = null;
    try {
      Kr = 1, tc(c, d, x, A);
    } finally {
      Kr = F, Wo.transition = W;
    }
  }
  function ec(c, d, x, A) {
    var F = Kr, W = Wo.transition;
    Wo.transition = null;
    try {
      Kr = 4, tc(c, d, x, A);
    } finally {
      Kr = F, Wo.transition = W;
    }
  }
  function tc(c, d, x, A) {
    if (co) {
      var F = Os(c, d, x, A);
      if (F === null)
        Ll(c, d, A, md, x), si(c, A);
      else if (Ju(F, c, d, x, A))
        A.stopPropagation();
      else if (si(c, A), d & 4 && -1 < dm.indexOf(c)) {
        for (; F !== null; ) {
          var W = Fs(F);
          if (W !== null && Zu(W), W = Os(c, d, x, A), W === null && Ll(c, d, A, md, x), W === F)
            break;
          F = W;
        }
        F !== null && A.stopPropagation();
      } else
        Ll(c, d, A, null, x);
    }
  }
  var md = null;
  function Os(c, d, x, A) {
    if (md = null, c = ge(A), c = $o(c), c !== null)
      if (d = ve(c), d === null)
        c = null;
      else if (x = d.tag, x === 13) {
        if (c = $e(d), c !== null)
          return c;
        c = null;
      } else if (x === 3) {
        if (d.stateNode.current.memoizedState.isDehydrated)
          return d.tag === 3 ? d.stateNode.containerInfo : null;
        c = null;
      } else
        d !== c && (c = null);
    return md = c, null;
  }
  function op(c) {
    switch (c) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (pr()) {
          case Pr:
            return 1;
          case kn:
            return 4;
          case za:
          case Ja:
            return 16;
          case Si:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var nl = null, ne = null, De = null;
  function st() {
    if (De)
      return De;
    var c, d = ne, x = d.length, A, F = "value" in nl ? nl.value : nl.textContent, W = F.length;
    for (c = 0; c < x && d[c] === F[c]; c++)
      ;
    var ie = x - c;
    for (A = 1; A <= ie && d[x - A] === F[W - A]; A++)
      ;
    return De = F.slice(c, 1 < A ? 1 - A : void 0);
  }
  function yt(c) {
    var d = c.keyCode;
    return "charCode" in c ? (c = c.charCode, c === 0 && d === 13 && (c = 13)) : c = d, c === 10 && (c = 13), 32 <= c || c === 13 ? c : 0;
  }
  function Zt() {
    return !0;
  }
  function Xn() {
    return !1;
  }
  function mn(c) {
    function d(x, A, F, W, ie) {
      this._reactName = x, this._targetInst = F, this.type = A, this.nativeEvent = W, this.target = ie, this.currentTarget = null;
      for (var Ae in c)
        c.hasOwnProperty(Ae) && (x = c[Ae], this[Ae] = x ? x(W) : W[Ae]);
      return this.isDefaultPrevented = (W.defaultPrevented != null ? W.defaultPrevented : W.returnValue === !1) ? Zt : Xn, this.isPropagationStopped = Xn, this;
    }
    return X(d.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var x = this.nativeEvent;
      x && (x.preventDefault ? x.preventDefault() : typeof x.returnValue != "unknown" && (x.returnValue = !1), this.isDefaultPrevented = Zt);
    }, stopPropagation: function() {
      var x = this.nativeEvent;
      x && (x.stopPropagation ? x.stopPropagation() : typeof x.cancelBubble != "unknown" && (x.cancelBubble = !0), this.isPropagationStopped = Zt);
    }, persist: function() {
    }, isPersistent: Zt }), d;
  }
  var qn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(c) {
    return c.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Nr = mn(qn), ri = X({}, qn, { view: 0, detail: 0 }), Ti = mn(ri), Br, Qr, li, $r = X({}, ri, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Af, button: 0, buttons: 0, relatedTarget: function(c) {
    return c.relatedTarget === void 0 ? c.fromElement === c.srcElement ? c.toElement : c.fromElement : c.relatedTarget;
  }, movementX: function(c) {
    return "movementX" in c ? c.movementX : (c !== li && (li && c.type === "mousemove" ? (Br = c.screenX - li.screenX, Qr = c.screenY - li.screenY) : Qr = Br = 0, li = c), Br);
  }, movementY: function(c) {
    return "movementY" in c ? c.movementY : Qr;
  } }), Cl = mn($r), rl = X({}, $r, { dataTransfer: 0 }), eu = mn(rl), fh = X({}, ri, { relatedTarget: 0 }), tu = mn(fh), Rf = X({}, qn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), dh = mn(Rf), hm = X({}, qn, { clipboardData: function(c) {
    return "clipboardData" in c ? c.clipboardData : window.clipboardData;
  } }), pm = mn(hm), mm = X({}, qn, { data: 0 }), vm = mn(mm), gm = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Cv = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, ym = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function vd(c) {
    var d = this.nativeEvent;
    return d.getModifierState ? d.getModifierState(c) : (c = ym[c]) ? !!d[c] : !1;
  }
  function Af() {
    return vd;
  }
  var nu = X({}, ri, { key: function(c) {
    if (c.key) {
      var d = gm[c.key] || c.key;
      if (d !== "Unidentified")
        return d;
    }
    return c.type === "keypress" ? (c = yt(c), c === 13 ? "Enter" : String.fromCharCode(c)) : c.type === "keydown" || c.type === "keyup" ? Cv[c.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Af, charCode: function(c) {
    return c.type === "keypress" ? yt(c) : 0;
  }, keyCode: function(c) {
    return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
  }, which: function(c) {
    return c.type === "keypress" ? yt(c) : c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
  } }), Sm = mn(nu), il = X({}, $r, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Ps = mn(il), zc = X({}, ri, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Af }), kc = mn(zc), ru = X({}, qn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Df = mn(ru), Ns = X({}, $r, {
    deltaX: function(c) {
      return "deltaX" in c ? c.deltaX : "wheelDeltaX" in c ? -c.wheelDeltaX : 0;
    },
    deltaY: function(c) {
      return "deltaY" in c ? c.deltaY : "wheelDeltaY" in c ? -c.wheelDeltaY : "wheelDelta" in c ? -c.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), bu = mn(Ns), ka = [9, 13, 27, 32], Ra = h && "CompositionEvent" in window, Aa = null;
  h && "documentMode" in document && (Aa = document.documentMode);
  var Yi = h && "TextEvent" in window && !Aa, gd = h && (!Ra || Aa && 8 < Aa && 11 >= Aa), jo = " ", xm = !1;
  function _m(c, d) {
    switch (c) {
      case "keyup":
        return ka.indexOf(d.keyCode) !== -1;
      case "keydown":
        return d.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function yd(c) {
    return c = c.detail, typeof c == "object" && "data" in c ? c.data : null;
  }
  var Ic = !1;
  function Rv(c, d) {
    switch (c) {
      case "compositionend":
        return yd(d);
      case "keypress":
        return d.which !== 32 ? null : (xm = !0, jo);
      case "textInput":
        return c = d.data, c === jo && xm ? null : c;
      default:
        return null;
    }
  }
  function sp(c, d) {
    if (Ic)
      return c === "compositionend" || !Ra && _m(c, d) ? (c = st(), De = ne = nl = null, Ic = !1, c) : null;
    switch (c) {
      case "paste":
        return null;
      case "keypress":
        if (!(d.ctrlKey || d.altKey || d.metaKey) || d.ctrlKey && d.altKey) {
          if (d.char && 1 < d.char.length)
            return d.char;
          if (d.which)
            return String.fromCharCode(d.which);
        }
        return null;
      case "compositionend":
        return gd && d.locale !== "ko" ? null : d.data;
      default:
        return null;
    }
  }
  var Sd = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function hh(c) {
    var d = c && c.nodeName && c.nodeName.toLowerCase();
    return d === "input" ? !!Sd[c.type] : d === "textarea";
  }
  function Lf(c, d, x, A) {
    zn(A), d = oc(d, "onChange"), 0 < d.length && (x = new Nr("onChange", "change", null, x, A), c.push({ event: x, listeners: d }));
  }
  var Us = null, Fc = null;
  function nc(c) {
    Gt(c, 0);
  }
  function Tu(c) {
    var d = xi(c);
    if (he(d))
      return c;
  }
  function lp(c, d) {
    if (c === "change")
      return d;
  }
  var xd = !1;
  if (h) {
    var cs;
    if (h) {
      var _d = "oninput" in document;
      if (!_d) {
        var Bc = document.createElement("div");
        Bc.setAttribute("oninput", "return;"), _d = typeof Bc.oninput == "function";
      }
      cs = _d;
    } else
      cs = !1;
    xd = cs && (!document.documentMode || 9 < document.documentMode);
  }
  function iu() {
    Us && (Us.detachEvent("onpropertychange", up), Fc = Us = null);
  }
  function up(c) {
    if (c.propertyName === "value" && Tu(Fc)) {
      var d = [];
      Lf(d, Fc, c, ge(c)), Ai(nc, d);
    }
  }
  function Ed(c, d, x) {
    c === "focusin" ? (iu(), Us = d, Fc = x, Us.attachEvent("onpropertychange", up)) : c === "focusout" && iu();
  }
  function cp(c) {
    if (c === "selectionchange" || c === "keyup" || c === "keydown")
      return Tu(Fc);
  }
  function Rl(c, d) {
    if (c === "click")
      return Tu(d);
  }
  function la(c, d) {
    if (c === "input" || c === "change")
      return Tu(d);
  }
  function bd(c, d) {
    return c === d && (c !== 0 || 1 / c === 1 / d) || c !== c && d !== d;
  }
  var Ia = typeof Object.is == "function" ? Object.is : bd;
  function al(c, d) {
    if (Ia(c, d))
      return !0;
    if (typeof c != "object" || c === null || typeof d != "object" || d === null)
      return !1;
    var x = Object.keys(c), A = Object.keys(d);
    if (x.length !== A.length)
      return !1;
    for (A = 0; A < x.length; A++) {
      var F = x[A];
      if (!v.call(d, F) || !Ia(c[F], d[F]))
        return !1;
    }
    return !0;
  }
  function fo(c) {
    for (; c && c.firstChild; )
      c = c.firstChild;
    return c;
  }
  function Gi(c, d) {
    var x = fo(c);
    c = 0;
    for (var A; x; ) {
      if (x.nodeType === 3) {
        if (A = c + x.textContent.length, c <= d && A >= d)
          return { node: x, offset: d - c };
        c = A;
      }
      e: {
        for (; x; ) {
          if (x.nextSibling) {
            x = x.nextSibling;
            break e;
          }
          x = x.parentNode;
        }
        x = void 0;
      }
      x = fo(x);
    }
  }
  function Hc(c, d) {
    return c && d ? c === d ? !0 : c && c.nodeType === 3 ? !1 : d && d.nodeType === 3 ? Hc(c, d.parentNode) : "contains" in c ? c.contains(d) : c.compareDocumentPosition ? !!(c.compareDocumentPosition(d) & 16) : !1 : !1;
  }
  function Zr() {
    for (var c = window, d = nt(); d instanceof c.HTMLIFrameElement; ) {
      try {
        var x = typeof d.contentWindow.location.href == "string";
      } catch {
        x = !1;
      }
      if (x)
        c = d.contentWindow;
      else
        break;
      d = nt(c.document);
    }
    return d;
  }
  function Mi(c) {
    var d = c && c.nodeName && c.nodeName.toLowerCase();
    return d && (d === "input" && (c.type === "text" || c.type === "search" || c.type === "tel" || c.type === "url" || c.type === "password") || d === "textarea" || c.contentEditable === "true");
  }
  function ki(c) {
    var d = Zr(), x = c.focusedElem, A = c.selectionRange;
    if (d !== x && x && x.ownerDocument && Hc(x.ownerDocument.documentElement, x)) {
      if (A !== null && Mi(x)) {
        if (d = A.start, c = A.end, c === void 0 && (c = d), "selectionStart" in x)
          x.selectionStart = d, x.selectionEnd = Math.min(c, x.value.length);
        else if (c = (d = x.ownerDocument || document) && d.defaultView || window, c.getSelection) {
          c = c.getSelection();
          var F = x.textContent.length, W = Math.min(A.start, F);
          A = A.end === void 0 ? W : Math.min(A.end, F), !c.extend && W > A && (F = A, A = W, W = F), F = Gi(x, W);
          var ie = Gi(
            x,
            A
          );
          F && ie && (c.rangeCount !== 1 || c.anchorNode !== F.node || c.anchorOffset !== F.offset || c.focusNode !== ie.node || c.focusOffset !== ie.offset) && (d = d.createRange(), d.setStart(F.node, F.offset), c.removeAllRanges(), W > A ? (c.addRange(d), c.extend(ie.node, ie.offset)) : (d.setEnd(ie.node, ie.offset), c.addRange(d)));
        }
      }
      for (d = [], c = x; c = c.parentNode; )
        c.nodeType === 1 && d.push({ element: c, left: c.scrollLeft, top: c.scrollTop });
      for (typeof x.focus == "function" && x.focus(), x = 0; x < d.length; x++)
        c = d[x], c.element.scrollLeft = c.left, c.element.scrollTop = c.top;
    }
  }
  var Td = h && "documentMode" in document && 11 >= document.documentMode, ho = null, Of = null, rc = null, eo = !1;
  function Al(c, d, x) {
    var A = x.window === x ? x.document : x.nodeType === 9 ? x : x.ownerDocument;
    eo || ho == null || ho !== nt(A) || (A = ho, "selectionStart" in A && Mi(A) ? A = { start: A.selectionStart, end: A.selectionEnd } : (A = (A.ownerDocument && A.ownerDocument.defaultView || window).getSelection(), A = { anchorNode: A.anchorNode, anchorOffset: A.anchorOffset, focusNode: A.focusNode, focusOffset: A.focusOffset }), rc && al(rc, A) || (rc = A, A = oc(Of, "onSelect"), 0 < A.length && (d = new Nr("onSelect", "select", null, d, x), c.push({ event: d, listeners: A }), d.target = ho)));
  }
  function Vc(c, d) {
    var x = {};
    return x[c.toLowerCase()] = d.toLowerCase(), x["Webkit" + c] = "webkit" + d, x["Moz" + c] = "moz" + d, x;
  }
  var Mu = { animationend: Vc("Animation", "AnimationEnd"), animationiteration: Vc("Animation", "AnimationIteration"), animationstart: Vc("Animation", "AnimationStart"), transitionend: Vc("Transition", "TransitionEnd") }, au = {}, Dl = {};
  h && (Dl = document.createElement("div").style, "AnimationEvent" in window || (delete Mu.animationend.animation, delete Mu.animationiteration.animation, delete Mu.animationstart.animation), "TransitionEvent" in window || delete Mu.transitionend.transition);
  function na(c) {
    if (au[c])
      return au[c];
    if (!Mu[c])
      return c;
    var d = Mu[c], x;
    for (x in d)
      if (d.hasOwnProperty(x) && x in Dl)
        return au[c] = d[x];
    return c;
  }
  var Md = na("animationend"), fp = na("animationiteration"), Pf = na("animationstart"), Em = na("transitionend"), mr = /* @__PURE__ */ new Map(), Ii = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Ur(c, d) {
    mr.set(c, d), s(d, [c]);
  }
  for (var ma = 0; ma < Ii.length; ma++) {
    var No = Ii[ma], ph = No.toLowerCase(), mh = No[0].toUpperCase() + No.slice(1);
    Ur(ph, "on" + mh);
  }
  Ur(Md, "onAnimationEnd"), Ur(fp, "onAnimationIteration"), Ur(Pf, "onAnimationStart"), Ur("dblclick", "onDoubleClick"), Ur("focusin", "onFocus"), Ur("focusout", "onBlur"), Ur(Em, "onTransitionEnd"), u("onMouseEnter", ["mouseout", "mouseover"]), u("onMouseLeave", ["mouseout", "mouseover"]), u("onPointerEnter", ["pointerout", "pointerover"]), u("onPointerLeave", ["pointerout", "pointerover"]), s("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), s("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), s("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Nf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), bm = new Set("cancel close invalid load scroll toggle".split(" ").concat(Nf));
  function vh(c, d, x) {
    var A = c.type || "unknown-event";
    c.currentTarget = x, _n(A, d, void 0, c), c.currentTarget = null;
  }
  function Gt(c, d) {
    d = (d & 4) !== 0;
    for (var x = 0; x < c.length; x++) {
      var A = c[x], F = A.event;
      A = A.listeners;
      e: {
        var W = void 0;
        if (d)
          for (var ie = A.length - 1; 0 <= ie; ie--) {
            var Ae = A[ie], Ie = Ae.instance, pt = Ae.currentTarget;
            if (Ae = Ae.listener, Ie !== W && F.isPropagationStopped())
              break e;
            vh(F, Ae, pt), W = Ie;
          }
        else
          for (ie = 0; ie < A.length; ie++) {
            if (Ae = A[ie], Ie = Ae.instance, pt = Ae.currentTarget, Ae = Ae.listener, Ie !== W && F.isPropagationStopped())
              break e;
            vh(F, Ae, pt), W = Ie;
          }
      }
    }
    if (Eo)
      throw c = Le, Eo = !1, Le = null, c;
  }
  function Tr(c, d) {
    var x = d[zf];
    x === void 0 && (x = d[zf] = /* @__PURE__ */ new Set());
    var A = c + "__bubble";
    x.has(A) || (ic(d, c, 2, !1), x.add(A));
  }
  function wr(c, d, x) {
    var A = 0;
    d && (A |= 4), ic(x, c, A, d);
  }
  var zs = "_reactListening" + Math.random().toString(36).slice(2);
  function ol(c) {
    if (!c[zs]) {
      c[zs] = !0, r.forEach(function(x) {
        x !== "selectionchange" && (bm.has(x) || wr(x, !1, c), wr(x, !0, c));
      });
      var d = c.nodeType === 9 ? c : c.ownerDocument;
      d === null || d[zs] || (d[zs] = !0, wr("selectionchange", !1, d));
    }
  }
  function ic(c, d, x, A) {
    switch (op(d)) {
      case 1:
        var F = Uc;
        break;
      case 4:
        F = ec;
        break;
      default:
        F = tc;
    }
    x = F.bind(null, d, x, c), F = void 0, !Ma || d !== "touchstart" && d !== "touchmove" && d !== "wheel" || (F = !0), A ? F !== void 0 ? c.addEventListener(d, x, { capture: !0, passive: F }) : c.addEventListener(d, x, !0) : F !== void 0 ? c.addEventListener(d, x, { passive: F }) : c.addEventListener(d, x, !1);
  }
  function Ll(c, d, x, A, F) {
    var W = A;
    if (!(d & 1) && !(d & 2) && A !== null)
      e:
        for (; ; ) {
          if (A === null)
            return;
          var ie = A.tag;
          if (ie === 3 || ie === 4) {
            var Ae = A.stateNode.containerInfo;
            if (Ae === F || Ae.nodeType === 8 && Ae.parentNode === F)
              break;
            if (ie === 4)
              for (ie = A.return; ie !== null; ) {
                var Ie = ie.tag;
                if ((Ie === 3 || Ie === 4) && (Ie = ie.stateNode.containerInfo, Ie === F || Ie.nodeType === 8 && Ie.parentNode === F))
                  return;
                ie = ie.return;
              }
            for (; Ae !== null; ) {
              if (ie = $o(Ae), ie === null)
                return;
              if (Ie = ie.tag, Ie === 5 || Ie === 6) {
                A = W = ie;
                continue e;
              }
              Ae = Ae.parentNode;
            }
          }
          A = A.return;
        }
    Ai(function() {
      var pt = W, Yt = ge(x), jt = [];
      e: {
        var Ft = mr.get(c);
        if (Ft !== void 0) {
          var Mn = Nr, Nn = c;
          switch (c) {
            case "keypress":
              if (yt(x) === 0)
                break e;
            case "keydown":
            case "keyup":
              Mn = Sm;
              break;
            case "focusin":
              Nn = "focus", Mn = tu;
              break;
            case "focusout":
              Nn = "blur", Mn = tu;
              break;
            case "beforeblur":
            case "afterblur":
              Mn = tu;
              break;
            case "click":
              if (x.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Mn = Cl;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Mn = eu;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Mn = kc;
              break;
            case Md:
            case fp:
            case Pf:
              Mn = dh;
              break;
            case Em:
              Mn = Df;
              break;
            case "scroll":
              Mn = Ti;
              break;
            case "wheel":
              Mn = bu;
              break;
            case "copy":
            case "cut":
            case "paste":
              Mn = pm;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Mn = Ps;
          }
          var Fn = (d & 4) !== 0, ro = !Fn && c === "scroll", Qe = Fn ? Ft !== null ? Ft + "Capture" : null : Ft;
          Fn = [];
          for (var Ve = pt, lt; Ve !== null; ) {
            lt = Ve;
            var on = lt.stateNode;
            if (lt.tag === 5 && on !== null && (lt = on, Qe !== null && (on = oi(Ve, Qe), on != null && Fn.push(ac(Ve, on, lt)))), ro)
              break;
            Ve = Ve.return;
          }
          0 < Fn.length && (Ft = new Mn(Ft, Nn, null, x, Yt), jt.push({ event: Ft, listeners: Fn }));
        }
      }
      if (!(d & 7)) {
        e: {
          if (Ft = c === "mouseover" || c === "pointerover", Mn = c === "mouseout" || c === "pointerout", Ft && x !== Tt && (Nn = x.relatedTarget || x.fromElement) && ($o(Nn) || Nn[Is]))
            break e;
          if ((Mn || Ft) && (Ft = Yt.window === Yt ? Yt : (Ft = Yt.ownerDocument) ? Ft.defaultView || Ft.parentWindow : window, Mn ? (Nn = x.relatedTarget || x.toElement, Mn = pt, Nn = Nn ? $o(Nn) : null, Nn !== null && (ro = ve(Nn), Nn !== ro || Nn.tag !== 5 && Nn.tag !== 6) && (Nn = null)) : (Mn = null, Nn = pt), Mn !== Nn)) {
            if (Fn = Cl, on = "onMouseLeave", Qe = "onMouseEnter", Ve = "mouse", (c === "pointerout" || c === "pointerover") && (Fn = Ps, on = "onPointerLeave", Qe = "onPointerEnter", Ve = "pointer"), ro = Mn == null ? Ft : xi(Mn), lt = Nn == null ? Ft : xi(Nn), Ft = new Fn(on, Ve + "leave", Mn, x, Yt), Ft.target = ro, Ft.relatedTarget = lt, on = null, $o(Yt) === pt && (Fn = new Fn(Qe, Ve + "enter", Nn, x, Yt), Fn.target = lt, Fn.relatedTarget = ro, on = Fn), ro = on, Mn && Nn)
              t: {
                for (Fn = Mn, Qe = Nn, Ve = 0, lt = Fn; lt; lt = ou(lt))
                  Ve++;
                for (lt = 0, on = Qe; on; on = ou(on))
                  lt++;
                for (; 0 < Ve - lt; )
                  Fn = ou(Fn), Ve--;
                for (; 0 < lt - Ve; )
                  Qe = ou(Qe), lt--;
                for (; Ve--; ) {
                  if (Fn === Qe || Qe !== null && Fn === Qe.alternate)
                    break t;
                  Fn = ou(Fn), Qe = ou(Qe);
                }
                Fn = null;
              }
            else
              Fn = null;
            Mn !== null && dp(jt, Ft, Mn, Fn, !1), Nn !== null && ro !== null && dp(jt, ro, Nn, Fn, !0);
          }
        }
        e: {
          if (Ft = pt ? xi(pt) : window, Mn = Ft.nodeName && Ft.nodeName.toLowerCase(), Mn === "select" || Mn === "input" && Ft.type === "file")
            var Bn = lp;
          else if (hh(Ft))
            if (xd)
              Bn = la;
            else {
              Bn = cp;
              var In = Ed;
            }
          else
            (Mn = Ft.nodeName) && Mn.toLowerCase() === "input" && (Ft.type === "checkbox" || Ft.type === "radio") && (Bn = Rl);
          if (Bn && (Bn = Bn(c, pt))) {
            Lf(jt, Bn, x, Yt);
            break e;
          }
          In && In(c, Ft, pt), c === "focusout" && (In = Ft._wrapperState) && In.controlled && Ft.type === "number" && qt(Ft, "number", Ft.value);
        }
        switch (In = pt ? xi(pt) : window, c) {
          case "focusin":
            (hh(In) || In.contentEditable === "true") && (ho = In, Of = pt, rc = null);
            break;
          case "focusout":
            rc = Of = ho = null;
            break;
          case "mousedown":
            eo = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            eo = !1, Al(jt, x, Yt);
            break;
          case "selectionchange":
            if (Td)
              break;
          case "keydown":
          case "keyup":
            Al(jt, x, Yt);
        }
        var er;
        if (Ra)
          e: {
            switch (c) {
              case "compositionstart":
                var gr = "onCompositionStart";
                break e;
              case "compositionend":
                gr = "onCompositionEnd";
                break e;
              case "compositionupdate":
                gr = "onCompositionUpdate";
                break e;
            }
            gr = void 0;
          }
        else
          Ic ? _m(c, x) && (gr = "onCompositionEnd") : c === "keydown" && x.keyCode === 229 && (gr = "onCompositionStart");
        gr && (gd && x.locale !== "ko" && (Ic || gr !== "onCompositionStart" ? gr === "onCompositionEnd" && Ic && (er = st()) : (nl = Yt, ne = "value" in nl ? nl.value : nl.textContent, Ic = !0)), In = oc(pt, gr), 0 < In.length && (gr = new vm(gr, c, null, x, Yt), jt.push({ event: gr, listeners: In }), er ? gr.data = er : (er = yd(x), er !== null && (gr.data = er)))), (er = Yi ? Rv(c, x) : sp(c, x)) && (pt = oc(pt, "onBeforeInput"), 0 < pt.length && (Yt = new vm("onBeforeInput", "beforeinput", null, x, Yt), jt.push({ event: Yt, listeners: pt }), Yt.data = er));
      }
      Gt(jt, d);
    });
  }
  function ac(c, d, x) {
    return { instance: c, listener: d, currentTarget: x };
  }
  function oc(c, d) {
    for (var x = d + "Capture", A = []; c !== null; ) {
      var F = c, W = F.stateNode;
      F.tag === 5 && W !== null && (F = W, W = oi(c, x), W != null && A.unshift(ac(c, W, F)), W = oi(c, d), W != null && A.push(ac(c, W, F))), c = c.return;
    }
    return A;
  }
  function ou(c) {
    if (c === null)
      return null;
    do
      c = c.return;
    while (c && c.tag !== 5);
    return c || null;
  }
  function dp(c, d, x, A, F) {
    for (var W = d._reactName, ie = []; x !== null && x !== A; ) {
      var Ae = x, Ie = Ae.alternate, pt = Ae.stateNode;
      if (Ie !== null && Ie === A)
        break;
      Ae.tag === 5 && pt !== null && (Ae = pt, F ? (Ie = oi(x, W), Ie != null && ie.unshift(ac(x, Ie, Ae))) : F || (Ie = oi(x, W), Ie != null && ie.push(ac(x, Ie, Ae)))), x = x.return;
    }
    ie.length !== 0 && c.push({ event: d, listeners: ie });
  }
  var hp = /\r\n?/g, Tm = /\u0000|\uFFFD/g;
  function gh(c) {
    return (typeof c == "string" ? c : "" + c).replace(hp, `
`).replace(Tm, "");
  }
  function wd(c, d, x) {
    if (d = gh(d), gh(c) !== d && x)
      throw Error(t(425));
  }
  function Cd() {
  }
  var Uf = null, Gc = null;
  function Rd(c, d) {
    return c === "textarea" || c === "noscript" || typeof d.children == "string" || typeof d.children == "number" || typeof d.dangerouslySetInnerHTML == "object" && d.dangerouslySetInnerHTML !== null && d.dangerouslySetInnerHTML.__html != null;
  }
  var Wc = typeof setTimeout == "function" ? setTimeout : void 0, yh = typeof clearTimeout == "function" ? clearTimeout : void 0, Ad = typeof Promise == "function" ? Promise : void 0, pp = typeof queueMicrotask == "function" ? queueMicrotask : typeof Ad < "u" ? function(c) {
    return Ad.resolve(null).then(c).catch(Mm);
  } : Wc;
  function Mm(c) {
    setTimeout(function() {
      throw c;
    });
  }
  function wu(c, d) {
    var x = d, A = 0;
    do {
      var F = x.nextSibling;
      if (c.removeChild(x), F && F.nodeType === 8)
        if (x = F.data, x === "/$") {
          if (A === 0) {
            c.removeChild(F), Cf(d);
            return;
          }
          A--;
        } else
          x !== "$" && x !== "$?" && x !== "$!" || A++;
      x = F;
    } while (x);
    Cf(d);
  }
  function ks(c) {
    for (; c != null; c = c.nextSibling) {
      var d = c.nodeType;
      if (d === 1 || d === 3)
        break;
      if (d === 8) {
        if (d = c.data, d === "$" || d === "$!" || d === "$?")
          break;
        if (d === "/$")
          return null;
      }
    }
    return c;
  }
  function Cu(c) {
    c = c.previousSibling;
    for (var d = 0; c; ) {
      if (c.nodeType === 8) {
        var x = c.data;
        if (x === "$" || x === "$!" || x === "$?") {
          if (d === 0)
            return c;
          d--;
        } else
          x === "/$" && d++;
      }
      c = c.previousSibling;
    }
    return null;
  }
  var Ru = Math.random().toString(36).slice(2), to = "__reactFiber$" + Ru, sc = "__reactProps$" + Ru, Is = "__reactContainer$" + Ru, zf = "__reactEvents$" + Ru, kf = "__reactListeners$" + Ru, Dd = "__reactHandles$" + Ru;
  function $o(c) {
    var d = c[to];
    if (d)
      return d;
    for (var x = c.parentNode; x; ) {
      if (d = x[Is] || x[to]) {
        if (x = d.alternate, d.child !== null || x !== null && x.child !== null)
          for (c = Cu(c); c !== null; ) {
            if (x = c[to])
              return x;
            c = Cu(c);
          }
        return d;
      }
      c = x, x = c.parentNode;
    }
    return null;
  }
  function Fs(c) {
    return c = c[to] || c[Is], !c || c.tag !== 5 && c.tag !== 6 && c.tag !== 13 && c.tag !== 3 ? null : c;
  }
  function xi(c) {
    if (c.tag === 5 || c.tag === 6)
      return c.stateNode;
    throw Error(t(33));
  }
  function Kn(c) {
    return c[sc] || null;
  }
  var _i = [], Hr = -1;
  function Hn(c) {
    return { current: c };
  }
  function ii(c) {
    0 > Hr || (c.current = _i[Hr], _i[Hr] = null, Hr--);
  }
  function di(c, d) {
    Hr++, _i[Hr] = c.current, c.current = d;
  }
  var Au = {}, dr = Hn(Au), Da = Hn(!1), fs = Au;
  function Bs(c, d) {
    var x = c.type.contextTypes;
    if (!x)
      return Au;
    var A = c.stateNode;
    if (A && A.__reactInternalMemoizedUnmaskedChildContext === d)
      return A.__reactInternalMemoizedMaskedChildContext;
    var F = {}, W;
    for (W in x)
      F[W] = d[W];
    return A && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = d, c.__reactInternalMemoizedMaskedChildContext = F), F;
  }
  function ua(c) {
    return c = c.childContextTypes, c != null;
  }
  function Hs() {
    ii(Da), ii(dr);
  }
  function lc(c, d, x) {
    if (dr.current !== Au)
      throw Error(t(168));
    di(dr, d), di(Da, x);
  }
  function If(c, d, x) {
    var A = c.stateNode;
    if (d = d.childContextTypes, typeof A.getChildContext != "function")
      return x;
    A = A.getChildContext();
    for (var F in A)
      if (!(F in d))
        throw Error(t(108, Je(c) || "Unknown", F));
    return X({}, x, A);
  }
  function uc(c) {
    return c = (c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext || Au, fs = dr.current, di(dr, c), di(Da, Da.current), !0;
  }
  function Av(c, d, x) {
    var A = c.stateNode;
    if (!A)
      throw Error(t(169));
    x ? (c = If(c, d, fs), A.__reactInternalMemoizedMergedChildContext = c, ii(Da), ii(dr), di(dr, c)) : ii(Da), di(Da, x);
  }
  var ds = null, bo = !1, Sh = !1;
  function su(c) {
    ds === null ? ds = [c] : ds.push(c);
  }
  function Ff(c) {
    bo = !0, su(c);
  }
  function Fa() {
    if (!Sh && ds !== null) {
      Sh = !0;
      var c = 0, d = Kr;
      try {
        var x = ds;
        for (Kr = 1; c < x.length; c++) {
          var A = x[c];
          do
            A = A(!0);
          while (A !== null);
        }
        ds = null, bo = !1;
      } catch (F) {
        throw ds !== null && (ds = ds.slice(c + 1)), pn(Pr, Fa), F;
      } finally {
        Kr = d, Sh = !1;
      }
    }
    return null;
  }
  var Du = [], hi = 0, lu = null, Sr = 0, po = [], La = 0, Lu = null, rn = 1, sl = "";
  function To(c, d) {
    Du[hi++] = Sr, Du[hi++] = lu, lu = c, Sr = d;
  }
  function wm(c, d, x) {
    po[La++] = rn, po[La++] = sl, po[La++] = Lu, Lu = c;
    var A = rn;
    c = sl;
    var F = 32 - Di(A) - 1;
    A &= ~(1 << F), x += 1;
    var W = 32 - Di(d) + F;
    if (30 < W) {
      var ie = F - F % 5;
      W = (A & (1 << ie) - 1).toString(32), A >>= ie, F -= ie, rn = 1 << 32 - Di(d) + F | x << F | A, sl = W + c;
    } else
      rn = 1 << W | x << F | A, sl = c;
  }
  function mp(c) {
    c.return !== null && (To(c, 1), wm(c, 1, 0));
  }
  function jc(c) {
    for (; c === lu; )
      lu = Du[--hi], Du[hi] = null, Sr = Du[--hi], Du[hi] = null;
    for (; c === Lu; )
      Lu = po[--La], po[La] = null, sl = po[--La], po[La] = null, rn = po[--La], po[La] = null;
  }
  var Mo = null, hs = null, ra = !1, ll = null;
  function Ol(c, d) {
    var x = Ys(5, null, null, 0);
    x.elementType = "DELETED", x.stateNode = d, x.return = c, d = c.deletions, d === null ? (c.deletions = [x], c.flags |= 16) : d.push(x);
  }
  function Ld(c, d) {
    switch (c.tag) {
      case 5:
        var x = c.type;
        return d = d.nodeType !== 1 || x.toLowerCase() !== d.nodeName.toLowerCase() ? null : d, d !== null ? (c.stateNode = d, Mo = c, hs = ks(d.firstChild), !0) : !1;
      case 6:
        return d = c.pendingProps === "" || d.nodeType !== 3 ? null : d, d !== null ? (c.stateNode = d, Mo = c, hs = null, !0) : !1;
      case 13:
        return d = d.nodeType !== 8 ? null : d, d !== null ? (x = Lu !== null ? { id: rn, overflow: sl } : null, c.memoizedState = { dehydrated: d, treeContext: x, retryLane: 1073741824 }, x = Ys(18, null, null, 0), x.stateNode = d, x.return = c, c.child = x, Mo = c, hs = null, !0) : !1;
      default:
        return !1;
    }
  }
  function $c(c) {
    return (c.mode & 1) !== 0 && (c.flags & 128) === 0;
  }
  function Od(c) {
    if (ra) {
      var d = hs;
      if (d) {
        var x = d;
        if (!Ld(c, d)) {
          if ($c(c))
            throw Error(t(418));
          d = ks(x.nextSibling);
          var A = Mo;
          d && Ld(c, d) ? Ol(A, x) : (c.flags = c.flags & -4097 | 2, ra = !1, Mo = c);
        }
      } else {
        if ($c(c))
          throw Error(t(418));
        c.flags = c.flags & -4097 | 2, ra = !1, Mo = c;
      }
    }
  }
  function Bf(c) {
    for (c = c.return; c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13; )
      c = c.return;
    Mo = c;
  }
  function ps(c) {
    if (c !== Mo)
      return !1;
    if (!ra)
      return Bf(c), ra = !0, !1;
    var d;
    if ((d = c.tag !== 3) && !(d = c.tag !== 5) && (d = c.type, d = d !== "head" && d !== "body" && !Rd(c.type, c.memoizedProps)), d && (d = hs)) {
      if ($c(c))
        throw mo(), Error(t(418));
      for (; d; )
        Ol(c, d), d = ks(d.nextSibling);
    }
    if (Bf(c), c.tag === 13) {
      if (c = c.memoizedState, c = c !== null ? c.dehydrated : null, !c)
        throw Error(t(317));
      e: {
        for (c = c.nextSibling, d = 0; c; ) {
          if (c.nodeType === 8) {
            var x = c.data;
            if (x === "/$") {
              if (d === 0) {
                hs = ks(c.nextSibling);
                break e;
              }
              d--;
            } else
              x !== "$" && x !== "$!" && x !== "$?" || d++;
          }
          c = c.nextSibling;
        }
        hs = null;
      }
    } else
      hs = Mo ? ks(c.stateNode.nextSibling) : null;
    return !0;
  }
  function mo() {
    for (var c = hs; c; )
      c = ks(c.nextSibling);
  }
  function va() {
    hs = Mo = null, ra = !1;
  }
  function xh(c) {
    ll === null ? ll = [c] : ll.push(c);
  }
  var Cm = G.ReactCurrentBatchConfig;
  function ul(c, d) {
    if (c && c.defaultProps) {
      d = X({}, d), c = c.defaultProps;
      for (var x in c)
        d[x] === void 0 && (d[x] = c[x]);
      return d;
    }
    return d;
  }
  var uu = Hn(null), _h = null, Yc = null, Rm = null;
  function Eh() {
    Rm = Yc = _h = null;
  }
  function Xi(c) {
    var d = uu.current;
    ii(uu), c._currentValue = d;
  }
  function ya(c, d, x) {
    for (; c !== null; ) {
      var A = c.alternate;
      if ((c.childLanes & d) !== d ? (c.childLanes |= d, A !== null && (A.childLanes |= d)) : A !== null && (A.childLanes & d) !== d && (A.childLanes |= d), c === x)
        break;
      c = c.return;
    }
  }
  function dn(c, d) {
    _h = c, Rm = Yc = null, c = c.dependencies, c !== null && c.firstContext !== null && (c.lanes & d && (yn = !0), c.firstContext = null);
  }
  function Wi(c) {
    var d = c._currentValue;
    if (Rm !== c)
      if (c = { context: c, memoizedValue: d, next: null }, Yc === null) {
        if (_h === null)
          throw Error(t(308));
        Yc = c, _h.dependencies = { lanes: 0, firstContext: c };
      } else
        Yc = Yc.next = c;
    return d;
  }
  var Ba = null;
  function vp(c) {
    Ba === null ? Ba = [c] : Ba.push(c);
  }
  function Am(c, d, x, A) {
    var F = d.interleaved;
    return F === null ? (x.next = x, vp(d)) : (x.next = F.next, F.next = x), d.interleaved = x, ms(c, A);
  }
  function ms(c, d) {
    c.lanes |= d;
    var x = c.alternate;
    for (x !== null && (x.lanes |= d), x = c, c = c.return; c !== null; )
      c.childLanes |= d, x = c.alternate, x !== null && (x.childLanes |= d), x = c, c = c.return;
    return x.tag === 3 ? x.stateNode : null;
  }
  var Sa = !1;
  function gn(c) {
    c.updateQueue = { baseState: c.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function qi(c, d) {
    c = c.updateQueue, d.updateQueue === c && (d.updateQueue = { baseState: c.baseState, firstBaseUpdate: c.firstBaseUpdate, lastBaseUpdate: c.lastBaseUpdate, shared: c.shared, effects: c.effects });
  }
  function Ha(c, d) {
    return { eventTime: c, lane: d, tag: 0, payload: null, callback: null, next: null };
  }
  function cc(c, d, x) {
    var A = c.updateQueue;
    if (A === null)
      return null;
    if (A = A.shared, xr & 2) {
      var F = A.pending;
      return F === null ? d.next = d : (d.next = F.next, F.next = d), A.pending = d, ms(c, x);
    }
    return F = A.interleaved, F === null ? (d.next = d, vp(A)) : (d.next = F.next, F.next = d), A.interleaved = d, ms(c, x);
  }
  function xa(c, d, x) {
    if (d = d.updateQueue, d !== null && (d = d.shared, (x & 4194240) !== 0)) {
      var A = d.lanes;
      A &= c.pendingLanes, x |= A, d.lanes = x, Tl(c, x);
    }
  }
  function zr(c, d) {
    var x = c.updateQueue, A = c.alternate;
    if (A !== null && (A = A.updateQueue, x === A)) {
      var F = null, W = null;
      if (x = x.firstBaseUpdate, x !== null) {
        do {
          var ie = { eventTime: x.eventTime, lane: x.lane, tag: x.tag, payload: x.payload, callback: x.callback, next: null };
          W === null ? F = W = ie : W = W.next = ie, x = x.next;
        } while (x !== null);
        W === null ? F = W = d : W = W.next = d;
      } else
        F = W = d;
      x = { baseState: A.baseState, firstBaseUpdate: F, lastBaseUpdate: W, shared: A.shared, effects: A.effects }, c.updateQueue = x;
      return;
    }
    c = x.lastBaseUpdate, c === null ? x.firstBaseUpdate = d : c.next = d, x.lastBaseUpdate = d;
  }
  function ia(c, d, x, A) {
    var F = c.updateQueue;
    Sa = !1;
    var W = F.firstBaseUpdate, ie = F.lastBaseUpdate, Ae = F.shared.pending;
    if (Ae !== null) {
      F.shared.pending = null;
      var Ie = Ae, pt = Ie.next;
      Ie.next = null, ie === null ? W = pt : ie.next = pt, ie = Ie;
      var Yt = c.alternate;
      Yt !== null && (Yt = Yt.updateQueue, Ae = Yt.lastBaseUpdate, Ae !== ie && (Ae === null ? Yt.firstBaseUpdate = pt : Ae.next = pt, Yt.lastBaseUpdate = Ie));
    }
    if (W !== null) {
      var jt = F.baseState;
      ie = 0, Yt = pt = Ie = null, Ae = W;
      do {
        var Ft = Ae.lane, Mn = Ae.eventTime;
        if ((A & Ft) === Ft) {
          Yt !== null && (Yt = Yt.next = {
            eventTime: Mn,
            lane: 0,
            tag: Ae.tag,
            payload: Ae.payload,
            callback: Ae.callback,
            next: null
          });
          e: {
            var Nn = c, Fn = Ae;
            switch (Ft = d, Mn = x, Fn.tag) {
              case 1:
                if (Nn = Fn.payload, typeof Nn == "function") {
                  jt = Nn.call(Mn, jt, Ft);
                  break e;
                }
                jt = Nn;
                break e;
              case 3:
                Nn.flags = Nn.flags & -65537 | 128;
              case 0:
                if (Nn = Fn.payload, Ft = typeof Nn == "function" ? Nn.call(Mn, jt, Ft) : Nn, Ft == null)
                  break e;
                jt = X({}, jt, Ft);
                break e;
              case 2:
                Sa = !0;
            }
          }
          Ae.callback !== null && Ae.lane !== 0 && (c.flags |= 64, Ft = F.effects, Ft === null ? F.effects = [Ae] : Ft.push(Ae));
        } else
          Mn = { eventTime: Mn, lane: Ft, tag: Ae.tag, payload: Ae.payload, callback: Ae.callback, next: null }, Yt === null ? (pt = Yt = Mn, Ie = jt) : Yt = Yt.next = Mn, ie |= Ft;
        if (Ae = Ae.next, Ae === null) {
          if (Ae = F.shared.pending, Ae === null)
            break;
          Ft = Ae, Ae = Ft.next, Ft.next = null, F.lastBaseUpdate = Ft, F.shared.pending = null;
        }
      } while (!0);
      if (Yt === null && (Ie = jt), F.baseState = Ie, F.firstBaseUpdate = pt, F.lastBaseUpdate = Yt, d = F.shared.interleaved, d !== null) {
        F = d;
        do
          ie |= F.lane, F = F.next;
        while (F !== d);
      } else
        W === null && (F.shared.lanes = 0);
      qf |= ie, c.lanes = ie, c.memoizedState = jt;
    }
  }
  function ca(c, d, x) {
    if (c = d.effects, d.effects = null, c !== null)
      for (d = 0; d < c.length; d++) {
        var A = c[d], F = A.callback;
        if (F !== null) {
          if (A.callback = null, A = x, typeof F != "function")
            throw Error(t(191, F));
          F.call(A);
        }
      }
  }
  var ui = new n.Component().refs;
  function Vs(c, d, x, A) {
    d = c.memoizedState, x = x(A, d), x = x == null ? d : X({}, d, x), c.memoizedState = x, c.lanes === 0 && (c.updateQueue.baseState = x);
  }
  var Xc = { isMounted: function(c) {
    return (c = c._reactInternals) ? ve(c) === c : !1;
  }, enqueueSetState: function(c, d, x) {
    c = c._reactInternals;
    var A = ji(), F = So(c), W = Ha(A, F);
    W.payload = d, x != null && (W.callback = x), d = cc(c, W, F), d !== null && (Ss(d, c, F, A), xa(d, c, F));
  }, enqueueReplaceState: function(c, d, x) {
    c = c._reactInternals;
    var A = ji(), F = So(c), W = Ha(A, F);
    W.tag = 1, W.payload = d, x != null && (W.callback = x), d = cc(c, W, F), d !== null && (Ss(d, c, F, A), xa(d, c, F));
  }, enqueueForceUpdate: function(c, d) {
    c = c._reactInternals;
    var x = ji(), A = So(c), F = Ha(x, A);
    F.tag = 2, d != null && (F.callback = d), d = cc(c, F, A), d !== null && (Ss(d, c, A, x), xa(d, c, A));
  } };
  function vo(c, d, x, A, F, W, ie) {
    return c = c.stateNode, typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(A, W, ie) : d.prototype && d.prototype.isPureReactComponent ? !al(x, A) || !al(F, W) : !0;
  }
  function Pd(c, d, x) {
    var A = !1, F = Au, W = d.contextType;
    return typeof W == "object" && W !== null ? W = Wi(W) : (F = ua(d) ? fs : dr.current, A = d.contextTypes, W = (A = A != null) ? Bs(c, F) : Au), d = new d(x, W), c.memoizedState = d.state !== null && d.state !== void 0 ? d.state : null, d.updater = Xc, c.stateNode = d, d._reactInternals = c, A && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = F, c.__reactInternalMemoizedMaskedChildContext = W), d;
  }
  function Ou(c, d, x, A) {
    c = d.state, typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(x, A), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(x, A), d.state !== c && Xc.enqueueReplaceState(d, d.state, null);
  }
  function cu(c, d, x, A) {
    var F = c.stateNode;
    F.props = x, F.state = c.memoizedState, F.refs = ui, gn(c);
    var W = d.contextType;
    typeof W == "object" && W !== null ? F.context = Wi(W) : (W = ua(d) ? fs : dr.current, F.context = Bs(c, W)), F.state = c.memoizedState, W = d.getDerivedStateFromProps, typeof W == "function" && (Vs(c, d, W, x), F.state = c.memoizedState), typeof d.getDerivedStateFromProps == "function" || typeof F.getSnapshotBeforeUpdate == "function" || typeof F.UNSAFE_componentWillMount != "function" && typeof F.componentWillMount != "function" || (d = F.state, typeof F.componentWillMount == "function" && F.componentWillMount(), typeof F.UNSAFE_componentWillMount == "function" && F.UNSAFE_componentWillMount(), d !== F.state && Xc.enqueueReplaceState(F, F.state, null), ia(c, x, F, A), F.state = c.memoizedState), typeof F.componentDidMount == "function" && (c.flags |= 4194308);
  }
  function Hf(c, d, x) {
    if (c = x.ref, c !== null && typeof c != "function" && typeof c != "object") {
      if (x._owner) {
        if (x = x._owner, x) {
          if (x.tag !== 1)
            throw Error(t(309));
          var A = x.stateNode;
        }
        if (!A)
          throw Error(t(147, c));
        var F = A, W = "" + c;
        return d !== null && d.ref !== null && typeof d.ref == "function" && d.ref._stringRef === W ? d.ref : (d = function(ie) {
          var Ae = F.refs;
          Ae === ui && (Ae = F.refs = {}), ie === null ? delete Ae[W] : Ae[W] = ie;
        }, d._stringRef = W, d);
      }
      if (typeof c != "string")
        throw Error(t(284));
      if (!x._owner)
        throw Error(t(290, c));
    }
    return c;
  }
  function Vf(c, d) {
    throw c = Object.prototype.toString.call(d), Error(t(31, c === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : c));
  }
  function Gs(c) {
    var d = c._init;
    return d(c._payload);
  }
  function Dm(c) {
    function d(Qe, Ve) {
      if (c) {
        var lt = Qe.deletions;
        lt === null ? (Qe.deletions = [Ve], Qe.flags |= 16) : lt.push(Ve);
      }
    }
    function x(Qe, Ve) {
      if (!c)
        return null;
      for (; Ve !== null; )
        d(Qe, Ve), Ve = Ve.sibling;
      return null;
    }
    function A(Qe, Ve) {
      for (Qe = /* @__PURE__ */ new Map(); Ve !== null; )
        Ve.key !== null ? Qe.set(Ve.key, Ve) : Qe.set(Ve.index, Ve), Ve = Ve.sibling;
      return Qe;
    }
    function F(Qe, Ve) {
      return Qe = kl(Qe, Ve), Qe.index = 0, Qe.sibling = null, Qe;
    }
    function W(Qe, Ve, lt) {
      return Qe.index = lt, c ? (lt = Qe.alternate, lt !== null ? (lt = lt.index, lt < Ve ? (Qe.flags |= 2, Ve) : lt) : (Qe.flags |= 2, Ve)) : (Qe.flags |= 1048576, Ve);
    }
    function ie(Qe) {
      return c && Qe.alternate === null && (Qe.flags |= 2), Qe;
    }
    function Ae(Qe, Ve, lt, on) {
      return Ve === null || Ve.tag !== 6 ? (Ve = vu(lt, Qe.mode, on), Ve.return = Qe, Ve) : (Ve = F(Ve, lt), Ve.return = Qe, Ve);
    }
    function Ie(Qe, Ve, lt, on) {
      var Bn = lt.type;
      return Bn === Z ? Yt(Qe, Ve, lt.props.children, on, lt.key) : Ve !== null && (Ve.elementType === Bn || typeof Bn == "object" && Bn !== null && Bn.$$typeof === Pe && Gs(Bn) === Ve.type) ? (on = F(Ve, lt.props), on.ref = Hf(Qe, Ve, lt), on.return = Qe, on) : (on = Wd(lt.type, lt.key, lt.props, null, Qe.mode, on), on.ref = Hf(Qe, Ve, lt), on.return = Qe, on);
    }
    function pt(Qe, Ve, lt, on) {
      return Ve === null || Ve.tag !== 4 || Ve.stateNode.containerInfo !== lt.containerInfo || Ve.stateNode.implementation !== lt.implementation ? (Ve = oa(lt, Qe.mode, on), Ve.return = Qe, Ve) : (Ve = F(Ve, lt.children || []), Ve.return = Qe, Ve);
    }
    function Yt(Qe, Ve, lt, on, Bn) {
      return Ve === null || Ve.tag !== 7 ? (Ve = Cp(lt, Qe.mode, on, Bn), Ve.return = Qe, Ve) : (Ve = F(Ve, lt), Ve.return = Qe, Ve);
    }
    function jt(Qe, Ve, lt) {
      if (typeof Ve == "string" && Ve !== "" || typeof Ve == "number")
        return Ve = vu("" + Ve, Qe.mode, lt), Ve.return = Qe, Ve;
      if (typeof Ve == "object" && Ve !== null) {
        switch (Ve.$$typeof) {
          case j:
            return lt = Wd(Ve.type, Ve.key, Ve.props, null, Qe.mode, lt), lt.ref = Hf(Qe, null, Ve), lt.return = Qe, lt;
          case Y:
            return Ve = oa(Ve, Qe.mode, lt), Ve.return = Qe, Ve;
          case Pe:
            var on = Ve._init;
            return jt(Qe, on(Ve._payload), lt);
        }
        if (hn(Ve) || we(Ve))
          return Ve = Cp(Ve, Qe.mode, lt, null), Ve.return = Qe, Ve;
        Vf(Qe, Ve);
      }
      return null;
    }
    function Ft(Qe, Ve, lt, on) {
      var Bn = Ve !== null ? Ve.key : null;
      if (typeof lt == "string" && lt !== "" || typeof lt == "number")
        return Bn !== null ? null : Ae(Qe, Ve, "" + lt, on);
      if (typeof lt == "object" && lt !== null) {
        switch (lt.$$typeof) {
          case j:
            return lt.key === Bn ? Ie(Qe, Ve, lt, on) : null;
          case Y:
            return lt.key === Bn ? pt(Qe, Ve, lt, on) : null;
          case Pe:
            return Bn = lt._init, Ft(
              Qe,
              Ve,
              Bn(lt._payload),
              on
            );
        }
        if (hn(lt) || we(lt))
          return Bn !== null ? null : Yt(Qe, Ve, lt, on, null);
        Vf(Qe, lt);
      }
      return null;
    }
    function Mn(Qe, Ve, lt, on, Bn) {
      if (typeof on == "string" && on !== "" || typeof on == "number")
        return Qe = Qe.get(lt) || null, Ae(Ve, Qe, "" + on, Bn);
      if (typeof on == "object" && on !== null) {
        switch (on.$$typeof) {
          case j:
            return Qe = Qe.get(on.key === null ? lt : on.key) || null, Ie(Ve, Qe, on, Bn);
          case Y:
            return Qe = Qe.get(on.key === null ? lt : on.key) || null, pt(Ve, Qe, on, Bn);
          case Pe:
            var In = on._init;
            return Mn(Qe, Ve, lt, In(on._payload), Bn);
        }
        if (hn(on) || we(on))
          return Qe = Qe.get(lt) || null, Yt(Ve, Qe, on, Bn, null);
        Vf(Ve, on);
      }
      return null;
    }
    function Nn(Qe, Ve, lt, on) {
      for (var Bn = null, In = null, er = Ve, gr = Ve = 0, Qo = null; er !== null && gr < lt.length; gr++) {
        er.index > gr ? (Qo = er, er = null) : Qo = er.sibling;
        var Ci = Ft(Qe, er, lt[gr], on);
        if (Ci === null) {
          er === null && (er = Qo);
          break;
        }
        c && er && Ci.alternate === null && d(Qe, er), Ve = W(Ci, Ve, gr), In === null ? Bn = Ci : In.sibling = Ci, In = Ci, er = Qo;
      }
      if (gr === lt.length)
        return x(Qe, er), ra && To(Qe, gr), Bn;
      if (er === null) {
        for (; gr < lt.length; gr++)
          er = jt(Qe, lt[gr], on), er !== null && (Ve = W(er, Ve, gr), In === null ? Bn = er : In.sibling = er, In = er);
        return ra && To(Qe, gr), Bn;
      }
      for (er = A(Qe, er); gr < lt.length; gr++)
        Qo = Mn(er, Qe, gr, lt[gr], on), Qo !== null && (c && Qo.alternate !== null && er.delete(Qo.key === null ? gr : Qo.key), Ve = W(Qo, Ve, gr), In === null ? Bn = Qo : In.sibling = Qo, In = Qo);
      return c && er.forEach(function(gc) {
        return d(Qe, gc);
      }), ra && To(Qe, gr), Bn;
    }
    function Fn(Qe, Ve, lt, on) {
      var Bn = we(lt);
      if (typeof Bn != "function")
        throw Error(t(150));
      if (lt = Bn.call(lt), lt == null)
        throw Error(t(151));
      for (var In = Bn = null, er = Ve, gr = Ve = 0, Qo = null, Ci = lt.next(); er !== null && !Ci.done; gr++, Ci = lt.next()) {
        er.index > gr ? (Qo = er, er = null) : Qo = er.sibling;
        var gc = Ft(Qe, er, Ci.value, on);
        if (gc === null) {
          er === null && (er = Qo);
          break;
        }
        c && er && gc.alternate === null && d(Qe, er), Ve = W(gc, Ve, gr), In === null ? Bn = gc : In.sibling = gc, In = gc, er = Qo;
      }
      if (Ci.done)
        return x(
          Qe,
          er
        ), ra && To(Qe, gr), Bn;
      if (er === null) {
        for (; !Ci.done; gr++, Ci = lt.next())
          Ci = jt(Qe, Ci.value, on), Ci !== null && (Ve = W(Ci, Ve, gr), In === null ? Bn = Ci : In.sibling = Ci, In = Ci);
        return ra && To(Qe, gr), Bn;
      }
      for (er = A(Qe, er); !Ci.done; gr++, Ci = lt.next())
        Ci = Mn(er, Qe, gr, Ci.value, on), Ci !== null && (c && Ci.alternate !== null && er.delete(Ci.key === null ? gr : Ci.key), Ve = W(Ci, Ve, gr), In === null ? Bn = Ci : In.sibling = Ci, In = Ci);
      return c && er.forEach(function(sy) {
        return d(Qe, sy);
      }), ra && To(Qe, gr), Bn;
    }
    function ro(Qe, Ve, lt, on) {
      if (typeof lt == "object" && lt !== null && lt.type === Z && lt.key === null && (lt = lt.props.children), typeof lt == "object" && lt !== null) {
        switch (lt.$$typeof) {
          case j:
            e: {
              for (var Bn = lt.key, In = Ve; In !== null; ) {
                if (In.key === Bn) {
                  if (Bn = lt.type, Bn === Z) {
                    if (In.tag === 7) {
                      x(Qe, In.sibling), Ve = F(In, lt.props.children), Ve.return = Qe, Qe = Ve;
                      break e;
                    }
                  } else if (In.elementType === Bn || typeof Bn == "object" && Bn !== null && Bn.$$typeof === Pe && Gs(Bn) === In.type) {
                    x(Qe, In.sibling), Ve = F(In, lt.props), Ve.ref = Hf(Qe, In, lt), Ve.return = Qe, Qe = Ve;
                    break e;
                  }
                  x(Qe, In);
                  break;
                } else
                  d(Qe, In);
                In = In.sibling;
              }
              lt.type === Z ? (Ve = Cp(lt.props.children, Qe.mode, on, lt.key), Ve.return = Qe, Qe = Ve) : (on = Wd(lt.type, lt.key, lt.props, null, Qe.mode, on), on.ref = Hf(Qe, Ve, lt), on.return = Qe, Qe = on);
            }
            return ie(Qe);
          case Y:
            e: {
              for (In = lt.key; Ve !== null; ) {
                if (Ve.key === In)
                  if (Ve.tag === 4 && Ve.stateNode.containerInfo === lt.containerInfo && Ve.stateNode.implementation === lt.implementation) {
                    x(Qe, Ve.sibling), Ve = F(Ve, lt.children || []), Ve.return = Qe, Qe = Ve;
                    break e;
                  } else {
                    x(Qe, Ve);
                    break;
                  }
                else
                  d(Qe, Ve);
                Ve = Ve.sibling;
              }
              Ve = oa(lt, Qe.mode, on), Ve.return = Qe, Qe = Ve;
            }
            return ie(Qe);
          case Pe:
            return In = lt._init, ro(Qe, Ve, In(lt._payload), on);
        }
        if (hn(lt))
          return Nn(Qe, Ve, lt, on);
        if (we(lt))
          return Fn(Qe, Ve, lt, on);
        Vf(Qe, lt);
      }
      return typeof lt == "string" && lt !== "" || typeof lt == "number" ? (lt = "" + lt, Ve !== null && Ve.tag === 6 ? (x(Qe, Ve.sibling), Ve = F(Ve, lt), Ve.return = Qe, Qe = Ve) : (x(Qe, Ve), Ve = vu(lt, Qe.mode, on), Ve.return = Qe, Qe = Ve), ie(Qe)) : x(Qe, Ve);
    }
    return ro;
  }
  var Gf = Dm(!0), Nd = Dm(!1), qc = {}, cl = Hn(qc), fu = Hn(qc), Kc = Hn(qc);
  function fl(c) {
    if (c === qc)
      throw Error(t(174));
    return c;
  }
  function bh(c, d) {
    switch (di(Kc, d), di(fu, c), di(cl, qc), c = d.nodeType, c) {
      case 9:
      case 11:
        d = (d = d.documentElement) ? d.namespaceURI : _t(null, "");
        break;
      default:
        c = c === 8 ? d.parentNode : d, d = c.namespaceURI || null, c = c.tagName, d = _t(d, c);
    }
    ii(cl), di(cl, d);
  }
  function du() {
    ii(cl), ii(fu), ii(Kc);
  }
  function Qn(c) {
    fl(Kc.current);
    var d = fl(cl.current), x = _t(d, c.type);
    d !== x && (di(fu, c), di(cl, x));
  }
  function Rr(c) {
    fu.current === c && (ii(cl), ii(fu));
  }
  var Zn = Hn(0);
  function Yr(c) {
    for (var d = c; d !== null; ) {
      if (d.tag === 13) {
        var x = d.memoizedState;
        if (x !== null && (x = x.dehydrated, x === null || x.data === "$?" || x.data === "$!"))
          return d;
      } else if (d.tag === 19 && d.memoizedProps.revealOrder !== void 0) {
        if (d.flags & 128)
          return d;
      } else if (d.child !== null) {
        d.child.return = d, d = d.child;
        continue;
      }
      if (d === c)
        break;
      for (; d.sibling === null; ) {
        if (d.return === null || d.return === c)
          return null;
        d = d.return;
      }
      d.sibling.return = d.return, d = d.sibling;
    }
    return null;
  }
  var wo = [];
  function Ws() {
    for (var c = 0; c < wo.length; c++)
      wo[c]._workInProgressVersionPrimary = null;
    wo.length = 0;
  }
  var Qc = G.ReactCurrentDispatcher, vs = G.ReactCurrentBatchConfig, Co = 0, ci = null, Ct = null, Jr = null, Wn = !1, Pu = !1, js = 0, Uo = 0;
  function wi() {
    throw Error(t(321));
  }
  function Wf(c, d) {
    if (d === null)
      return !1;
    for (var x = 0; x < d.length && x < c.length; x++)
      if (!Ia(c[x], d[x]))
        return !1;
    return !0;
  }
  function Zc(c, d, x, A, F, W) {
    if (Co = W, ci = d, d.memoizedState = null, d.updateQueue = null, d.lanes = 0, Qc.current = c === null || c.memoizedState === null ? g : R, c = x(A, F), Pu) {
      W = 0;
      do {
        if (Pu = !1, js = 0, 25 <= W)
          throw Error(t(301));
        W += 1, Jr = Ct = null, d.updateQueue = null, Qc.current = z, c = x(A, F);
      } while (Pu);
    }
    if (Qc.current = m, d = Ct !== null && Ct.next !== null, Co = 0, Jr = Ct = ci = null, Wn = !1, d)
      throw Error(t(300));
    return c;
  }
  function Jc() {
    var c = js !== 0;
    return js = 0, c;
  }
  function zo() {
    var c = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Jr === null ? ci.memoizedState = Jr = c : Jr = Jr.next = c, Jr;
  }
  function dl() {
    if (Ct === null) {
      var c = ci.alternate;
      c = c !== null ? c.memoizedState : null;
    } else
      c = Ct.next;
    var d = Jr === null ? ci.memoizedState : Jr.next;
    if (d !== null)
      Jr = d, Ct = c;
    else {
      if (c === null)
        throw Error(t(310));
      Ct = c, c = { memoizedState: Ct.memoizedState, baseState: Ct.baseState, baseQueue: Ct.baseQueue, queue: Ct.queue, next: null }, Jr === null ? ci.memoizedState = Jr = c : Jr = Jr.next = c;
    }
    return Jr;
  }
  function jf(c, d) {
    return typeof d == "function" ? d(c) : d;
  }
  function Ud(c) {
    var d = dl(), x = d.queue;
    if (x === null)
      throw Error(t(311));
    x.lastRenderedReducer = c;
    var A = Ct, F = A.baseQueue, W = x.pending;
    if (W !== null) {
      if (F !== null) {
        var ie = F.next;
        F.next = W.next, W.next = ie;
      }
      A.baseQueue = F = W, x.pending = null;
    }
    if (F !== null) {
      W = F.next, A = A.baseState;
      var Ae = ie = null, Ie = null, pt = W;
      do {
        var Yt = pt.lane;
        if ((Co & Yt) === Yt)
          Ie !== null && (Ie = Ie.next = { lane: 0, action: pt.action, hasEagerState: pt.hasEagerState, eagerState: pt.eagerState, next: null }), A = pt.hasEagerState ? pt.eagerState : c(A, pt.action);
        else {
          var jt = {
            lane: Yt,
            action: pt.action,
            hasEagerState: pt.hasEagerState,
            eagerState: pt.eagerState,
            next: null
          };
          Ie === null ? (Ae = Ie = jt, ie = A) : Ie = Ie.next = jt, ci.lanes |= Yt, qf |= Yt;
        }
        pt = pt.next;
      } while (pt !== null && pt !== W);
      Ie === null ? ie = A : Ie.next = Ae, Ia(A, d.memoizedState) || (yn = !0), d.memoizedState = A, d.baseState = ie, d.baseQueue = Ie, x.lastRenderedState = A;
    }
    if (c = x.interleaved, c !== null) {
      F = c;
      do
        W = F.lane, ci.lanes |= W, qf |= W, F = F.next;
      while (F !== c);
    } else
      F === null && (x.lanes = 0);
    return [d.memoizedState, x.dispatch];
  }
  function Yo(c) {
    var d = dl(), x = d.queue;
    if (x === null)
      throw Error(t(311));
    x.lastRenderedReducer = c;
    var A = x.dispatch, F = x.pending, W = d.memoizedState;
    if (F !== null) {
      x.pending = null;
      var ie = F = F.next;
      do
        W = c(W, ie.action), ie = ie.next;
      while (ie !== F);
      Ia(W, d.memoizedState) || (yn = !0), d.memoizedState = W, d.baseQueue === null && (d.baseState = W), x.lastRenderedState = W;
    }
    return [W, A];
  }
  function hl() {
  }
  function Lm(c, d) {
    var x = ci, A = dl(), F = d(), W = !Ia(A.memoizedState, F);
    if (W && (A.memoizedState = F, yn = !0), A = A.queue, Nu(pi.bind(null, x, A, c), [c]), A.getSnapshot !== d || W || Jr !== null && Jr.memoizedState.tag & 1) {
      if (x.flags |= 2048, Nl(9, go.bind(null, x, A, F, d), void 0, null), Li === null)
        throw Error(t(349));
      Co & 30 || fc(x, d, F);
    }
    return F;
  }
  function fc(c, d, x) {
    c.flags |= 16384, c = { getSnapshot: d, value: x }, d = ci.updateQueue, d === null ? (d = { lastEffect: null, stores: null }, ci.updateQueue = d, d.stores = [c]) : (x = d.stores, x === null ? d.stores = [c] : x.push(c));
  }
  function go(c, d, x, A) {
    d.value = x, d.getSnapshot = A, Pl(d) && $s(c);
  }
  function pi(c, d, x) {
    return x(function() {
      Pl(d) && $s(c);
    });
  }
  function Pl(c) {
    var d = c.getSnapshot;
    c = c.value;
    try {
      var x = d();
      return !Ia(c, x);
    } catch {
      return !0;
    }
  }
  function $s(c) {
    var d = ms(c, 1);
    d !== null && Ss(d, c, 1, -1);
  }
  function Om(c) {
    var d = zo();
    return typeof c == "function" && (c = c()), d.memoizedState = d.baseState = c, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: jf, lastRenderedState: c }, d.queue = c, c = c.dispatch = rf.bind(null, ci, c), [d.memoizedState, c];
  }
  function Nl(c, d, x, A) {
    return c = { tag: c, create: d, destroy: x, deps: A, next: null }, d = ci.updateQueue, d === null ? (d = { lastEffect: null, stores: null }, ci.updateQueue = d, d.lastEffect = c.next = c) : (x = d.lastEffect, x === null ? d.lastEffect = c.next = c : (A = x.next, x.next = c, c.next = A, d.lastEffect = c)), c;
  }
  function ef() {
    return dl().memoizedState;
  }
  function hu(c, d, x, A) {
    var F = zo();
    ci.flags |= c, F.memoizedState = Nl(1 | d, x, void 0, A === void 0 ? null : A);
  }
  function Ul(c, d, x, A) {
    var F = dl();
    A = A === void 0 ? null : A;
    var W = void 0;
    if (Ct !== null) {
      var ie = Ct.memoizedState;
      if (W = ie.destroy, A !== null && Wf(A, ie.deps)) {
        F.memoizedState = Nl(d, x, W, A);
        return;
      }
    }
    ci.flags |= c, F.memoizedState = Nl(1 | d, x, W, A);
  }
  function Ro(c, d) {
    return hu(8390656, 8, c, d);
  }
  function Nu(c, d) {
    return Ul(2048, 8, c, d);
  }
  function $f(c, d) {
    return Ul(4, 2, c, d);
  }
  function Xo(c, d) {
    return Ul(4, 4, c, d);
  }
  function tf(c, d) {
    if (typeof d == "function")
      return c = c(), d(c), function() {
        d(null);
      };
    if (d != null)
      return c = c(), d.current = c, function() {
        d.current = null;
      };
  }
  function zl(c, d, x) {
    return x = x != null ? x.concat([c]) : null, Ul(4, 4, tf.bind(null, d, c), x);
  }
  function Yf() {
  }
  function nf(c, d) {
    var x = dl();
    d = d === void 0 ? null : d;
    var A = x.memoizedState;
    return A !== null && d !== null && Wf(d, A[1]) ? A[0] : (x.memoizedState = [c, d], c);
  }
  function pu(c, d) {
    var x = dl();
    d = d === void 0 ? null : d;
    var A = x.memoizedState;
    return A !== null && d !== null && Wf(d, A[1]) ? A[0] : (c = c(), x.memoizedState = [c, d], c);
  }
  function pl(c, d, x) {
    return Co & 21 ? (Ia(x, d) || (x = Go(), ci.lanes |= x, qf |= x, c.baseState = !0), d) : (c.baseState && (c.baseState = !1, yn = !0), c.memoizedState = x);
  }
  function Yg(c, d) {
    var x = Kr;
    Kr = x !== 0 && 4 > x ? x : 4, c(!0);
    var A = vs.transition;
    vs.transition = {};
    try {
      c(!1), d();
    } finally {
      Kr = x, vs.transition = A;
    }
  }
  function Xr() {
    return dl().memoizedState;
  }
  function Xf(c, d, x) {
    var A = So(c);
    if (x = { lane: A, action: x, hasEagerState: !1, eagerState: null, next: null }, Uu(c))
      dc(d, x);
    else if (x = Am(c, d, x, A), x !== null) {
      var F = ji();
      Ss(x, c, A, F), Pm(x, d, A);
    }
  }
  function rf(c, d, x) {
    var A = So(c), F = { lane: A, action: x, hasEagerState: !1, eagerState: null, next: null };
    if (Uu(c))
      dc(d, F);
    else {
      var W = c.alternate;
      if (c.lanes === 0 && (W === null || W.lanes === 0) && (W = d.lastRenderedReducer, W !== null))
        try {
          var ie = d.lastRenderedState, Ae = W(ie, x);
          if (F.hasEagerState = !0, F.eagerState = Ae, Ia(Ae, ie)) {
            var Ie = d.interleaved;
            Ie === null ? (F.next = F, vp(d)) : (F.next = Ie.next, Ie.next = F), d.interleaved = F;
            return;
          }
        } catch {
        } finally {
        }
      x = Am(c, d, F, A), x !== null && (F = ji(), Ss(x, c, A, F), Pm(x, d, A));
    }
  }
  function Uu(c) {
    var d = c.alternate;
    return c === ci || d !== null && d === ci;
  }
  function dc(c, d) {
    Pu = Wn = !0;
    var x = c.pending;
    x === null ? d.next = d : (d.next = x.next, x.next = d), c.pending = d;
  }
  function Pm(c, d, x) {
    if (x & 4194240) {
      var A = d.lanes;
      A &= c.pendingLanes, x |= A, d.lanes = x, Tl(c, x);
    }
  }
  var m = { readContext: Wi, useCallback: wi, useContext: wi, useEffect: wi, useImperativeHandle: wi, useInsertionEffect: wi, useLayoutEffect: wi, useMemo: wi, useReducer: wi, useRef: wi, useState: wi, useDebugValue: wi, useDeferredValue: wi, useTransition: wi, useMutableSource: wi, useSyncExternalStore: wi, useId: wi, unstable_isNewReconciler: !1 }, g = { readContext: Wi, useCallback: function(c, d) {
    return zo().memoizedState = [c, d === void 0 ? null : d], c;
  }, useContext: Wi, useEffect: Ro, useImperativeHandle: function(c, d, x) {
    return x = x != null ? x.concat([c]) : null, hu(
      4194308,
      4,
      tf.bind(null, d, c),
      x
    );
  }, useLayoutEffect: function(c, d) {
    return hu(4194308, 4, c, d);
  }, useInsertionEffect: function(c, d) {
    return hu(4, 2, c, d);
  }, useMemo: function(c, d) {
    var x = zo();
    return d = d === void 0 ? null : d, c = c(), x.memoizedState = [c, d], c;
  }, useReducer: function(c, d, x) {
    var A = zo();
    return d = x !== void 0 ? x(d) : d, A.memoizedState = A.baseState = d, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: c, lastRenderedState: d }, A.queue = c, c = c.dispatch = Xf.bind(null, ci, c), [A.memoizedState, c];
  }, useRef: function(c) {
    var d = zo();
    return c = { current: c }, d.memoizedState = c;
  }, useState: Om, useDebugValue: Yf, useDeferredValue: function(c) {
    return zo().memoizedState = c;
  }, useTransition: function() {
    var c = Om(!1), d = c[0];
    return c = Yg.bind(null, c[1]), zo().memoizedState = c, [d, c];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(c, d, x) {
    var A = ci, F = zo();
    if (ra) {
      if (x === void 0)
        throw Error(t(407));
      x = x();
    } else {
      if (x = d(), Li === null)
        throw Error(t(349));
      Co & 30 || fc(A, d, x);
    }
    F.memoizedState = x;
    var W = { value: x, getSnapshot: d };
    return F.queue = W, Ro(pi.bind(
      null,
      A,
      W,
      c
    ), [c]), A.flags |= 2048, Nl(9, go.bind(null, A, W, x, d), void 0, null), x;
  }, useId: function() {
    var c = zo(), d = Li.identifierPrefix;
    if (ra) {
      var x = sl, A = rn;
      x = (A & ~(1 << 32 - Di(A) - 1)).toString(32) + x, d = ":" + d + "R" + x, x = js++, 0 < x && (d += "H" + x.toString(32)), d += ":";
    } else
      x = Uo++, d = ":" + d + "r" + x.toString(32) + ":";
    return c.memoizedState = d;
  }, unstable_isNewReconciler: !1 }, R = {
    readContext: Wi,
    useCallback: nf,
    useContext: Wi,
    useEffect: Nu,
    useImperativeHandle: zl,
    useInsertionEffect: $f,
    useLayoutEffect: Xo,
    useMemo: pu,
    useReducer: Ud,
    useRef: ef,
    useState: function() {
      return Ud(jf);
    },
    useDebugValue: Yf,
    useDeferredValue: function(c) {
      var d = dl();
      return pl(d, Ct.memoizedState, c);
    },
    useTransition: function() {
      var c = Ud(jf)[0], d = dl().memoizedState;
      return [c, d];
    },
    useMutableSource: hl,
    useSyncExternalStore: Lm,
    useId: Xr,
    unstable_isNewReconciler: !1
  }, z = { readContext: Wi, useCallback: nf, useContext: Wi, useEffect: Nu, useImperativeHandle: zl, useInsertionEffect: $f, useLayoutEffect: Xo, useMemo: pu, useReducer: Yo, useRef: ef, useState: function() {
    return Yo(jf);
  }, useDebugValue: Yf, useDeferredValue: function(c) {
    var d = dl();
    return Ct === null ? d.memoizedState = c : pl(d, Ct.memoizedState, c);
  }, useTransition: function() {
    var c = Yo(jf)[0], d = dl().memoizedState;
    return [c, d];
  }, useMutableSource: hl, useSyncExternalStore: Lm, useId: Xr, unstable_isNewReconciler: !1 };
  function V(c, d) {
    try {
      var x = "", A = d;
      do
        x += Ze(A), A = A.return;
      while (A);
      var F = x;
    } catch (W) {
      F = `
Error generating stack: ` + W.message + `
` + W.stack;
    }
    return { value: c, source: d, stack: F, digest: null };
  }
  function Q(c, d, x) {
    return { value: c, source: null, stack: x ?? null, digest: d ?? null };
  }
  function Me(c, d) {
    try {
      console.error(d.value);
    } catch (x) {
      setTimeout(function() {
        throw x;
      });
    }
  }
  var We = typeof WeakMap == "function" ? WeakMap : Map;
  function Mt(c, d, x) {
    x = Ha(-1, x), x.tag = 3, x.payload = { element: null };
    var A = d.value;
    return x.callback = function() {
      ey || (ey = !0, Mp = A), Me(c, d);
    }, x;
  }
  function Qt(c, d, x) {
    x = Ha(-1, x), x.tag = 3;
    var A = c.type.getDerivedStateFromError;
    if (typeof A == "function") {
      var F = d.value;
      x.payload = function() {
        return A(F);
      }, x.callback = function() {
        Me(c, d);
      };
    }
    var W = c.stateNode;
    return W !== null && typeof W.componentDidCatch == "function" && (x.callback = function() {
      Me(c, d), typeof A != "function" && (Kf === null ? Kf = /* @__PURE__ */ new Set([this]) : Kf.add(this));
      var ie = d.stack;
      this.componentDidCatch(d.value, { componentStack: ie !== null ? ie : "" });
    }), x;
  }
  function cn(c, d, x) {
    var A = c.pingCache;
    if (A === null) {
      A = c.pingCache = new We();
      var F = /* @__PURE__ */ new Set();
      A.set(d, F);
    } else
      F = A.get(d), F === void 0 && (F = /* @__PURE__ */ new Set(), A.set(d, F));
    F.has(x) || (F.add(x), c = N0.bind(null, c, d, x), d.then(c, c));
  }
  function sr(c) {
    do {
      var d;
      if ((d = c.tag === 13) && (d = c.memoizedState, d = d !== null ? d.dehydrated !== null : !0), d)
        return c;
      c = c.return;
    } while (c !== null);
    return null;
  }
  function Jn(c, d, x, A, F) {
    return c.mode & 1 ? (c.flags |= 65536, c.lanes = F, c) : (c === d ? c.flags |= 65536 : (c.flags |= 128, x.flags |= 131072, x.flags &= -52805, x.tag === 1 && (x.alternate === null ? x.tag = 17 : (d = Ha(-1, 1), d.tag = 2, cc(x, d, 1))), x.lanes |= 1), c);
  }
  var aa = G.ReactCurrentOwner, yn = !1;
  function fi(c, d, x, A) {
    d.child = c === null ? Nd(d, null, x, A) : Gf(d, c.child, x, A);
  }
  function Va(c, d, x, A, F) {
    x = x.render;
    var W = d.ref;
    return dn(d, F), A = Zc(c, d, x, A, W, F), x = Jc(), c !== null && !yn ? (d.updateQueue = c.updateQueue, d.flags &= -2053, c.lanes &= ~F, qo(c, d, F)) : (ra && x && mp(d), d.flags |= 1, fi(c, d, A, F), d.child);
  }
  function ot(c, d, x, A, F) {
    if (c === null) {
      var W = x.type;
      return typeof W == "function" && !Hv(W) && W.defaultProps === void 0 && x.compare === null && x.defaultProps === void 0 ? (d.tag = 15, d.type = W, Be(c, d, W, A, F)) : (c = Wd(x.type, null, A, d, d.mode, F), c.ref = d.ref, c.return = d, d.child = c);
    }
    if (W = c.child, !(c.lanes & F)) {
      var ie = W.memoizedProps;
      if (x = x.compare, x = x !== null ? x : al, x(ie, A) && c.ref === d.ref)
        return qo(c, d, F);
    }
    return d.flags |= 1, c = kl(W, A), c.ref = d.ref, c.return = d, d.child = c;
  }
  function Be(c, d, x, A, F) {
    if (c !== null) {
      var W = c.memoizedProps;
      if (al(W, A) && c.ref === d.ref)
        if (yn = !1, d.pendingProps = A = W, (c.lanes & F) !== 0)
          c.flags & 131072 && (yn = !0);
        else
          return d.lanes = c.lanes, qo(c, d, F);
    }
    return Dn(c, d, x, A, F);
  }
  function vt(c, d, x) {
    var A = d.pendingProps, F = A.children, W = c !== null ? c.memoizedState : null;
    if (A.mode === "hidden")
      if (!(d.mode & 1))
        d.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, di(zm, ku), ku |= x;
      else {
        if (!(x & 1073741824))
          return c = W !== null ? W.baseLanes | x : x, d.lanes = d.childLanes = 1073741824, d.memoizedState = { baseLanes: c, cachePool: null, transitions: null }, d.updateQueue = null, di(zm, ku), ku |= c, null;
        d.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, A = W !== null ? W.baseLanes : x, di(zm, ku), ku |= A;
      }
    else
      W !== null ? (A = W.baseLanes | x, d.memoizedState = null) : A = x, di(zm, ku), ku |= A;
    return fi(c, d, F, x), d.child;
  }
  function Pt(c, d) {
    var x = d.ref;
    (c === null && x !== null || c !== null && c.ref !== x) && (d.flags |= 512, d.flags |= 2097152);
  }
  function Dn(c, d, x, A, F) {
    var W = ua(x) ? fs : dr.current;
    return W = Bs(d, W), dn(d, F), x = Zc(c, d, x, A, W, F), A = Jc(), c !== null && !yn ? (d.updateQueue = c.updateQueue, d.flags &= -2053, c.lanes &= ~F, qo(c, d, F)) : (ra && A && mp(d), d.flags |= 1, fi(c, d, x, F), d.child);
  }
  function Ar(c, d, x, A, F) {
    if (ua(x)) {
      var W = !0;
      uc(d);
    } else
      W = !1;
    if (dn(d, F), d.stateNode === null)
      gs(c, d), Pd(d, x, A), cu(d, x, A, F), A = !0;
    else if (c === null) {
      var ie = d.stateNode, Ae = d.memoizedProps;
      ie.props = Ae;
      var Ie = ie.context, pt = x.contextType;
      typeof pt == "object" && pt !== null ? pt = Wi(pt) : (pt = ua(x) ? fs : dr.current, pt = Bs(d, pt));
      var Yt = x.getDerivedStateFromProps, jt = typeof Yt == "function" || typeof ie.getSnapshotBeforeUpdate == "function";
      jt || typeof ie.UNSAFE_componentWillReceiveProps != "function" && typeof ie.componentWillReceiveProps != "function" || (Ae !== A || Ie !== pt) && Ou(d, ie, A, pt), Sa = !1;
      var Ft = d.memoizedState;
      ie.state = Ft, ia(d, A, ie, F), Ie = d.memoizedState, Ae !== A || Ft !== Ie || Da.current || Sa ? (typeof Yt == "function" && (Vs(d, x, Yt, A), Ie = d.memoizedState), (Ae = Sa || vo(d, x, Ae, A, Ft, Ie, pt)) ? (jt || typeof ie.UNSAFE_componentWillMount != "function" && typeof ie.componentWillMount != "function" || (typeof ie.componentWillMount == "function" && ie.componentWillMount(), typeof ie.UNSAFE_componentWillMount == "function" && ie.UNSAFE_componentWillMount()), typeof ie.componentDidMount == "function" && (d.flags |= 4194308)) : (typeof ie.componentDidMount == "function" && (d.flags |= 4194308), d.memoizedProps = A, d.memoizedState = Ie), ie.props = A, ie.state = Ie, ie.context = pt, A = Ae) : (typeof ie.componentDidMount == "function" && (d.flags |= 4194308), A = !1);
    } else {
      ie = d.stateNode, qi(c, d), Ae = d.memoizedProps, pt = d.type === d.elementType ? Ae : ul(d.type, Ae), ie.props = pt, jt = d.pendingProps, Ft = ie.context, Ie = x.contextType, typeof Ie == "object" && Ie !== null ? Ie = Wi(Ie) : (Ie = ua(x) ? fs : dr.current, Ie = Bs(d, Ie));
      var Mn = x.getDerivedStateFromProps;
      (Yt = typeof Mn == "function" || typeof ie.getSnapshotBeforeUpdate == "function") || typeof ie.UNSAFE_componentWillReceiveProps != "function" && typeof ie.componentWillReceiveProps != "function" || (Ae !== jt || Ft !== Ie) && Ou(d, ie, A, Ie), Sa = !1, Ft = d.memoizedState, ie.state = Ft, ia(d, A, ie, F);
      var Nn = d.memoizedState;
      Ae !== jt || Ft !== Nn || Da.current || Sa ? (typeof Mn == "function" && (Vs(d, x, Mn, A), Nn = d.memoizedState), (pt = Sa || vo(d, x, pt, A, Ft, Nn, Ie) || !1) ? (Yt || typeof ie.UNSAFE_componentWillUpdate != "function" && typeof ie.componentWillUpdate != "function" || (typeof ie.componentWillUpdate == "function" && ie.componentWillUpdate(A, Nn, Ie), typeof ie.UNSAFE_componentWillUpdate == "function" && ie.UNSAFE_componentWillUpdate(A, Nn, Ie)), typeof ie.componentDidUpdate == "function" && (d.flags |= 4), typeof ie.getSnapshotBeforeUpdate == "function" && (d.flags |= 1024)) : (typeof ie.componentDidUpdate != "function" || Ae === c.memoizedProps && Ft === c.memoizedState || (d.flags |= 4), typeof ie.getSnapshotBeforeUpdate != "function" || Ae === c.memoizedProps && Ft === c.memoizedState || (d.flags |= 1024), d.memoizedProps = A, d.memoizedState = Nn), ie.props = A, ie.state = Nn, ie.context = Ie, A = pt) : (typeof ie.componentDidUpdate != "function" || Ae === c.memoizedProps && Ft === c.memoizedState || (d.flags |= 4), typeof ie.getSnapshotBeforeUpdate != "function" || Ae === c.memoizedProps && Ft === c.memoizedState || (d.flags |= 1024), A = !1);
    }
    return ar(c, d, x, A, W, F);
  }
  function ar(c, d, x, A, F, W) {
    Pt(c, d);
    var ie = (d.flags & 128) !== 0;
    if (!A && !ie)
      return F && Av(d, x, !1), qo(c, d, W);
    A = d.stateNode, aa.current = d;
    var Ae = ie && typeof x.getDerivedStateFromError != "function" ? null : A.render();
    return d.flags |= 1, c !== null && ie ? (d.child = Gf(d, c.child, null, W), d.child = Gf(d, null, Ae, W)) : fi(c, d, Ae, W), d.memoizedState = A.state, F && Av(d, x, !0), d.child;
  }
  function Vr(c) {
    var d = c.stateNode;
    d.pendingContext ? lc(c, d.pendingContext, d.pendingContext !== d.context) : d.context && lc(c, d.context, !1), bh(c, d.containerInfo);
  }
  function _a(c, d, x, A, F) {
    return va(), xh(F), d.flags |= 256, fi(c, d, x, A), d.child;
  }
  var Gr = { dehydrated: null, treeContext: null, retryLane: 0 };
  function hc(c) {
    return { baseLanes: c, cachePool: null, transitions: null };
  }
  function Th(c, d, x) {
    var A = d.pendingProps, F = Zn.current, W = !1, ie = (d.flags & 128) !== 0, Ae;
    if ((Ae = ie) || (Ae = c !== null && c.memoizedState === null ? !1 : (F & 2) !== 0), Ae ? (W = !0, d.flags &= -129) : (c === null || c.memoizedState !== null) && (F |= 1), di(Zn, F & 1), c === null)
      return Od(d), c = d.memoizedState, c !== null && (c = c.dehydrated, c !== null) ? (d.mode & 1 ? c.data === "$!" ? d.lanes = 8 : d.lanes = 1073741824 : d.lanes = 1, null) : (ie = A.children, c = A.fallback, W ? (A = d.mode, W = d.child, ie = { mode: "hidden", children: ie }, !(A & 1) && W !== null ? (W.childLanes = 0, W.pendingProps = ie) : W = zh(ie, A, 0, null), c = Cp(c, A, x, null), W.return = d, c.return = d, W.sibling = c, d.child = W, d.child.memoizedState = hc(x), d.memoizedState = Gr, c) : T0(d, ie));
    if (F = c.memoizedState, F !== null && (Ae = F.dehydrated, Ae !== null))
      return Xg(c, d, ie, A, Ae, F, x);
    if (W) {
      W = A.fallback, ie = d.mode, F = c.child, Ae = F.sibling;
      var Ie = { mode: "hidden", children: A.children };
      return !(ie & 1) && d.child !== F ? (A = d.child, A.childLanes = 0, A.pendingProps = Ie, d.deletions = null) : (A = kl(F, Ie), A.subtreeFlags = F.subtreeFlags & 14680064), Ae !== null ? W = kl(Ae, W) : (W = Cp(W, ie, x, null), W.flags |= 2), W.return = d, A.return = d, A.sibling = W, d.child = A, A = W, W = d.child, ie = c.child.memoizedState, ie = ie === null ? hc(x) : { baseLanes: ie.baseLanes | x, cachePool: null, transitions: ie.transitions }, W.memoizedState = ie, W.childLanes = c.childLanes & ~x, d.memoizedState = Gr, A;
    }
    return W = c.child, c = W.sibling, A = kl(W, { mode: "visible", children: A.children }), !(d.mode & 1) && (A.lanes = x), A.return = d, A.sibling = null, c !== null && (x = d.deletions, x === null ? (d.deletions = [c], d.flags |= 16) : x.push(c)), d.child = A, d.memoizedState = null, A;
  }
  function T0(c, d) {
    return d = zh({ mode: "visible", children: d }, c.mode, 0, null), d.return = c, c.child = d;
  }
  function gp(c, d, x, A) {
    return A !== null && xh(A), Gf(d, c.child, null, x), c = T0(d, d.pendingProps.children), c.flags |= 2, d.memoizedState = null, c;
  }
  function Xg(c, d, x, A, F, W, ie) {
    if (x)
      return d.flags & 256 ? (d.flags &= -257, A = Q(Error(t(422))), gp(c, d, ie, A)) : d.memoizedState !== null ? (d.child = c.child, d.flags |= 128, null) : (W = A.fallback, F = d.mode, A = zh({ mode: "visible", children: A.children }, F, 0, null), W = Cp(W, F, ie, null), W.flags |= 2, A.return = d, W.return = d, A.sibling = W, d.child = A, d.mode & 1 && Gf(d, c.child, null, ie), d.child.memoizedState = hc(ie), d.memoizedState = Gr, W);
    if (!(d.mode & 1))
      return gp(c, d, ie, null);
    if (F.data === "$!") {
      if (A = F.nextSibling && F.nextSibling.dataset, A)
        var Ae = A.dgst;
      return A = Ae, W = Error(t(419)), A = Q(W, A, void 0), gp(c, d, ie, A);
    }
    if (Ae = (ie & c.childLanes) !== 0, yn || Ae) {
      if (A = Li, A !== null) {
        switch (ie & -ie) {
          case 4:
            F = 2;
            break;
          case 16:
            F = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            F = 32;
            break;
          case 536870912:
            F = 268435456;
            break;
          default:
            F = 0;
        }
        F = F & (A.suspendedLanes | ie) ? 0 : F, F !== 0 && F !== W.retryLane && (W.retryLane = F, ms(c, F), Ss(A, c, F, -1));
      }
      return O0(), A = Q(Error(t(421))), gp(c, d, ie, A);
    }
    return F.data === "$?" ? (d.flags |= 128, d.child = c.child, d = Ex.bind(null, c), F._reactRetry = d, null) : (c = W.treeContext, hs = ks(F.nextSibling), Mo = d, ra = !0, ll = null, c !== null && (po[La++] = rn, po[La++] = sl, po[La++] = Lu, rn = c.id, sl = c.overflow, Lu = d), d = T0(d, A.children), d.flags |= 4096, d);
  }
  function qg(c, d, x) {
    c.lanes |= d;
    var A = c.alternate;
    A !== null && (A.lanes |= d), ya(c.return, d, x);
  }
  function Nm(c, d, x, A, F) {
    var W = c.memoizedState;
    W === null ? c.memoizedState = { isBackwards: d, rendering: null, renderingStartTime: 0, last: A, tail: x, tailMode: F } : (W.isBackwards = d, W.rendering = null, W.renderingStartTime = 0, W.last = A, W.tail = x, W.tailMode = F);
  }
  function Kg(c, d, x) {
    var A = d.pendingProps, F = A.revealOrder, W = A.tail;
    if (fi(c, d, A.children, x), A = Zn.current, A & 2)
      A = A & 1 | 2, d.flags |= 128;
    else {
      if (c !== null && c.flags & 128)
        e:
          for (c = d.child; c !== null; ) {
            if (c.tag === 13)
              c.memoizedState !== null && qg(c, x, d);
            else if (c.tag === 19)
              qg(c, x, d);
            else if (c.child !== null) {
              c.child.return = c, c = c.child;
              continue;
            }
            if (c === d)
              break e;
            for (; c.sibling === null; ) {
              if (c.return === null || c.return === d)
                break e;
              c = c.return;
            }
            c.sibling.return = c.return, c = c.sibling;
          }
      A &= 1;
    }
    if (di(Zn, A), !(d.mode & 1))
      d.memoizedState = null;
    else
      switch (F) {
        case "forwards":
          for (x = d.child, F = null; x !== null; )
            c = x.alternate, c !== null && Yr(c) === null && (F = x), x = x.sibling;
          x = F, x === null ? (F = d.child, d.child = null) : (F = x.sibling, x.sibling = null), Nm(d, !1, F, x, W);
          break;
        case "backwards":
          for (x = null, F = d.child, d.child = null; F !== null; ) {
            if (c = F.alternate, c !== null && Yr(c) === null) {
              d.child = F;
              break;
            }
            c = F.sibling, F.sibling = x, x = F, F = c;
          }
          Nm(d, !0, x, null, W);
          break;
        case "together":
          Nm(d, !1, null, null, void 0);
          break;
        default:
          d.memoizedState = null;
      }
    return d.child;
  }
  function gs(c, d) {
    !(d.mode & 1) && c !== null && (c.alternate = null, d.alternate = null, d.flags |= 2);
  }
  function qo(c, d, x) {
    if (c !== null && (d.dependencies = c.dependencies), qf |= d.lanes, !(x & d.childLanes))
      return null;
    if (c !== null && d.child !== c.child)
      throw Error(t(153));
    if (d.child !== null) {
      for (c = d.child, x = kl(c, c.pendingProps), d.child = x, x.return = d; c.sibling !== null; )
        c = c.sibling, x = x.sibling = kl(c, c.pendingProps), x.return = d;
      x.sibling = null;
    }
    return d.child;
  }
  function af(c, d, x) {
    switch (d.tag) {
      case 3:
        Vr(d), va();
        break;
      case 5:
        Qn(d);
        break;
      case 1:
        ua(d.type) && uc(d);
        break;
      case 4:
        bh(d, d.stateNode.containerInfo);
        break;
      case 10:
        var A = d.type._context, F = d.memoizedProps.value;
        di(uu, A._currentValue), A._currentValue = F;
        break;
      case 13:
        if (A = d.memoizedState, A !== null)
          return A.dehydrated !== null ? (di(Zn, Zn.current & 1), d.flags |= 128, null) : x & d.child.childLanes ? Th(c, d, x) : (di(Zn, Zn.current & 1), c = qo(c, d, x), c !== null ? c.sibling : null);
        di(Zn, Zn.current & 1);
        break;
      case 19:
        if (A = (x & d.childLanes) !== 0, c.flags & 128) {
          if (A)
            return Kg(c, d, x);
          d.flags |= 128;
        }
        if (F = d.memoizedState, F !== null && (F.rendering = null, F.tail = null, F.lastEffect = null), di(Zn, Zn.current), A)
          break;
        return null;
      case 22:
      case 23:
        return d.lanes = 0, vt(c, d, x);
    }
    return qo(c, d, x);
  }
  var yp, zd, zu, yo;
  yp = function(c, d) {
    for (var x = d.child; x !== null; ) {
      if (x.tag === 5 || x.tag === 6)
        c.appendChild(x.stateNode);
      else if (x.tag !== 4 && x.child !== null) {
        x.child.return = x, x = x.child;
        continue;
      }
      if (x === d)
        break;
      for (; x.sibling === null; ) {
        if (x.return === null || x.return === d)
          return;
        x = x.return;
      }
      x.sibling.return = x.return, x = x.sibling;
    }
  }, zd = function() {
  }, zu = function(c, d, x, A) {
    var F = c.memoizedProps;
    if (F !== A) {
      c = d.stateNode, fl(cl.current);
      var W = null;
      switch (x) {
        case "input":
          F = et(c, F), A = et(c, A), W = [];
          break;
        case "select":
          F = X({}, F, { value: void 0 }), A = X({}, A, { value: void 0 }), W = [];
          break;
        case "textarea":
          F = Yn(c, F), A = Yn(c, A), W = [];
          break;
        default:
          typeof F.onClick != "function" && typeof A.onClick == "function" && (c.onclick = Cd);
      }
      Ye(x, A);
      var ie;
      x = null;
      for (pt in F)
        if (!A.hasOwnProperty(pt) && F.hasOwnProperty(pt) && F[pt] != null)
          if (pt === "style") {
            var Ae = F[pt];
            for (ie in Ae)
              Ae.hasOwnProperty(ie) && (x || (x = {}), x[ie] = "");
          } else
            pt !== "dangerouslySetInnerHTML" && pt !== "children" && pt !== "suppressContentEditableWarning" && pt !== "suppressHydrationWarning" && pt !== "autoFocus" && (a.hasOwnProperty(pt) ? W || (W = []) : (W = W || []).push(pt, null));
      for (pt in A) {
        var Ie = A[pt];
        if (Ae = F != null ? F[pt] : void 0, A.hasOwnProperty(pt) && Ie !== Ae && (Ie != null || Ae != null))
          if (pt === "style")
            if (Ae) {
              for (ie in Ae)
                !Ae.hasOwnProperty(ie) || Ie && Ie.hasOwnProperty(ie) || (x || (x = {}), x[ie] = "");
              for (ie in Ie)
                Ie.hasOwnProperty(ie) && Ae[ie] !== Ie[ie] && (x || (x = {}), x[ie] = Ie[ie]);
            } else
              x || (W || (W = []), W.push(
                pt,
                x
              )), x = Ie;
          else
            pt === "dangerouslySetInnerHTML" ? (Ie = Ie ? Ie.__html : void 0, Ae = Ae ? Ae.__html : void 0, Ie != null && Ae !== Ie && (W = W || []).push(pt, Ie)) : pt === "children" ? typeof Ie != "string" && typeof Ie != "number" || (W = W || []).push(pt, "" + Ie) : pt !== "suppressContentEditableWarning" && pt !== "suppressHydrationWarning" && (a.hasOwnProperty(pt) ? (Ie != null && pt === "onScroll" && Tr("scroll", c), W || Ae === Ie || (W = [])) : (W = W || []).push(pt, Ie));
      }
      x && (W = W || []).push("style", x);
      var pt = W;
      (d.updateQueue = pt) && (d.flags |= 4);
    }
  }, yo = function(c, d, x, A) {
    x !== A && (d.flags |= 4);
  };
  function Sp(c, d) {
    if (!ra)
      switch (c.tailMode) {
        case "hidden":
          d = c.tail;
          for (var x = null; d !== null; )
            d.alternate !== null && (x = d), d = d.sibling;
          x === null ? c.tail = null : x.sibling = null;
          break;
        case "collapsed":
          x = c.tail;
          for (var A = null; x !== null; )
            x.alternate !== null && (A = x), x = x.sibling;
          A === null ? d || c.tail === null ? c.tail = null : c.tail.sibling = null : A.sibling = null;
      }
  }
  function ys(c) {
    var d = c.alternate !== null && c.alternate.child === c.child, x = 0, A = 0;
    if (d)
      for (var F = c.child; F !== null; )
        x |= F.lanes | F.childLanes, A |= F.subtreeFlags & 14680064, A |= F.flags & 14680064, F.return = c, F = F.sibling;
    else
      for (F = c.child; F !== null; )
        x |= F.lanes | F.childLanes, A |= F.subtreeFlags, A |= F.flags, F.return = c, F = F.sibling;
    return c.subtreeFlags |= A, c.childLanes = x, d;
  }
  function M0(c, d, x) {
    var A = d.pendingProps;
    switch (jc(d), d.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ys(d), null;
      case 1:
        return ua(d.type) && Hs(), ys(d), null;
      case 3:
        return A = d.stateNode, du(), ii(Da), ii(dr), Ws(), A.pendingContext && (A.context = A.pendingContext, A.pendingContext = null), (c === null || c.child === null) && (ps(d) ? d.flags |= 4 : c === null || c.memoizedState.isDehydrated && !(d.flags & 256) || (d.flags |= 1024, ll !== null && (wp(ll), ll = null))), zd(c, d), ys(d), null;
      case 5:
        Rr(d);
        var F = fl(Kc.current);
        if (x = d.type, c !== null && d.stateNode != null)
          zu(c, d, x, A, F), c.ref !== d.ref && (d.flags |= 512, d.flags |= 2097152);
        else {
          if (!A) {
            if (d.stateNode === null)
              throw Error(t(166));
            return ys(d), null;
          }
          if (c = fl(cl.current), ps(d)) {
            A = d.stateNode, x = d.type;
            var W = d.memoizedProps;
            switch (A[to] = d, A[sc] = W, c = (d.mode & 1) !== 0, x) {
              case "dialog":
                Tr("cancel", A), Tr("close", A);
                break;
              case "iframe":
              case "object":
              case "embed":
                Tr("load", A);
                break;
              case "video":
              case "audio":
                for (F = 0; F < Nf.length; F++)
                  Tr(Nf[F], A);
                break;
              case "source":
                Tr("error", A);
                break;
              case "img":
              case "image":
              case "link":
                Tr(
                  "error",
                  A
                ), Tr("load", A);
                break;
              case "details":
                Tr("toggle", A);
                break;
              case "input":
                Rt(A, W), Tr("invalid", A);
                break;
              case "select":
                A._wrapperState = { wasMultiple: !!W.multiple }, Tr("invalid", A);
                break;
              case "textarea":
                se(A, W), Tr("invalid", A);
            }
            Ye(x, W), F = null;
            for (var ie in W)
              if (W.hasOwnProperty(ie)) {
                var Ae = W[ie];
                ie === "children" ? typeof Ae == "string" ? A.textContent !== Ae && (W.suppressHydrationWarning !== !0 && wd(A.textContent, Ae, c), F = ["children", Ae]) : typeof Ae == "number" && A.textContent !== "" + Ae && (W.suppressHydrationWarning !== !0 && wd(
                  A.textContent,
                  Ae,
                  c
                ), F = ["children", "" + Ae]) : a.hasOwnProperty(ie) && Ae != null && ie === "onScroll" && Tr("scroll", A);
              }
            switch (x) {
              case "input":
                Ht(A), Kt(A, W, !0);
                break;
              case "textarea":
                Ht(A), Ke(A);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof W.onClick == "function" && (A.onclick = Cd);
            }
            A = F, d.updateQueue = A, A !== null && (d.flags |= 4);
          } else {
            ie = F.nodeType === 9 ? F : F.ownerDocument, c === "http://www.w3.org/1999/xhtml" && (c = wt(x)), c === "http://www.w3.org/1999/xhtml" ? x === "script" ? (c = ie.createElement("div"), c.innerHTML = "<script><\/script>", c = c.removeChild(c.firstChild)) : typeof A.is == "string" ? c = ie.createElement(x, { is: A.is }) : (c = ie.createElement(x), x === "select" && (ie = c, A.multiple ? ie.multiple = !0 : A.size && (ie.size = A.size))) : c = ie.createElementNS(c, x), c[to] = d, c[sc] = A, yp(c, d, !1, !1), d.stateNode = c;
            e: {
              switch (ie = bt(x, A), x) {
                case "dialog":
                  Tr("cancel", c), Tr("close", c), F = A;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Tr("load", c), F = A;
                  break;
                case "video":
                case "audio":
                  for (F = 0; F < Nf.length; F++)
                    Tr(Nf[F], c);
                  F = A;
                  break;
                case "source":
                  Tr("error", c), F = A;
                  break;
                case "img":
                case "image":
                case "link":
                  Tr(
                    "error",
                    c
                  ), Tr("load", c), F = A;
                  break;
                case "details":
                  Tr("toggle", c), F = A;
                  break;
                case "input":
                  Rt(c, A), F = et(c, A), Tr("invalid", c);
                  break;
                case "option":
                  F = A;
                  break;
                case "select":
                  c._wrapperState = { wasMultiple: !!A.multiple }, F = X({}, A, { value: void 0 }), Tr("invalid", c);
                  break;
                case "textarea":
                  se(c, A), F = Yn(c, A), Tr("invalid", c);
                  break;
                default:
                  F = A;
              }
              Ye(x, F), Ae = F;
              for (W in Ae)
                if (Ae.hasOwnProperty(W)) {
                  var Ie = Ae[W];
                  W === "style" ? Ut(c, Ie) : W === "dangerouslySetInnerHTML" ? (Ie = Ie ? Ie.__html : void 0, Ie != null && fn(c, Ie)) : W === "children" ? typeof Ie == "string" ? (x !== "textarea" || Ie !== "") && Wt(c, Ie) : typeof Ie == "number" && Wt(c, "" + Ie) : W !== "suppressContentEditableWarning" && W !== "suppressHydrationWarning" && W !== "autoFocus" && (a.hasOwnProperty(W) ? Ie != null && W === "onScroll" && Tr("scroll", c) : Ie != null && k(c, W, Ie, ie));
                }
              switch (x) {
                case "input":
                  Ht(c), Kt(c, A, !1);
                  break;
                case "textarea":
                  Ht(c), Ke(c);
                  break;
                case "option":
                  A.value != null && c.setAttribute("value", "" + at(A.value));
                  break;
                case "select":
                  c.multiple = !!A.multiple, W = A.value, W != null ? Rn(c, !!A.multiple, W, !1) : A.defaultValue != null && Rn(
                    c,
                    !!A.multiple,
                    A.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof F.onClick == "function" && (c.onclick = Cd);
              }
              switch (x) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  A = !!A.autoFocus;
                  break e;
                case "img":
                  A = !0;
                  break e;
                default:
                  A = !1;
              }
            }
            A && (d.flags |= 4);
          }
          d.ref !== null && (d.flags |= 512, d.flags |= 2097152);
        }
        return ys(d), null;
      case 6:
        if (c && d.stateNode != null)
          yo(c, d, c.memoizedProps, A);
        else {
          if (typeof A != "string" && d.stateNode === null)
            throw Error(t(166));
          if (x = fl(Kc.current), fl(cl.current), ps(d)) {
            if (A = d.stateNode, x = d.memoizedProps, A[to] = d, (W = A.nodeValue !== x) && (c = Mo, c !== null))
              switch (c.tag) {
                case 3:
                  wd(A.nodeValue, x, (c.mode & 1) !== 0);
                  break;
                case 5:
                  c.memoizedProps.suppressHydrationWarning !== !0 && wd(A.nodeValue, x, (c.mode & 1) !== 0);
              }
            W && (d.flags |= 4);
          } else
            A = (x.nodeType === 9 ? x : x.ownerDocument).createTextNode(A), A[to] = d, d.stateNode = A;
        }
        return ys(d), null;
      case 13:
        if (ii(Zn), A = d.memoizedState, c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
          if (ra && hs !== null && d.mode & 1 && !(d.flags & 128))
            mo(), va(), d.flags |= 98560, W = !1;
          else if (W = ps(d), A !== null && A.dehydrated !== null) {
            if (c === null) {
              if (!W)
                throw Error(t(318));
              if (W = d.memoizedState, W = W !== null ? W.dehydrated : null, !W)
                throw Error(t(317));
              W[to] = d;
            } else
              va(), !(d.flags & 128) && (d.memoizedState = null), d.flags |= 4;
            ys(d), W = !1;
          } else
            ll !== null && (wp(ll), ll = null), W = !0;
          if (!W)
            return d.flags & 65536 ? d : null;
        }
        return d.flags & 128 ? (d.lanes = x, d) : (A = A !== null, A !== (c !== null && c.memoizedState !== null) && A && (d.child.flags |= 8192, d.mode & 1 && (c === null || Zn.current & 1 ? Ko === 0 && (Ko = 3) : O0())), d.updateQueue !== null && (d.flags |= 4), ys(d), null);
      case 4:
        return du(), zd(c, d), c === null && ol(d.stateNode.containerInfo), ys(d), null;
      case 10:
        return Xi(d.type._context), ys(d), null;
      case 17:
        return ua(d.type) && Hs(), ys(d), null;
      case 19:
        if (ii(Zn), W = d.memoizedState, W === null)
          return ys(d), null;
        if (A = (d.flags & 128) !== 0, ie = W.rendering, ie === null)
          if (A)
            Sp(W, !1);
          else {
            if (Ko !== 0 || c !== null && c.flags & 128)
              for (c = d.child; c !== null; ) {
                if (ie = Yr(c), ie !== null) {
                  for (d.flags |= 128, Sp(W, !1), A = ie.updateQueue, A !== null && (d.updateQueue = A, d.flags |= 4), d.subtreeFlags = 0, A = x, x = d.child; x !== null; )
                    W = x, c = A, W.flags &= 14680066, ie = W.alternate, ie === null ? (W.childLanes = 0, W.lanes = c, W.child = null, W.subtreeFlags = 0, W.memoizedProps = null, W.memoizedState = null, W.updateQueue = null, W.dependencies = null, W.stateNode = null) : (W.childLanes = ie.childLanes, W.lanes = ie.lanes, W.child = ie.child, W.subtreeFlags = 0, W.deletions = null, W.memoizedProps = ie.memoizedProps, W.memoizedState = ie.memoizedState, W.updateQueue = ie.updateQueue, W.type = ie.type, c = ie.dependencies, W.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }), x = x.sibling;
                  return di(Zn, Zn.current & 1 | 2), d.child;
                }
                c = c.sibling;
              }
            W.tail !== null && sn() > Ah && (d.flags |= 128, A = !0, Sp(W, !1), d.lanes = 4194304);
          }
        else {
          if (!A)
            if (c = Yr(ie), c !== null) {
              if (d.flags |= 128, A = !0, x = c.updateQueue, x !== null && (d.updateQueue = x, d.flags |= 4), Sp(W, !0), W.tail === null && W.tailMode === "hidden" && !ie.alternate && !ra)
                return ys(d), null;
            } else
              2 * sn() - W.renderingStartTime > Ah && x !== 1073741824 && (d.flags |= 128, A = !0, Sp(W, !1), d.lanes = 4194304);
          W.isBackwards ? (ie.sibling = d.child, d.child = ie) : (x = W.last, x !== null ? x.sibling = ie : d.child = ie, W.last = ie);
        }
        return W.tail !== null ? (d = W.tail, W.rendering = d, W.tail = d.sibling, W.renderingStartTime = sn(), d.sibling = null, x = Zn.current, di(Zn, A ? x & 1 | 2 : x & 1), d) : (ys(d), null);
      case 22:
      case 23:
        return ny(), A = d.memoizedState !== null, c !== null && c.memoizedState !== null !== A && (d.flags |= 8192), A && d.mode & 1 ? ku & 1073741824 && (ys(d), d.subtreeFlags & 6 && (d.flags |= 8192)) : ys(d), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, d.tag));
  }
  function Qg(c, d) {
    switch (jc(d), d.tag) {
      case 1:
        return ua(d.type) && Hs(), c = d.flags, c & 65536 ? (d.flags = c & -65537 | 128, d) : null;
      case 3:
        return du(), ii(Da), ii(dr), Ws(), c = d.flags, c & 65536 && !(c & 128) ? (d.flags = c & -65537 | 128, d) : null;
      case 5:
        return Rr(d), null;
      case 13:
        if (ii(Zn), c = d.memoizedState, c !== null && c.dehydrated !== null) {
          if (d.alternate === null)
            throw Error(t(340));
          va();
        }
        return c = d.flags, c & 65536 ? (d.flags = c & -65537 | 128, d) : null;
      case 19:
        return ii(Zn), null;
      case 4:
        return du(), null;
      case 10:
        return Xi(d.type._context), null;
      case 22:
      case 23:
        return ny(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var xp = !1, Ao = !1, w0 = typeof WeakSet == "function" ? WeakSet : Set, Pn = null;
  function _p(c, d) {
    var x = c.ref;
    if (x !== null)
      if (typeof x == "function")
        try {
          x(null);
        } catch (A) {
          no(c, d, A);
        }
      else
        x.current = null;
  }
  function Um(c, d, x) {
    try {
      x();
    } catch (A) {
      no(c, d, A);
    }
  }
  var xx = !1;
  function C0(c, d) {
    if (Uf = co, c = Zr(), Mi(c)) {
      if ("selectionStart" in c)
        var x = { start: c.selectionStart, end: c.selectionEnd };
      else
        e: {
          x = (x = c.ownerDocument) && x.defaultView || window;
          var A = x.getSelection && x.getSelection();
          if (A && A.rangeCount !== 0) {
            x = A.anchorNode;
            var F = A.anchorOffset, W = A.focusNode;
            A = A.focusOffset;
            try {
              x.nodeType, W.nodeType;
            } catch {
              x = null;
              break e;
            }
            var ie = 0, Ae = -1, Ie = -1, pt = 0, Yt = 0, jt = c, Ft = null;
            t:
              for (; ; ) {
                for (var Mn; jt !== x || F !== 0 && jt.nodeType !== 3 || (Ae = ie + F), jt !== W || A !== 0 && jt.nodeType !== 3 || (Ie = ie + A), jt.nodeType === 3 && (ie += jt.nodeValue.length), (Mn = jt.firstChild) !== null; )
                  Ft = jt, jt = Mn;
                for (; ; ) {
                  if (jt === c)
                    break t;
                  if (Ft === x && ++pt === F && (Ae = ie), Ft === W && ++Yt === A && (Ie = ie), (Mn = jt.nextSibling) !== null)
                    break;
                  jt = Ft, Ft = jt.parentNode;
                }
                jt = Mn;
              }
            x = Ae === -1 || Ie === -1 ? null : { start: Ae, end: Ie };
          } else
            x = null;
        }
      x = x || { start: 0, end: 0 };
    } else
      x = null;
    for (Gc = { focusedElem: c, selectionRange: x }, co = !1, Pn = d; Pn !== null; )
      if (d = Pn, c = d.child, (d.subtreeFlags & 1028) !== 0 && c !== null)
        c.return = d, Pn = c;
      else
        for (; Pn !== null; ) {
          d = Pn;
          try {
            var Nn = d.alternate;
            if (d.flags & 1024)
              switch (d.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Nn !== null) {
                    var Fn = Nn.memoizedProps, ro = Nn.memoizedState, Qe = d.stateNode, Ve = Qe.getSnapshotBeforeUpdate(d.elementType === d.type ? Fn : ul(d.type, Fn), ro);
                    Qe.__reactInternalSnapshotBeforeUpdate = Ve;
                  }
                  break;
                case 3:
                  var lt = d.stateNode.containerInfo;
                  lt.nodeType === 1 ? lt.textContent = "" : lt.nodeType === 9 && lt.documentElement && lt.removeChild(lt.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(t(163));
              }
          } catch (on) {
            no(d, d.return, on);
          }
          if (c = d.sibling, c !== null) {
            c.return = d.return, Pn = c;
            break;
          }
          Pn = d.return;
        }
    return Nn = xx, xx = !1, Nn;
  }
  function Ep(c, d, x) {
    var A = d.updateQueue;
    if (A = A !== null ? A.lastEffect : null, A !== null) {
      var F = A = A.next;
      do {
        if ((F.tag & c) === c) {
          var W = F.destroy;
          F.destroy = void 0, W !== void 0 && Um(d, x, W);
        }
        F = F.next;
      } while (F !== A);
    }
  }
  function Dv(c, d) {
    if (d = d.updateQueue, d = d !== null ? d.lastEffect : null, d !== null) {
      var x = d = d.next;
      do {
        if ((x.tag & c) === c) {
          var A = x.create;
          x.destroy = A();
        }
        x = x.next;
      } while (x !== d);
    }
  }
  function R0(c) {
    var d = c.ref;
    if (d !== null) {
      var x = c.stateNode;
      switch (c.tag) {
        case 5:
          c = x;
          break;
        default:
          c = x;
      }
      typeof d == "function" ? d(c) : d.current = c;
    }
  }
  function Mh(c) {
    var d = c.alternate;
    d !== null && (c.alternate = null, Mh(d)), c.child = null, c.deletions = null, c.sibling = null, c.tag === 5 && (d = c.stateNode, d !== null && (delete d[to], delete d[sc], delete d[zf], delete d[kf], delete d[Dd])), c.stateNode = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
  }
  function bp(c) {
    return c.tag === 5 || c.tag === 3 || c.tag === 4;
  }
  function Tp(c) {
    e:
      for (; ; ) {
        for (; c.sibling === null; ) {
          if (c.return === null || bp(c.return))
            return null;
          c = c.return;
        }
        for (c.sibling.return = c.return, c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
          if (c.flags & 2 || c.child === null || c.tag === 4)
            continue e;
          c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2))
          return c.stateNode;
      }
  }
  function kd(c, d, x) {
    var A = c.tag;
    if (A === 5 || A === 6)
      c = c.stateNode, d ? x.nodeType === 8 ? x.parentNode.insertBefore(c, d) : x.insertBefore(c, d) : (x.nodeType === 8 ? (d = x.parentNode, d.insertBefore(c, x)) : (d = x, d.appendChild(c)), x = x._reactRootContainer, x != null || d.onclick !== null || (d.onclick = Cd));
    else if (A !== 4 && (c = c.child, c !== null))
      for (kd(c, d, x), c = c.sibling; c !== null; )
        kd(c, d, x), c = c.sibling;
  }
  function Do(c, d, x) {
    var A = c.tag;
    if (A === 5 || A === 6)
      c = c.stateNode, d ? x.insertBefore(c, d) : x.appendChild(c);
    else if (A !== 4 && (c = c.child, c !== null))
      for (Do(c, d, x), c = c.sibling; c !== null; )
        Do(c, d, x), c = c.sibling;
  }
  var Ei = null, Ga = !1;
  function ko(c, d, x) {
    for (x = x.child; x !== null; )
      mu(c, d, x), x = x.sibling;
  }
  function mu(c, d, x) {
    if (Cr && typeof Cr.onCommitFiberUnmount == "function")
      try {
        Cr.onCommitFiberUnmount(ir, x);
      } catch {
      }
    switch (x.tag) {
      case 5:
        Ao || _p(x, d);
      case 6:
        var A = Ei, F = Ga;
        Ei = null, ko(c, d, x), Ei = A, Ga = F, Ei !== null && (Ga ? (c = Ei, x = x.stateNode, c.nodeType === 8 ? c.parentNode.removeChild(x) : c.removeChild(x)) : Ei.removeChild(x.stateNode));
        break;
      case 18:
        Ei !== null && (Ga ? (c = Ei, x = x.stateNode, c.nodeType === 8 ? wu(c.parentNode, x) : c.nodeType === 1 && wu(c, x), Cf(c)) : wu(Ei, x.stateNode));
        break;
      case 4:
        A = Ei, F = Ga, Ei = x.stateNode.containerInfo, Ga = !0, ko(c, d, x), Ei = A, Ga = F;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Ao && (A = x.updateQueue, A !== null && (A = A.lastEffect, A !== null))) {
          F = A = A.next;
          do {
            var W = F, ie = W.destroy;
            W = W.tag, ie !== void 0 && (W & 2 || W & 4) && Um(x, d, ie), F = F.next;
          } while (F !== A);
        }
        ko(c, d, x);
        break;
      case 1:
        if (!Ao && (_p(x, d), A = x.stateNode, typeof A.componentWillUnmount == "function"))
          try {
            A.props = x.memoizedProps, A.state = x.memoizedState, A.componentWillUnmount();
          } catch (Ae) {
            no(x, d, Ae);
          }
        ko(c, d, x);
        break;
      case 21:
        ko(c, d, x);
        break;
      case 22:
        x.mode & 1 ? (Ao = (A = Ao) || x.memoizedState !== null, ko(c, d, x), Ao = A) : ko(c, d, x);
        break;
      default:
        ko(c, d, x);
    }
  }
  function Id(c) {
    var d = c.updateQueue;
    if (d !== null) {
      c.updateQueue = null;
      var x = c.stateNode;
      x === null && (x = c.stateNode = new w0()), d.forEach(function(A) {
        var F = bx.bind(null, c, A);
        x.has(A) || (x.add(A), A.then(F, F));
      });
    }
  }
  function of(c, d) {
    var x = d.deletions;
    if (x !== null)
      for (var A = 0; A < x.length; A++) {
        var F = x[A];
        try {
          var W = c, ie = d, Ae = ie;
          e:
            for (; Ae !== null; ) {
              switch (Ae.tag) {
                case 5:
                  Ei = Ae.stateNode, Ga = !1;
                  break e;
                case 3:
                  Ei = Ae.stateNode.containerInfo, Ga = !0;
                  break e;
                case 4:
                  Ei = Ae.stateNode.containerInfo, Ga = !0;
                  break e;
              }
              Ae = Ae.return;
            }
          if (Ei === null)
            throw Error(t(160));
          mu(W, ie, F), Ei = null, Ga = !1;
          var Ie = F.alternate;
          Ie !== null && (Ie.return = null), F.return = null;
        } catch (pt) {
          no(F, d, pt);
        }
      }
    if (d.subtreeFlags & 12854)
      for (d = d.child; d !== null; )
        _x(d, c), d = d.sibling;
  }
  function _x(c, d) {
    var x = c.alternate, A = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (of(d, c), ml(c), A & 4) {
          try {
            Ep(3, c, c.return), Dv(3, c);
          } catch (Fn) {
            no(c, c.return, Fn);
          }
          try {
            Ep(5, c, c.return);
          } catch (Fn) {
            no(c, c.return, Fn);
          }
        }
        break;
      case 1:
        of(d, c), ml(c), A & 512 && x !== null && _p(x, x.return);
        break;
      case 5:
        if (of(d, c), ml(c), A & 512 && x !== null && _p(x, x.return), c.flags & 32) {
          var F = c.stateNode;
          try {
            Wt(F, "");
          } catch (Fn) {
            no(c, c.return, Fn);
          }
        }
        if (A & 4 && (F = c.stateNode, F != null)) {
          var W = c.memoizedProps, ie = x !== null ? x.memoizedProps : W, Ae = c.type, Ie = c.updateQueue;
          if (c.updateQueue = null, Ie !== null)
            try {
              Ae === "input" && W.type === "radio" && W.name != null && gt(F, W), bt(Ae, ie);
              var pt = bt(Ae, W);
              for (ie = 0; ie < Ie.length; ie += 2) {
                var Yt = Ie[ie], jt = Ie[ie + 1];
                Yt === "style" ? Ut(F, jt) : Yt === "dangerouslySetInnerHTML" ? fn(F, jt) : Yt === "children" ? Wt(F, jt) : k(F, Yt, jt, pt);
              }
              switch (Ae) {
                case "input":
                  Jt(F, W);
                  break;
                case "textarea":
                  ae(F, W);
                  break;
                case "select":
                  var Ft = F._wrapperState.wasMultiple;
                  F._wrapperState.wasMultiple = !!W.multiple;
                  var Mn = W.value;
                  Mn != null ? Rn(F, !!W.multiple, Mn, !1) : Ft !== !!W.multiple && (W.defaultValue != null ? Rn(
                    F,
                    !!W.multiple,
                    W.defaultValue,
                    !0
                  ) : Rn(F, !!W.multiple, W.multiple ? [] : "", !1));
              }
              F[sc] = W;
            } catch (Fn) {
              no(c, c.return, Fn);
            }
        }
        break;
      case 6:
        if (of(d, c), ml(c), A & 4) {
          if (c.stateNode === null)
            throw Error(t(162));
          F = c.stateNode, W = c.memoizedProps;
          try {
            F.nodeValue = W;
          } catch (Fn) {
            no(c, c.return, Fn);
          }
        }
        break;
      case 3:
        if (of(d, c), ml(c), A & 4 && x !== null && x.memoizedState.isDehydrated)
          try {
            Cf(d.containerInfo);
          } catch (Fn) {
            no(c, c.return, Fn);
          }
        break;
      case 4:
        of(d, c), ml(c);
        break;
      case 13:
        of(d, c), ml(c), F = c.child, F.flags & 8192 && (W = F.memoizedState !== null, F.stateNode.isHidden = W, !W || F.alternate !== null && F.alternate.memoizedState !== null || (Uv = sn())), A & 4 && Id(c);
        break;
      case 22:
        if (Yt = x !== null && x.memoizedState !== null, c.mode & 1 ? (Ao = (pt = Ao) || Yt, of(d, c), Ao = pt) : of(d, c), ml(c), A & 8192) {
          if (pt = c.memoizedState !== null, (c.stateNode.isHidden = pt) && !Yt && c.mode & 1)
            for (Pn = c, Yt = c.child; Yt !== null; ) {
              for (jt = Pn = Yt; Pn !== null; ) {
                switch (Ft = Pn, Mn = Ft.child, Ft.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Ep(4, Ft, Ft.return);
                    break;
                  case 1:
                    _p(Ft, Ft.return);
                    var Nn = Ft.stateNode;
                    if (typeof Nn.componentWillUnmount == "function") {
                      A = Ft, x = Ft.return;
                      try {
                        d = A, Nn.props = d.memoizedProps, Nn.state = d.memoizedState, Nn.componentWillUnmount();
                      } catch (Fn) {
                        no(A, x, Fn);
                      }
                    }
                    break;
                  case 5:
                    _p(Ft, Ft.return);
                    break;
                  case 22:
                    if (Ft.memoizedState !== null) {
                      D0(jt);
                      continue;
                    }
                }
                Mn !== null ? (Mn.return = Ft, Pn = Mn) : D0(jt);
              }
              Yt = Yt.sibling;
            }
          e:
            for (Yt = null, jt = c; ; ) {
              if (jt.tag === 5) {
                if (Yt === null) {
                  Yt = jt;
                  try {
                    F = jt.stateNode, pt ? (W = F.style, typeof W.setProperty == "function" ? W.setProperty("display", "none", "important") : W.display = "none") : (Ae = jt.stateNode, Ie = jt.memoizedProps.style, ie = Ie != null && Ie.hasOwnProperty("display") ? Ie.display : null, Ae.style.display = St("display", ie));
                  } catch (Fn) {
                    no(c, c.return, Fn);
                  }
                }
              } else if (jt.tag === 6) {
                if (Yt === null)
                  try {
                    jt.stateNode.nodeValue = pt ? "" : jt.memoizedProps;
                  } catch (Fn) {
                    no(c, c.return, Fn);
                  }
              } else if ((jt.tag !== 22 && jt.tag !== 23 || jt.memoizedState === null || jt === c) && jt.child !== null) {
                jt.child.return = jt, jt = jt.child;
                continue;
              }
              if (jt === c)
                break e;
              for (; jt.sibling === null; ) {
                if (jt.return === null || jt.return === c)
                  break e;
                Yt === jt && (Yt = null), jt = jt.return;
              }
              Yt === jt && (Yt = null), jt.sibling.return = jt.return, jt = jt.sibling;
            }
        }
        break;
      case 19:
        of(d, c), ml(c), A & 4 && Id(c);
        break;
      case 21:
        break;
      default:
        of(
          d,
          c
        ), ml(c);
    }
  }
  function ml(c) {
    var d = c.flags;
    if (d & 2) {
      try {
        e: {
          for (var x = c.return; x !== null; ) {
            if (bp(x)) {
              var A = x;
              break e;
            }
            x = x.return;
          }
          throw Error(t(160));
        }
        switch (A.tag) {
          case 5:
            var F = A.stateNode;
            A.flags & 32 && (Wt(F, ""), A.flags &= -33);
            var W = Tp(c);
            Do(c, W, F);
            break;
          case 3:
          case 4:
            var ie = A.stateNode.containerInfo, Ae = Tp(c);
            kd(c, Ae, ie);
            break;
          default:
            throw Error(t(161));
        }
      } catch (Ie) {
        no(c, c.return, Ie);
      }
      c.flags &= -3;
    }
    d & 4096 && (c.flags &= -4097);
  }
  function A0(c, d, x) {
    Pn = c, wh(c);
  }
  function wh(c, d, x) {
    for (var A = (c.mode & 1) !== 0; Pn !== null; ) {
      var F = Pn, W = F.child;
      if (F.tag === 22 && A) {
        var ie = F.memoizedState !== null || xp;
        if (!ie) {
          var Ae = F.alternate, Ie = Ae !== null && Ae.memoizedState !== null || Ao;
          Ae = xp;
          var pt = Ao;
          if (xp = ie, (Ao = Ie) && !pt)
            for (Pn = F; Pn !== null; )
              ie = Pn, Ie = ie.child, ie.tag === 22 && ie.memoizedState !== null ? Zg(F) : Ie !== null ? (Ie.return = ie, Pn = Ie) : Zg(F);
          for (; W !== null; )
            Pn = W, wh(W), W = W.sibling;
          Pn = F, xp = Ae, Ao = pt;
        }
        Lv(c);
      } else
        F.subtreeFlags & 8772 && W !== null ? (W.return = F, Pn = W) : Lv(c);
    }
  }
  function Lv(c) {
    for (; Pn !== null; ) {
      var d = Pn;
      if (d.flags & 8772) {
        var x = d.alternate;
        try {
          if (d.flags & 8772)
            switch (d.tag) {
              case 0:
              case 11:
              case 15:
                Ao || Dv(5, d);
                break;
              case 1:
                var A = d.stateNode;
                if (d.flags & 4 && !Ao)
                  if (x === null)
                    A.componentDidMount();
                  else {
                    var F = d.elementType === d.type ? x.memoizedProps : ul(d.type, x.memoizedProps);
                    A.componentDidUpdate(F, x.memoizedState, A.__reactInternalSnapshotBeforeUpdate);
                  }
                var W = d.updateQueue;
                W !== null && ca(d, W, A);
                break;
              case 3:
                var ie = d.updateQueue;
                if (ie !== null) {
                  if (x = null, d.child !== null)
                    switch (d.child.tag) {
                      case 5:
                        x = d.child.stateNode;
                        break;
                      case 1:
                        x = d.child.stateNode;
                    }
                  ca(d, ie, x);
                }
                break;
              case 5:
                var Ae = d.stateNode;
                if (x === null && d.flags & 4) {
                  x = Ae;
                  var Ie = d.memoizedProps;
                  switch (d.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      Ie.autoFocus && x.focus();
                      break;
                    case "img":
                      Ie.src && (x.src = Ie.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (d.memoizedState === null) {
                  var pt = d.alternate;
                  if (pt !== null) {
                    var Yt = pt.memoizedState;
                    if (Yt !== null) {
                      var jt = Yt.dehydrated;
                      jt !== null && Cf(jt);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(t(163));
            }
          Ao || d.flags & 512 && R0(d);
        } catch (Ft) {
          no(d, d.return, Ft);
        }
      }
      if (d === c) {
        Pn = null;
        break;
      }
      if (x = d.sibling, x !== null) {
        x.return = d.return, Pn = x;
        break;
      }
      Pn = d.return;
    }
  }
  function D0(c) {
    for (; Pn !== null; ) {
      var d = Pn;
      if (d === c) {
        Pn = null;
        break;
      }
      var x = d.sibling;
      if (x !== null) {
        x.return = d.return, Pn = x;
        break;
      }
      Pn = d.return;
    }
  }
  function Zg(c) {
    for (; Pn !== null; ) {
      var d = Pn;
      try {
        switch (d.tag) {
          case 0:
          case 11:
          case 15:
            var x = d.return;
            try {
              Dv(4, d);
            } catch (Ie) {
              no(d, x, Ie);
            }
            break;
          case 1:
            var A = d.stateNode;
            if (typeof A.componentDidMount == "function") {
              var F = d.return;
              try {
                A.componentDidMount();
              } catch (Ie) {
                no(d, F, Ie);
              }
            }
            var W = d.return;
            try {
              R0(d);
            } catch (Ie) {
              no(d, W, Ie);
            }
            break;
          case 5:
            var ie = d.return;
            try {
              R0(d);
            } catch (Ie) {
              no(d, ie, Ie);
            }
        }
      } catch (Ie) {
        no(d, d.return, Ie);
      }
      if (d === c) {
        Pn = null;
        break;
      }
      var Ae = d.sibling;
      if (Ae !== null) {
        Ae.return = d.return, Pn = Ae;
        break;
      }
      Pn = d.return;
    }
  }
  var Jg = Math.ceil, Ov = G.ReactCurrentDispatcher, Fd = G.ReactCurrentOwner, Fi = G.ReactCurrentBatchConfig, xr = 0, Li = null, fa = null, Oa = 0, ku = 0, zm = Hn(0), Ko = 0, Pv = null, qf = 0, Nv = 0, Ch = 0, Rh = null, vl = null, Uv = 0, Ah = 1 / 0, sf = null, ey = !1, Mp = null, Kf = null, Dh = !1, Bd = null, Lh = 0, km = 0, zv = null, pc = -1, Oh = 0;
  function ji() {
    return xr & 6 ? sn() : pc !== -1 ? pc : pc = sn();
  }
  function So(c) {
    return c.mode & 1 ? xr & 2 && Oa !== 0 ? Oa & -Oa : Cm.transition !== null ? (Oh === 0 && (Oh = Go()), Oh) : (c = Kr, c !== 0 || (c = window.event, c = c === void 0 ? 16 : op(c.type)), c) : 1;
  }
  function Ss(c, d, x, A) {
    if (50 < km)
      throw km = 0, zv = null, Error(t(185));
    Qu(c, x, A), (!(xr & 2) || c !== Li) && (c === Li && (!(xr & 2) && (Nv |= x), Ko === 4 && gl(c, Oa)), xs(c, A), x === 1 && xr === 0 && !(d.mode & 1) && (Ah = sn() + 500, bo && Fa()));
  }
  function xs(c, d) {
    var x = c.callbackNode;
    Ds(c, d);
    var A = Ui(c, c === Li ? Oa : 0);
    if (A === 0)
      x !== null && An(x), c.callbackNode = null, c.callbackPriority = 0;
    else if (d = A & -A, c.callbackPriority !== d) {
      if (x != null && An(x), d === 1)
        c.tag === 0 ? Ff(Iv.bind(null, c)) : su(Iv.bind(null, c)), pp(function() {
          !(xr & 6) && Fa();
        }), x = null;
      else {
        switch (Ml(A)) {
          case 1:
            x = Pr;
            break;
          case 4:
            x = kn;
            break;
          case 16:
            x = za;
            break;
          case 536870912:
            x = Si;
            break;
          default:
            x = za;
        }
        x = Iu(x, Ph.bind(null, c));
      }
      c.callbackPriority = d, c.callbackNode = x;
    }
  }
  function Ph(c, d) {
    if (pc = -1, Oh = 0, xr & 6)
      throw Error(t(327));
    var x = c.callbackNode;
    if (lf() && c.callbackNode !== x)
      return null;
    var A = Ui(c, c === Li ? Oa : 0);
    if (A === 0)
      return null;
    if (A & 30 || A & c.expiredLanes || d)
      d = Nh(c, A);
    else {
      d = A;
      var F = xr;
      xr |= 2;
      var W = ry();
      (Li !== c || Oa !== d) && (sf = null, Ah = sn() + 500, mc(c, d));
      do
        try {
          Fv();
          break;
        } catch (Ae) {
          L0(c, Ae);
        }
      while (!0);
      Eh(), Ov.current = W, xr = F, fa !== null ? d = 0 : (Li = null, Oa = 0, d = Ko);
    }
    if (d !== 0) {
      if (d === 2 && (F = bl(c), F !== 0 && (A = F, d = kv(c, F))), d === 1)
        throw x = Pv, mc(c, 0), gl(c, A), xs(c, sn()), x;
      if (d === 6)
        gl(c, A);
      else {
        if (F = c.current.alternate, !(A & 30) && !ty(F) && (d = Nh(c, A), d === 2 && (W = bl(c), W !== 0 && (A = W, d = kv(c, W))), d === 1))
          throw x = Pv, mc(c, 0), gl(c, A), xs(c, sn()), x;
        switch (c.finishedWork = F, c.finishedLanes = A, d) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            Gd(c, vl, sf);
            break;
          case 3:
            if (gl(c, A), (A & 130023424) === A && (d = Uv + 500 - sn(), 10 < d)) {
              if (Ui(c, 0) !== 0)
                break;
              if (F = c.suspendedLanes, (F & A) !== A) {
                ji(), c.pingedLanes |= c.suspendedLanes & F;
                break;
              }
              c.timeoutHandle = Wc(Gd.bind(null, c, vl, sf), d);
              break;
            }
            Gd(c, vl, sf);
            break;
          case 4:
            if (gl(c, A), (A & 4194240) === A)
              break;
            for (d = c.eventTimes, F = -1; 0 < A; ) {
              var ie = 31 - Di(A);
              W = 1 << ie, ie = d[ie], ie > F && (F = ie), A &= ~W;
            }
            if (A = F, A = sn() - A, A = (120 > A ? 120 : 480 > A ? 480 : 1080 > A ? 1080 : 1920 > A ? 1920 : 3e3 > A ? 3e3 : 4320 > A ? 4320 : 1960 * Jg(A / 1960)) - A, 10 < A) {
              c.timeoutHandle = Wc(Gd.bind(null, c, vl, sf), A);
              break;
            }
            Gd(c, vl, sf);
            break;
          case 5:
            Gd(c, vl, sf);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return xs(c, sn()), c.callbackNode === x ? Ph.bind(null, c) : null;
  }
  function kv(c, d) {
    var x = Rh;
    return c.current.memoizedState.isDehydrated && (mc(c, d).flags |= 256), c = Nh(c, d), c !== 2 && (d = vl, vl = x, d !== null && wp(d)), c;
  }
  function wp(c) {
    vl === null ? vl = c : vl.push.apply(vl, c);
  }
  function ty(c) {
    for (var d = c; ; ) {
      if (d.flags & 16384) {
        var x = d.updateQueue;
        if (x !== null && (x = x.stores, x !== null))
          for (var A = 0; A < x.length; A++) {
            var F = x[A], W = F.getSnapshot;
            F = F.value;
            try {
              if (!Ia(W(), F))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (x = d.child, d.subtreeFlags & 16384 && x !== null)
        x.return = d, d = x;
      else {
        if (d === c)
          break;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === c)
            return !0;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
    }
    return !0;
  }
  function gl(c, d) {
    for (d &= ~Ch, d &= ~Nv, c.suspendedLanes |= d, c.pingedLanes &= ~d, c = c.expirationTimes; 0 < d; ) {
      var x = 31 - Di(d), A = 1 << x;
      c[x] = -1, d &= ~A;
    }
  }
  function Iv(c) {
    if (xr & 6)
      throw Error(t(327));
    lf();
    var d = Ui(c, 0);
    if (!(d & 1))
      return xs(c, sn()), null;
    var x = Nh(c, d);
    if (c.tag !== 0 && x === 2) {
      var A = bl(c);
      A !== 0 && (d = A, x = kv(c, A));
    }
    if (x === 1)
      throw x = Pv, mc(c, 0), gl(c, d), xs(c, sn()), x;
    if (x === 6)
      throw Error(t(345));
    return c.finishedWork = c.current.alternate, c.finishedLanes = d, Gd(c, vl, sf), xs(c, sn()), null;
  }
  function Hd(c, d) {
    var x = xr;
    xr |= 1;
    try {
      return c(d);
    } finally {
      xr = x, xr === 0 && (Ah = sn() + 500, bo && Fa());
    }
  }
  function Vd(c) {
    Bd !== null && Bd.tag === 0 && !(xr & 6) && lf();
    var d = xr;
    xr |= 1;
    var x = Fi.transition, A = Kr;
    try {
      if (Fi.transition = null, Kr = 1, c)
        return c();
    } finally {
      Kr = A, Fi.transition = x, xr = d, !(xr & 6) && Fa();
    }
  }
  function ny() {
    ku = zm.current, ii(zm);
  }
  function mc(c, d) {
    c.finishedWork = null, c.finishedLanes = 0;
    var x = c.timeoutHandle;
    if (x !== -1 && (c.timeoutHandle = -1, yh(x)), fa !== null)
      for (x = fa.return; x !== null; ) {
        var A = x;
        switch (jc(A), A.tag) {
          case 1:
            A = A.type.childContextTypes, A != null && Hs();
            break;
          case 3:
            du(), ii(Da), ii(dr), Ws();
            break;
          case 5:
            Rr(A);
            break;
          case 4:
            du();
            break;
          case 13:
            ii(Zn);
            break;
          case 19:
            ii(Zn);
            break;
          case 10:
            Xi(A.type._context);
            break;
          case 22:
          case 23:
            ny();
        }
        x = x.return;
      }
    if (Li = c, fa = c = kl(c.current, null), Oa = ku = d, Ko = 0, Pv = null, Ch = Nv = qf = 0, vl = Rh = null, Ba !== null) {
      for (d = 0; d < Ba.length; d++)
        if (x = Ba[d], A = x.interleaved, A !== null) {
          x.interleaved = null;
          var F = A.next, W = x.pending;
          if (W !== null) {
            var ie = W.next;
            W.next = F, A.next = ie;
          }
          x.pending = A;
        }
      Ba = null;
    }
    return c;
  }
  function L0(c, d) {
    do {
      var x = fa;
      try {
        if (Eh(), Qc.current = m, Wn) {
          for (var A = ci.memoizedState; A !== null; ) {
            var F = A.queue;
            F !== null && (F.pending = null), A = A.next;
          }
          Wn = !1;
        }
        if (Co = 0, Jr = Ct = ci = null, Pu = !1, js = 0, Fd.current = null, x === null || x.return === null) {
          Ko = 1, Pv = d, fa = null;
          break;
        }
        e: {
          var W = c, ie = x.return, Ae = x, Ie = d;
          if (d = Oa, Ae.flags |= 32768, Ie !== null && typeof Ie == "object" && typeof Ie.then == "function") {
            var pt = Ie, Yt = Ae, jt = Yt.tag;
            if (!(Yt.mode & 1) && (jt === 0 || jt === 11 || jt === 15)) {
              var Ft = Yt.alternate;
              Ft ? (Yt.updateQueue = Ft.updateQueue, Yt.memoizedState = Ft.memoizedState, Yt.lanes = Ft.lanes) : (Yt.updateQueue = null, Yt.memoizedState = null);
            }
            var Mn = sr(ie);
            if (Mn !== null) {
              Mn.flags &= -257, Jn(Mn, ie, Ae, W, d), Mn.mode & 1 && cn(W, pt, d), d = Mn, Ie = pt;
              var Nn = d.updateQueue;
              if (Nn === null) {
                var Fn = /* @__PURE__ */ new Set();
                Fn.add(Ie), d.updateQueue = Fn;
              } else
                Nn.add(Ie);
              break e;
            } else {
              if (!(d & 1)) {
                cn(W, pt, d), O0();
                break e;
              }
              Ie = Error(t(426));
            }
          } else if (ra && Ae.mode & 1) {
            var ro = sr(ie);
            if (ro !== null) {
              !(ro.flags & 65536) && (ro.flags |= 256), Jn(ro, ie, Ae, W, d), xh(V(Ie, Ae));
              break e;
            }
          }
          W = Ie = V(Ie, Ae), Ko !== 4 && (Ko = 2), Rh === null ? Rh = [W] : Rh.push(W), W = ie;
          do {
            switch (W.tag) {
              case 3:
                W.flags |= 65536, d &= -d, W.lanes |= d;
                var Qe = Mt(W, Ie, d);
                zr(W, Qe);
                break e;
              case 1:
                Ae = Ie;
                var Ve = W.type, lt = W.stateNode;
                if (!(W.flags & 128) && (typeof Ve.getDerivedStateFromError == "function" || lt !== null && typeof lt.componentDidCatch == "function" && (Kf === null || !Kf.has(lt)))) {
                  W.flags |= 65536, d &= -d, W.lanes |= d;
                  var on = Qt(W, Ae, d);
                  zr(W, on);
                  break e;
                }
            }
            W = W.return;
          } while (W !== null);
        }
        Im(x);
      } catch (Bn) {
        d = Bn, fa === x && x !== null && (fa = x = x.return);
        continue;
      }
      break;
    } while (!0);
  }
  function ry() {
    var c = Ov.current;
    return Ov.current = m, c === null ? m : c;
  }
  function O0() {
    (Ko === 0 || Ko === 3 || Ko === 2) && (Ko = 4), Li === null || !(qf & 268435455) && !(Nv & 268435455) || gl(Li, Oa);
  }
  function Nh(c, d) {
    var x = xr;
    xr |= 2;
    var A = ry();
    (Li !== c || Oa !== d) && (sf = null, mc(c, d));
    do
      try {
        Uh();
        break;
      } catch (F) {
        L0(c, F);
      }
    while (!0);
    if (Eh(), xr = x, Ov.current = A, fa !== null)
      throw Error(t(261));
    return Li = null, Oa = 0, Ko;
  }
  function Uh() {
    for (; fa !== null; )
      Bv(fa);
  }
  function Fv() {
    for (; fa !== null && !Gn(); )
      Bv(fa);
  }
  function Bv(c) {
    var d = Bm(c.alternate, c, ku);
    c.memoizedProps = c.pendingProps, d === null ? Im(c) : fa = d, Fd.current = null;
  }
  function Im(c) {
    var d = c;
    do {
      var x = d.alternate;
      if (c = d.return, d.flags & 32768) {
        if (x = Qg(x, d), x !== null) {
          x.flags &= 32767, fa = x;
          return;
        }
        if (c !== null)
          c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null;
        else {
          Ko = 6, fa = null;
          return;
        }
      } else if (x = M0(x, d, ku), x !== null) {
        fa = x;
        return;
      }
      if (d = d.sibling, d !== null) {
        fa = d;
        return;
      }
      fa = d = c;
    } while (d !== null);
    Ko === 0 && (Ko = 5);
  }
  function Gd(c, d, x) {
    var A = Kr, F = Fi.transition;
    try {
      Fi.transition = null, Kr = 1, P0(c, d, x, A);
    } finally {
      Fi.transition = F, Kr = A;
    }
    return null;
  }
  function P0(c, d, x, A) {
    do
      lf();
    while (Bd !== null);
    if (xr & 6)
      throw Error(t(327));
    x = c.finishedWork;
    var F = c.finishedLanes;
    if (x === null)
      return null;
    if (c.finishedWork = null, c.finishedLanes = 0, x === c.current)
      throw Error(t(177));
    c.callbackNode = null, c.callbackPriority = 0;
    var W = x.lanes | x.childLanes;
    if (fm(c, W), c === Li && (fa = Li = null, Oa = 0), !(x.subtreeFlags & 2064) && !(x.flags & 2064) || Dh || (Dh = !0, Iu(za, function() {
      return lf(), null;
    })), W = (x.flags & 15990) !== 0, x.subtreeFlags & 15990 || W) {
      W = Fi.transition, Fi.transition = null;
      var ie = Kr;
      Kr = 1;
      var Ae = xr;
      xr |= 4, Fd.current = null, C0(c, x), _x(x, c), ki(Gc), co = !!Uf, Gc = Uf = null, c.current = x, A0(x), cr(), xr = Ae, Kr = ie, Fi.transition = W;
    } else
      c.current = x;
    if (Dh && (Dh = !1, Bd = c, Lh = F), W = c.pendingLanes, W === 0 && (Kf = null), fr(x.stateNode), xs(c, sn()), d !== null)
      for (A = c.onRecoverableError, x = 0; x < d.length; x++)
        F = d[x], A(F.value, { componentStack: F.stack, digest: F.digest });
    if (ey)
      throw ey = !1, c = Mp, Mp = null, c;
    return Lh & 1 && c.tag !== 0 && lf(), W = c.pendingLanes, W & 1 ? c === zv ? km++ : (km = 0, zv = c) : km = 0, Fa(), null;
  }
  function lf() {
    if (Bd !== null) {
      var c = Ml(Lh), d = Fi.transition, x = Kr;
      try {
        if (Fi.transition = null, Kr = 16 > c ? 16 : c, Bd === null)
          var A = !1;
        else {
          if (c = Bd, Bd = null, Lh = 0, xr & 6)
            throw Error(t(331));
          var F = xr;
          for (xr |= 4, Pn = c.current; Pn !== null; ) {
            var W = Pn, ie = W.child;
            if (Pn.flags & 16) {
              var Ae = W.deletions;
              if (Ae !== null) {
                for (var Ie = 0; Ie < Ae.length; Ie++) {
                  var pt = Ae[Ie];
                  for (Pn = pt; Pn !== null; ) {
                    var Yt = Pn;
                    switch (Yt.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Ep(8, Yt, W);
                    }
                    var jt = Yt.child;
                    if (jt !== null)
                      jt.return = Yt, Pn = jt;
                    else
                      for (; Pn !== null; ) {
                        Yt = Pn;
                        var Ft = Yt.sibling, Mn = Yt.return;
                        if (Mh(Yt), Yt === pt) {
                          Pn = null;
                          break;
                        }
                        if (Ft !== null) {
                          Ft.return = Mn, Pn = Ft;
                          break;
                        }
                        Pn = Mn;
                      }
                  }
                }
                var Nn = W.alternate;
                if (Nn !== null) {
                  var Fn = Nn.child;
                  if (Fn !== null) {
                    Nn.child = null;
                    do {
                      var ro = Fn.sibling;
                      Fn.sibling = null, Fn = ro;
                    } while (Fn !== null);
                  }
                }
                Pn = W;
              }
            }
            if (W.subtreeFlags & 2064 && ie !== null)
              ie.return = W, Pn = ie;
            else
              e:
                for (; Pn !== null; ) {
                  if (W = Pn, W.flags & 2048)
                    switch (W.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Ep(9, W, W.return);
                    }
                  var Qe = W.sibling;
                  if (Qe !== null) {
                    Qe.return = W.return, Pn = Qe;
                    break e;
                  }
                  Pn = W.return;
                }
          }
          var Ve = c.current;
          for (Pn = Ve; Pn !== null; ) {
            ie = Pn;
            var lt = ie.child;
            if (ie.subtreeFlags & 2064 && lt !== null)
              lt.return = ie, Pn = lt;
            else
              e:
                for (ie = Ve; Pn !== null; ) {
                  if (Ae = Pn, Ae.flags & 2048)
                    try {
                      switch (Ae.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Dv(9, Ae);
                      }
                    } catch (Bn) {
                      no(Ae, Ae.return, Bn);
                    }
                  if (Ae === ie) {
                    Pn = null;
                    break e;
                  }
                  var on = Ae.sibling;
                  if (on !== null) {
                    on.return = Ae.return, Pn = on;
                    break e;
                  }
                  Pn = Ae.return;
                }
          }
          if (xr = F, Fa(), Cr && typeof Cr.onPostCommitFiberRoot == "function")
            try {
              Cr.onPostCommitFiberRoot(ir, c);
            } catch {
            }
          A = !0;
        }
        return A;
      } finally {
        Kr = x, Fi.transition = d;
      }
    }
    return !1;
  }
  function Fm(c, d, x) {
    d = V(x, d), d = Mt(c, d, 1), c = cc(c, d, 1), d = ji(), c !== null && (Qu(c, 1, d), xs(c, d));
  }
  function no(c, d, x) {
    if (c.tag === 3)
      Fm(c, c, x);
    else
      for (; d !== null; ) {
        if (d.tag === 3) {
          Fm(d, c, x);
          break;
        } else if (d.tag === 1) {
          var A = d.stateNode;
          if (typeof d.type.getDerivedStateFromError == "function" || typeof A.componentDidCatch == "function" && (Kf === null || !Kf.has(A))) {
            c = V(x, c), c = Qt(d, c, 1), d = cc(d, c, 1), c = ji(), d !== null && (Qu(d, 1, c), xs(d, c));
            break;
          }
        }
        d = d.return;
      }
  }
  function N0(c, d, x) {
    var A = c.pingCache;
    A !== null && A.delete(d), d = ji(), c.pingedLanes |= c.suspendedLanes & x, Li === c && (Oa & x) === x && (Ko === 4 || Ko === 3 && (Oa & 130023424) === Oa && 500 > sn() - Uv ? mc(c, 0) : Ch |= x), xs(c, d);
  }
  function iy(c, d) {
    d === 0 && (c.mode & 1 ? (d = Vi, Vi <<= 1, !(Vi & 130023424) && (Vi = 4194304)) : d = 1);
    var x = ji();
    c = ms(c, d), c !== null && (Qu(c, d, x), xs(c, x));
  }
  function Ex(c) {
    var d = c.memoizedState, x = 0;
    d !== null && (x = d.retryLane), iy(c, x);
  }
  function bx(c, d) {
    var x = 0;
    switch (c.tag) {
      case 13:
        var A = c.stateNode, F = c.memoizedState;
        F !== null && (x = F.retryLane);
        break;
      case 19:
        A = c.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    A !== null && A.delete(d), iy(c, x);
  }
  var Bm;
  Bm = function(c, d, x) {
    if (c !== null)
      if (c.memoizedProps !== d.pendingProps || Da.current)
        yn = !0;
      else {
        if (!(c.lanes & x) && !(d.flags & 128))
          return yn = !1, af(c, d, x);
        yn = !!(c.flags & 131072);
      }
    else
      yn = !1, ra && d.flags & 1048576 && wm(d, Sr, d.index);
    switch (d.lanes = 0, d.tag) {
      case 2:
        var A = d.type;
        gs(c, d), c = d.pendingProps;
        var F = Bs(d, dr.current);
        dn(d, x), F = Zc(null, d, A, c, F, x);
        var W = Jc();
        return d.flags |= 1, typeof F == "object" && F !== null && typeof F.render == "function" && F.$$typeof === void 0 ? (d.tag = 1, d.memoizedState = null, d.updateQueue = null, ua(A) ? (W = !0, uc(d)) : W = !1, d.memoizedState = F.state !== null && F.state !== void 0 ? F.state : null, gn(d), F.updater = Xc, d.stateNode = F, F._reactInternals = d, cu(d, A, c, x), d = ar(null, d, A, !0, W, x)) : (d.tag = 0, ra && W && mp(d), fi(null, d, F, x), d = d.child), d;
      case 16:
        A = d.elementType;
        e: {
          switch (gs(c, d), c = d.pendingProps, F = A._init, A = F(A._payload), d.type = A, F = d.tag = ib(A), c = ul(A, c), F) {
            case 0:
              d = Dn(null, d, A, c, x);
              break e;
            case 1:
              d = Ar(null, d, A, c, x);
              break e;
            case 11:
              d = Va(null, d, A, c, x);
              break e;
            case 14:
              d = ot(null, d, A, ul(A.type, c), x);
              break e;
          }
          throw Error(t(
            306,
            A,
            ""
          ));
        }
        return d;
      case 0:
        return A = d.type, F = d.pendingProps, F = d.elementType === A ? F : ul(A, F), Dn(c, d, A, F, x);
      case 1:
        return A = d.type, F = d.pendingProps, F = d.elementType === A ? F : ul(A, F), Ar(c, d, A, F, x);
      case 3:
        e: {
          if (Vr(d), c === null)
            throw Error(t(387));
          A = d.pendingProps, W = d.memoizedState, F = W.element, qi(c, d), ia(d, A, null, x);
          var ie = d.memoizedState;
          if (A = ie.element, W.isDehydrated)
            if (W = { element: A, isDehydrated: !1, cache: ie.cache, pendingSuspenseBoundaries: ie.pendingSuspenseBoundaries, transitions: ie.transitions }, d.updateQueue.baseState = W, d.memoizedState = W, d.flags & 256) {
              F = V(Error(t(423)), d), d = _a(c, d, A, x, F);
              break e;
            } else if (A !== F) {
              F = V(Error(t(424)), d), d = _a(c, d, A, x, F);
              break e;
            } else
              for (hs = ks(d.stateNode.containerInfo.firstChild), Mo = d, ra = !0, ll = null, x = Nd(d, null, A, x), d.child = x; x; )
                x.flags = x.flags & -3 | 4096, x = x.sibling;
          else {
            if (va(), A === F) {
              d = qo(c, d, x);
              break e;
            }
            fi(c, d, A, x);
          }
          d = d.child;
        }
        return d;
      case 5:
        return Qn(d), c === null && Od(d), A = d.type, F = d.pendingProps, W = c !== null ? c.memoizedProps : null, ie = F.children, Rd(A, F) ? ie = null : W !== null && Rd(A, W) && (d.flags |= 32), Pt(c, d), fi(c, d, ie, x), d.child;
      case 6:
        return c === null && Od(d), null;
      case 13:
        return Th(c, d, x);
      case 4:
        return bh(d, d.stateNode.containerInfo), A = d.pendingProps, c === null ? d.child = Gf(d, null, A, x) : fi(c, d, A, x), d.child;
      case 11:
        return A = d.type, F = d.pendingProps, F = d.elementType === A ? F : ul(A, F), Va(c, d, A, F, x);
      case 7:
        return fi(c, d, d.pendingProps, x), d.child;
      case 8:
        return fi(c, d, d.pendingProps.children, x), d.child;
      case 12:
        return fi(c, d, d.pendingProps.children, x), d.child;
      case 10:
        e: {
          if (A = d.type._context, F = d.pendingProps, W = d.memoizedProps, ie = F.value, di(uu, A._currentValue), A._currentValue = ie, W !== null)
            if (Ia(W.value, ie)) {
              if (W.children === F.children && !Da.current) {
                d = qo(c, d, x);
                break e;
              }
            } else
              for (W = d.child, W !== null && (W.return = d); W !== null; ) {
                var Ae = W.dependencies;
                if (Ae !== null) {
                  ie = W.child;
                  for (var Ie = Ae.firstContext; Ie !== null; ) {
                    if (Ie.context === A) {
                      if (W.tag === 1) {
                        Ie = Ha(-1, x & -x), Ie.tag = 2;
                        var pt = W.updateQueue;
                        if (pt !== null) {
                          pt = pt.shared;
                          var Yt = pt.pending;
                          Yt === null ? Ie.next = Ie : (Ie.next = Yt.next, Yt.next = Ie), pt.pending = Ie;
                        }
                      }
                      W.lanes |= x, Ie = W.alternate, Ie !== null && (Ie.lanes |= x), ya(
                        W.return,
                        x,
                        d
                      ), Ae.lanes |= x;
                      break;
                    }
                    Ie = Ie.next;
                  }
                } else if (W.tag === 10)
                  ie = W.type === d.type ? null : W.child;
                else if (W.tag === 18) {
                  if (ie = W.return, ie === null)
                    throw Error(t(341));
                  ie.lanes |= x, Ae = ie.alternate, Ae !== null && (Ae.lanes |= x), ya(ie, x, d), ie = W.sibling;
                } else
                  ie = W.child;
                if (ie !== null)
                  ie.return = W;
                else
                  for (ie = W; ie !== null; ) {
                    if (ie === d) {
                      ie = null;
                      break;
                    }
                    if (W = ie.sibling, W !== null) {
                      W.return = ie.return, ie = W;
                      break;
                    }
                    ie = ie.return;
                  }
                W = ie;
              }
          fi(c, d, F.children, x), d = d.child;
        }
        return d;
      case 9:
        return F = d.type, A = d.pendingProps.children, dn(d, x), F = Wi(F), A = A(F), d.flags |= 1, fi(c, d, A, x), d.child;
      case 14:
        return A = d.type, F = ul(A, d.pendingProps), F = ul(A.type, F), ot(c, d, A, F, x);
      case 15:
        return Be(c, d, d.type, d.pendingProps, x);
      case 17:
        return A = d.type, F = d.pendingProps, F = d.elementType === A ? F : ul(A, F), gs(c, d), d.tag = 1, ua(A) ? (c = !0, uc(d)) : c = !1, dn(d, x), Pd(d, A, F), cu(d, A, F, x), ar(null, d, A, !0, c, x);
      case 19:
        return Kg(c, d, x);
      case 22:
        return vt(c, d, x);
    }
    throw Error(t(156, d.tag));
  };
  function Iu(c, d) {
    return pn(c, d);
  }
  function U0(c, d, x, A) {
    this.tag = c, this.key = x, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = d, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = A, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Ys(c, d, x, A) {
    return new U0(c, d, x, A);
  }
  function Hv(c) {
    return c = c.prototype, !(!c || !c.isReactComponent);
  }
  function ib(c) {
    if (typeof c == "function")
      return Hv(c) ? 1 : 0;
    if (c != null) {
      if (c = c.$$typeof, c === ye)
        return 11;
      if (c === Re)
        return 14;
    }
    return 2;
  }
  function kl(c, d) {
    var x = c.alternate;
    return x === null ? (x = Ys(c.tag, d, c.key, c.mode), x.elementType = c.elementType, x.type = c.type, x.stateNode = c.stateNode, x.alternate = c, c.alternate = x) : (x.pendingProps = d, x.type = c.type, x.flags = 0, x.subtreeFlags = 0, x.deletions = null), x.flags = c.flags & 14680064, x.childLanes = c.childLanes, x.lanes = c.lanes, x.child = c.child, x.memoizedProps = c.memoizedProps, x.memoizedState = c.memoizedState, x.updateQueue = c.updateQueue, d = c.dependencies, x.dependencies = d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }, x.sibling = c.sibling, x.index = c.index, x.ref = c.ref, x;
  }
  function Wd(c, d, x, A, F, W) {
    var ie = 2;
    if (A = c, typeof c == "function")
      Hv(c) && (ie = 1);
    else if (typeof c == "string")
      ie = 5;
    else
      e:
        switch (c) {
          case Z:
            return Cp(x.children, F, W, d);
          case te:
            ie = 8, F |= 8;
            break;
          case J:
            return c = Ys(12, x, d, F | 2), c.elementType = J, c.lanes = W, c;
          case de:
            return c = Ys(13, x, d, F), c.elementType = de, c.lanes = W, c;
          case xe:
            return c = Ys(19, x, d, F), c.elementType = xe, c.lanes = W, c;
          case Te:
            return zh(x, F, W, d);
          default:
            if (typeof c == "object" && c !== null)
              switch (c.$$typeof) {
                case q:
                  ie = 10;
                  break e;
                case oe:
                  ie = 9;
                  break e;
                case ye:
                  ie = 11;
                  break e;
                case Re:
                  ie = 14;
                  break e;
                case Pe:
                  ie = 16, A = null;
                  break e;
              }
            throw Error(t(130, c == null ? c : typeof c, ""));
        }
    return d = Ys(ie, x, d, F), d.elementType = c, d.type = A, d.lanes = W, d;
  }
  function Cp(c, d, x, A) {
    return c = Ys(7, c, A, d), c.lanes = x, c;
  }
  function zh(c, d, x, A) {
    return c = Ys(22, c, A, d), c.elementType = Te, c.lanes = x, c.stateNode = { isHidden: !1 }, c;
  }
  function vu(c, d, x) {
    return c = Ys(6, c, null, d), c.lanes = x, c;
  }
  function oa(c, d, x) {
    return d = Ys(4, c.children !== null ? c.children : [], c.key, d), d.lanes = x, d.stateNode = { containerInfo: c.containerInfo, pendingChildren: null, implementation: c.implementation }, d;
  }
  function kh(c, d, x, A, F) {
    this.tag = d, this.containerInfo = c, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Mf(0), this.expirationTimes = Mf(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Mf(0), this.identifierPrefix = A, this.onRecoverableError = F, this.mutableSourceEagerHydrationData = null;
  }
  function Wa(c, d, x, A, F, W, ie, Ae, Ie) {
    return c = new kh(c, d, x, Ae, Ie), d === 1 ? (d = 1, W === !0 && (d |= 8)) : d = 0, W = Ys(3, null, null, d), c.current = W, W.stateNode = c, W.memoizedState = { element: A, isDehydrated: x, cache: null, transitions: null, pendingSuspenseBoundaries: null }, gn(W), c;
  }
  function _s(c, d, x) {
    var A = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: Y, key: A == null ? null : "" + A, children: c, containerInfo: d, implementation: x };
  }
  function Vv(c) {
    if (!c)
      return Au;
    c = c._reactInternals;
    e: {
      if (ve(c) !== c || c.tag !== 1)
        throw Error(t(170));
      var d = c;
      do {
        switch (d.tag) {
          case 3:
            d = d.stateNode.context;
            break e;
          case 1:
            if (ua(d.type)) {
              d = d.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        d = d.return;
      } while (d !== null);
      throw Error(t(171));
    }
    if (c.tag === 1) {
      var x = c.type;
      if (ua(x))
        return If(c, x, d);
    }
    return d;
  }
  function ay(c, d, x, A, F, W, ie, Ae, Ie) {
    return c = Wa(x, A, !0, c, F, W, ie, Ae, Ie), c.context = Vv(null), x = c.current, A = ji(), F = So(x), W = Ha(A, F), W.callback = d ?? null, cc(x, W, F), c.current.lanes = F, Qu(c, F, A), xs(c, A), c;
  }
  function Gv(c, d, x, A) {
    var F = d.current, W = ji(), ie = So(F);
    return x = Vv(x), d.context === null ? d.context = x : d.pendingContext = x, d = Ha(W, ie), d.payload = { element: c }, A = A === void 0 ? null : A, A !== null && (d.callback = A), c = cc(F, d, ie), c !== null && (Ss(c, F, ie, W), xa(c, F, ie)), ie;
  }
  function En(c) {
    if (c = c.current, !c.child)
      return null;
    switch (c.child.tag) {
      case 5:
        return c.child.stateNode;
      default:
        return c.child.stateNode;
    }
  }
  function Il(c, d) {
    if (c = c.memoizedState, c !== null && c.dehydrated !== null) {
      var x = c.retryLane;
      c.retryLane = x !== 0 && x < d ? x : d;
    }
  }
  function Wv(c, d) {
    Il(c, d), (c = c.alternate) && Il(c, d);
  }
  function Rp() {
    return null;
  }
  var Ih = typeof reportError == "function" ? reportError : function(c) {
    console.error(c);
  };
  function $i(c) {
    this._internalRoot = c;
  }
  ja.prototype.render = $i.prototype.render = function(c) {
    var d = this._internalRoot;
    if (d === null)
      throw Error(t(409));
    Gv(c, d, null, null);
  }, ja.prototype.unmount = $i.prototype.unmount = function() {
    var c = this._internalRoot;
    if (c !== null) {
      this._internalRoot = null;
      var d = c.containerInfo;
      Vd(function() {
        Gv(null, c, null, null);
      }), d[Is] = null;
    }
  };
  function ja(c) {
    this._internalRoot = c;
  }
  ja.prototype.unstable_scheduleHydration = function(c) {
    if (c) {
      var d = lo();
      c = { blockedOn: null, target: c, priority: d };
      for (var x = 0; x < zi.length && d !== 0 && d < zi[x].priority; x++)
        ;
      zi.splice(x, 0, c), x === 0 && ch(c);
    }
  };
  function Lo(c) {
    return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11);
  }
  function Ap(c) {
    return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11 && (c.nodeType !== 8 || c.nodeValue !== " react-mount-point-unstable "));
  }
  function Hm() {
  }
  function jv(c, d, x, A, F) {
    if (F) {
      if (typeof A == "function") {
        var W = A;
        A = function() {
          var pt = En(ie);
          W.call(pt);
        };
      }
      var ie = ay(d, A, c, 0, null, !1, !1, "", Hm);
      return c._reactRootContainer = ie, c[Is] = ie.current, ol(c.nodeType === 8 ? c.parentNode : c), Vd(), ie;
    }
    for (; F = c.lastChild; )
      c.removeChild(F);
    if (typeof A == "function") {
      var Ae = A;
      A = function() {
        var pt = En(Ie);
        Ae.call(pt);
      };
    }
    var Ie = Wa(c, 0, !1, null, null, !1, !1, "", Hm);
    return c._reactRootContainer = Ie, c[Is] = Ie.current, ol(c.nodeType === 8 ? c.parentNode : c), Vd(function() {
      Gv(d, Ie, x, A);
    }), Ie;
  }
  function oy(c, d, x, A, F) {
    var W = x._reactRootContainer;
    if (W) {
      var ie = W;
      if (typeof F == "function") {
        var Ae = F;
        F = function() {
          var Ie = En(ie);
          Ae.call(Ie);
        };
      }
      Gv(d, ie, c, F);
    } else
      ie = jv(x, d, c, F, A);
    return En(ie);
  }
  Zu = function(c) {
    switch (c.tag) {
      case 3:
        var d = c.stateNode;
        if (d.current.memoizedState.isDehydrated) {
          var x = Po(d.pendingLanes);
          x !== 0 && (Tl(d, x | 1), xs(d, sn()), !(xr & 6) && (Ah = sn() + 500, Fa()));
        }
        break;
      case 13:
        Vd(function() {
          var A = ms(c, 1);
          if (A !== null) {
            var F = ji();
            Ss(A, c, 1, F);
          }
        }), Wv(c, 1);
    }
  }, ls = function(c) {
    if (c.tag === 13) {
      var d = ms(c, 134217728);
      if (d !== null) {
        var x = ji();
        Ss(d, c, 134217728, x);
      }
      Wv(c, 134217728);
    }
  }, jr = function(c) {
    if (c.tag === 13) {
      var d = So(c), x = ms(c, d);
      if (x !== null) {
        var A = ji();
        Ss(x, c, d, A);
      }
      Wv(c, d);
    }
  }, lo = function() {
    return Kr;
  }, wf = function(c, d) {
    var x = Kr;
    try {
      return Kr = c, d();
    } finally {
      Kr = x;
    }
  }, zt = function(c, d, x) {
    switch (d) {
      case "input":
        if (Jt(c, x), d = x.name, x.type === "radio" && d != null) {
          for (x = c; x.parentNode; )
            x = x.parentNode;
          for (x = x.querySelectorAll("input[name=" + JSON.stringify("" + d) + '][type="radio"]'), d = 0; d < x.length; d++) {
            var A = x[d];
            if (A !== c && A.form === c.form) {
              var F = Kn(A);
              if (!F)
                throw Error(t(90));
              he(A), Jt(A, F);
            }
          }
        }
        break;
      case "textarea":
        ae(c, x);
        break;
      case "select":
        d = x.value, d != null && Rn(c, !!x.multiple, d, !1);
    }
  }, ti = Hd, rr = Vd;
  var ab = { usingClientEntryPoint: !1, Events: [Fs, xi, Kn, zn, yr, Hd] }, At = { findFiberByHostInstance: $o, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, vc = { bundleType: At.bundleType, version: At.version, rendererPackageName: At.rendererPackageName, rendererConfig: At.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: G.ReactCurrentDispatcher, findHostInstanceByFiber: function(c) {
    return c = dt(c), c === null ? null : c.stateNode;
  }, findFiberByHostInstance: At.findFiberByHostInstance || Rp, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var uf = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!uf.isDisabled && uf.supportsFiber)
      try {
        ir = uf.inject(vc), Cr = uf;
      } catch {
      }
  }
  return sd.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ab, sd.createPortal = function(c, d) {
    var x = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Lo(d))
      throw Error(t(200));
    return _s(c, d, null, x);
  }, sd.createRoot = function(c, d) {
    if (!Lo(c))
      throw Error(t(299));
    var x = !1, A = "", F = Ih;
    return d != null && (d.unstable_strictMode === !0 && (x = !0), d.identifierPrefix !== void 0 && (A = d.identifierPrefix), d.onRecoverableError !== void 0 && (F = d.onRecoverableError)), d = Wa(c, 1, !1, null, null, x, !1, A, F), c[Is] = d.current, ol(c.nodeType === 8 ? c.parentNode : c), new $i(d);
  }, sd.findDOMNode = function(c) {
    if (c == null)
      return null;
    if (c.nodeType === 1)
      return c;
    var d = c._reactInternals;
    if (d === void 0)
      throw typeof c.render == "function" ? Error(t(188)) : (c = Object.keys(c).join(","), Error(t(268, c)));
    return c = dt(d), c = c === null ? null : c.stateNode, c;
  }, sd.flushSync = function(c) {
    return Vd(c);
  }, sd.hydrate = function(c, d, x) {
    if (!Ap(d))
      throw Error(t(200));
    return oy(null, c, d, !0, x);
  }, sd.hydrateRoot = function(c, d, x) {
    if (!Lo(c))
      throw Error(t(405));
    var A = x != null && x.hydratedSources || null, F = !1, W = "", ie = Ih;
    if (x != null && (x.unstable_strictMode === !0 && (F = !0), x.identifierPrefix !== void 0 && (W = x.identifierPrefix), x.onRecoverableError !== void 0 && (ie = x.onRecoverableError)), d = ay(d, null, c, 1, x ?? null, F, !1, W, ie), c[Is] = d.current, ol(c), A)
      for (c = 0; c < A.length; c++)
        x = A[c], F = x._getVersion, F = F(x._source), d.mutableSourceEagerHydrationData == null ? d.mutableSourceEagerHydrationData = [x, F] : d.mutableSourceEagerHydrationData.push(
          x,
          F
        );
    return new ja(d);
  }, sd.render = function(c, d, x) {
    if (!Ap(d))
      throw Error(t(200));
    return oy(null, c, d, !1, x);
  }, sd.unmountComponentAtNode = function(c) {
    if (!Ap(c))
      throw Error(t(40));
    return c._reactRootContainer ? (Vd(function() {
      oy(null, null, c, !1, function() {
        c._reactRootContainer = null, c[Is] = null;
      });
    }), !0) : !1;
  }, sd.unstable_batchedUpdates = Hd, sd.unstable_renderSubtreeIntoContainer = function(c, d, x, A) {
    if (!Ap(x))
      throw Error(t(200));
    if (c == null || c._reactInternals === void 0)
      throw Error(t(38));
    return oy(c, d, x, !1, A);
  }, sd.version = "18.2.0-next-9e3b772b8-20220608", sd;
}
var ld = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e3;
function o6() {
  return e3 || (e3 = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var n = px(), e = CI(), t = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
    function a(i) {
      r = i;
    }
    function s(i) {
      if (!r) {
        for (var o = arguments.length, p = new Array(o > 1 ? o - 1 : 0), S = 1; S < o; S++)
          p[S - 1] = arguments[S];
        h("warn", i, p);
      }
    }
    function u(i) {
      if (!r) {
        for (var o = arguments.length, p = new Array(o > 1 ? o - 1 : 0), S = 1; S < o; S++)
          p[S - 1] = arguments[S];
        h("error", i, p);
      }
    }
    function h(i, o, p) {
      {
        var S = t.ReactDebugCurrentFrame, T = S.getStackAddendum();
        T !== "" && (o += "%s", p = p.concat([T]));
        var P = p.map(function(H) {
          return String(H);
        });
        P.unshift("Warning: " + o), Function.prototype.apply.call(console[i], console, P);
      }
    }
    var v = 0, y = 1, _ = 2, b = 3, M = 4, C = 5, D = 6, U = 7, N = 8, O = 9, I = 10, k = 11, G = 12, j = 13, Y = 14, Z = 15, te = 16, J = 17, q = 18, oe = 19, ye = 21, de = 22, xe = 23, Re = 24, Pe = 25, Te = !0, ue = !1, we = !1, X = !1, me = !1, ce = !0, Ue = !1, Oe = !1, Ze = !0, je = !0, Je = !0, at = /* @__PURE__ */ new Set(), xt = {}, $t = {};
    function Ht(i, o) {
      he(i, o), he(i + "Capture", o);
    }
    function he(i, o) {
      xt[i] && u("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", i), xt[i] = o;
      {
        var p = i.toLowerCase();
        $t[p] = i, i === "onDoubleClick" && ($t.ondblclick = i);
      }
      for (var S = 0; S < o.length; S++)
        at.add(o[S]);
    }
    var nt = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", et = Object.prototype.hasOwnProperty;
    function Rt(i) {
      {
        var o = typeof Symbol == "function" && Symbol.toStringTag, p = o && i[Symbol.toStringTag] || i.constructor.name || "Object";
        return p;
      }
    }
    function gt(i) {
      try {
        return Jt(i), !1;
      } catch {
        return !0;
      }
    }
    function Jt(i) {
      return "" + i;
    }
    function Kt(i, o) {
      if (gt(i))
        return u("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", o, Rt(i)), Jt(i);
    }
    function qt(i) {
      if (gt(i))
        return u("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Rt(i)), Jt(i);
    }
    function hn(i, o) {
      if (gt(i))
        return u("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", o, Rt(i)), Jt(i);
    }
    function Rn(i, o) {
      if (gt(i))
        return u("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", o, Rt(i)), Jt(i);
    }
    function Yn(i) {
      if (gt(i))
        return u("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", Rt(i)), Jt(i);
    }
    function se(i) {
      if (gt(i))
        return u("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", Rt(i)), Jt(i);
    }
    var ae = 0, Ke = 1, wt = 2, _t = 3, Vt = 4, fn = 5, Wt = 6, Ee = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Xe = Ee + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", St = new RegExp("^[" + Ee + "][" + Xe + "]*$"), Ut = {}, Se = {};
    function Ye(i) {
      return et.call(Se, i) ? !0 : et.call(Ut, i) ? !1 : St.test(i) ? (Se[i] = !0, !0) : (Ut[i] = !0, u("Invalid attribute name: `%s`", i), !1);
    }
    function bt(i, o, p) {
      return o !== null ? o.type === ae : p ? !1 : i.length > 2 && (i[0] === "o" || i[0] === "O") && (i[1] === "n" || i[1] === "N");
    }
    function Tt(i, o, p, S) {
      if (p !== null && p.type === ae)
        return !1;
      switch (typeof o) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (S)
            return !1;
          if (p !== null)
            return !p.acceptsBooleans;
          var T = i.toLowerCase().slice(0, 5);
          return T !== "data-" && T !== "aria-";
        }
        default:
          return !1;
      }
    }
    function ge(i, o, p, S) {
      if (o === null || typeof o > "u" || Tt(i, o, p, S))
        return !0;
      if (S)
        return !1;
      if (p !== null)
        switch (p.type) {
          case _t:
            return !o;
          case Vt:
            return o === !1;
          case fn:
            return isNaN(o);
          case Wt:
            return isNaN(o) || o < 1;
        }
      return !1;
    }
    function zt(i) {
      return ft.hasOwnProperty(i) ? ft[i] : null;
    }
    function Fe(i, o, p, S, T, P, H) {
      this.acceptsBooleans = o === wt || o === _t || o === Vt, this.attributeName = S, this.attributeNamespace = T, this.mustUseProperty = p, this.propertyName = i, this.type = o, this.sanitizeURL = P, this.removeEmptyString = H;
    }
    var ft = {}, ln = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ln.forEach(function(i) {
      ft[i] = new Fe(
        i,
        ae,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(i) {
      var o = i[0], p = i[1];
      ft[o] = new Fe(
        o,
        Ke,
        !1,
        // mustUseProperty
        p,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(i) {
      ft[i] = new Fe(
        i,
        wt,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(i) {
      ft[i] = new Fe(
        i,
        wt,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(i) {
      ft[i] = new Fe(
        i,
        _t,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      ft[i] = new Fe(
        i,
        _t,
        !0,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      ft[i] = new Fe(
        i,
        Vt,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      ft[i] = new Fe(
        i,
        Wt,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(i) {
      ft[i] = new Fe(
        i,
        fn,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var zn = /[\-\:]([a-z])/g, yr = function(i) {
      return i[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      var o = i.replace(zn, yr);
      ft[o] = new Fe(
        o,
        Ke,
        !1,
        // mustUseProperty
        i,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      var o = i.replace(zn, yr);
      ft[o] = new Fe(
        o,
        Ke,
        !1,
        // mustUseProperty
        i,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      var o = i.replace(zn, yr);
      ft[o] = new Fe(
        o,
        Ke,
        !1,
        // mustUseProperty
        i,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(i) {
      ft[i] = new Fe(
        i,
        Ke,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ti = "xlinkHref";
    ft[ti] = new Fe(
      "xlinkHref",
      Ke,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(i) {
      ft[i] = new Fe(
        i,
        Ke,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var rr = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, vr = !1;
    function Ai(i) {
      !vr && rr.test(i) && (vr = !0, u("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(i)));
    }
    function oi(i, o, p, S) {
      if (S.mustUseProperty) {
        var T = S.propertyName;
        return i[T];
      } else {
        Kt(p, o), S.sanitizeURL && Ai("" + p);
        var P = S.attributeName, H = null;
        if (S.type === Vt) {
          if (i.hasAttribute(P)) {
            var $ = i.getAttribute(P);
            return $ === "" ? !0 : ge(o, p, S, !1) ? $ : $ === "" + p ? p : $;
          }
        } else if (i.hasAttribute(P)) {
          if (ge(o, p, S, !1))
            return i.getAttribute(P);
          if (S.type === _t)
            return p;
          H = i.getAttribute(P);
        }
        return ge(o, p, S, !1) ? H === null ? p : H : H === "" + p ? p : H;
      }
    }
    function Ma(i, o, p, S) {
      {
        if (!Ye(o))
          return;
        if (!i.hasAttribute(o))
          return p === void 0 ? void 0 : null;
        var T = i.getAttribute(o);
        return Kt(p, o), T === "" + p ? p : T;
      }
    }
    function Ji(i, o, p, S) {
      var T = zt(o);
      if (!bt(o, T, S)) {
        if (ge(o, p, T, S) && (p = null), S || T === null) {
          if (Ye(o)) {
            var P = o;
            p === null ? i.removeAttribute(P) : (Kt(p, o), i.setAttribute(P, "" + p));
          }
          return;
        }
        var H = T.mustUseProperty;
        if (H) {
          var $ = T.propertyName;
          if (p === null) {
            var ee = T.type;
            i[$] = ee === _t ? !1 : "";
          } else
            i[$] = p;
          return;
        }
        var pe = T.attributeName, _e = T.attributeNamespace;
        if (p === null)
          i.removeAttribute(pe);
        else {
          var Ge = T.type, He;
          Ge === _t || Ge === Vt && p === !0 ? He = "" : (Kt(p, pe), He = "" + p, T.sanitizeURL && Ai(He.toString())), _e ? i.setAttributeNS(_e, pe, He) : i.setAttribute(pe, He);
        }
      }
    }
    var _l = Symbol.for("react.element"), ea = Symbol.for("react.portal"), _o = Symbol.for("react.fragment"), Eo = Symbol.for("react.strict_mode"), Le = Symbol.for("react.profiler"), Bt = Symbol.for("react.provider"), en = Symbol.for("react.context"), _n = Symbol.for("react.forward_ref"), ve = Symbol.for("react.suspense"), $e = Symbol.for("react.suspense_list"), qe = Symbol.for("react.memo"), ze = Symbol.for("react.lazy"), dt = Symbol.for("react.scope"), tn = Symbol.for("react.debug_trace_mode"), pn = Symbol.for("react.offscreen"), An = Symbol.for("react.legacy_hidden"), Gn = Symbol.for("react.cache"), cr = Symbol.for("react.tracing_marker"), sn = Symbol.iterator, pr = "@@iterator";
    function Pr(i) {
      if (i === null || typeof i != "object")
        return null;
      var o = sn && i[sn] || i[pr];
      return typeof o == "function" ? o : null;
    }
    var kn = Object.assign, za = 0, Ja, Si, ir, Cr, fr, Di, wa;
    function ni() {
    }
    ni.__reactDisabledLog = !0;
    function ss() {
      {
        if (za === 0) {
          Ja = console.log, Si = console.info, ir = console.warn, Cr = console.error, fr = console.group, Di = console.groupCollapsed, wa = console.groupEnd;
          var i = {
            configurable: !0,
            enumerable: !0,
            value: ni,
            writable: !0
          };
          Object.defineProperties(console, {
            info: i,
            log: i,
            warn: i,
            error: i,
            group: i,
            groupCollapsed: i,
            groupEnd: i
          });
        }
        za++;
      }
    }
    function ta() {
      {
        if (za--, za === 0) {
          var i = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: kn({}, i, {
              value: Ja
            }),
            info: kn({}, i, {
              value: Si
            }),
            warn: kn({}, i, {
              value: ir
            }),
            error: kn({}, i, {
              value: Cr
            }),
            group: kn({}, i, {
              value: fr
            }),
            groupCollapsed: kn({}, i, {
              value: Di
            }),
            groupEnd: kn({}, i, {
              value: wa
            })
          });
        }
        za < 0 && u("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Vi = t.ReactCurrentDispatcher, Po;
    function Ui(i, o, p) {
      {
        if (Po === void 0)
          try {
            throw Error();
          } catch (T) {
            var S = T.stack.trim().match(/\n( *(at )?)/);
            Po = S && S[1] || "";
          }
        return `
` + Po + i;
      }
    }
    var El = !1, Ds;
    {
      var bl = typeof WeakMap == "function" ? WeakMap : Map;
      Ds = new bl();
    }
    function Go(i, o) {
      if (!i || El)
        return "";
      {
        var p = Ds.get(i);
        if (p !== void 0)
          return p;
      }
      var S;
      El = !0;
      var T = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var P;
      P = Vi.current, Vi.current = null, ss();
      try {
        if (o) {
          var H = function() {
            throw Error();
          };
          if (Object.defineProperty(H.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(H, []);
            } catch (mt) {
              S = mt;
            }
            Reflect.construct(i, [], H);
          } else {
            try {
              H.call();
            } catch (mt) {
              S = mt;
            }
            i.call(H.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (mt) {
            S = mt;
          }
          i();
        }
      } catch (mt) {
        if (mt && S && typeof mt.stack == "string") {
          for (var $ = mt.stack.split(`
`), ee = S.stack.split(`
`), pe = $.length - 1, _e = ee.length - 1; pe >= 1 && _e >= 0 && $[pe] !== ee[_e]; )
            _e--;
          for (; pe >= 1 && _e >= 0; pe--, _e--)
            if ($[pe] !== ee[_e]) {
              if (pe !== 1 || _e !== 1)
                do
                  if (pe--, _e--, _e < 0 || $[pe] !== ee[_e]) {
                    var Ge = `
` + $[pe].replace(" at new ", " at ");
                    return i.displayName && Ge.includes("<anonymous>") && (Ge = Ge.replace("<anonymous>", i.displayName)), typeof i == "function" && Ds.set(i, Ge), Ge;
                  }
                while (pe >= 1 && _e >= 0);
              break;
            }
        }
      } finally {
        El = !1, Vi.current = P, ta(), Error.prepareStackTrace = T;
      }
      var He = i ? i.displayName || i.name : "", ht = He ? Ui(He) : "";
      return typeof i == "function" && Ds.set(i, ht), ht;
    }
    function Mf(i, o, p) {
      return Go(i, !0);
    }
    function Qu(i, o, p) {
      return Go(i, !1);
    }
    function fm(i) {
      var o = i.prototype;
      return !!(o && o.isReactComponent);
    }
    function Tl(i, o, p) {
      if (i == null)
        return "";
      if (typeof i == "function")
        return Go(i, fm(i));
      if (typeof i == "string")
        return Ui(i);
      switch (i) {
        case ve:
          return Ui("Suspense");
        case $e:
          return Ui("SuspenseList");
      }
      if (typeof i == "object")
        switch (i.$$typeof) {
          case _n:
            return Qu(i.render);
          case qe:
            return Tl(i.type, o, p);
          case ze: {
            var S = i, T = S._payload, P = S._init;
            try {
              return Tl(P(T), o, p);
            } catch {
            }
          }
        }
      return "";
    }
    function Kr(i) {
      switch (i._debugOwner && i._debugOwner.type, i._debugSource, i.tag) {
        case C:
          return Ui(i.type);
        case te:
          return Ui("Lazy");
        case j:
          return Ui("Suspense");
        case oe:
          return Ui("SuspenseList");
        case v:
        case _:
        case Z:
          return Qu(i.type);
        case k:
          return Qu(i.type.render);
        case y:
          return Mf(i.type);
        default:
          return "";
      }
    }
    function Ml(i) {
      try {
        var o = "", p = i;
        do
          o += Kr(p), p = p.return;
        while (p);
        return o;
      } catch (S) {
        return `
Error generating stack: ` + S.message + `
` + S.stack;
      }
    }
    function Zu(i, o, p) {
      var S = i.displayName;
      if (S)
        return S;
      var T = o.displayName || o.name || "";
      return T !== "" ? p + "(" + T + ")" : p;
    }
    function ls(i) {
      return i.displayName || "Context";
    }
    function jr(i) {
      if (i == null)
        return null;
      if (typeof i.tag == "number" && u("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof i == "function")
        return i.displayName || i.name || null;
      if (typeof i == "string")
        return i;
      switch (i) {
        case _o:
          return "Fragment";
        case ea:
          return "Portal";
        case Le:
          return "Profiler";
        case Eo:
          return "StrictMode";
        case ve:
          return "Suspense";
        case $e:
          return "SuspenseList";
      }
      if (typeof i == "object")
        switch (i.$$typeof) {
          case en:
            var o = i;
            return ls(o) + ".Consumer";
          case Bt:
            var p = i;
            return ls(p._context) + ".Provider";
          case _n:
            return Zu(i, i.render, "ForwardRef");
          case qe:
            var S = i.displayName || null;
            return S !== null ? S : jr(i.type) || "Memo";
          case ze: {
            var T = i, P = T._payload, H = T._init;
            try {
              return jr(H(P));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function lo(i, o, p) {
      var S = o.displayName || o.name || "";
      return i.displayName || (S !== "" ? p + "(" + S + ")" : p);
    }
    function wf(i) {
      return i.displayName || "Context";
    }
    function lr(i) {
      var o = i.tag, p = i.type;
      switch (o) {
        case Re:
          return "Cache";
        case O:
          var S = p;
          return wf(S) + ".Consumer";
        case I:
          var T = p;
          return wf(T._context) + ".Provider";
        case q:
          return "DehydratedFragment";
        case k:
          return lo(p, p.render, "ForwardRef");
        case U:
          return "Fragment";
        case C:
          return p;
        case M:
          return "Portal";
        case b:
          return "Root";
        case D:
          return "Text";
        case te:
          return jr(p);
        case N:
          return p === Eo ? "StrictMode" : "Mode";
        case de:
          return "Offscreen";
        case G:
          return "Profiler";
        case ye:
          return "Scope";
        case j:
          return "Suspense";
        case oe:
          return "SuspenseList";
        case Pe:
          return "TracingMarker";
        case y:
        case v:
        case J:
        case _:
        case Y:
        case Z:
          if (typeof p == "function")
            return p.displayName || p.name || null;
          if (typeof p == "string")
            return p;
          break;
      }
      return null;
    }
    var pd = t.ReactDebugCurrentFrame, pa = null, br = !1;
    function us() {
      {
        if (pa === null)
          return null;
        var i = pa._debugOwner;
        if (i !== null && typeof i < "u")
          return lr(i);
      }
      return null;
    }
    function Ls() {
      return pa === null ? "" : Ml(pa);
    }
    function Ca() {
      pd.getCurrentStack = null, pa = null, br = !1;
    }
    function zi(i) {
      pd.getCurrentStack = i === null ? null : Ls, pa = i, br = !1;
    }
    function dm() {
      return pa;
    }
    function si(i) {
      br = i;
    }
    function uo(i) {
      return "" + i;
    }
    function Ju(i) {
      switch (typeof i) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return i;
        case "object":
          return se(i), i;
        default:
          return "";
      }
    }
    var ch = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Nc(i, o) {
      ch[o.type] || o.onChange || o.onInput || o.readOnly || o.disabled || o.value == null || u("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), o.onChange || o.readOnly || o.disabled || o.checked == null || u("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Eu(i) {
      var o = i.type, p = i.nodeName;
      return p && p.toLowerCase() === "input" && (o === "checkbox" || o === "radio");
    }
    function wl(i) {
      return i._valueTracker;
    }
    function Jl(i) {
      i._valueTracker = null;
    }
    function Cf(i) {
      var o = "";
      return i && (Eu(i) ? o = i.checked ? "true" : "false" : o = i.value), o;
    }
    function Wo(i) {
      var o = Eu(i) ? "checked" : "value", p = Object.getOwnPropertyDescriptor(i.constructor.prototype, o);
      se(i[o]);
      var S = "" + i[o];
      if (!(i.hasOwnProperty(o) || typeof p > "u" || typeof p.get != "function" || typeof p.set != "function")) {
        var T = p.get, P = p.set;
        Object.defineProperty(i, o, {
          configurable: !0,
          get: function() {
            return T.call(this);
          },
          set: function($) {
            se($), S = "" + $, P.call(this, $);
          }
        }), Object.defineProperty(i, o, {
          enumerable: p.enumerable
        });
        var H = {
          getValue: function() {
            return S;
          },
          setValue: function($) {
            se($), S = "" + $;
          },
          stopTracking: function() {
            Jl(i), delete i[o];
          }
        };
        return H;
      }
    }
    function co(i) {
      wl(i) || (i._valueTracker = Wo(i));
    }
    function Uc(i) {
      if (!i)
        return !1;
      var o = wl(i);
      if (!o)
        return !0;
      var p = o.getValue(), S = Cf(i);
      return S !== p ? (o.setValue(S), !0) : !1;
    }
    function ec(i) {
      if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u")
        return null;
      try {
        return i.activeElement || i.body;
      } catch {
        return i.body;
      }
    }
    var tc = !1, md = !1, Os = !1, op = !1;
    function nl(i) {
      var o = i.type === "checkbox" || i.type === "radio";
      return o ? i.checked != null : i.value != null;
    }
    function ne(i, o) {
      var p = i, S = o.checked, T = kn({}, o, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: S ?? p._wrapperState.initialChecked
      });
      return T;
    }
    function De(i, o) {
      Nc("input", o), o.checked !== void 0 && o.defaultChecked !== void 0 && !md && (u("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", us() || "A component", o.type), md = !0), o.value !== void 0 && o.defaultValue !== void 0 && !tc && (u("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", us() || "A component", o.type), tc = !0);
      var p = i, S = o.defaultValue == null ? "" : o.defaultValue;
      p._wrapperState = {
        initialChecked: o.checked != null ? o.checked : o.defaultChecked,
        initialValue: Ju(o.value != null ? o.value : S),
        controlled: nl(o)
      };
    }
    function st(i, o) {
      var p = i, S = o.checked;
      S != null && Ji(p, "checked", S, !1);
    }
    function yt(i, o) {
      var p = i;
      {
        var S = nl(o);
        !p._wrapperState.controlled && S && !op && (u("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), op = !0), p._wrapperState.controlled && !S && !Os && (u("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Os = !0);
      }
      st(i, o);
      var T = Ju(o.value), P = o.type;
      if (T != null)
        P === "number" ? (T === 0 && p.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        p.value != T) && (p.value = uo(T)) : p.value !== uo(T) && (p.value = uo(T));
      else if (P === "submit" || P === "reset") {
        p.removeAttribute("value");
        return;
      }
      o.hasOwnProperty("value") ? qn(p, o.type, T) : o.hasOwnProperty("defaultValue") && qn(p, o.type, Ju(o.defaultValue)), o.checked == null && o.defaultChecked != null && (p.defaultChecked = !!o.defaultChecked);
    }
    function Zt(i, o, p) {
      var S = i;
      if (o.hasOwnProperty("value") || o.hasOwnProperty("defaultValue")) {
        var T = o.type, P = T === "submit" || T === "reset";
        if (P && (o.value === void 0 || o.value === null))
          return;
        var H = uo(S._wrapperState.initialValue);
        p || H !== S.value && (S.value = H), S.defaultValue = H;
      }
      var $ = S.name;
      $ !== "" && (S.name = ""), S.defaultChecked = !S.defaultChecked, S.defaultChecked = !!S._wrapperState.initialChecked, $ !== "" && (S.name = $);
    }
    function Xn(i, o) {
      var p = i;
      yt(p, o), mn(p, o);
    }
    function mn(i, o) {
      var p = o.name;
      if (o.type === "radio" && p != null) {
        for (var S = i; S.parentNode; )
          S = S.parentNode;
        Kt(p, "name");
        for (var T = S.querySelectorAll("input[name=" + JSON.stringify("" + p) + '][type="radio"]'), P = 0; P < T.length; P++) {
          var H = T[P];
          if (!(H === i || H.form !== i.form)) {
            var $ = Zf(H);
            if (!$)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Uc(H), yt(H, $);
          }
        }
      }
    }
    function qn(i, o, p) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (o !== "number" || ec(i.ownerDocument) !== i) && (p == null ? i.defaultValue = uo(i._wrapperState.initialValue) : i.defaultValue !== uo(p) && (i.defaultValue = uo(p)));
    }
    var Nr = !1, ri = !1, Ti = !1;
    function Br(i, o) {
      o.value == null && (typeof o.children == "object" && o.children !== null ? n.Children.forEach(o.children, function(p) {
        p != null && (typeof p == "string" || typeof p == "number" || ri || (ri = !0, u("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : o.dangerouslySetInnerHTML != null && (Ti || (Ti = !0, u("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), o.selected != null && !Nr && (u("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Nr = !0);
    }
    function Qr(i, o) {
      o.value != null && i.setAttribute("value", uo(Ju(o.value)));
    }
    var li = Array.isArray;
    function $r(i) {
      return li(i);
    }
    var Cl;
    Cl = !1;
    function rl() {
      var i = us();
      return i ? `

Check the render method of \`` + i + "`." : "";
    }
    var eu = ["value", "defaultValue"];
    function fh(i) {
      {
        Nc("select", i);
        for (var o = 0; o < eu.length; o++) {
          var p = eu[o];
          if (i[p] != null) {
            var S = $r(i[p]);
            i.multiple && !S ? u("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", p, rl()) : !i.multiple && S && u("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", p, rl());
          }
        }
      }
    }
    function tu(i, o, p, S) {
      var T = i.options;
      if (o) {
        for (var P = p, H = {}, $ = 0; $ < P.length; $++)
          H["$" + P[$]] = !0;
        for (var ee = 0; ee < T.length; ee++) {
          var pe = H.hasOwnProperty("$" + T[ee].value);
          T[ee].selected !== pe && (T[ee].selected = pe), pe && S && (T[ee].defaultSelected = !0);
        }
      } else {
        for (var _e = uo(Ju(p)), Ge = null, He = 0; He < T.length; He++) {
          if (T[He].value === _e) {
            T[He].selected = !0, S && (T[He].defaultSelected = !0);
            return;
          }
          Ge === null && !T[He].disabled && (Ge = T[He]);
        }
        Ge !== null && (Ge.selected = !0);
      }
    }
    function Rf(i, o) {
      return kn({}, o, {
        value: void 0
      });
    }
    function dh(i, o) {
      var p = i;
      fh(o), p._wrapperState = {
        wasMultiple: !!o.multiple
      }, o.value !== void 0 && o.defaultValue !== void 0 && !Cl && (u("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Cl = !0);
    }
    function hm(i, o) {
      var p = i;
      p.multiple = !!o.multiple;
      var S = o.value;
      S != null ? tu(p, !!o.multiple, S, !1) : o.defaultValue != null && tu(p, !!o.multiple, o.defaultValue, !0);
    }
    function pm(i, o) {
      var p = i, S = p._wrapperState.wasMultiple;
      p._wrapperState.wasMultiple = !!o.multiple;
      var T = o.value;
      T != null ? tu(p, !!o.multiple, T, !1) : S !== !!o.multiple && (o.defaultValue != null ? tu(p, !!o.multiple, o.defaultValue, !0) : tu(p, !!o.multiple, o.multiple ? [] : "", !1));
    }
    function mm(i, o) {
      var p = i, S = o.value;
      S != null && tu(p, !!o.multiple, S, !1);
    }
    var vm = !1;
    function gm(i, o) {
      var p = i;
      if (o.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var S = kn({}, o, {
        value: void 0,
        defaultValue: void 0,
        children: uo(p._wrapperState.initialValue)
      });
      return S;
    }
    function Cv(i, o) {
      var p = i;
      Nc("textarea", o), o.value !== void 0 && o.defaultValue !== void 0 && !vm && (u("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", us() || "A component"), vm = !0);
      var S = o.value;
      if (S == null) {
        var T = o.children, P = o.defaultValue;
        if (T != null) {
          u("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (P != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if ($r(T)) {
              if (T.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              T = T[0];
            }
            P = T;
          }
        }
        P == null && (P = ""), S = P;
      }
      p._wrapperState = {
        initialValue: Ju(S)
      };
    }
    function ym(i, o) {
      var p = i, S = Ju(o.value), T = Ju(o.defaultValue);
      if (S != null) {
        var P = uo(S);
        P !== p.value && (p.value = P), o.defaultValue == null && p.defaultValue !== P && (p.defaultValue = P);
      }
      T != null && (p.defaultValue = uo(T));
    }
    function vd(i, o) {
      var p = i, S = p.textContent;
      S === p._wrapperState.initialValue && S !== "" && S !== null && (p.value = S);
    }
    function Af(i, o) {
      ym(i, o);
    }
    var nu = "http://www.w3.org/1999/xhtml", Sm = "http://www.w3.org/1998/Math/MathML", il = "http://www.w3.org/2000/svg";
    function Ps(i) {
      switch (i) {
        case "svg":
          return il;
        case "math":
          return Sm;
        default:
          return nu;
      }
    }
    function zc(i, o) {
      return i == null || i === nu ? Ps(o) : i === il && o === "foreignObject" ? nu : i;
    }
    var kc = function(i) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(o, p, S, T) {
        MSApp.execUnsafeLocalFunction(function() {
          return i(o, p, S, T);
        });
      } : i;
    }, ru, Df = kc(function(i, o) {
      if (i.namespaceURI === il && !("innerHTML" in i)) {
        ru = ru || document.createElement("div"), ru.innerHTML = "<svg>" + o.valueOf().toString() + "</svg>";
        for (var p = ru.firstChild; i.firstChild; )
          i.removeChild(i.firstChild);
        for (; p.firstChild; )
          i.appendChild(p.firstChild);
        return;
      }
      i.innerHTML = o;
    }), Ns = 1, bu = 3, ka = 8, Ra = 9, Aa = 11, Yi = function(i, o) {
      if (o) {
        var p = i.firstChild;
        if (p && p === i.lastChild && p.nodeType === bu) {
          p.nodeValue = o;
          return;
        }
      }
      i.textContent = o;
    }, gd = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, jo = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function xm(i, o) {
      return i + o.charAt(0).toUpperCase() + o.substring(1);
    }
    var _m = ["Webkit", "ms", "Moz", "O"];
    Object.keys(jo).forEach(function(i) {
      _m.forEach(function(o) {
        jo[xm(o, i)] = jo[i];
      });
    });
    function yd(i, o, p) {
      var S = o == null || typeof o == "boolean" || o === "";
      return S ? "" : !p && typeof o == "number" && o !== 0 && !(jo.hasOwnProperty(i) && jo[i]) ? o + "px" : (Rn(o, i), ("" + o).trim());
    }
    var Ic = /([A-Z])/g, Rv = /^ms-/;
    function sp(i) {
      return i.replace(Ic, "-$1").toLowerCase().replace(Rv, "-ms-");
    }
    var Sd = function() {
    };
    {
      var hh = /^(?:webkit|moz|o)[A-Z]/, Lf = /^-ms-/, Us = /-(.)/g, Fc = /;\s*$/, nc = {}, Tu = {}, lp = !1, xd = !1, cs = function(i) {
        return i.replace(Us, function(o, p) {
          return p.toUpperCase();
        });
      }, _d = function(i) {
        nc.hasOwnProperty(i) && nc[i] || (nc[i] = !0, u(
          "Unsupported style property %s. Did you mean %s?",
          i,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          cs(i.replace(Lf, "ms-"))
        ));
      }, Bc = function(i) {
        nc.hasOwnProperty(i) && nc[i] || (nc[i] = !0, u("Unsupported vendor-prefixed style property %s. Did you mean %s?", i, i.charAt(0).toUpperCase() + i.slice(1)));
      }, iu = function(i, o) {
        Tu.hasOwnProperty(o) && Tu[o] || (Tu[o] = !0, u(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, i, o.replace(Fc, "")));
      }, up = function(i, o) {
        lp || (lp = !0, u("`NaN` is an invalid value for the `%s` css style property.", i));
      }, Ed = function(i, o) {
        xd || (xd = !0, u("`Infinity` is an invalid value for the `%s` css style property.", i));
      };
      Sd = function(i, o) {
        i.indexOf("-") > -1 ? _d(i) : hh.test(i) ? Bc(i) : Fc.test(o) && iu(i, o), typeof o == "number" && (isNaN(o) ? up(i, o) : isFinite(o) || Ed(i, o));
      };
    }
    var cp = Sd;
    function Rl(i) {
      {
        var o = "", p = "";
        for (var S in i)
          if (i.hasOwnProperty(S)) {
            var T = i[S];
            if (T != null) {
              var P = S.indexOf("--") === 0;
              o += p + (P ? S : sp(S)) + ":", o += yd(S, T, P), p = ";";
            }
          }
        return o || null;
      }
    }
    function la(i, o) {
      var p = i.style;
      for (var S in o)
        if (o.hasOwnProperty(S)) {
          var T = S.indexOf("--") === 0;
          T || cp(S, o[S]);
          var P = yd(S, o[S], T);
          S === "float" && (S = "cssFloat"), T ? p.setProperty(S, P) : p[S] = P;
        }
    }
    function bd(i) {
      return i == null || typeof i == "boolean" || i === "";
    }
    function Ia(i) {
      var o = {};
      for (var p in i)
        for (var S = gd[p] || [p], T = 0; T < S.length; T++)
          o[S[T]] = p;
      return o;
    }
    function al(i, o) {
      {
        if (!o)
          return;
        var p = Ia(i), S = Ia(o), T = {};
        for (var P in p) {
          var H = p[P], $ = S[P];
          if ($ && H !== $) {
            var ee = H + "," + $;
            if (T[ee])
              continue;
            T[ee] = !0, u("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", bd(i[H]) ? "Removing" : "Updating", H, $);
          }
        }
      }
    }
    var fo = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, Gi = kn({
      menuitem: !0
    }, fo), Hc = "__html";
    function Zr(i, o) {
      if (o) {
        if (Gi[i] && (o.children != null || o.dangerouslySetInnerHTML != null))
          throw new Error(i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (o.dangerouslySetInnerHTML != null) {
          if (o.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof o.dangerouslySetInnerHTML != "object" || !(Hc in o.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!o.suppressContentEditableWarning && o.contentEditable && o.children != null && u("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), o.style != null && typeof o.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function Mi(i, o) {
      if (i.indexOf("-") === -1)
        return typeof o.is == "string";
      switch (i) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ki = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Td = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, ho = {}, Of = new RegExp("^(aria)-[" + Xe + "]*$"), rc = new RegExp("^(aria)[A-Z][" + Xe + "]*$");
    function eo(i, o) {
      {
        if (et.call(ho, o) && ho[o])
          return !0;
        if (rc.test(o)) {
          var p = "aria-" + o.slice(4).toLowerCase(), S = Td.hasOwnProperty(p) ? p : null;
          if (S == null)
            return u("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", o), ho[o] = !0, !0;
          if (o !== S)
            return u("Invalid ARIA attribute `%s`. Did you mean `%s`?", o, S), ho[o] = !0, !0;
        }
        if (Of.test(o)) {
          var T = o.toLowerCase(), P = Td.hasOwnProperty(T) ? T : null;
          if (P == null)
            return ho[o] = !0, !1;
          if (o !== P)
            return u("Unknown ARIA attribute `%s`. Did you mean `%s`?", o, P), ho[o] = !0, !0;
        }
      }
      return !0;
    }
    function Al(i, o) {
      {
        var p = [];
        for (var S in o) {
          var T = eo(i, S);
          T || p.push(S);
        }
        var P = p.map(function(H) {
          return "`" + H + "`";
        }).join(", ");
        p.length === 1 ? u("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", P, i) : p.length > 1 && u("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", P, i);
      }
    }
    function Vc(i, o) {
      Mi(i, o) || Al(i, o);
    }
    var Mu = !1;
    function au(i, o) {
      {
        if (i !== "input" && i !== "textarea" && i !== "select")
          return;
        o != null && o.value === null && !Mu && (Mu = !0, i === "select" && o.multiple ? u("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", i) : u("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", i));
      }
    }
    var Dl = function() {
    };
    {
      var na = {}, Md = /^on./, fp = /^on[^A-Z]/, Pf = new RegExp("^(aria)-[" + Xe + "]*$"), Em = new RegExp("^(aria)[A-Z][" + Xe + "]*$");
      Dl = function(i, o, p, S) {
        if (et.call(na, o) && na[o])
          return !0;
        var T = o.toLowerCase();
        if (T === "onfocusin" || T === "onfocusout")
          return u("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), na[o] = !0, !0;
        if (S != null) {
          var P = S.registrationNameDependencies, H = S.possibleRegistrationNames;
          if (P.hasOwnProperty(o))
            return !0;
          var $ = H.hasOwnProperty(T) ? H[T] : null;
          if ($ != null)
            return u("Invalid event handler property `%s`. Did you mean `%s`?", o, $), na[o] = !0, !0;
          if (Md.test(o))
            return u("Unknown event handler property `%s`. It will be ignored.", o), na[o] = !0, !0;
        } else if (Md.test(o))
          return fp.test(o) && u("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", o), na[o] = !0, !0;
        if (Pf.test(o) || Em.test(o))
          return !0;
        if (T === "innerhtml")
          return u("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), na[o] = !0, !0;
        if (T === "aria")
          return u("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), na[o] = !0, !0;
        if (T === "is" && p !== null && p !== void 0 && typeof p != "string")
          return u("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof p), na[o] = !0, !0;
        if (typeof p == "number" && isNaN(p))
          return u("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", o), na[o] = !0, !0;
        var ee = zt(o), pe = ee !== null && ee.type === ae;
        if (ki.hasOwnProperty(T)) {
          var _e = ki[T];
          if (_e !== o)
            return u("Invalid DOM property `%s`. Did you mean `%s`?", o, _e), na[o] = !0, !0;
        } else if (!pe && o !== T)
          return u("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", o, T), na[o] = !0, !0;
        return typeof p == "boolean" && Tt(o, p, ee, !1) ? (p ? u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', p, o, o, p, o) : u('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', p, o, o, p, o, o, o), na[o] = !0, !0) : pe ? !0 : Tt(o, p, ee, !1) ? (na[o] = !0, !1) : ((p === "false" || p === "true") && ee !== null && ee.type === _t && (u("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", p, o, p === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', o, p), na[o] = !0), !0);
      };
    }
    var mr = function(i, o, p) {
      {
        var S = [];
        for (var T in o) {
          var P = Dl(i, T, o[T], p);
          P || S.push(T);
        }
        var H = S.map(function($) {
          return "`" + $ + "`";
        }).join(", ");
        S.length === 1 ? u("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", H, i) : S.length > 1 && u("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", H, i);
      }
    };
    function Ii(i, o, p) {
      Mi(i, o) || mr(i, o, p);
    }
    var Ur = 1, ma = 2, No = 4, ph = Ur | ma | No, mh = null;
    function Nf(i) {
      mh !== null && u("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), mh = i;
    }
    function bm() {
      mh === null && u("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), mh = null;
    }
    function vh(i) {
      return i === mh;
    }
    function Gt(i) {
      var o = i.target || i.srcElement || window;
      return o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === bu ? o.parentNode : o;
    }
    var Tr = null, wr = null, zs = null;
    function ol(i) {
      var o = Ym(i);
      if (o) {
        if (typeof Tr != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var p = o.stateNode;
        if (p) {
          var S = Zf(p);
          Tr(o.stateNode, o.type, S);
        }
      }
    }
    function ic(i) {
      Tr = i;
    }
    function Ll(i) {
      wr ? zs ? zs.push(i) : zs = [i] : wr = i;
    }
    function ac() {
      return wr !== null || zs !== null;
    }
    function oc() {
      if (wr) {
        var i = wr, o = zs;
        if (wr = null, zs = null, ol(i), o)
          for (var p = 0; p < o.length; p++)
            ol(o[p]);
      }
    }
    var ou = function(i, o) {
      return i(o);
    }, dp = function() {
    }, hp = !1;
    function Tm() {
      var i = ac();
      i && (dp(), oc());
    }
    function gh(i, o, p) {
      if (hp)
        return i(o, p);
      hp = !0;
      try {
        return ou(i, o, p);
      } finally {
        hp = !1, Tm();
      }
    }
    function wd(i, o, p) {
      ou = i, dp = p;
    }
    function Cd(i) {
      return i === "button" || i === "input" || i === "select" || i === "textarea";
    }
    function Uf(i, o, p) {
      switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(p.disabled && Cd(o));
        default:
          return !1;
      }
    }
    function Gc(i, o) {
      var p = i.stateNode;
      if (p === null)
        return null;
      var S = Zf(p);
      if (S === null)
        return null;
      var T = S[o];
      if (Uf(o, i.type, S))
        return null;
      if (T && typeof T != "function")
        throw new Error("Expected `" + o + "` listener to be a function, instead got a value of `" + typeof T + "` type.");
      return T;
    }
    var Rd = !1;
    if (nt)
      try {
        var Wc = {};
        Object.defineProperty(Wc, "passive", {
          get: function() {
            Rd = !0;
          }
        }), window.addEventListener("test", Wc, Wc), window.removeEventListener("test", Wc, Wc);
      } catch {
        Rd = !1;
      }
    function yh(i, o, p, S, T, P, H, $, ee) {
      var pe = Array.prototype.slice.call(arguments, 3);
      try {
        o.apply(p, pe);
      } catch (_e) {
        this.onError(_e);
      }
    }
    var Ad = yh;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var pp = document.createElement("react");
      Ad = function(o, p, S, T, P, H, $, ee, pe) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var _e = document.createEvent("Event"), Ge = !1, He = !0, ht = window.event, mt = Object.getOwnPropertyDescriptor(window, "event");
        function Lt() {
          pp.removeEventListener(Ot, ur, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = ht);
        }
        var Ln = Array.prototype.slice.call(arguments, 3);
        function ur() {
          Ge = !0, Lt(), p.apply(S, Ln), He = !1;
        }
        var tr, Pi = !1, bi = !1;
        function rt(it) {
          if (tr = it.error, Pi = !0, tr === null && it.colno === 0 && it.lineno === 0 && (bi = !0), it.defaultPrevented && tr != null && typeof tr == "object")
            try {
              tr._suppressLogging = !0;
            } catch {
            }
        }
        var Ot = "react-" + (o || "invokeguardedcallback");
        if (window.addEventListener("error", rt), pp.addEventListener(Ot, ur, !1), _e.initEvent(Ot, !1, !1), pp.dispatchEvent(_e), mt && Object.defineProperty(window, "event", mt), Ge && He && (Pi ? bi && (tr = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : tr = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(tr)), window.removeEventListener("error", rt), !Ge)
          return Lt(), yh.apply(this, arguments);
      };
    }
    var Mm = Ad, wu = !1, ks = null, Cu = !1, Ru = null, to = {
      onError: function(i) {
        wu = !0, ks = i;
      }
    };
    function sc(i, o, p, S, T, P, H, $, ee) {
      wu = !1, ks = null, Mm.apply(to, arguments);
    }
    function Is(i, o, p, S, T, P, H, $, ee) {
      if (sc.apply(this, arguments), wu) {
        var pe = Dd();
        Cu || (Cu = !0, Ru = pe);
      }
    }
    function zf() {
      if (Cu) {
        var i = Ru;
        throw Cu = !1, Ru = null, i;
      }
    }
    function kf() {
      return wu;
    }
    function Dd() {
      if (wu) {
        var i = ks;
        return wu = !1, ks = null, i;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function $o(i) {
      return i._reactInternals;
    }
    function Fs(i) {
      return i._reactInternals !== void 0;
    }
    function xi(i, o) {
      i._reactInternals = o;
    }
    var Kn = (
      /*                      */
      0
    ), _i = (
      /*                */
      1
    ), Hr = (
      /*                    */
      2
    ), Hn = (
      /*                       */
      4
    ), ii = (
      /*                */
      16
    ), di = (
      /*                 */
      32
    ), Au = (
      /*                     */
      64
    ), dr = (
      /*                   */
      128
    ), Da = (
      /*            */
      256
    ), fs = (
      /*                          */
      512
    ), Bs = (
      /*                     */
      1024
    ), ua = (
      /*                      */
      2048
    ), Hs = (
      /*                    */
      4096
    ), lc = (
      /*                   */
      8192
    ), If = (
      /*             */
      16384
    ), uc = ua | Hn | Au | fs | Bs | If, Av = (
      /*               */
      32767
    ), ds = (
      /*                   */
      32768
    ), bo = (
      /*                */
      65536
    ), Sh = (
      /* */
      131072
    ), su = (
      /*                       */
      1048576
    ), Ff = (
      /*                    */
      2097152
    ), Fa = (
      /*                 */
      4194304
    ), Du = (
      /*                */
      8388608
    ), hi = (
      /*               */
      16777216
    ), lu = (
      /*              */
      33554432
    ), Sr = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Hn | Bs | 0
    ), po = Hr | Hn | ii | di | fs | Hs | lc, La = Hn | Au | fs | lc, Lu = ua | ii, rn = Fa | Du | Ff, sl = t.ReactCurrentOwner;
    function To(i) {
      var o = i, p = i;
      if (i.alternate)
        for (; o.return; )
          o = o.return;
      else {
        var S = o;
        do
          o = S, (o.flags & (Hr | Hs)) !== Kn && (p = o.return), S = o.return;
        while (S);
      }
      return o.tag === b ? p : null;
    }
    function wm(i) {
      if (i.tag === j) {
        var o = i.memoizedState;
        if (o === null) {
          var p = i.alternate;
          p !== null && (o = p.memoizedState);
        }
        if (o !== null)
          return o.dehydrated;
      }
      return null;
    }
    function mp(i) {
      return i.tag === b ? i.stateNode.containerInfo : null;
    }
    function jc(i) {
      return To(i) === i;
    }
    function Mo(i) {
      {
        var o = sl.current;
        if (o !== null && o.tag === y) {
          var p = o, S = p.stateNode;
          S._warnedAboutRefsInRender || u("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", lr(p) || "A component"), S._warnedAboutRefsInRender = !0;
        }
      }
      var T = $o(i);
      return T ? To(T) === T : !1;
    }
    function hs(i) {
      if (To(i) !== i)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function ra(i) {
      var o = i.alternate;
      if (!o) {
        var p = To(i);
        if (p === null)
          throw new Error("Unable to find node on an unmounted component.");
        return p !== i ? null : i;
      }
      for (var S = i, T = o; ; ) {
        var P = S.return;
        if (P === null)
          break;
        var H = P.alternate;
        if (H === null) {
          var $ = P.return;
          if ($ !== null) {
            S = T = $;
            continue;
          }
          break;
        }
        if (P.child === H.child) {
          for (var ee = P.child; ee; ) {
            if (ee === S)
              return hs(P), i;
            if (ee === T)
              return hs(P), o;
            ee = ee.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (S.return !== T.return)
          S = P, T = H;
        else {
          for (var pe = !1, _e = P.child; _e; ) {
            if (_e === S) {
              pe = !0, S = P, T = H;
              break;
            }
            if (_e === T) {
              pe = !0, T = P, S = H;
              break;
            }
            _e = _e.sibling;
          }
          if (!pe) {
            for (_e = H.child; _e; ) {
              if (_e === S) {
                pe = !0, S = H, T = P;
                break;
              }
              if (_e === T) {
                pe = !0, T = H, S = P;
                break;
              }
              _e = _e.sibling;
            }
            if (!pe)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (S.alternate !== T)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (S.tag !== b)
        throw new Error("Unable to find node on an unmounted component.");
      return S.stateNode.current === S ? i : o;
    }
    function ll(i) {
      var o = ra(i);
      return o !== null ? Ol(o) : null;
    }
    function Ol(i) {
      if (i.tag === C || i.tag === D)
        return i;
      for (var o = i.child; o !== null; ) {
        var p = Ol(o);
        if (p !== null)
          return p;
        o = o.sibling;
      }
      return null;
    }
    function Ld(i) {
      var o = ra(i);
      return o !== null ? $c(o) : null;
    }
    function $c(i) {
      if (i.tag === C || i.tag === D)
        return i;
      for (var o = i.child; o !== null; ) {
        if (o.tag !== M) {
          var p = $c(o);
          if (p !== null)
            return p;
        }
        o = o.sibling;
      }
      return null;
    }
    var Od = e.unstable_scheduleCallback, Bf = e.unstable_cancelCallback, ps = e.unstable_shouldYield, mo = e.unstable_requestPaint, va = e.unstable_now, xh = e.unstable_getCurrentPriorityLevel, Cm = e.unstable_ImmediatePriority, ul = e.unstable_UserBlockingPriority, uu = e.unstable_NormalPriority, _h = e.unstable_LowPriority, Yc = e.unstable_IdlePriority, Rm = e.unstable_yieldValue, Eh = e.unstable_setDisableYieldValue, Xi = null, ya = null, dn = null, Wi = !1, Ba = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function vp(i) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var o = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (o.isDisabled)
        return !0;
      if (!o.supportsFiber)
        return u("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Ze && (i = kn({}, i, {
          getLaneLabelMap: cc,
          injectProfilingHooks: Ha
        })), Xi = o.inject(i), ya = o;
      } catch (p) {
        u("React instrumentation encountered an error: %s.", p);
      }
      return !!o.checkDCE;
    }
    function Am(i, o) {
      if (ya && typeof ya.onScheduleFiberRoot == "function")
        try {
          ya.onScheduleFiberRoot(Xi, i, o);
        } catch (p) {
          Wi || (Wi = !0, u("React instrumentation encountered an error: %s", p));
        }
    }
    function ms(i, o) {
      if (ya && typeof ya.onCommitFiberRoot == "function")
        try {
          var p = (i.current.flags & dr) === dr;
          if (je) {
            var S;
            switch (o) {
              case gs:
                S = Cm;
                break;
              case qo:
                S = ul;
                break;
              case af:
                S = uu;
                break;
              case yp:
                S = Yc;
                break;
              default:
                S = uu;
                break;
            }
            ya.onCommitFiberRoot(Xi, i, S, p);
          }
        } catch (T) {
          Wi || (Wi = !0, u("React instrumentation encountered an error: %s", T));
        }
    }
    function Sa(i) {
      if (ya && typeof ya.onPostCommitFiberRoot == "function")
        try {
          ya.onPostCommitFiberRoot(Xi, i);
        } catch (o) {
          Wi || (Wi = !0, u("React instrumentation encountered an error: %s", o));
        }
    }
    function gn(i) {
      if (ya && typeof ya.onCommitFiberUnmount == "function")
        try {
          ya.onCommitFiberUnmount(Xi, i);
        } catch (o) {
          Wi || (Wi = !0, u("React instrumentation encountered an error: %s", o));
        }
    }
    function qi(i) {
      if (typeof Rm == "function" && (Eh(i), a(i)), ya && typeof ya.setStrictMode == "function")
        try {
          ya.setStrictMode(Xi, i);
        } catch (o) {
          Wi || (Wi = !0, u("React instrumentation encountered an error: %s", o));
        }
    }
    function Ha(i) {
      dn = i;
    }
    function cc() {
      {
        for (var i = /* @__PURE__ */ new Map(), o = 1, p = 0; p < ci; p++) {
          var S = Yg(o);
          i.set(o, S), o *= 2;
        }
        return i;
      }
    }
    function xa(i) {
      dn !== null && typeof dn.markCommitStarted == "function" && dn.markCommitStarted(i);
    }
    function zr() {
      dn !== null && typeof dn.markCommitStopped == "function" && dn.markCommitStopped();
    }
    function ia(i) {
      dn !== null && typeof dn.markComponentRenderStarted == "function" && dn.markComponentRenderStarted(i);
    }
    function ca() {
      dn !== null && typeof dn.markComponentRenderStopped == "function" && dn.markComponentRenderStopped();
    }
    function ui(i) {
      dn !== null && typeof dn.markComponentPassiveEffectMountStarted == "function" && dn.markComponentPassiveEffectMountStarted(i);
    }
    function Vs() {
      dn !== null && typeof dn.markComponentPassiveEffectMountStopped == "function" && dn.markComponentPassiveEffectMountStopped();
    }
    function Xc(i) {
      dn !== null && typeof dn.markComponentPassiveEffectUnmountStarted == "function" && dn.markComponentPassiveEffectUnmountStarted(i);
    }
    function vo() {
      dn !== null && typeof dn.markComponentPassiveEffectUnmountStopped == "function" && dn.markComponentPassiveEffectUnmountStopped();
    }
    function Pd(i) {
      dn !== null && typeof dn.markComponentLayoutEffectMountStarted == "function" && dn.markComponentLayoutEffectMountStarted(i);
    }
    function Ou() {
      dn !== null && typeof dn.markComponentLayoutEffectMountStopped == "function" && dn.markComponentLayoutEffectMountStopped();
    }
    function cu(i) {
      dn !== null && typeof dn.markComponentLayoutEffectUnmountStarted == "function" && dn.markComponentLayoutEffectUnmountStarted(i);
    }
    function Hf() {
      dn !== null && typeof dn.markComponentLayoutEffectUnmountStopped == "function" && dn.markComponentLayoutEffectUnmountStopped();
    }
    function Vf(i, o, p) {
      dn !== null && typeof dn.markComponentErrored == "function" && dn.markComponentErrored(i, o, p);
    }
    function Gs(i, o, p) {
      dn !== null && typeof dn.markComponentSuspended == "function" && dn.markComponentSuspended(i, o, p);
    }
    function Dm(i) {
      dn !== null && typeof dn.markLayoutEffectsStarted == "function" && dn.markLayoutEffectsStarted(i);
    }
    function Gf() {
      dn !== null && typeof dn.markLayoutEffectsStopped == "function" && dn.markLayoutEffectsStopped();
    }
    function Nd(i) {
      dn !== null && typeof dn.markPassiveEffectsStarted == "function" && dn.markPassiveEffectsStarted(i);
    }
    function qc() {
      dn !== null && typeof dn.markPassiveEffectsStopped == "function" && dn.markPassiveEffectsStopped();
    }
    function cl(i) {
      dn !== null && typeof dn.markRenderStarted == "function" && dn.markRenderStarted(i);
    }
    function fu() {
      dn !== null && typeof dn.markRenderYielded == "function" && dn.markRenderYielded();
    }
    function Kc() {
      dn !== null && typeof dn.markRenderStopped == "function" && dn.markRenderStopped();
    }
    function fl(i) {
      dn !== null && typeof dn.markRenderScheduled == "function" && dn.markRenderScheduled(i);
    }
    function bh(i, o) {
      dn !== null && typeof dn.markForceUpdateScheduled == "function" && dn.markForceUpdateScheduled(i, o);
    }
    function du(i, o) {
      dn !== null && typeof dn.markStateUpdateScheduled == "function" && dn.markStateUpdateScheduled(i, o);
    }
    var Qn = (
      /*                         */
      0
    ), Rr = (
      /*                 */
      1
    ), Zn = (
      /*                    */
      2
    ), Yr = (
      /*               */
      8
    ), wo = (
      /*              */
      16
    ), Ws = Math.clz32 ? Math.clz32 : Co, Qc = Math.log, vs = Math.LN2;
    function Co(i) {
      var o = i >>> 0;
      return o === 0 ? 32 : 31 - (Qc(o) / vs | 0) | 0;
    }
    var ci = 31, Ct = (
      /*                        */
      0
    ), Jr = (
      /*                          */
      0
    ), Wn = (
      /*                        */
      1
    ), Pu = (
      /*    */
      2
    ), js = (
      /*             */
      4
    ), Uo = (
      /*            */
      8
    ), wi = (
      /*                     */
      16
    ), Wf = (
      /*                */
      32
    ), Zc = (
      /*                       */
      4194240
    ), Jc = (
      /*                        */
      64
    ), zo = (
      /*                        */
      128
    ), dl = (
      /*                        */
      256
    ), jf = (
      /*                        */
      512
    ), Ud = (
      /*                        */
      1024
    ), Yo = (
      /*                        */
      2048
    ), hl = (
      /*                        */
      4096
    ), Lm = (
      /*                        */
      8192
    ), fc = (
      /*                        */
      16384
    ), go = (
      /*                       */
      32768
    ), pi = (
      /*                       */
      65536
    ), Pl = (
      /*                       */
      131072
    ), $s = (
      /*                       */
      262144
    ), Om = (
      /*                       */
      524288
    ), Nl = (
      /*                       */
      1048576
    ), ef = (
      /*                       */
      2097152
    ), hu = (
      /*                            */
      130023424
    ), Ul = (
      /*                             */
      4194304
    ), Ro = (
      /*                             */
      8388608
    ), Nu = (
      /*                             */
      16777216
    ), $f = (
      /*                             */
      33554432
    ), Xo = (
      /*                             */
      67108864
    ), tf = Ul, zl = (
      /*          */
      134217728
    ), Yf = (
      /*                          */
      268435455
    ), nf = (
      /*               */
      268435456
    ), pu = (
      /*                        */
      536870912
    ), pl = (
      /*                   */
      1073741824
    );
    function Yg(i) {
      {
        if (i & Wn)
          return "Sync";
        if (i & Pu)
          return "InputContinuousHydration";
        if (i & js)
          return "InputContinuous";
        if (i & Uo)
          return "DefaultHydration";
        if (i & wi)
          return "Default";
        if (i & Wf)
          return "TransitionHydration";
        if (i & Zc)
          return "Transition";
        if (i & hu)
          return "Retry";
        if (i & zl)
          return "SelectiveHydration";
        if (i & nf)
          return "IdleHydration";
        if (i & pu)
          return "Idle";
        if (i & pl)
          return "Offscreen";
      }
    }
    var Xr = -1, Xf = Jc, rf = Ul;
    function Uu(i) {
      switch (yn(i)) {
        case Wn:
          return Wn;
        case Pu:
          return Pu;
        case js:
          return js;
        case Uo:
          return Uo;
        case wi:
          return wi;
        case Wf:
          return Wf;
        case Jc:
        case zo:
        case dl:
        case jf:
        case Ud:
        case Yo:
        case hl:
        case Lm:
        case fc:
        case go:
        case pi:
        case Pl:
        case $s:
        case Om:
        case Nl:
        case ef:
          return i & Zc;
        case Ul:
        case Ro:
        case Nu:
        case $f:
        case Xo:
          return i & hu;
        case zl:
          return zl;
        case nf:
          return nf;
        case pu:
          return pu;
        case pl:
          return pl;
        default:
          return u("Should have found matching lanes. This is a bug in React."), i;
      }
    }
    function dc(i, o) {
      var p = i.pendingLanes;
      if (p === Ct)
        return Ct;
      var S = Ct, T = i.suspendedLanes, P = i.pingedLanes, H = p & Yf;
      if (H !== Ct) {
        var $ = H & ~T;
        if ($ !== Ct)
          S = Uu($);
        else {
          var ee = H & P;
          ee !== Ct && (S = Uu(ee));
        }
      } else {
        var pe = p & ~T;
        pe !== Ct ? S = Uu(pe) : P !== Ct && (S = Uu(P));
      }
      if (S === Ct)
        return Ct;
      if (o !== Ct && o !== S && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (o & T) === Ct) {
        var _e = yn(S), Ge = yn(o);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          _e >= Ge || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          _e === wi && (Ge & Zc) !== Ct
        )
          return o;
      }
      (S & js) !== Ct && (S |= p & wi);
      var He = i.entangledLanes;
      if (He !== Ct)
        for (var ht = i.entanglements, mt = S & He; mt > 0; ) {
          var Lt = Va(mt), Ln = 1 << Lt;
          S |= ht[Lt], mt &= ~Ln;
        }
      return S;
    }
    function Pm(i, o) {
      for (var p = i.eventTimes, S = Xr; o > 0; ) {
        var T = Va(o), P = 1 << T, H = p[T];
        H > S && (S = H), o &= ~P;
      }
      return S;
    }
    function m(i, o) {
      switch (i) {
        case Wn:
        case Pu:
        case js:
          return o + 250;
        case Uo:
        case wi:
        case Wf:
        case Jc:
        case zo:
        case dl:
        case jf:
        case Ud:
        case Yo:
        case hl:
        case Lm:
        case fc:
        case go:
        case pi:
        case Pl:
        case $s:
        case Om:
        case Nl:
        case ef:
          return o + 5e3;
        case Ul:
        case Ro:
        case Nu:
        case $f:
        case Xo:
          return Xr;
        case zl:
        case nf:
        case pu:
        case pl:
          return Xr;
        default:
          return u("Should have found matching lanes. This is a bug in React."), Xr;
      }
    }
    function g(i, o) {
      for (var p = i.pendingLanes, S = i.suspendedLanes, T = i.pingedLanes, P = i.expirationTimes, H = p; H > 0; ) {
        var $ = Va(H), ee = 1 << $, pe = P[$];
        pe === Xr ? ((ee & S) === Ct || (ee & T) !== Ct) && (P[$] = m(ee, o)) : pe <= o && (i.expiredLanes |= ee), H &= ~ee;
      }
    }
    function R(i) {
      return Uu(i.pendingLanes);
    }
    function z(i) {
      var o = i.pendingLanes & ~pl;
      return o !== Ct ? o : o & pl ? pl : Ct;
    }
    function V(i) {
      return (i & Wn) !== Ct;
    }
    function Q(i) {
      return (i & Yf) !== Ct;
    }
    function Me(i) {
      return (i & hu) === i;
    }
    function We(i) {
      var o = Wn | js | wi;
      return (i & o) === Ct;
    }
    function Mt(i) {
      return (i & Zc) === i;
    }
    function Qt(i, o) {
      var p = Pu | js | Uo | wi;
      return (o & p) !== Ct;
    }
    function cn(i, o) {
      return (o & i.expiredLanes) !== Ct;
    }
    function sr(i) {
      return (i & Zc) !== Ct;
    }
    function Jn() {
      var i = Xf;
      return Xf <<= 1, (Xf & Zc) === Ct && (Xf = Jc), i;
    }
    function aa() {
      var i = rf;
      return rf <<= 1, (rf & hu) === Ct && (rf = Ul), i;
    }
    function yn(i) {
      return i & -i;
    }
    function fi(i) {
      return yn(i);
    }
    function Va(i) {
      return 31 - Ws(i);
    }
    function ot(i) {
      return Va(i);
    }
    function Be(i, o) {
      return (i & o) !== Ct;
    }
    function vt(i, o) {
      return (i & o) === o;
    }
    function Pt(i, o) {
      return i | o;
    }
    function Dn(i, o) {
      return i & ~o;
    }
    function Ar(i, o) {
      return i & o;
    }
    function ar(i) {
      return i;
    }
    function Vr(i, o) {
      return i !== Jr && i < o ? i : o;
    }
    function _a(i) {
      for (var o = [], p = 0; p < ci; p++)
        o.push(i);
      return o;
    }
    function Gr(i, o, p) {
      i.pendingLanes |= o, o !== pu && (i.suspendedLanes = Ct, i.pingedLanes = Ct);
      var S = i.eventTimes, T = ot(o);
      S[T] = p;
    }
    function hc(i, o) {
      i.suspendedLanes |= o, i.pingedLanes &= ~o;
      for (var p = i.expirationTimes, S = o; S > 0; ) {
        var T = Va(S), P = 1 << T;
        p[T] = Xr, S &= ~P;
      }
    }
    function Th(i, o, p) {
      i.pingedLanes |= i.suspendedLanes & o;
    }
    function T0(i, o) {
      var p = i.pendingLanes & ~o;
      i.pendingLanes = o, i.suspendedLanes = Ct, i.pingedLanes = Ct, i.expiredLanes &= o, i.mutableReadLanes &= o, i.entangledLanes &= o;
      for (var S = i.entanglements, T = i.eventTimes, P = i.expirationTimes, H = p; H > 0; ) {
        var $ = Va(H), ee = 1 << $;
        S[$] = Ct, T[$] = Xr, P[$] = Xr, H &= ~ee;
      }
    }
    function gp(i, o) {
      for (var p = i.entangledLanes |= o, S = i.entanglements, T = p; T; ) {
        var P = Va(T), H = 1 << P;
        // Is this one of the newly entangled lanes?
        H & o | // Is this lane transitively entangled with the newly entangled lanes?
        S[P] & o && (S[P] |= o), T &= ~H;
      }
    }
    function Xg(i, o) {
      var p = yn(o), S;
      switch (p) {
        case js:
          S = Pu;
          break;
        case wi:
          S = Uo;
          break;
        case Jc:
        case zo:
        case dl:
        case jf:
        case Ud:
        case Yo:
        case hl:
        case Lm:
        case fc:
        case go:
        case pi:
        case Pl:
        case $s:
        case Om:
        case Nl:
        case ef:
        case Ul:
        case Ro:
        case Nu:
        case $f:
        case Xo:
          S = Wf;
          break;
        case pu:
          S = nf;
          break;
        default:
          S = Jr;
          break;
      }
      return (S & (i.suspendedLanes | o)) !== Jr ? Jr : S;
    }
    function qg(i, o, p) {
      if (Ba)
        for (var S = i.pendingUpdatersLaneMap; p > 0; ) {
          var T = ot(p), P = 1 << T, H = S[T];
          H.add(o), p &= ~P;
        }
    }
    function Nm(i, o) {
      if (Ba)
        for (var p = i.pendingUpdatersLaneMap, S = i.memoizedUpdaters; o > 0; ) {
          var T = ot(o), P = 1 << T, H = p[T];
          H.size > 0 && (H.forEach(function($) {
            var ee = $.alternate;
            (ee === null || !S.has(ee)) && S.add($);
          }), H.clear()), o &= ~P;
        }
    }
    function Kg(i, o) {
      return null;
    }
    var gs = Wn, qo = js, af = wi, yp = pu, zd = Jr;
    function zu() {
      return zd;
    }
    function yo(i) {
      zd = i;
    }
    function Sp(i, o) {
      var p = zd;
      try {
        return zd = i, o();
      } finally {
        zd = p;
      }
    }
    function ys(i, o) {
      return i !== 0 && i < o ? i : o;
    }
    function M0(i, o) {
      return i === 0 || i > o ? i : o;
    }
    function Qg(i, o) {
      return i !== 0 && i < o;
    }
    function xp(i) {
      var o = yn(i);
      return Qg(gs, o) ? Qg(qo, o) ? Q(o) ? af : yp : qo : gs;
    }
    function Ao(i) {
      var o = i.current.memoizedState;
      return o.isDehydrated;
    }
    var w0;
    function Pn(i) {
      w0 = i;
    }
    function _p(i) {
      w0(i);
    }
    var Um;
    function xx(i) {
      Um = i;
    }
    var C0;
    function Ep(i) {
      C0 = i;
    }
    var Dv;
    function R0(i) {
      Dv = i;
    }
    var Mh;
    function bp(i) {
      Mh = i;
    }
    var Tp = !1, kd = [], Do = null, Ei = null, Ga = null, ko = /* @__PURE__ */ new Map(), mu = /* @__PURE__ */ new Map(), Id = [], of = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function _x(i) {
      return of.indexOf(i) > -1;
    }
    function ml(i, o, p, S, T) {
      return {
        blockedOn: i,
        domEventName: o,
        eventSystemFlags: p,
        nativeEvent: T,
        targetContainers: [S]
      };
    }
    function A0(i, o) {
      switch (i) {
        case "focusin":
        case "focusout":
          Do = null;
          break;
        case "dragenter":
        case "dragleave":
          Ei = null;
          break;
        case "mouseover":
        case "mouseout":
          Ga = null;
          break;
        case "pointerover":
        case "pointerout": {
          var p = o.pointerId;
          ko.delete(p);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var S = o.pointerId;
          mu.delete(S);
          break;
        }
      }
    }
    function wh(i, o, p, S, T, P) {
      if (i === null || i.nativeEvent !== P) {
        var H = ml(o, p, S, T, P);
        if (o !== null) {
          var $ = Ym(o);
          $ !== null && Um($);
        }
        return H;
      }
      i.eventSystemFlags |= S;
      var ee = i.targetContainers;
      return T !== null && ee.indexOf(T) === -1 && ee.push(T), i;
    }
    function Lv(i, o, p, S, T) {
      switch (o) {
        case "focusin": {
          var P = T;
          return Do = wh(Do, i, o, p, S, P), !0;
        }
        case "dragenter": {
          var H = T;
          return Ei = wh(Ei, i, o, p, S, H), !0;
        }
        case "mouseover": {
          var $ = T;
          return Ga = wh(Ga, i, o, p, S, $), !0;
        }
        case "pointerover": {
          var ee = T, pe = ee.pointerId;
          return ko.set(pe, wh(ko.get(pe) || null, i, o, p, S, ee)), !0;
        }
        case "gotpointercapture": {
          var _e = T, Ge = _e.pointerId;
          return mu.set(Ge, wh(mu.get(Ge) || null, i, o, p, S, _e)), !0;
        }
      }
      return !1;
    }
    function D0(i) {
      var o = Jv(i.target);
      if (o !== null) {
        var p = To(o);
        if (p !== null) {
          var S = p.tag;
          if (S === j) {
            var T = wm(p);
            if (T !== null) {
              i.blockedOn = T, Mh(i.priority, function() {
                C0(p);
              });
              return;
            }
          } else if (S === b) {
            var P = p.stateNode;
            if (Ao(P)) {
              i.blockedOn = mp(p);
              return;
            }
          }
        }
      }
      i.blockedOn = null;
    }
    function Zg(i) {
      for (var o = Dv(), p = {
        blockedOn: null,
        target: i,
        priority: o
      }, S = 0; S < Id.length && Qg(o, Id[S].priority); S++)
        ;
      Id.splice(S, 0, p), S === 0 && D0(p);
    }
    function Jg(i) {
      if (i.blockedOn !== null)
        return !1;
      for (var o = i.targetContainers; o.length > 0; ) {
        var p = o[0], S = Rh(i.domEventName, i.eventSystemFlags, p, i.nativeEvent);
        if (S === null) {
          var T = i.nativeEvent, P = new T.constructor(T.type, T);
          Nf(P), T.target.dispatchEvent(P), bm();
        } else {
          var H = Ym(S);
          return H !== null && Um(H), i.blockedOn = S, !1;
        }
        o.shift();
      }
      return !0;
    }
    function Ov(i, o, p) {
      Jg(i) && p.delete(o);
    }
    function Fd() {
      Tp = !1, Do !== null && Jg(Do) && (Do = null), Ei !== null && Jg(Ei) && (Ei = null), Ga !== null && Jg(Ga) && (Ga = null), ko.forEach(Ov), mu.forEach(Ov);
    }
    function Fi(i, o) {
      i.blockedOn === o && (i.blockedOn = null, Tp || (Tp = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Fd)));
    }
    function xr(i) {
      if (kd.length > 0) {
        Fi(kd[0], i);
        for (var o = 1; o < kd.length; o++) {
          var p = kd[o];
          p.blockedOn === i && (p.blockedOn = null);
        }
      }
      Do !== null && Fi(Do, i), Ei !== null && Fi(Ei, i), Ga !== null && Fi(Ga, i);
      var S = function($) {
        return Fi($, i);
      };
      ko.forEach(S), mu.forEach(S);
      for (var T = 0; T < Id.length; T++) {
        var P = Id[T];
        P.blockedOn === i && (P.blockedOn = null);
      }
      for (; Id.length > 0; ) {
        var H = Id[0];
        if (H.blockedOn !== null)
          break;
        D0(H), H.blockedOn === null && Id.shift();
      }
    }
    var Li = t.ReactCurrentBatchConfig, fa = !0;
    function Oa(i) {
      fa = !!i;
    }
    function ku() {
      return fa;
    }
    function zm(i, o, p) {
      var S = vl(o), T;
      switch (S) {
        case gs:
          T = Ko;
          break;
        case qo:
          T = Pv;
          break;
        case af:
        default:
          T = qf;
          break;
      }
      return T.bind(null, o, p, i);
    }
    function Ko(i, o, p, S) {
      var T = zu(), P = Li.transition;
      Li.transition = null;
      try {
        yo(gs), qf(i, o, p, S);
      } finally {
        yo(T), Li.transition = P;
      }
    }
    function Pv(i, o, p, S) {
      var T = zu(), P = Li.transition;
      Li.transition = null;
      try {
        yo(qo), qf(i, o, p, S);
      } finally {
        yo(T), Li.transition = P;
      }
    }
    function qf(i, o, p, S) {
      fa && Nv(i, o, p, S);
    }
    function Nv(i, o, p, S) {
      var T = Rh(i, o, p, S);
      if (T === null) {
        _r(i, o, S, Ch, p), A0(i, S);
        return;
      }
      if (Lv(T, i, o, p, S)) {
        S.stopPropagation();
        return;
      }
      if (A0(i, S), o & No && _x(i)) {
        for (; T !== null; ) {
          var P = Ym(T);
          P !== null && _p(P);
          var H = Rh(i, o, p, S);
          if (H === null && _r(i, o, S, Ch, p), H === T)
            break;
          T = H;
        }
        T !== null && S.stopPropagation();
        return;
      }
      _r(i, o, S, null, p);
    }
    var Ch = null;
    function Rh(i, o, p, S) {
      Ch = null;
      var T = Gt(S), P = Jv(T);
      if (P !== null) {
        var H = To(P);
        if (H === null)
          P = null;
        else {
          var $ = H.tag;
          if ($ === j) {
            var ee = wm(H);
            if (ee !== null)
              return ee;
            P = null;
          } else if ($ === b) {
            var pe = H.stateNode;
            if (Ao(pe))
              return mp(H);
            P = null;
          } else
            H !== P && (P = null);
        }
      }
      return Ch = P, null;
    }
    function vl(i) {
      switch (i) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return gs;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return qo;
        case "message": {
          var o = xh();
          switch (o) {
            case Cm:
              return gs;
            case ul:
              return qo;
            case uu:
            case _h:
              return af;
            case Yc:
              return yp;
            default:
              return af;
          }
        }
        default:
          return af;
      }
    }
    function Uv(i, o, p) {
      return i.addEventListener(o, p, !1), p;
    }
    function Ah(i, o, p) {
      return i.addEventListener(o, p, !0), p;
    }
    function sf(i, o, p, S) {
      return i.addEventListener(o, p, {
        capture: !0,
        passive: S
      }), p;
    }
    function ey(i, o, p, S) {
      return i.addEventListener(o, p, {
        passive: S
      }), p;
    }
    var Mp = null, Kf = null, Dh = null;
    function Bd(i) {
      return Mp = i, Kf = zv(), !0;
    }
    function Lh() {
      Mp = null, Kf = null, Dh = null;
    }
    function km() {
      if (Dh)
        return Dh;
      var i, o = Kf, p = o.length, S, T = zv(), P = T.length;
      for (i = 0; i < p && o[i] === T[i]; i++)
        ;
      var H = p - i;
      for (S = 1; S <= H && o[p - S] === T[P - S]; S++)
        ;
      var $ = S > 1 ? 1 - S : void 0;
      return Dh = T.slice(i, $), Dh;
    }
    function zv() {
      return "value" in Mp ? Mp.value : Mp.textContent;
    }
    function pc(i) {
      var o, p = i.keyCode;
      return "charCode" in i ? (o = i.charCode, o === 0 && p === 13 && (o = 13)) : o = p, o === 10 && (o = 13), o >= 32 || o === 13 ? o : 0;
    }
    function Oh() {
      return !0;
    }
    function ji() {
      return !1;
    }
    function So(i) {
      function o(p, S, T, P, H) {
        this._reactName = p, this._targetInst = T, this.type = S, this.nativeEvent = P, this.target = H, this.currentTarget = null;
        for (var $ in i)
          if (i.hasOwnProperty($)) {
            var ee = i[$];
            ee ? this[$] = ee(P) : this[$] = P[$];
          }
        var pe = P.defaultPrevented != null ? P.defaultPrevented : P.returnValue === !1;
        return pe ? this.isDefaultPrevented = Oh : this.isDefaultPrevented = ji, this.isPropagationStopped = ji, this;
      }
      return kn(o.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var p = this.nativeEvent;
          p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = Oh);
        },
        stopPropagation: function() {
          var p = this.nativeEvent;
          p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = Oh);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: Oh
      }), o;
    }
    var Ss = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(i) {
        return i.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, xs = So(Ss), Ph = kn({}, Ss, {
      view: 0,
      detail: 0
    }), kv = So(Ph), wp, ty, gl;
    function Iv(i) {
      i !== gl && (gl && i.type === "mousemove" ? (wp = i.screenX - gl.screenX, ty = i.screenY - gl.screenY) : (wp = 0, ty = 0), gl = i);
    }
    var Hd = kn({}, Ph, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: iy,
      button: 0,
      buttons: 0,
      relatedTarget: function(i) {
        return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget;
      },
      movementX: function(i) {
        return "movementX" in i ? i.movementX : (Iv(i), wp);
      },
      movementY: function(i) {
        return "movementY" in i ? i.movementY : ty;
      }
    }), Vd = So(Hd), ny = kn({}, Hd, {
      dataTransfer: 0
    }), mc = So(ny), L0 = kn({}, Ph, {
      relatedTarget: 0
    }), ry = So(L0), O0 = kn({}, Ss, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Nh = So(O0), Uh = kn({}, Ss, {
      clipboardData: function(i) {
        return "clipboardData" in i ? i.clipboardData : window.clipboardData;
      }
    }), Fv = So(Uh), Bv = kn({}, Ss, {
      data: 0
    }), Im = So(Bv), Gd = Im, P0 = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, lf = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Fm(i) {
      if (i.key) {
        var o = P0[i.key] || i.key;
        if (o !== "Unidentified")
          return o;
      }
      if (i.type === "keypress") {
        var p = pc(i);
        return p === 13 ? "Enter" : String.fromCharCode(p);
      }
      return i.type === "keydown" || i.type === "keyup" ? lf[i.keyCode] || "Unidentified" : "";
    }
    var no = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function N0(i) {
      var o = this, p = o.nativeEvent;
      if (p.getModifierState)
        return p.getModifierState(i);
      var S = no[i];
      return S ? !!p[S] : !1;
    }
    function iy(i) {
      return N0;
    }
    var Ex = kn({}, Ph, {
      key: Fm,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: iy,
      // Legacy Interface
      charCode: function(i) {
        return i.type === "keypress" ? pc(i) : 0;
      },
      keyCode: function(i) {
        return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
      },
      which: function(i) {
        return i.type === "keypress" ? pc(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
      }
    }), bx = So(Ex), Bm = kn({}, Hd, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Iu = So(Bm), U0 = kn({}, Ph, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: iy
    }), Ys = So(U0), Hv = kn({}, Ss, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), ib = So(Hv), kl = kn({}, Hd, {
      deltaX: function(i) {
        return "deltaX" in i ? i.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in i ? -i.wheelDeltaX : 0
        );
      },
      deltaY: function(i) {
        return "deltaY" in i ? i.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in i ? -i.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in i ? -i.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Wd = So(kl), Cp = [9, 13, 27, 32], zh = 229, vu = nt && "CompositionEvent" in window, oa = null;
    nt && "documentMode" in document && (oa = document.documentMode);
    var kh = nt && "TextEvent" in window && !oa, Wa = nt && (!vu || oa && oa > 8 && oa <= 11), _s = 32, Vv = String.fromCharCode(_s);
    function ay() {
      Ht("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Ht("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Ht("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Ht("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Gv = !1;
    function En(i) {
      return (i.ctrlKey || i.altKey || i.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(i.ctrlKey && i.altKey);
    }
    function Il(i) {
      switch (i) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Wv(i, o) {
      return i === "keydown" && o.keyCode === zh;
    }
    function Rp(i, o) {
      switch (i) {
        case "keyup":
          return Cp.indexOf(o.keyCode) !== -1;
        case "keydown":
          return o.keyCode !== zh;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Ih(i) {
      var o = i.detail;
      return typeof o == "object" && "data" in o ? o.data : null;
    }
    function $i(i) {
      return i.locale === "ko";
    }
    var ja = !1;
    function Lo(i, o, p, S, T) {
      var P, H;
      if (vu ? P = Il(o) : ja ? Rp(o, S) && (P = "onCompositionEnd") : Wv(o, S) && (P = "onCompositionStart"), !P)
        return null;
      Wa && !$i(S) && (!ja && P === "onCompositionStart" ? ja = Bd(T) : P === "onCompositionEnd" && ja && (H = km()));
      var $ = qv(p, P);
      if ($.length > 0) {
        var ee = new Im(P, o, null, S, T);
        if (i.push({
          event: ee,
          listeners: $
        }), H)
          ee.data = H;
        else {
          var pe = Ih(S);
          pe !== null && (ee.data = pe);
        }
      }
    }
    function Ap(i, o) {
      switch (i) {
        case "compositionend":
          return Ih(o);
        case "keypress":
          var p = o.which;
          return p !== _s ? null : (Gv = !0, Vv);
        case "textInput":
          var S = o.data;
          return S === Vv && Gv ? null : S;
        default:
          return null;
      }
    }
    function Hm(i, o) {
      if (ja) {
        if (i === "compositionend" || !vu && Rp(i, o)) {
          var p = km();
          return Lh(), ja = !1, p;
        }
        return null;
      }
      switch (i) {
        case "paste":
          return null;
        case "keypress":
          if (!En(o)) {
            if (o.char && o.char.length > 1)
              return o.char;
            if (o.which)
              return String.fromCharCode(o.which);
          }
          return null;
        case "compositionend":
          return Wa && !$i(o) ? null : o.data;
        default:
          return null;
      }
    }
    function jv(i, o, p, S, T) {
      var P;
      if (kh ? P = Ap(o, S) : P = Hm(o, S), !P)
        return null;
      var H = qv(p, "onBeforeInput");
      if (H.length > 0) {
        var $ = new Gd("onBeforeInput", "beforeinput", null, S, T);
        i.push({
          event: $,
          listeners: H
        }), $.data = P;
      }
    }
    function oy(i, o, p, S, T, P, H) {
      Lo(i, o, p, S, T), jv(i, o, p, S, T);
    }
    var ab = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function At(i) {
      var o = i && i.nodeName && i.nodeName.toLowerCase();
      return o === "input" ? !!ab[i.type] : o === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function vc(i) {
      if (!nt)
        return !1;
      var o = "on" + i, p = o in document;
      if (!p) {
        var S = document.createElement("div");
        S.setAttribute(o, "return;"), p = typeof S[o] == "function";
      }
      return p;
    }
    function uf() {
      Ht("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function c(i, o, p, S) {
      Ll(S);
      var T = qv(o, "onChange");
      if (T.length > 0) {
        var P = new xs("onChange", "change", null, p, S);
        i.push({
          event: P,
          listeners: T
        });
      }
    }
    var d = null, x = null;
    function A(i) {
      var o = i.nodeName && i.nodeName.toLowerCase();
      return o === "select" || o === "input" && i.type === "file";
    }
    function F(i) {
      var o = [];
      c(o, x, i, Gt(i)), gh(W, o);
    }
    function W(i) {
      hb(i, 0);
    }
    function ie(i) {
      var o = qs(i);
      if (Uc(o))
        return i;
    }
    function Ae(i, o) {
      if (i === "change")
        return o;
    }
    var Ie = !1;
    nt && (Ie = vc("input") && (!document.documentMode || document.documentMode > 9));
    function pt(i, o) {
      d = i, x = o, d.attachEvent("onpropertychange", jt);
    }
    function Yt() {
      d && (d.detachEvent("onpropertychange", jt), d = null, x = null);
    }
    function jt(i) {
      i.propertyName === "value" && ie(x) && F(i);
    }
    function Ft(i, o, p) {
      i === "focusin" ? (Yt(), pt(o, p)) : i === "focusout" && Yt();
    }
    function Mn(i, o) {
      if (i === "selectionchange" || i === "keyup" || i === "keydown")
        return ie(x);
    }
    function Nn(i) {
      var o = i.nodeName;
      return o && o.toLowerCase() === "input" && (i.type === "checkbox" || i.type === "radio");
    }
    function Fn(i, o) {
      if (i === "click")
        return ie(o);
    }
    function ro(i, o) {
      if (i === "input" || i === "change")
        return ie(o);
    }
    function Qe(i) {
      var o = i._wrapperState;
      !o || !o.controlled || i.type !== "number" || qn(i, "number", i.value);
    }
    function Ve(i, o, p, S, T, P, H) {
      var $ = p ? qs(p) : window, ee, pe;
      if (A($) ? ee = Ae : At($) ? Ie ? ee = ro : (ee = Mn, pe = Ft) : Nn($) && (ee = Fn), ee) {
        var _e = ee(o, p);
        if (_e) {
          c(i, _e, S, T);
          return;
        }
      }
      pe && pe(o, $, p), o === "focusout" && Qe($);
    }
    function lt() {
      he("onMouseEnter", ["mouseout", "mouseover"]), he("onMouseLeave", ["mouseout", "mouseover"]), he("onPointerEnter", ["pointerout", "pointerover"]), he("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function on(i, o, p, S, T, P, H) {
      var $ = o === "mouseover" || o === "pointerover", ee = o === "mouseout" || o === "pointerout";
      if ($ && !vh(S)) {
        var pe = S.relatedTarget || S.fromElement;
        if (pe && (Jv(pe) || eS(pe)))
          return;
      }
      if (!(!ee && !$)) {
        var _e;
        if (T.window === T)
          _e = T;
        else {
          var Ge = T.ownerDocument;
          Ge ? _e = Ge.defaultView || Ge.parentWindow : _e = window;
        }
        var He, ht;
        if (ee) {
          var mt = S.relatedTarget || S.toElement;
          if (He = p, ht = mt ? Jv(mt) : null, ht !== null) {
            var Lt = To(ht);
            (ht !== Lt || ht.tag !== C && ht.tag !== D) && (ht = null);
          }
        } else
          He = null, ht = p;
        if (He !== ht) {
          var Ln = Vd, ur = "onMouseLeave", tr = "onMouseEnter", Pi = "mouse";
          (o === "pointerout" || o === "pointerover") && (Ln = Iu, ur = "onPointerLeave", tr = "onPointerEnter", Pi = "pointer");
          var bi = He == null ? _e : qs(He), rt = ht == null ? _e : qs(ht), Ot = new Ln(ur, Pi + "leave", He, S, T);
          Ot.target = bi, Ot.relatedTarget = rt;
          var it = null, nn = Jv(T);
          if (nn === p) {
            var On = new Ln(tr, Pi + "enter", ht, S, T);
            On.target = rt, On.relatedTarget = bi, it = On;
          }
          Bx(i, Ot, it, He, ht);
        }
      }
    }
    function Bn(i, o) {
      return i === o && (i !== 0 || 1 / i === 1 / o) || i !== i && o !== o;
    }
    var In = typeof Object.is == "function" ? Object.is : Bn;
    function er(i, o) {
      if (In(i, o))
        return !0;
      if (typeof i != "object" || i === null || typeof o != "object" || o === null)
        return !1;
      var p = Object.keys(i), S = Object.keys(o);
      if (p.length !== S.length)
        return !1;
      for (var T = 0; T < p.length; T++) {
        var P = p[T];
        if (!et.call(o, P) || !In(i[P], o[P]))
          return !1;
      }
      return !0;
    }
    function gr(i) {
      for (; i && i.firstChild; )
        i = i.firstChild;
      return i;
    }
    function Qo(i) {
      for (; i; ) {
        if (i.nextSibling)
          return i.nextSibling;
        i = i.parentNode;
      }
    }
    function Ci(i, o) {
      for (var p = gr(i), S = 0, T = 0; p; ) {
        if (p.nodeType === bu) {
          if (T = S + p.textContent.length, S <= o && T >= o)
            return {
              node: p,
              offset: o - S
            };
          S = T;
        }
        p = gr(Qo(p));
      }
    }
    function gc(i) {
      var o = i.ownerDocument, p = o && o.defaultView || window, S = p.getSelection && p.getSelection();
      if (!S || S.rangeCount === 0)
        return null;
      var T = S.anchorNode, P = S.anchorOffset, H = S.focusNode, $ = S.focusOffset;
      try {
        T.nodeType, H.nodeType;
      } catch {
        return null;
      }
      return sy(i, T, P, H, $);
    }
    function sy(i, o, p, S, T) {
      var P = 0, H = -1, $ = -1, ee = 0, pe = 0, _e = i, Ge = null;
      e:
        for (; ; ) {
          for (var He = null; _e === o && (p === 0 || _e.nodeType === bu) && (H = P + p), _e === S && (T === 0 || _e.nodeType === bu) && ($ = P + T), _e.nodeType === bu && (P += _e.nodeValue.length), (He = _e.firstChild) !== null; )
            Ge = _e, _e = He;
          for (; ; ) {
            if (_e === i)
              break e;
            if (Ge === o && ++ee === p && (H = P), Ge === S && ++pe === T && ($ = P), (He = _e.nextSibling) !== null)
              break;
            _e = Ge, Ge = _e.parentNode;
          }
          _e = He;
        }
      return H === -1 || $ === -1 ? null : {
        start: H,
        end: $
      };
    }
    function Tx(i, o) {
      var p = i.ownerDocument || document, S = p && p.defaultView || window;
      if (S.getSelection) {
        var T = S.getSelection(), P = i.textContent.length, H = Math.min(o.start, P), $ = o.end === void 0 ? H : Math.min(o.end, P);
        if (!T.extend && H > $) {
          var ee = $;
          $ = H, H = ee;
        }
        var pe = Ci(i, H), _e = Ci(i, $);
        if (pe && _e) {
          if (T.rangeCount === 1 && T.anchorNode === pe.node && T.anchorOffset === pe.offset && T.focusNode === _e.node && T.focusOffset === _e.offset)
            return;
          var Ge = p.createRange();
          Ge.setStart(pe.node, pe.offset), T.removeAllRanges(), H > $ ? (T.addRange(Ge), T.extend(_e.node, _e.offset)) : (Ge.setEnd(_e.node, _e.offset), T.addRange(Ge));
        }
      }
    }
    function ly(i) {
      return i && i.nodeType === bu;
    }
    function Mx(i, o) {
      return !i || !o ? !1 : i === o ? !0 : ly(i) ? !1 : ly(o) ? Mx(i, o.parentNode) : "contains" in i ? i.contains(o) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(o) & 16) : !1;
    }
    function wx(i) {
      return i && i.ownerDocument && Mx(i.ownerDocument.documentElement, i);
    }
    function z0(i) {
      try {
        return typeof i.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function k0() {
      for (var i = window, o = ec(); o instanceof i.HTMLIFrameElement; ) {
        if (z0(o))
          i = o.contentWindow;
        else
          return o;
        o = ec(i.document);
      }
      return o;
    }
    function $v(i) {
      var o = i && i.nodeName && i.nodeName.toLowerCase();
      return o && (o === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || o === "textarea" || i.contentEditable === "true");
    }
    function Yv() {
      var i = k0();
      return {
        focusedElem: i,
        selectionRange: $v(i) ? Cx(i) : null
      };
    }
    function ob(i) {
      var o = k0(), p = i.focusedElem, S = i.selectionRange;
      if (o !== p && wx(p)) {
        S !== null && $v(p) && sb(p, S);
        for (var T = [], P = p; P = P.parentNode; )
          P.nodeType === Ns && T.push({
            element: P,
            left: P.scrollLeft,
            top: P.scrollTop
          });
        typeof p.focus == "function" && p.focus();
        for (var H = 0; H < T.length; H++) {
          var $ = T[H];
          $.element.scrollLeft = $.left, $.element.scrollTop = $.top;
        }
      }
    }
    function Cx(i) {
      var o;
      return "selectionStart" in i ? o = {
        start: i.selectionStart,
        end: i.selectionEnd
      } : o = gc(i), o || {
        start: 0,
        end: 0
      };
    }
    function sb(i, o) {
      var p = o.start, S = o.end;
      S === void 0 && (S = p), "selectionStart" in i ? (i.selectionStart = p, i.selectionEnd = Math.min(S, i.value.length)) : Tx(i, o);
    }
    var Rx = nt && "documentMode" in document && document.documentMode <= 11;
    function SM() {
      Ht("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Vm = null, uy = null, I0 = null, cy = !1;
    function lb(i) {
      if ("selectionStart" in i && $v(i))
        return {
          start: i.selectionStart,
          end: i.selectionEnd
        };
      var o = i.ownerDocument && i.ownerDocument.defaultView || window, p = o.getSelection();
      return {
        anchorNode: p.anchorNode,
        anchorOffset: p.anchorOffset,
        focusNode: p.focusNode,
        focusOffset: p.focusOffset
      };
    }
    function Ax(i) {
      return i.window === i ? i.document : i.nodeType === Ra ? i : i.ownerDocument;
    }
    function Dx(i, o, p) {
      var S = Ax(p);
      if (!(cy || Vm == null || Vm !== ec(S))) {
        var T = lb(Vm);
        if (!I0 || !er(I0, T)) {
          I0 = T;
          var P = qv(uy, "onSelect");
          if (P.length > 0) {
            var H = new xs("onSelect", "select", null, o, p);
            i.push({
              event: H,
              listeners: P
            }), H.target = Vm;
          }
        }
      }
    }
    function Lx(i, o, p, S, T, P, H) {
      var $ = p ? qs(p) : window;
      switch (o) {
        case "focusin":
          (At($) || $.contentEditable === "true") && (Vm = $, uy = p, I0 = null);
          break;
        case "focusout":
          Vm = null, uy = null, I0 = null;
          break;
        case "mousedown":
          cy = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          cy = !1, Dx(i, S, T);
          break;
        case "selectionchange":
          if (Rx)
            break;
        case "keydown":
        case "keyup":
          Dx(i, S, T);
      }
    }
    function fy(i, o) {
      var p = {};
      return p[i.toLowerCase()] = o.toLowerCase(), p["Webkit" + i] = "webkit" + o, p["Moz" + i] = "moz" + o, p;
    }
    var Xv = {
      animationend: fy("Animation", "AnimationEnd"),
      animationiteration: fy("Animation", "AnimationIteration"),
      animationstart: fy("Animation", "AnimationStart"),
      transitionend: fy("Transition", "TransitionEnd")
    }, Ox = {}, xM = {};
    nt && (xM = document.createElement("div").style, "AnimationEvent" in window || (delete Xv.animationend.animation, delete Xv.animationiteration.animation, delete Xv.animationstart.animation), "TransitionEvent" in window || delete Xv.transitionend.transition);
    function dy(i) {
      if (Ox[i])
        return Ox[i];
      if (!Xv[i])
        return i;
      var o = Xv[i];
      for (var p in o)
        if (o.hasOwnProperty(p) && p in xM)
          return Ox[i] = o[p];
      return i;
    }
    var ub = dy("animationend"), cb = dy("animationiteration"), fb = dy("animationstart"), _M = dy("transitionend"), Px = /* @__PURE__ */ new Map(), F0 = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Gm(i, o) {
      Px.set(i, o), Ht(o, [i]);
    }
    function lA() {
      for (var i = 0; i < F0.length; i++) {
        var o = F0[i], p = o.toLowerCase(), S = o[0].toUpperCase() + o.slice(1);
        Gm(p, "on" + S);
      }
      Gm(ub, "onAnimationEnd"), Gm(cb, "onAnimationIteration"), Gm(fb, "onAnimationStart"), Gm("dblclick", "onDoubleClick"), Gm("focusin", "onFocus"), Gm("focusout", "onBlur"), Gm(_M, "onTransitionEnd");
    }
    function EM(i, o, p, S, T, P, H) {
      var $ = Px.get(o);
      if ($ !== void 0) {
        var ee = xs, pe = o;
        switch (o) {
          case "keypress":
            if (pc(S) === 0)
              return;
          case "keydown":
          case "keyup":
            ee = bx;
            break;
          case "focusin":
            pe = "focus", ee = ry;
            break;
          case "focusout":
            pe = "blur", ee = ry;
            break;
          case "beforeblur":
          case "afterblur":
            ee = ry;
            break;
          case "click":
            if (S.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            ee = Vd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            ee = mc;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            ee = Ys;
            break;
          case ub:
          case cb:
          case fb:
            ee = Nh;
            break;
          case _M:
            ee = ib;
            break;
          case "scroll":
            ee = kv;
            break;
          case "wheel":
            ee = Wd;
            break;
          case "copy":
          case "cut":
          case "paste":
            ee = Fv;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            ee = Iu;
            break;
        }
        var _e = (P & No) !== 0;
        {
          var Ge = !_e && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          o === "scroll", He = MM(p, $, S.type, _e, Ge);
          if (He.length > 0) {
            var ht = new ee($, pe, null, S, T);
            i.push({
              event: ht,
              listeners: He
            });
          }
        }
      }
    }
    lA(), lt(), uf(), SM(), ay();
    function bM(i, o, p, S, T, P, H) {
      EM(i, o, p, S, T, P);
      var $ = (P & ph) === 0;
      $ && (on(i, o, p, S, T), Ve(i, o, p, S, T), Lx(i, o, p, S, T), oy(i, o, p, S, T));
    }
    var hy = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], Nx = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(hy));
    function db(i, o, p) {
      var S = i.type || "unknown-event";
      i.currentTarget = p, Is(S, o, void 0, i), i.currentTarget = null;
    }
    function Ux(i, o, p) {
      var S;
      if (p)
        for (var T = o.length - 1; T >= 0; T--) {
          var P = o[T], H = P.instance, $ = P.currentTarget, ee = P.listener;
          if (H !== S && i.isPropagationStopped())
            return;
          db(i, ee, $), S = H;
        }
      else
        for (var pe = 0; pe < o.length; pe++) {
          var _e = o[pe], Ge = _e.instance, He = _e.currentTarget, ht = _e.listener;
          if (Ge !== S && i.isPropagationStopped())
            return;
          db(i, ht, He), S = Ge;
        }
    }
    function hb(i, o) {
      for (var p = (o & No) !== 0, S = 0; S < i.length; S++) {
        var T = i[S], P = T.event, H = T.listeners;
        Ux(P, H, p);
      }
      zf();
    }
    function TM(i, o, p, S, T) {
      var P = Gt(p), H = [];
      bM(H, i, S, p, P, o), hb(H, o);
    }
    function $a(i, o) {
      Nx.has(i) || u('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', i);
      var p = !1, S = zA(o), T = wM(i, p);
      S.has(T) || (B0(o, i, ma, p), S.add(T));
    }
    function zx(i, o, p) {
      Nx.has(i) && !o && u('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', i);
      var S = 0;
      o && (S |= No), B0(p, i, S, o);
    }
    var cf = "_reactListening" + Math.random().toString(36).slice(2);
    function Fu(i) {
      if (!i[cf]) {
        i[cf] = !0, at.forEach(function(p) {
          p !== "selectionchange" && (Nx.has(p) || zx(p, !1, i), zx(p, !0, i));
        });
        var o = i.nodeType === Ra ? i : i.ownerDocument;
        o !== null && (o[cf] || (o[cf] = !0, zx("selectionchange", !1, o)));
      }
    }
    function B0(i, o, p, S, T) {
      var P = zm(i, o, p), H = void 0;
      Rd && (o === "touchstart" || o === "touchmove" || o === "wheel") && (H = !0), i = i, S ? H !== void 0 ? sf(i, o, P, H) : Ah(i, o, P) : H !== void 0 ? ey(i, o, P, H) : Uv(i, o, P);
    }
    function kx(i, o) {
      return i === o || i.nodeType === ka && i.parentNode === o;
    }
    function _r(i, o, p, S, T) {
      var P = S;
      if (!(o & Ur) && !(o & ma)) {
        var H = T;
        if (S !== null) {
          var $ = S;
          e:
            for (; ; ) {
              if ($ === null)
                return;
              var ee = $.tag;
              if (ee === b || ee === M) {
                var pe = $.stateNode.containerInfo;
                if (kx(pe, H))
                  break;
                if (ee === M)
                  for (var _e = $.return; _e !== null; ) {
                    var Ge = _e.tag;
                    if (Ge === b || Ge === M) {
                      var He = _e.stateNode.containerInfo;
                      if (kx(He, H))
                        return;
                    }
                    _e = _e.return;
                  }
                for (; pe !== null; ) {
                  var ht = Jv(pe);
                  if (ht === null)
                    return;
                  var mt = ht.tag;
                  if (mt === C || mt === D) {
                    $ = P = ht;
                    continue e;
                  }
                  pe = pe.parentNode;
                }
              }
              $ = $.return;
            }
        }
      }
      gh(function() {
        return TM(i, o, p, P);
      });
    }
    function Qf(i, o, p) {
      return {
        instance: i,
        listener: o,
        currentTarget: p
      };
    }
    function MM(i, o, p, S, T, P) {
      for (var H = o !== null ? o + "Capture" : null, $ = S ? H : o, ee = [], pe = i, _e = null; pe !== null; ) {
        var Ge = pe, He = Ge.stateNode, ht = Ge.tag;
        if (ht === C && He !== null && (_e = He, $ !== null)) {
          var mt = Gc(pe, $);
          mt != null && ee.push(Qf(pe, mt, _e));
        }
        if (T)
          break;
        pe = pe.return;
      }
      return ee;
    }
    function qv(i, o) {
      for (var p = o + "Capture", S = [], T = i; T !== null; ) {
        var P = T, H = P.stateNode, $ = P.tag;
        if ($ === C && H !== null) {
          var ee = H, pe = Gc(T, p);
          pe != null && S.unshift(Qf(T, pe, ee));
          var _e = Gc(T, o);
          _e != null && S.push(Qf(T, _e, ee));
        }
        T = T.return;
      }
      return S;
    }
    function Fh(i) {
      if (i === null)
        return null;
      do
        i = i.return;
      while (i && i.tag !== C);
      return i || null;
    }
    function Ix(i, o) {
      for (var p = i, S = o, T = 0, P = p; P; P = Fh(P))
        T++;
      for (var H = 0, $ = S; $; $ = Fh($))
        H++;
      for (; T - H > 0; )
        p = Fh(p), T--;
      for (; H - T > 0; )
        S = Fh(S), H--;
      for (var ee = T; ee--; ) {
        if (p === S || S !== null && p === S.alternate)
          return p;
        p = Fh(p), S = Fh(S);
      }
      return null;
    }
    function Fx(i, o, p, S, T) {
      for (var P = o._reactName, H = [], $ = p; $ !== null && $ !== S; ) {
        var ee = $, pe = ee.alternate, _e = ee.stateNode, Ge = ee.tag;
        if (pe !== null && pe === S)
          break;
        if (Ge === C && _e !== null) {
          var He = _e;
          if (T) {
            var ht = Gc($, P);
            ht != null && H.unshift(Qf($, ht, He));
          } else if (!T) {
            var mt = Gc($, P);
            mt != null && H.push(Qf($, mt, He));
          }
        }
        $ = $.return;
      }
      H.length !== 0 && i.push({
        event: o,
        listeners: H
      });
    }
    function Bx(i, o, p, S, T) {
      var P = S && T ? Ix(S, T) : null;
      S !== null && Fx(i, o, S, P, !1), T !== null && p !== null && Fx(i, p, T, P, !0);
    }
    function wM(i, o) {
      return i + "__" + (o ? "capture" : "bubble");
    }
    var yc = !1, H0 = "dangerouslySetInnerHTML", Hx = "suppressContentEditableWarning", Dp = "suppressHydrationWarning", pb = "autoFocus", Lp = "children", Wm = "style", Kv = "__html", Sc, py, gu, Vx, my, V0, CM;
    Sc = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, py = function(i, o) {
      Vc(i, o), au(i, o), Ii(i, o, {
        registrationNameDependencies: xt,
        possibleRegistrationNames: $t
      });
    }, V0 = nt && !document.documentMode, gu = function(i, o, p) {
      if (!yc) {
        var S = G0(p), T = G0(o);
        T !== S && (yc = !0, u("Prop `%s` did not match. Server: %s Client: %s", i, JSON.stringify(T), JSON.stringify(S)));
      }
    }, Vx = function(i) {
      if (!yc) {
        yc = !0;
        var o = [];
        i.forEach(function(p) {
          o.push(p);
        }), u("Extra attributes from the server: %s", o);
      }
    }, my = function(i, o) {
      o === !1 ? u("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", i, i, i) : u("Expected `%s` listener to be a function, instead got a value of `%s` type.", i, typeof o);
    }, CM = function(i, o) {
      var p = i.namespaceURI === nu ? i.ownerDocument.createElement(i.tagName) : i.ownerDocument.createElementNS(i.namespaceURI, i.tagName);
      return p.innerHTML = o, p.innerHTML;
    };
    var mb = /\r\n?/g, uA = /\u0000|\uFFFD/g;
    function G0(i) {
      Yn(i);
      var o = typeof i == "string" ? i : "" + i;
      return o.replace(mb, `
`).replace(uA, "");
    }
    function vy(i, o, p, S) {
      var T = G0(o), P = G0(i);
      if (P !== T && (S && (yc || (yc = !0, u('Text content did not match. Server: "%s" Client: "%s"', P, T))), p && Te))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function vb(i) {
      return i.nodeType === Ra ? i : i.ownerDocument;
    }
    function cA() {
    }
    function Gx(i) {
      i.onclick = cA;
    }
    function RM(i, o, p, S, T) {
      for (var P in S)
        if (S.hasOwnProperty(P)) {
          var H = S[P];
          if (P === Wm)
            H && Object.freeze(H), la(o, H);
          else if (P === H0) {
            var $ = H ? H[Kv] : void 0;
            $ != null && Df(o, $);
          } else if (P === Lp)
            if (typeof H == "string") {
              var ee = i !== "textarea" || H !== "";
              ee && Yi(o, H);
            } else
              typeof H == "number" && Yi(o, "" + H);
          else
            P === Hx || P === Dp || P === pb || (xt.hasOwnProperty(P) ? H != null && (typeof H != "function" && my(P, H), P === "onScroll" && $a("scroll", o)) : H != null && Ji(o, P, H, T));
        }
    }
    function AM(i, o, p, S) {
      for (var T = 0; T < o.length; T += 2) {
        var P = o[T], H = o[T + 1];
        P === Wm ? la(i, H) : P === H0 ? Df(i, H) : P === Lp ? Yi(i, H) : Ji(i, P, H, S);
      }
    }
    function fA(i, o, p, S) {
      var T, P = vb(p), H, $ = S;
      if ($ === nu && ($ = Ps(i)), $ === nu) {
        if (T = Mi(i, o), !T && i !== i.toLowerCase() && u("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", i), i === "script") {
          var ee = P.createElement("div");
          ee.innerHTML = "<script><\/script>";
          var pe = ee.firstChild;
          H = ee.removeChild(pe);
        } else if (typeof o.is == "string")
          H = P.createElement(i, {
            is: o.is
          });
        else if (H = P.createElement(i), i === "select") {
          var _e = H;
          o.multiple ? _e.multiple = !0 : o.size && (_e.size = o.size);
        }
      } else
        H = P.createElementNS($, i);
      return $ === nu && !T && Object.prototype.toString.call(H) === "[object HTMLUnknownElement]" && !et.call(Sc, i) && (Sc[i] = !0, u("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", i)), H;
    }
    function dA(i, o) {
      return vb(o).createTextNode(i);
    }
    function Bh(i, o, p, S) {
      var T = Mi(o, p);
      py(o, p);
      var P;
      switch (o) {
        case "dialog":
          $a("cancel", i), $a("close", i), P = p;
          break;
        case "iframe":
        case "object":
        case "embed":
          $a("load", i), P = p;
          break;
        case "video":
        case "audio":
          for (var H = 0; H < hy.length; H++)
            $a(hy[H], i);
          P = p;
          break;
        case "source":
          $a("error", i), P = p;
          break;
        case "img":
        case "image":
        case "link":
          $a("error", i), $a("load", i), P = p;
          break;
        case "details":
          $a("toggle", i), P = p;
          break;
        case "input":
          De(i, p), P = ne(i, p), $a("invalid", i);
          break;
        case "option":
          Br(i, p), P = p;
          break;
        case "select":
          dh(i, p), P = Rf(i, p), $a("invalid", i);
          break;
        case "textarea":
          Cv(i, p), P = gm(i, p), $a("invalid", i);
          break;
        default:
          P = p;
      }
      switch (Zr(o, P), RM(o, i, S, P, T), o) {
        case "input":
          co(i), Zt(i, p, !1);
          break;
        case "textarea":
          co(i), vd(i);
          break;
        case "option":
          Qr(i, p);
          break;
        case "select":
          hm(i, p);
          break;
        default:
          typeof P.onClick == "function" && Gx(i);
          break;
      }
    }
    function DM(i, o, p, S, T) {
      py(o, S);
      var P = null, H, $;
      switch (o) {
        case "input":
          H = ne(i, p), $ = ne(i, S), P = [];
          break;
        case "select":
          H = Rf(i, p), $ = Rf(i, S), P = [];
          break;
        case "textarea":
          H = gm(i, p), $ = gm(i, S), P = [];
          break;
        default:
          H = p, $ = S, typeof H.onClick != "function" && typeof $.onClick == "function" && Gx(i);
          break;
      }
      Zr(o, $);
      var ee, pe, _e = null;
      for (ee in H)
        if (!($.hasOwnProperty(ee) || !H.hasOwnProperty(ee) || H[ee] == null))
          if (ee === Wm) {
            var Ge = H[ee];
            for (pe in Ge)
              Ge.hasOwnProperty(pe) && (_e || (_e = {}), _e[pe] = "");
          } else
            ee === H0 || ee === Lp || ee === Hx || ee === Dp || ee === pb || (xt.hasOwnProperty(ee) ? P || (P = []) : (P = P || []).push(ee, null));
      for (ee in $) {
        var He = $[ee], ht = H != null ? H[ee] : void 0;
        if (!(!$.hasOwnProperty(ee) || He === ht || He == null && ht == null))
          if (ee === Wm)
            if (He && Object.freeze(He), ht) {
              for (pe in ht)
                ht.hasOwnProperty(pe) && (!He || !He.hasOwnProperty(pe)) && (_e || (_e = {}), _e[pe] = "");
              for (pe in He)
                He.hasOwnProperty(pe) && ht[pe] !== He[pe] && (_e || (_e = {}), _e[pe] = He[pe]);
            } else
              _e || (P || (P = []), P.push(ee, _e)), _e = He;
          else if (ee === H0) {
            var mt = He ? He[Kv] : void 0, Lt = ht ? ht[Kv] : void 0;
            mt != null && Lt !== mt && (P = P || []).push(ee, mt);
          } else
            ee === Lp ? (typeof He == "string" || typeof He == "number") && (P = P || []).push(ee, "" + He) : ee === Hx || ee === Dp || (xt.hasOwnProperty(ee) ? (He != null && (typeof He != "function" && my(ee, He), ee === "onScroll" && $a("scroll", i)), !P && ht !== He && (P = [])) : (P = P || []).push(ee, He));
      }
      return _e && (al(_e, $[Wm]), (P = P || []).push(Wm, _e)), P;
    }
    function LM(i, o, p, S, T) {
      p === "input" && T.type === "radio" && T.name != null && st(i, T);
      var P = Mi(p, S), H = Mi(p, T);
      switch (AM(i, o, P, H), p) {
        case "input":
          yt(i, T);
          break;
        case "textarea":
          ym(i, T);
          break;
        case "select":
          pm(i, T);
          break;
      }
    }
    function W0(i) {
      {
        var o = i.toLowerCase();
        return ki.hasOwnProperty(o) && ki[o] || null;
      }
    }
    function j0(i, o, p, S, T, P, H) {
      var $, ee;
      switch ($ = Mi(o, p), py(o, p), o) {
        case "dialog":
          $a("cancel", i), $a("close", i);
          break;
        case "iframe":
        case "object":
        case "embed":
          $a("load", i);
          break;
        case "video":
        case "audio":
          for (var pe = 0; pe < hy.length; pe++)
            $a(hy[pe], i);
          break;
        case "source":
          $a("error", i);
          break;
        case "img":
        case "image":
        case "link":
          $a("error", i), $a("load", i);
          break;
        case "details":
          $a("toggle", i);
          break;
        case "input":
          De(i, p), $a("invalid", i);
          break;
        case "option":
          Br(i, p);
          break;
        case "select":
          dh(i, p), $a("invalid", i);
          break;
        case "textarea":
          Cv(i, p), $a("invalid", i);
          break;
      }
      Zr(o, p);
      {
        ee = /* @__PURE__ */ new Set();
        for (var _e = i.attributes, Ge = 0; Ge < _e.length; Ge++) {
          var He = _e[Ge].name.toLowerCase();
          switch (He) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              ee.add(_e[Ge].name);
          }
        }
      }
      var ht = null;
      for (var mt in p)
        if (p.hasOwnProperty(mt)) {
          var Lt = p[mt];
          if (mt === Lp)
            typeof Lt == "string" ? i.textContent !== Lt && (p[Dp] !== !0 && vy(i.textContent, Lt, P, H), ht = [Lp, Lt]) : typeof Lt == "number" && i.textContent !== "" + Lt && (p[Dp] !== !0 && vy(i.textContent, Lt, P, H), ht = [Lp, "" + Lt]);
          else if (xt.hasOwnProperty(mt))
            Lt != null && (typeof Lt != "function" && my(mt, Lt), mt === "onScroll" && $a("scroll", i));
          else if (H && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof $ == "boolean") {
            var Ln = void 0, ur = $ && Ue ? null : zt(mt);
            if (p[Dp] !== !0) {
              if (!(mt === Hx || mt === Dp || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              mt === "value" || mt === "checked" || mt === "selected")) {
                if (mt === H0) {
                  var tr = i.innerHTML, Pi = Lt ? Lt[Kv] : void 0;
                  if (Pi != null) {
                    var bi = CM(i, Pi);
                    bi !== tr && gu(mt, tr, bi);
                  }
                } else if (mt === Wm) {
                  if (ee.delete(mt), V0) {
                    var rt = Rl(Lt);
                    Ln = i.getAttribute("style"), rt !== Ln && gu(mt, Ln, rt);
                  }
                } else if ($ && !Ue)
                  ee.delete(mt.toLowerCase()), Ln = Ma(i, mt, Lt), Lt !== Ln && gu(mt, Ln, Lt);
                else if (!bt(mt, ur, $) && !ge(mt, Lt, ur, $)) {
                  var Ot = !1;
                  if (ur !== null)
                    ee.delete(ur.attributeName), Ln = oi(i, mt, Lt, ur);
                  else {
                    var it = S;
                    if (it === nu && (it = Ps(o)), it === nu)
                      ee.delete(mt.toLowerCase());
                    else {
                      var nn = W0(mt);
                      nn !== null && nn !== mt && (Ot = !0, ee.delete(nn)), ee.delete(mt);
                    }
                    Ln = Ma(i, mt, Lt);
                  }
                  var On = Ue;
                  !On && Lt !== Ln && !Ot && gu(mt, Ln, Lt);
                }
              }
            }
          }
        }
      switch (H && // $FlowFixMe - Should be inferred as not undefined.
      ee.size > 0 && p[Dp] !== !0 && Vx(ee), o) {
        case "input":
          co(i), Zt(i, p, !0);
          break;
        case "textarea":
          co(i), vd(i);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof p.onClick == "function" && Gx(i);
          break;
      }
      return ht;
    }
    function Wx(i, o, p) {
      var S = i.nodeValue !== o;
      return S;
    }
    function gy(i, o) {
      {
        if (yc)
          return;
        yc = !0, u("Did not expect server HTML to contain a <%s> in <%s>.", o.nodeName.toLowerCase(), i.nodeName.toLowerCase());
      }
    }
    function jx(i, o) {
      {
        if (yc)
          return;
        yc = !0, u('Did not expect server HTML to contain the text node "%s" in <%s>.', o.nodeValue, i.nodeName.toLowerCase());
      }
    }
    function Qv(i, o, p) {
      {
        if (yc)
          return;
        yc = !0, u("Expected server HTML to contain a matching <%s> in <%s>.", o, i.nodeName.toLowerCase());
      }
    }
    function Xs(i, o) {
      {
        if (o === "" || yc)
          return;
        yc = !0, u('Expected server HTML to contain a matching text node for "%s" in <%s>.', o, i.nodeName.toLowerCase());
      }
    }
    function OM(i, o, p) {
      switch (o) {
        case "input":
          Xn(i, p);
          return;
        case "textarea":
          Af(i, p);
          return;
        case "select":
          mm(i, p);
          return;
      }
    }
    var Op = function() {
    }, Bu = function() {
    };
    {
      var gb = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], yy = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], yb = yy.concat(["button"]), Sb = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], $x = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Bu = function(i, o) {
        var p = kn({}, i || $x), S = {
          tag: o
        };
        return yy.indexOf(o) !== -1 && (p.aTagInScope = null, p.buttonTagInScope = null, p.nobrTagInScope = null), yb.indexOf(o) !== -1 && (p.pTagInButtonScope = null), gb.indexOf(o) !== -1 && o !== "address" && o !== "div" && o !== "p" && (p.listItemTagAutoclosing = null, p.dlItemTagAutoclosing = null), p.current = S, o === "form" && (p.formTag = S), o === "a" && (p.aTagInScope = S), o === "button" && (p.buttonTagInScope = S), o === "nobr" && (p.nobrTagInScope = S), o === "p" && (p.pTagInButtonScope = S), o === "li" && (p.listItemTagAutoclosing = S), (o === "dd" || o === "dt") && (p.dlItemTagAutoclosing = S), p;
      };
      var Zv = function(i, o) {
        switch (o) {
          case "select":
            return i === "option" || i === "optgroup" || i === "#text";
          case "optgroup":
            return i === "option" || i === "#text";
          case "option":
            return i === "#text";
          case "tr":
            return i === "th" || i === "td" || i === "style" || i === "script" || i === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return i === "tr" || i === "style" || i === "script" || i === "template";
          case "colgroup":
            return i === "col" || i === "template";
          case "table":
            return i === "caption" || i === "colgroup" || i === "tbody" || i === "tfoot" || i === "thead" || i === "style" || i === "script" || i === "template";
          case "head":
            return i === "base" || i === "basefont" || i === "bgsound" || i === "link" || i === "meta" || i === "title" || i === "noscript" || i === "noframes" || i === "style" || i === "script" || i === "template";
          case "html":
            return i === "head" || i === "body" || i === "frameset";
          case "frameset":
            return i === "frame";
          case "#document":
            return i === "html";
        }
        switch (i) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return o !== "h1" && o !== "h2" && o !== "h3" && o !== "h4" && o !== "h5" && o !== "h6";
          case "rp":
          case "rt":
            return Sb.indexOf(o) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return o == null;
        }
        return !0;
      }, xb = function(i, o) {
        switch (i) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return o.pTagInButtonScope;
          case "form":
            return o.formTag || o.pTagInButtonScope;
          case "li":
            return o.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return o.dlItemTagAutoclosing;
          case "button":
            return o.buttonTagInScope;
          case "a":
            return o.aTagInScope;
          case "nobr":
            return o.nobrTagInScope;
        }
        return null;
      }, $0 = {};
      Op = function(i, o, p) {
        p = p || $x;
        var S = p.current, T = S && S.tag;
        o != null && (i != null && u("validateDOMNesting: when childText is passed, childTag should be null"), i = "#text");
        var P = Zv(i, T) ? null : S, H = P ? null : xb(i, p), $ = P || H;
        if ($) {
          var ee = $.tag, pe = !!P + "|" + i + "|" + ee;
          if (!$0[pe]) {
            $0[pe] = !0;
            var _e = i, Ge = "";
            if (i === "#text" ? /\S/.test(o) ? _e = "Text nodes" : (_e = "Whitespace text nodes", Ge = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : _e = "<" + i + ">", P) {
              var He = "";
              ee === "table" && i === "tr" && (He += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), u("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", _e, ee, Ge, He);
            } else
              u("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", _e, ee);
          }
        }
      };
    }
    var yl = "suppressHydrationWarning", Yx = "$", Y0 = "/$", Sy = "$?", xy = "$!", PM = "style", _b = null, Eb = null;
    function hA(i) {
      var o, p, S = i.nodeType;
      switch (S) {
        case Ra:
        case Aa: {
          o = S === Ra ? "#document" : "#fragment";
          var T = i.documentElement;
          p = T ? T.namespaceURI : zc(null, "");
          break;
        }
        default: {
          var P = S === ka ? i.parentNode : i, H = P.namespaceURI || null;
          o = P.tagName, p = zc(H, o);
          break;
        }
      }
      {
        var $ = o.toLowerCase(), ee = Bu(null, $);
        return {
          namespace: p,
          ancestorInfo: ee
        };
      }
    }
    function NM(i, o, p) {
      {
        var S = i, T = zc(S.namespace, o), P = Bu(S.ancestorInfo, o);
        return {
          namespace: T,
          ancestorInfo: P
        };
      }
    }
    function UM(i) {
      return i;
    }
    function zM(i) {
      _b = ku(), Eb = Yv();
      var o = null;
      return Oa(!1), o;
    }
    function bb(i) {
      ob(Eb), Oa(_b), _b = null, Eb = null;
    }
    function kM(i, o, p, S, T) {
      var P;
      {
        var H = S;
        if (Op(i, null, H.ancestorInfo), typeof o.children == "string" || typeof o.children == "number") {
          var $ = "" + o.children, ee = Bu(H.ancestorInfo, i);
          Op(null, $, ee);
        }
        P = H.namespace;
      }
      var pe = fA(i, o, p, P);
      return $m(T, pe), zb(pe, o), pe;
    }
    function pA(i, o) {
      i.appendChild(o);
    }
    function IM(i, o, p, S, T) {
      switch (Bh(i, o, p, S), o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!p.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function mA(i, o, p, S, T, P) {
      {
        var H = P;
        if (typeof S.children != typeof p.children && (typeof S.children == "string" || typeof S.children == "number")) {
          var $ = "" + S.children, ee = Bu(H.ancestorInfo, o);
          Op(null, $, ee);
        }
      }
      return DM(i, o, p, S);
    }
    function Tb(i, o) {
      return i === "textarea" || i === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null;
    }
    function vA(i, o, p, S) {
      {
        var T = p;
        Op(null, i, T.ancestorInfo);
      }
      var P = dA(i, o);
      return $m(S, P), P;
    }
    function gA() {
      var i = window.event;
      return i === void 0 ? af : vl(i.type);
    }
    var Mb = typeof setTimeout == "function" ? setTimeout : void 0, wb = typeof clearTimeout == "function" ? clearTimeout : void 0, _y = -1, X0 = typeof Promise == "function" ? Promise : void 0, FM = typeof queueMicrotask == "function" ? queueMicrotask : typeof X0 < "u" ? function(i) {
      return X0.resolve(null).then(i).catch(yA);
    } : Mb;
    function yA(i) {
      setTimeout(function() {
        throw i;
      });
    }
    function BM(i, o, p, S) {
      switch (o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          p.autoFocus && i.focus();
          return;
        case "img": {
          p.src && (i.src = p.src);
          return;
        }
      }
    }
    function HM(i, o, p, S, T, P) {
      LM(i, o, p, S, T), zb(i, T);
    }
    function Xx(i) {
      Yi(i, "");
    }
    function SA(i, o, p) {
      i.nodeValue = p;
    }
    function Cb(i, o) {
      i.appendChild(o);
    }
    function VM(i, o) {
      var p;
      i.nodeType === ka ? (p = i.parentNode, p.insertBefore(o, i)) : (p = i, p.appendChild(o));
      var S = i._reactRootContainer;
      S == null && p.onclick === null && Gx(p);
    }
    function GM(i, o, p) {
      i.insertBefore(o, p);
    }
    function WM(i, o, p) {
      i.nodeType === ka ? i.parentNode.insertBefore(o, p) : i.insertBefore(o, p);
    }
    function qx(i, o) {
      i.removeChild(o);
    }
    function xA(i, o) {
      i.nodeType === ka ? i.parentNode.removeChild(o) : i.removeChild(o);
    }
    function Rb(i, o) {
      var p = o, S = 0;
      do {
        var T = p.nextSibling;
        if (i.removeChild(p), T && T.nodeType === ka) {
          var P = T.data;
          if (P === Y0)
            if (S === 0) {
              i.removeChild(T), xr(o);
              return;
            } else
              S--;
          else
            (P === Yx || P === Sy || P === xy) && S++;
        }
        p = T;
      } while (p);
      xr(o);
    }
    function _A(i, o) {
      i.nodeType === ka ? Rb(i.parentNode, o) : i.nodeType === Ns && Rb(i, o), xr(i);
    }
    function jM(i) {
      i = i;
      var o = i.style;
      typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none";
    }
    function EA(i) {
      i.nodeValue = "";
    }
    function bA(i, o) {
      i = i;
      var p = o[PM], S = p != null && p.hasOwnProperty("display") ? p.display : null;
      i.style.display = yd("display", S);
    }
    function TA(i, o) {
      i.nodeValue = o;
    }
    function MA(i) {
      i.nodeType === Ns ? i.textContent = "" : i.nodeType === Ra && i.documentElement && i.removeChild(i.documentElement);
    }
    function $M(i, o, p) {
      return i.nodeType !== Ns || o.toLowerCase() !== i.nodeName.toLowerCase() ? null : i;
    }
    function wA(i, o) {
      return o === "" || i.nodeType !== bu ? null : i;
    }
    function Ab(i) {
      return i.nodeType !== ka ? null : i;
    }
    function Db(i) {
      return i.data === Sy;
    }
    function Lb(i) {
      return i.data === xy;
    }
    function YM(i) {
      var o = i.nextSibling && i.nextSibling.dataset, p, S, T;
      return o && (p = o.dgst, S = o.msg, T = o.stck), {
        message: S,
        digest: p,
        stack: T
      };
    }
    function CA(i, o) {
      i._reactRetry = o;
    }
    function q0(i) {
      for (; i != null; i = i.nextSibling) {
        var o = i.nodeType;
        if (o === Ns || o === bu)
          break;
        if (o === ka) {
          var p = i.data;
          if (p === Yx || p === xy || p === Sy)
            break;
          if (p === Y0)
            return null;
        }
      }
      return i;
    }
    function K0(i) {
      return q0(i.nextSibling);
    }
    function Kx(i) {
      return q0(i.firstChild);
    }
    function Pp(i) {
      return q0(i.firstChild);
    }
    function RA(i) {
      return q0(i.nextSibling);
    }
    function Ob(i, o, p, S, T, P, H) {
      $m(P, i), zb(i, p);
      var $;
      {
        var ee = T;
        $ = ee.namespace;
      }
      var pe = (P.mode & Rr) !== Qn;
      return j0(i, o, p, $, S, pe, H);
    }
    function AA(i, o, p, S) {
      return $m(p, i), p.mode & Rr, Wx(i, o);
    }
    function XM(i, o) {
      $m(o, i);
    }
    function DA(i) {
      for (var o = i.nextSibling, p = 0; o; ) {
        if (o.nodeType === ka) {
          var S = o.data;
          if (S === Y0) {
            if (p === 0)
              return K0(o);
            p--;
          } else
            (S === Yx || S === xy || S === Sy) && p++;
        }
        o = o.nextSibling;
      }
      return null;
    }
    function Pb(i) {
      for (var o = i.previousSibling, p = 0; o; ) {
        if (o.nodeType === ka) {
          var S = o.data;
          if (S === Yx || S === xy || S === Sy) {
            if (p === 0)
              return o;
            p--;
          } else
            S === Y0 && p++;
        }
        o = o.previousSibling;
      }
      return null;
    }
    function qM(i) {
      xr(i);
    }
    function KM(i) {
      xr(i);
    }
    function Nb(i) {
      return i !== "head" && i !== "body";
    }
    function LA(i, o, p, S) {
      var T = !0;
      vy(o.nodeValue, p, S, T);
    }
    function Q0(i, o, p, S, T, P) {
      if (o[yl] !== !0) {
        var H = !0;
        vy(S.nodeValue, T, P, H);
      }
    }
    function Qx(i, o) {
      o.nodeType === Ns ? gy(i, o) : o.nodeType === ka || jx(i, o);
    }
    function OA(i, o) {
      {
        var p = i.parentNode;
        p !== null && (o.nodeType === Ns ? gy(p, o) : o.nodeType === ka || jx(p, o));
      }
    }
    function QM(i, o, p, S, T) {
      (T || o[yl] !== !0) && (S.nodeType === Ns ? gy(p, S) : S.nodeType === ka || jx(p, S));
    }
    function PA(i, o, p) {
      Qv(i, o);
    }
    function ZM(i, o) {
      Xs(i, o);
    }
    function JM(i, o, p) {
      {
        var S = i.parentNode;
        S !== null && Qv(S, o);
      }
    }
    function Zx(i, o) {
      {
        var p = i.parentNode;
        p !== null && Xs(p, o);
      }
    }
    function jm(i, o, p, S, T, P) {
      (P || o[yl] !== !0) && Qv(p, S);
    }
    function NA(i, o, p, S, T) {
      (T || o[yl] !== !0) && Xs(p, S);
    }
    function Tn(i) {
      u("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", i.nodeName.toLowerCase());
    }
    function Ey(i) {
      Fu(i);
    }
    var jd = Math.random().toString(36).slice(2), Io = "__reactFiber$" + jd, Ub = "__reactProps$" + jd, by = "__reactContainer$" + jd, Z0 = "__reactEvents$" + jd, UA = "__reactListeners$" + jd, ew = "__reactHandles$" + jd;
    function Jx(i) {
      delete i[Io], delete i[Ub], delete i[Z0], delete i[UA], delete i[ew];
    }
    function $m(i, o) {
      o[Io] = i;
    }
    function J0(i, o) {
      o[by] = i;
    }
    function tw(i) {
      i[by] = null;
    }
    function eS(i) {
      return !!i[by];
    }
    function Jv(i) {
      var o = i[Io];
      if (o)
        return o;
      for (var p = i.parentNode; p; ) {
        if (o = p[by] || p[Io], o) {
          var S = o.alternate;
          if (o.child !== null || S !== null && S.child !== null)
            for (var T = Pb(i); T !== null; ) {
              var P = T[Io];
              if (P)
                return P;
              T = Pb(T);
            }
          return o;
        }
        i = p, p = i.parentNode;
      }
      return null;
    }
    function Ym(i) {
      var o = i[Io] || i[by];
      return o && (o.tag === C || o.tag === D || o.tag === j || o.tag === b) ? o : null;
    }
    function qs(i) {
      if (i.tag === C || i.tag === D)
        return i.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function Zf(i) {
      return i[Ub] || null;
    }
    function zb(i, o) {
      i[Ub] = o;
    }
    function zA(i) {
      var o = i[Z0];
      return o === void 0 && (o = i[Z0] = /* @__PURE__ */ new Set()), o;
    }
    var nw = {}, rw = t.ReactDebugCurrentFrame;
    function tS(i) {
      if (i) {
        var o = i._owner, p = Tl(i.type, i._source, o ? o.type : null);
        rw.setExtraStackFrame(p);
      } else
        rw.setExtraStackFrame(null);
    }
    function $d(i, o, p, S, T) {
      {
        var P = Function.call.bind(et);
        for (var H in i)
          if (P(i, H)) {
            var $ = void 0;
            try {
              if (typeof i[H] != "function") {
                var ee = Error((S || "React class") + ": " + p + " type `" + H + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[H] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ee.name = "Invariant Violation", ee;
              }
              $ = i[H](o, H, S, p, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (pe) {
              $ = pe;
            }
            $ && !($ instanceof Error) && (tS(T), u("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", S || "React class", p, H, typeof $), tS(null)), $ instanceof Error && !($.message in nw) && (nw[$.message] = !0, tS(T), u("Failed %s type: %s", p, $.message), tS(null));
          }
      }
    }
    var e_ = [], nS;
    nS = [];
    var Np = -1;
    function Up(i) {
      return {
        current: i
      };
    }
    function yu(i, o) {
      if (Np < 0) {
        u("Unexpected pop.");
        return;
      }
      o !== nS[Np] && u("Unexpected Fiber popped."), i.current = e_[Np], e_[Np] = null, nS[Np] = null, Np--;
    }
    function Su(i, o, p) {
      Np++, e_[Np] = i.current, nS[Np] = p, i.current = o;
    }
    var kb;
    kb = {};
    var xc = {};
    Object.freeze(xc);
    var Hh = Up(xc), Yd = Up(!1), rS = xc;
    function Xm(i, o, p) {
      return p && Xd(o) ? rS : Hh.current;
    }
    function Ib(i, o, p) {
      {
        var S = i.stateNode;
        S.__reactInternalMemoizedUnmaskedChildContext = o, S.__reactInternalMemoizedMaskedChildContext = p;
      }
    }
    function Ty(i, o) {
      {
        var p = i.type, S = p.contextTypes;
        if (!S)
          return xc;
        var T = i.stateNode;
        if (T && T.__reactInternalMemoizedUnmaskedChildContext === o)
          return T.__reactInternalMemoizedMaskedChildContext;
        var P = {};
        for (var H in S)
          P[H] = o[H];
        {
          var $ = lr(i) || "Unknown";
          $d(S, P, "context", $);
        }
        return T && Ib(i, o, P), P;
      }
    }
    function My() {
      return Yd.current;
    }
    function Xd(i) {
      {
        var o = i.childContextTypes;
        return o != null;
      }
    }
    function t_(i) {
      yu(Yd, i), yu(Hh, i);
    }
    function wy(i) {
      yu(Yd, i), yu(Hh, i);
    }
    function iw(i, o, p) {
      {
        if (Hh.current !== xc)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Su(Hh, o, i), Su(Yd, p, i);
      }
    }
    function aw(i, o, p) {
      {
        var S = i.stateNode, T = o.childContextTypes;
        if (typeof S.getChildContext != "function") {
          {
            var P = lr(i) || "Unknown";
            kb[P] || (kb[P] = !0, u("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", P, P));
          }
          return p;
        }
        var H = S.getChildContext();
        for (var $ in H)
          if (!($ in T))
            throw new Error((lr(i) || "Unknown") + '.getChildContext(): key "' + $ + '" is not defined in childContextTypes.');
        {
          var ee = lr(i) || "Unknown";
          $d(T, H, "child context", ee);
        }
        return kn({}, p, H);
      }
    }
    function n_(i) {
      {
        var o = i.stateNode, p = o && o.__reactInternalMemoizedMergedChildContext || xc;
        return rS = Hh.current, Su(Hh, p, i), Su(Yd, Yd.current, i), !0;
      }
    }
    function ow(i, o, p) {
      {
        var S = i.stateNode;
        if (!S)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (p) {
          var T = aw(i, o, rS);
          S.__reactInternalMemoizedMergedChildContext = T, yu(Yd, i), yu(Hh, i), Su(Hh, T, i), Su(Yd, p, i);
        } else
          yu(Yd, i), Su(Yd, p, i);
      }
    }
    function kA(i) {
      {
        if (!jc(i) || i.tag !== y)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var o = i;
        do {
          switch (o.tag) {
            case b:
              return o.stateNode.context;
            case y: {
              var p = o.type;
              if (Xd(p))
                return o.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          o = o.return;
        } while (o !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var qm = 0, iS = 1, qd = null, Fb = !1, r_ = !1;
    function sw(i) {
      qd === null ? qd = [i] : qd.push(i);
    }
    function lw(i) {
      Fb = !0, sw(i);
    }
    function uw() {
      Fb && Km();
    }
    function Km() {
      if (!r_ && qd !== null) {
        r_ = !0;
        var i = 0, o = zu();
        try {
          var p = !0, S = qd;
          for (yo(gs); i < S.length; i++) {
            var T = S[i];
            do
              T = T(p);
            while (T !== null);
          }
          qd = null, Fb = !1;
        } catch (P) {
          throw qd !== null && (qd = qd.slice(i + 1)), Od(Cm, Km), P;
        } finally {
          yo(o), r_ = !1;
        }
      }
      return null;
    }
    var Cy = [], Ry = 0, i_ = null, a_ = 0, Jf = [], ed = 0, eg = null, zp = 1, kp = "";
    function cw(i) {
      return Kd(), (i.flags & su) !== Kn;
    }
    function td(i) {
      return Kd(), a_;
    }
    function IA() {
      var i = kp, o = zp, p = o & ~o_(o);
      return p.toString(32) + i;
    }
    function tg(i, o) {
      Kd(), Cy[Ry++] = a_, Cy[Ry++] = i_, i_ = i, a_ = o;
    }
    function fw(i, o, p) {
      Kd(), Jf[ed++] = zp, Jf[ed++] = kp, Jf[ed++] = eg, eg = i;
      var S = zp, T = kp, P = ng(S) - 1, H = S & ~(1 << P), $ = p + 1, ee = ng(o) + P;
      if (ee > 30) {
        var pe = P - P % 5, _e = (1 << pe) - 1, Ge = (H & _e).toString(32), He = H >> pe, ht = P - pe, mt = ng(o) + ht, Lt = $ << ht, Ln = Lt | He, ur = Ge + T;
        zp = 1 << mt | Ln, kp = ur;
      } else {
        var tr = $ << P, Pi = tr | H, bi = T;
        zp = 1 << ee | Pi, kp = bi;
      }
    }
    function Bb(i) {
      Kd();
      var o = i.return;
      if (o !== null) {
        var p = 1, S = 0;
        tg(i, p), fw(i, p, S);
      }
    }
    function ng(i) {
      return 32 - Ws(i);
    }
    function o_(i) {
      return 1 << ng(i) - 1;
    }
    function Ay(i) {
      for (; i === i_; )
        i_ = Cy[--Ry], Cy[Ry] = null, a_ = Cy[--Ry], Cy[Ry] = null;
      for (; i === eg; )
        eg = Jf[--ed], Jf[ed] = null, kp = Jf[--ed], Jf[ed] = null, zp = Jf[--ed], Jf[ed] = null;
    }
    function s_() {
      return Kd(), eg !== null ? {
        id: zp,
        overflow: kp
      } : null;
    }
    function l_(i, o) {
      Kd(), Jf[ed++] = zp, Jf[ed++] = kp, Jf[ed++] = eg, zp = o.id, kp = o.overflow, eg = i;
    }
    function Kd() {
      Pa() || u("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Fl = null, nd = null, Qd = !1, rg = !1, Qm = null;
    function Hb() {
      Qd && u("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function u_() {
      rg = !0;
    }
    function Vb() {
      return rg;
    }
    function dw(i) {
      var o = i.stateNode.containerInfo;
      return nd = Pp(o), Fl = i, Qd = !0, Qm = null, rg = !1, !0;
    }
    function FA(i, o, p) {
      return nd = RA(o), Fl = i, Qd = !0, Qm = null, rg = !1, p !== null && l_(i, p), !0;
    }
    function aS(i, o) {
      switch (i.tag) {
        case b: {
          Qx(i.stateNode.containerInfo, o);
          break;
        }
        case C: {
          var p = (i.mode & Rr) !== Qn;
          QM(
            i.type,
            i.memoizedProps,
            i.stateNode,
            o,
            // TODO: Delete this argument when we remove the legacy root API.
            p
          );
          break;
        }
        case j: {
          var S = i.memoizedState;
          S.dehydrated !== null && OA(S.dehydrated, o);
          break;
        }
      }
    }
    function hw(i, o) {
      aS(i, o);
      var p = SG();
      p.stateNode = o, p.return = i;
      var S = i.deletions;
      S === null ? (i.deletions = [p], i.flags |= ii) : S.push(p);
    }
    function Gb(i, o) {
      {
        if (rg)
          return;
        switch (i.tag) {
          case b: {
            var p = i.stateNode.containerInfo;
            switch (o.tag) {
              case C:
                var S = o.type;
                o.pendingProps, PA(p, S);
                break;
              case D:
                var T = o.pendingProps;
                ZM(p, T);
                break;
            }
            break;
          }
          case C: {
            var P = i.type, H = i.memoizedProps, $ = i.stateNode;
            switch (o.tag) {
              case C: {
                var ee = o.type, pe = o.pendingProps, _e = (i.mode & Rr) !== Qn;
                jm(
                  P,
                  H,
                  $,
                  ee,
                  pe,
                  // TODO: Delete this argument when we remove the legacy root API.
                  _e
                );
                break;
              }
              case D: {
                var Ge = o.pendingProps, He = (i.mode & Rr) !== Qn;
                NA(
                  P,
                  H,
                  $,
                  Ge,
                  // TODO: Delete this argument when we remove the legacy root API.
                  He
                );
                break;
              }
            }
            break;
          }
          case j: {
            var ht = i.memoizedState, mt = ht.dehydrated;
            if (mt !== null)
              switch (o.tag) {
                case C:
                  var Lt = o.type;
                  o.pendingProps, JM(mt, Lt);
                  break;
                case D:
                  var Ln = o.pendingProps;
                  Zx(mt, Ln);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function pw(i, o) {
      o.flags = o.flags & ~Hs | Hr, Gb(i, o);
    }
    function oS(i, o) {
      switch (i.tag) {
        case C: {
          var p = i.type;
          i.pendingProps;
          var S = $M(o, p);
          return S !== null ? (i.stateNode = S, Fl = i, nd = Kx(S), !0) : !1;
        }
        case D: {
          var T = i.pendingProps, P = wA(o, T);
          return P !== null ? (i.stateNode = P, Fl = i, nd = null, !0) : !1;
        }
        case j: {
          var H = Ab(o);
          if (H !== null) {
            var $ = {
              dehydrated: H,
              treeContext: s_(),
              retryLane: pl
            };
            i.memoizedState = $;
            var ee = xG(H);
            return ee.return = i, i.child = ee, Fl = i, nd = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Wb(i) {
      return (i.mode & Rr) !== Qn && (i.flags & dr) === Kn;
    }
    function jb(i) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function $b(i) {
      if (Qd) {
        var o = nd;
        if (!o) {
          Wb(i) && (Gb(Fl, i), jb()), pw(Fl, i), Qd = !1, Fl = i;
          return;
        }
        var p = o;
        if (!oS(i, o)) {
          Wb(i) && (Gb(Fl, i), jb()), o = K0(p);
          var S = Fl;
          if (!o || !oS(i, o)) {
            pw(Fl, i), Qd = !1, Fl = i;
            return;
          }
          hw(S, p);
        }
      }
    }
    function BA(i, o, p) {
      var S = i.stateNode, T = !rg, P = Ob(S, i.type, i.memoizedProps, o, p, i, T);
      return i.updateQueue = P, P !== null;
    }
    function mw(i) {
      var o = i.stateNode, p = i.memoizedProps, S = AA(o, p, i);
      if (S) {
        var T = Fl;
        if (T !== null)
          switch (T.tag) {
            case b: {
              var P = T.stateNode.containerInfo, H = (T.mode & Rr) !== Qn;
              LA(
                P,
                o,
                p,
                // TODO: Delete this argument when we remove the legacy root API.
                H
              );
              break;
            }
            case C: {
              var $ = T.type, ee = T.memoizedProps, pe = T.stateNode, _e = (T.mode & Rr) !== Qn;
              Q0(
                $,
                ee,
                pe,
                o,
                p,
                // TODO: Delete this argument when we remove the legacy root API.
                _e
              );
              break;
            }
          }
      }
      return S;
    }
    function HA(i) {
      var o = i.memoizedState, p = o !== null ? o.dehydrated : null;
      if (!p)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      XM(p, i);
    }
    function Yb(i) {
      var o = i.memoizedState, p = o !== null ? o.dehydrated : null;
      if (!p)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return DA(p);
    }
    function c_(i) {
      for (var o = i.return; o !== null && o.tag !== C && o.tag !== b && o.tag !== j; )
        o = o.return;
      Fl = o;
    }
    function Ya(i) {
      if (i !== Fl)
        return !1;
      if (!Qd)
        return c_(i), Qd = !0, !1;
      if (i.tag !== b && (i.tag !== C || Nb(i.type) && !Tb(i.type, i.memoizedProps))) {
        var o = nd;
        if (o)
          if (Wb(i))
            Zo(i), jb();
          else
            for (; o; )
              hw(i, o), o = K0(o);
      }
      return c_(i), i.tag === j ? nd = Yb(i) : nd = Fl ? K0(i.stateNode) : null, !0;
    }
    function Zd() {
      return Qd && nd !== null;
    }
    function Zo(i) {
      for (var o = nd; o; )
        aS(i, o), o = K0(o);
    }
    function Zm() {
      Fl = null, nd = null, Qd = !1, rg = !1;
    }
    function Bl() {
      Qm !== null && (KN(Qm), Qm = null);
    }
    function Pa() {
      return Qd;
    }
    function Jd(i) {
      Qm === null ? Qm = [i] : Qm.push(i);
    }
    var sS = t.ReactCurrentBatchConfig, ig = null;
    function f_() {
      return sS.transition;
    }
    var Hu = {
      recordUnsafeLifecycleWarnings: function(i, o) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(i, o) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var vw = function(i) {
        for (var o = null, p = i; p !== null; )
          p.mode & Yr && (o = p), p = p.return;
        return o;
      }, Ip = function(i) {
        var o = [];
        return i.forEach(function(p) {
          o.push(p);
        }), o.sort().join(", ");
      }, kr = [], Es = [], Na = [], Oo = [], _c = [], ag = [], io = /* @__PURE__ */ new Set();
      Hu.recordUnsafeLifecycleWarnings = function(i, o) {
        io.has(i.type) || (typeof o.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        o.componentWillMount.__suppressDeprecationWarning !== !0 && kr.push(i), i.mode & Yr && typeof o.UNSAFE_componentWillMount == "function" && Es.push(i), typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Na.push(i), i.mode & Yr && typeof o.UNSAFE_componentWillReceiveProps == "function" && Oo.push(i), typeof o.componentWillUpdate == "function" && o.componentWillUpdate.__suppressDeprecationWarning !== !0 && _c.push(i), i.mode & Yr && typeof o.UNSAFE_componentWillUpdate == "function" && ag.push(i));
      }, Hu.flushPendingUnsafeLifecycleWarnings = function() {
        var i = /* @__PURE__ */ new Set();
        kr.length > 0 && (kr.forEach(function(He) {
          i.add(lr(He) || "Component"), io.add(He.type);
        }), kr = []);
        var o = /* @__PURE__ */ new Set();
        Es.length > 0 && (Es.forEach(function(He) {
          o.add(lr(He) || "Component"), io.add(He.type);
        }), Es = []);
        var p = /* @__PURE__ */ new Set();
        Na.length > 0 && (Na.forEach(function(He) {
          p.add(lr(He) || "Component"), io.add(He.type);
        }), Na = []);
        var S = /* @__PURE__ */ new Set();
        Oo.length > 0 && (Oo.forEach(function(He) {
          S.add(lr(He) || "Component"), io.add(He.type);
        }), Oo = []);
        var T = /* @__PURE__ */ new Set();
        _c.length > 0 && (_c.forEach(function(He) {
          T.add(lr(He) || "Component"), io.add(He.type);
        }), _c = []);
        var P = /* @__PURE__ */ new Set();
        if (ag.length > 0 && (ag.forEach(function(He) {
          P.add(lr(He) || "Component"), io.add(He.type);
        }), ag = []), o.size > 0) {
          var H = Ip(o);
          u(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, H);
        }
        if (S.size > 0) {
          var $ = Ip(S);
          u(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, $);
        }
        if (P.size > 0) {
          var ee = Ip(P);
          u(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, ee);
        }
        if (i.size > 0) {
          var pe = Ip(i);
          s(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, pe);
        }
        if (p.size > 0) {
          var _e = Ip(p);
          s(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _e);
        }
        if (T.size > 0) {
          var Ge = Ip(T);
          s(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ge);
        }
      };
      var Jm = /* @__PURE__ */ new Map(), lS = /* @__PURE__ */ new Set();
      Hu.recordLegacyContextWarning = function(i, o) {
        var p = vw(i);
        if (p === null) {
          u("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!lS.has(i.type)) {
          var S = Jm.get(p);
          (i.type.contextTypes != null || i.type.childContextTypes != null || o !== null && typeof o.getChildContext == "function") && (S === void 0 && (S = [], Jm.set(p, S)), S.push(i));
        }
      }, Hu.flushLegacyContextWarning = function() {
        Jm.forEach(function(i, o) {
          if (i.length !== 0) {
            var p = i[0], S = /* @__PURE__ */ new Set();
            i.forEach(function(P) {
              S.add(lr(P) || "Component"), lS.add(P.type);
            });
            var T = Ip(S);
            try {
              zi(p), u(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, T);
            } finally {
              Ca();
            }
          }
        });
      }, Hu.discardPendingWarnings = function() {
        kr = [], Es = [], Na = [], Oo = [], _c = [], ag = [], Jm = /* @__PURE__ */ new Map();
      };
    }
    function Vu(i, o) {
      if (i && i.defaultProps) {
        var p = kn({}, o), S = i.defaultProps;
        for (var T in S)
          p[T] === void 0 && (p[T] = S[T]);
        return p;
      }
      return o;
    }
    var Dy = Up(null), og;
    og = {};
    var Hl = null, ev = null, d_ = null, uS = !1;
    function h_() {
      Hl = null, ev = null, d_ = null, uS = !1;
    }
    function sg() {
      uS = !0;
    }
    function Xb() {
      uS = !1;
    }
    function cS(i, o, p) {
      Su(Dy, o._currentValue, i), o._currentValue = p, o._currentRenderer !== void 0 && o._currentRenderer !== null && o._currentRenderer !== og && u("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), o._currentRenderer = og;
    }
    function fS(i, o) {
      var p = Dy.current;
      yu(Dy, o), i._currentValue = p;
    }
    function tv(i, o, p) {
      for (var S = i; S !== null; ) {
        var T = S.alternate;
        if (vt(S.childLanes, o) ? T !== null && !vt(T.childLanes, o) && (T.childLanes = Pt(T.childLanes, o)) : (S.childLanes = Pt(S.childLanes, o), T !== null && (T.childLanes = Pt(T.childLanes, o))), S === p)
          break;
        S = S.return;
      }
      S !== p && u("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function lg(i, o, p) {
      Fp(i, o, p);
    }
    function Fp(i, o, p) {
      var S = i.child;
      for (S !== null && (S.return = i); S !== null; ) {
        var T = void 0, P = S.dependencies;
        if (P !== null) {
          T = S.child;
          for (var H = P.firstContext; H !== null; ) {
            if (H.context === o) {
              if (S.tag === y) {
                var $ = fi(p), ee = Gh(Xr, $);
                ee.tag = Bo;
                var pe = S.updateQueue;
                if (pe !== null) {
                  var _e = pe.shared, Ge = _e.pending;
                  Ge === null ? ee.next = ee : (ee.next = Ge.next, Ge.next = ee), _e.pending = ee;
                }
              }
              S.lanes = Pt(S.lanes, p);
              var He = S.alternate;
              He !== null && (He.lanes = Pt(He.lanes, p)), tv(S.return, p, i), P.lanes = Pt(P.lanes, p);
              break;
            }
            H = H.next;
          }
        } else if (S.tag === I)
          T = S.type === i.type ? null : S.child;
        else if (S.tag === q) {
          var ht = S.return;
          if (ht === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          ht.lanes = Pt(ht.lanes, p);
          var mt = ht.alternate;
          mt !== null && (mt.lanes = Pt(mt.lanes, p)), tv(ht, p, i), T = S.sibling;
        } else
          T = S.child;
        if (T !== null)
          T.return = S;
        else
          for (T = S; T !== null; ) {
            if (T === i) {
              T = null;
              break;
            }
            var Lt = T.sibling;
            if (Lt !== null) {
              Lt.return = T.return, T = Lt;
              break;
            }
            T = T.return;
          }
        S = T;
      }
    }
    function Vh(i, o) {
      Hl = i, ev = null, d_ = null;
      var p = i.dependencies;
      if (p !== null) {
        var S = p.firstContext;
        S !== null && (Be(p.lanes, o) && R1(), p.firstContext = null);
      }
    }
    function Fo(i) {
      uS && u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var o = i._currentValue;
      if (d_ !== i) {
        var p = {
          context: i,
          memoizedValue: o,
          next: null
        };
        if (ev === null) {
          if (Hl === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          ev = p, Hl.dependencies = {
            lanes: Ct,
            firstContext: p
          };
        } else
          ev = ev.next = p;
      }
      return o;
    }
    var ug = null;
    function cg(i) {
      ug === null ? ug = [i] : ug.push(i);
    }
    function qb() {
      if (ug !== null) {
        for (var i = 0; i < ug.length; i++) {
          var o = ug[i], p = o.interleaved;
          if (p !== null) {
            o.interleaved = null;
            var S = p.next, T = o.pending;
            if (T !== null) {
              var P = T.next;
              T.next = S, p.next = P;
            }
            o.pending = p;
          }
        }
        ug = null;
      }
    }
    function gw(i, o, p, S) {
      var T = o.interleaved;
      return T === null ? (p.next = p, cg(o)) : (p.next = T.next, T.next = p), o.interleaved = p, Sl(i, S);
    }
    function p_(i, o, p, S) {
      var T = o.interleaved;
      T === null ? (p.next = p, cg(o)) : (p.next = T.next, T.next = p), o.interleaved = p;
    }
    function dS(i, o, p, S) {
      var T = o.interleaved;
      return T === null ? (p.next = p, cg(o)) : (p.next = T.next, T.next = p), o.interleaved = p, Sl(i, S);
    }
    function Vl(i, o) {
      return Sl(i, o);
    }
    var m_ = Sl;
    function Sl(i, o) {
      i.lanes = Pt(i.lanes, o);
      var p = i.alternate;
      p !== null && (p.lanes = Pt(p.lanes, o)), p === null && (i.flags & (Hr | Hs)) !== Kn && lU(i);
      for (var S = i, T = i.return; T !== null; )
        T.childLanes = Pt(T.childLanes, o), p = T.alternate, p !== null ? p.childLanes = Pt(p.childLanes, o) : (T.flags & (Hr | Hs)) !== Kn && lU(i), S = T, T = T.return;
      if (S.tag === b) {
        var P = S.stateNode;
        return P;
      } else
        return null;
    }
    var Bp = 0, yw = 1, Bo = 2, Kb = 3, fg = !1, v_, Gl;
    v_ = !1, Gl = null;
    function g_(i) {
      var o = {
        baseState: i.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Ct
        },
        effects: null
      };
      i.updateQueue = o;
    }
    function y_(i, o) {
      var p = o.updateQueue, S = i.updateQueue;
      if (p === S) {
        var T = {
          baseState: S.baseState,
          firstBaseUpdate: S.firstBaseUpdate,
          lastBaseUpdate: S.lastBaseUpdate,
          shared: S.shared,
          effects: S.effects
        };
        o.updateQueue = T;
      }
    }
    function Gh(i, o) {
      var p = {
        eventTime: i,
        lane: o,
        tag: Bp,
        payload: null,
        callback: null,
        next: null
      };
      return p;
    }
    function nv(i, o, p) {
      var S = i.updateQueue;
      if (S === null)
        return null;
      var T = S.shared;
      if (Gl === T && !v_ && (u("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), v_ = !0), L5()) {
        var P = T.pending;
        return P === null ? o.next = o : (o.next = P.next, P.next = o), T.pending = o, m_(i, p);
      } else
        return dS(i, T, o, p);
    }
    function S_(i, o, p) {
      var S = o.updateQueue;
      if (S !== null) {
        var T = S.shared;
        if (sr(p)) {
          var P = T.lanes;
          P = Ar(P, i.pendingLanes);
          var H = Pt(P, p);
          T.lanes = H, gp(i, H);
        }
      }
    }
    function Wh(i, o) {
      var p = i.updateQueue, S = i.alternate;
      if (S !== null) {
        var T = S.updateQueue;
        if (p === T) {
          var P = null, H = null, $ = p.firstBaseUpdate;
          if ($ !== null) {
            var ee = $;
            do {
              var pe = {
                eventTime: ee.eventTime,
                lane: ee.lane,
                tag: ee.tag,
                payload: ee.payload,
                callback: ee.callback,
                next: null
              };
              H === null ? P = H = pe : (H.next = pe, H = pe), ee = ee.next;
            } while (ee !== null);
            H === null ? P = H = o : (H.next = o, H = o);
          } else
            P = H = o;
          p = {
            baseState: T.baseState,
            firstBaseUpdate: P,
            lastBaseUpdate: H,
            shared: T.shared,
            effects: T.effects
          }, i.updateQueue = p;
          return;
        }
      }
      var _e = p.lastBaseUpdate;
      _e === null ? p.firstBaseUpdate = o : _e.next = o, p.lastBaseUpdate = o;
    }
    function Sw(i, o, p, S, T, P) {
      switch (p.tag) {
        case yw: {
          var H = p.payload;
          if (typeof H == "function") {
            sg();
            var $ = H.call(P, S, T);
            {
              if (i.mode & Yr) {
                qi(!0);
                try {
                  H.call(P, S, T);
                } finally {
                  qi(!1);
                }
              }
              Xb();
            }
            return $;
          }
          return H;
        }
        case Kb:
          i.flags = i.flags & ~bo | dr;
        case Bp: {
          var ee = p.payload, pe;
          if (typeof ee == "function") {
            sg(), pe = ee.call(P, S, T);
            {
              if (i.mode & Yr) {
                qi(!0);
                try {
                  ee.call(P, S, T);
                } finally {
                  qi(!1);
                }
              }
              Xb();
            }
          } else
            pe = ee;
          return pe == null ? S : kn({}, S, pe);
        }
        case Bo:
          return fg = !0, S;
      }
      return S;
    }
    function x_(i, o, p, S) {
      var T = i.updateQueue;
      fg = !1, Gl = T.shared;
      var P = T.firstBaseUpdate, H = T.lastBaseUpdate, $ = T.shared.pending;
      if ($ !== null) {
        T.shared.pending = null;
        var ee = $, pe = ee.next;
        ee.next = null, H === null ? P = pe : H.next = pe, H = ee;
        var _e = i.alternate;
        if (_e !== null) {
          var Ge = _e.updateQueue, He = Ge.lastBaseUpdate;
          He !== H && (He === null ? Ge.firstBaseUpdate = pe : He.next = pe, Ge.lastBaseUpdate = ee);
        }
      }
      if (P !== null) {
        var ht = T.baseState, mt = Ct, Lt = null, Ln = null, ur = null, tr = P;
        do {
          var Pi = tr.lane, bi = tr.eventTime;
          if (vt(S, Pi)) {
            if (ur !== null) {
              var Ot = {
                eventTime: bi,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Jr,
                tag: tr.tag,
                payload: tr.payload,
                callback: tr.callback,
                next: null
              };
              ur = ur.next = Ot;
            }
            ht = Sw(i, T, tr, ht, o, p);
            var it = tr.callback;
            if (it !== null && // If the update was already committed, we should not queue its
            // callback again.
            tr.lane !== Jr) {
              i.flags |= Au;
              var nn = T.effects;
              nn === null ? T.effects = [tr] : nn.push(tr);
            }
          } else {
            var rt = {
              eventTime: bi,
              lane: Pi,
              tag: tr.tag,
              payload: tr.payload,
              callback: tr.callback,
              next: null
            };
            ur === null ? (Ln = ur = rt, Lt = ht) : ur = ur.next = rt, mt = Pt(mt, Pi);
          }
          if (tr = tr.next, tr === null) {
            if ($ = T.shared.pending, $ === null)
              break;
            var On = $, Cn = On.next;
            On.next = null, tr = Cn, T.lastBaseUpdate = On, T.shared.pending = null;
          }
        } while (!0);
        ur === null && (Lt = ht), T.baseState = Lt, T.firstBaseUpdate = Ln, T.lastBaseUpdate = ur;
        var Mr = T.shared.interleaved;
        if (Mr !== null) {
          var Ir = Mr;
          do
            mt = Pt(mt, Ir.lane), Ir = Ir.next;
          while (Ir !== Mr);
        } else
          P === null && (T.shared.lanes = Ct);
        B1(mt), i.lanes = mt, i.memoizedState = ht;
      }
      Gl = null;
    }
    function VA(i, o) {
      if (typeof i != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + i));
      i.call(o);
    }
    function xw() {
      fg = !1;
    }
    function __() {
      return fg;
    }
    function hS(i, o, p) {
      var S = o.effects;
      if (o.effects = null, S !== null)
        for (var T = 0; T < S.length; T++) {
          var P = S[T], H = P.callback;
          H !== null && (P.callback = null, VA(H, p));
        }
    }
    var Qb = {}, _w = new n.Component().refs, Ly, pS, Hp, E_, b_, Zb, T_, Oy, Jb, mS;
    {
      Ly = /* @__PURE__ */ new Set(), pS = /* @__PURE__ */ new Set(), Hp = /* @__PURE__ */ new Set(), E_ = /* @__PURE__ */ new Set(), Oy = /* @__PURE__ */ new Set(), b_ = /* @__PURE__ */ new Set(), Jb = /* @__PURE__ */ new Set(), mS = /* @__PURE__ */ new Set();
      var Ew = /* @__PURE__ */ new Set();
      T_ = function(i, o) {
        if (!(i === null || typeof i == "function")) {
          var p = o + "_" + i;
          Ew.has(p) || (Ew.add(p), u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", o, i));
        }
      }, Zb = function(i, o) {
        if (o === void 0) {
          var p = jr(i) || "Component";
          b_.has(p) || (b_.add(p), u("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", p));
        }
      }, Object.defineProperty(Qb, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(Qb);
    }
    function e1(i, o, p, S) {
      var T = i.memoizedState, P = p(S, T);
      {
        if (i.mode & Yr) {
          qi(!0);
          try {
            P = p(S, T);
          } finally {
            qi(!1);
          }
        }
        Zb(o, P);
      }
      var H = P == null ? T : kn({}, T, P);
      if (i.memoizedState = H, i.lanes === Ct) {
        var $ = i.updateQueue;
        $.baseState = H;
      }
    }
    var Py = {
      isMounted: Mo,
      enqueueSetState: function(i, o, p) {
        var S = $o(i), T = mf(), P = Ky(S), H = Gh(T, P);
        H.payload = o, p != null && (T_(p, "setState"), H.callback = p);
        var $ = nv(S, H, P);
        $ !== null && (Kl($, S, P, T), S_($, S, P)), du(S, P);
      },
      enqueueReplaceState: function(i, o, p) {
        var S = $o(i), T = mf(), P = Ky(S), H = Gh(T, P);
        H.tag = yw, H.payload = o, p != null && (T_(p, "replaceState"), H.callback = p);
        var $ = nv(S, H, P);
        $ !== null && (Kl($, S, P, T), S_($, S, P)), du(S, P);
      },
      enqueueForceUpdate: function(i, o) {
        var p = $o(i), S = mf(), T = Ky(p), P = Gh(S, T);
        P.tag = Bo, o != null && (T_(o, "forceUpdate"), P.callback = o);
        var H = nv(p, P, T);
        H !== null && (Kl(H, p, T, S), S_(H, p, T)), bh(p, T);
      }
    };
    function bw(i, o, p, S, T, P, H) {
      var $ = i.stateNode;
      if (typeof $.shouldComponentUpdate == "function") {
        var ee = $.shouldComponentUpdate(S, P, H);
        {
          if (i.mode & Yr) {
            qi(!0);
            try {
              ee = $.shouldComponentUpdate(S, P, H);
            } finally {
              qi(!1);
            }
          }
          ee === void 0 && u("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", jr(o) || "Component");
        }
        return ee;
      }
      return o.prototype && o.prototype.isPureReactComponent ? !er(p, S) || !er(T, P) : !0;
    }
    function GA(i, o, p) {
      var S = i.stateNode;
      {
        var T = jr(o) || "Component", P = S.render;
        P || (o.prototype && typeof o.prototype.render == "function" ? u("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", T) : u("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", T)), S.getInitialState && !S.getInitialState.isReactClassApproved && !S.state && u("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", T), S.getDefaultProps && !S.getDefaultProps.isReactClassApproved && u("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", T), S.propTypes && u("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", T), S.contextType && u("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", T), S.contextTypes && u("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", T), o.contextType && o.contextTypes && !Jb.has(o) && (Jb.add(o), u("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", T)), typeof S.componentShouldUpdate == "function" && u("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", T), o.prototype && o.prototype.isPureReactComponent && typeof S.shouldComponentUpdate < "u" && u("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", jr(o) || "A pure component"), typeof S.componentDidUnmount == "function" && u("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", T), typeof S.componentDidReceiveProps == "function" && u("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", T), typeof S.componentWillRecieveProps == "function" && u("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", T), typeof S.UNSAFE_componentWillRecieveProps == "function" && u("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", T);
        var H = S.props !== p;
        S.props !== void 0 && H && u("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", T, T), S.defaultProps && u("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", T, T), typeof S.getSnapshotBeforeUpdate == "function" && typeof S.componentDidUpdate != "function" && !Hp.has(o) && (Hp.add(o), u("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", jr(o))), typeof S.getDerivedStateFromProps == "function" && u("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", T), typeof S.getDerivedStateFromError == "function" && u("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", T), typeof o.getSnapshotBeforeUpdate == "function" && u("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", T);
        var $ = S.state;
        $ && (typeof $ != "object" || $r($)) && u("%s.state: must be set to an object or null", T), typeof S.getChildContext == "function" && typeof o.childContextTypes != "object" && u("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", T);
      }
    }
    function Tw(i, o) {
      o.updater = Py, i.stateNode = o, xi(o, i), o._reactInternalInstance = Qb;
    }
    function t1(i, o, p) {
      var S = !1, T = xc, P = xc, H = o.contextType;
      if ("contextType" in o) {
        var $ = (
          // Allow null for conditional declaration
          H === null || H !== void 0 && H.$$typeof === en && H._context === void 0
        );
        if (!$ && !mS.has(o)) {
          mS.add(o);
          var ee = "";
          H === void 0 ? ee = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof H != "object" ? ee = " However, it is set to a " + typeof H + "." : H.$$typeof === Bt ? ee = " Did you accidentally pass the Context.Provider instead?" : H._context !== void 0 ? ee = " Did you accidentally pass the Context.Consumer instead?" : ee = " However, it is set to an object with keys {" + Object.keys(H).join(", ") + "}.", u("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", jr(o) || "Component", ee);
        }
      }
      if (typeof H == "object" && H !== null)
        P = Fo(H);
      else {
        T = Xm(i, o, !0);
        var pe = o.contextTypes;
        S = pe != null, P = S ? Ty(i, T) : xc;
      }
      var _e = new o(p, P);
      if (i.mode & Yr) {
        qi(!0);
        try {
          _e = new o(p, P);
        } finally {
          qi(!1);
        }
      }
      var Ge = i.memoizedState = _e.state !== null && _e.state !== void 0 ? _e.state : null;
      Tw(i, _e);
      {
        if (typeof o.getDerivedStateFromProps == "function" && Ge === null) {
          var He = jr(o) || "Component";
          pS.has(He) || (pS.add(He), u("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", He, _e.state === null ? "null" : "undefined", He));
        }
        if (typeof o.getDerivedStateFromProps == "function" || typeof _e.getSnapshotBeforeUpdate == "function") {
          var ht = null, mt = null, Lt = null;
          if (typeof _e.componentWillMount == "function" && _e.componentWillMount.__suppressDeprecationWarning !== !0 ? ht = "componentWillMount" : typeof _e.UNSAFE_componentWillMount == "function" && (ht = "UNSAFE_componentWillMount"), typeof _e.componentWillReceiveProps == "function" && _e.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? mt = "componentWillReceiveProps" : typeof _e.UNSAFE_componentWillReceiveProps == "function" && (mt = "UNSAFE_componentWillReceiveProps"), typeof _e.componentWillUpdate == "function" && _e.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Lt = "componentWillUpdate" : typeof _e.UNSAFE_componentWillUpdate == "function" && (Lt = "UNSAFE_componentWillUpdate"), ht !== null || mt !== null || Lt !== null) {
            var Ln = jr(o) || "Component", ur = typeof o.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            E_.has(Ln) || (E_.add(Ln), u(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Ln, ur, ht !== null ? `
  ` + ht : "", mt !== null ? `
  ` + mt : "", Lt !== null ? `
  ` + Lt : ""));
          }
        }
      }
      return S && Ib(i, T, P), _e;
    }
    function Mw(i, o) {
      var p = o.state;
      typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount(), p !== o.state && (u("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", lr(i) || "Component"), Py.enqueueReplaceState(o, o.state, null));
    }
    function rv(i, o, p, S) {
      var T = o.state;
      if (typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(p, S), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(p, S), o.state !== T) {
        {
          var P = lr(i) || "Component";
          Ly.has(P) || (Ly.add(P), u("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", P));
        }
        Py.enqueueReplaceState(o, o.state, null);
      }
    }
    function n1(i, o, p, S) {
      GA(i, o, p);
      var T = i.stateNode;
      T.props = p, T.state = i.memoizedState, T.refs = _w, g_(i);
      var P = o.contextType;
      if (typeof P == "object" && P !== null)
        T.context = Fo(P);
      else {
        var H = Xm(i, o, !0);
        T.context = Ty(i, H);
      }
      {
        if (T.state === p) {
          var $ = jr(o) || "Component";
          Oy.has($) || (Oy.add($), u("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", $));
        }
        i.mode & Yr && Hu.recordLegacyContextWarning(i, T), Hu.recordUnsafeLifecycleWarnings(i, T);
      }
      T.state = i.memoizedState;
      var ee = o.getDerivedStateFromProps;
      if (typeof ee == "function" && (e1(i, o, ee, p), T.state = i.memoizedState), typeof o.getDerivedStateFromProps != "function" && typeof T.getSnapshotBeforeUpdate != "function" && (typeof T.UNSAFE_componentWillMount == "function" || typeof T.componentWillMount == "function") && (Mw(i, T), x_(i, p, T, S), T.state = i.memoizedState), typeof T.componentDidMount == "function") {
        var pe = Hn;
        pe |= Fa, (i.mode & wo) !== Qn && (pe |= hi), i.flags |= pe;
      }
    }
    function jh(i, o, p, S) {
      var T = i.stateNode, P = i.memoizedProps;
      T.props = P;
      var H = T.context, $ = o.contextType, ee = xc;
      if (typeof $ == "object" && $ !== null)
        ee = Fo($);
      else {
        var pe = Xm(i, o, !0);
        ee = Ty(i, pe);
      }
      var _e = o.getDerivedStateFromProps, Ge = typeof _e == "function" || typeof T.getSnapshotBeforeUpdate == "function";
      !Ge && (typeof T.UNSAFE_componentWillReceiveProps == "function" || typeof T.componentWillReceiveProps == "function") && (P !== p || H !== ee) && rv(i, T, p, ee), xw();
      var He = i.memoizedState, ht = T.state = He;
      if (x_(i, p, T, S), ht = i.memoizedState, P === p && He === ht && !My() && !__()) {
        if (typeof T.componentDidMount == "function") {
          var mt = Hn;
          mt |= Fa, (i.mode & wo) !== Qn && (mt |= hi), i.flags |= mt;
        }
        return !1;
      }
      typeof _e == "function" && (e1(i, o, _e, p), ht = i.memoizedState);
      var Lt = __() || bw(i, o, P, p, He, ht, ee);
      if (Lt) {
        if (!Ge && (typeof T.UNSAFE_componentWillMount == "function" || typeof T.componentWillMount == "function") && (typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount()), typeof T.componentDidMount == "function") {
          var Ln = Hn;
          Ln |= Fa, (i.mode & wo) !== Qn && (Ln |= hi), i.flags |= Ln;
        }
      } else {
        if (typeof T.componentDidMount == "function") {
          var ur = Hn;
          ur |= Fa, (i.mode & wo) !== Qn && (ur |= hi), i.flags |= ur;
        }
        i.memoizedProps = p, i.memoizedState = ht;
      }
      return T.props = p, T.state = ht, T.context = ee, Lt;
    }
    function WA(i, o, p, S, T) {
      var P = o.stateNode;
      y_(i, o);
      var H = o.memoizedProps, $ = o.type === o.elementType ? H : Vu(o.type, H);
      P.props = $;
      var ee = o.pendingProps, pe = P.context, _e = p.contextType, Ge = xc;
      if (typeof _e == "object" && _e !== null)
        Ge = Fo(_e);
      else {
        var He = Xm(o, p, !0);
        Ge = Ty(o, He);
      }
      var ht = p.getDerivedStateFromProps, mt = typeof ht == "function" || typeof P.getSnapshotBeforeUpdate == "function";
      !mt && (typeof P.UNSAFE_componentWillReceiveProps == "function" || typeof P.componentWillReceiveProps == "function") && (H !== ee || pe !== Ge) && rv(o, P, S, Ge), xw();
      var Lt = o.memoizedState, Ln = P.state = Lt;
      if (x_(o, S, P, T), Ln = o.memoizedState, H === ee && Lt === Ln && !My() && !__() && !we)
        return typeof P.componentDidUpdate == "function" && (H !== i.memoizedProps || Lt !== i.memoizedState) && (o.flags |= Hn), typeof P.getSnapshotBeforeUpdate == "function" && (H !== i.memoizedProps || Lt !== i.memoizedState) && (o.flags |= Bs), !1;
      typeof ht == "function" && (e1(o, p, ht, S), Ln = o.memoizedState);
      var ur = __() || bw(o, p, $, S, Lt, Ln, Ge) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      we;
      return ur ? (!mt && (typeof P.UNSAFE_componentWillUpdate == "function" || typeof P.componentWillUpdate == "function") && (typeof P.componentWillUpdate == "function" && P.componentWillUpdate(S, Ln, Ge), typeof P.UNSAFE_componentWillUpdate == "function" && P.UNSAFE_componentWillUpdate(S, Ln, Ge)), typeof P.componentDidUpdate == "function" && (o.flags |= Hn), typeof P.getSnapshotBeforeUpdate == "function" && (o.flags |= Bs)) : (typeof P.componentDidUpdate == "function" && (H !== i.memoizedProps || Lt !== i.memoizedState) && (o.flags |= Hn), typeof P.getSnapshotBeforeUpdate == "function" && (H !== i.memoizedProps || Lt !== i.memoizedState) && (o.flags |= Bs), o.memoizedProps = S, o.memoizedState = Ln), P.props = S, P.state = Ln, P.context = Ge, ur;
    }
    var r1, M_, i1, a1, o1, s1 = function(i, o) {
    };
    r1 = !1, M_ = !1, i1 = {}, a1 = {}, o1 = {}, s1 = function(i, o) {
      if (!(i === null || typeof i != "object") && !(!i._store || i._store.validated || i.key != null)) {
        if (typeof i._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        i._store.validated = !0;
        var p = lr(o) || "Component";
        a1[p] || (a1[p] = !0, u('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function Jo(i, o, p) {
      var S = p.ref;
      if (S !== null && typeof S != "function" && typeof S != "object") {
        if ((i.mode & Yr || Oe) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(p._owner && p._self && p._owner.stateNode !== p._self)) {
          var T = lr(i) || "Component";
          i1[T] || (u('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', S), i1[T] = !0);
        }
        if (p._owner) {
          var P = p._owner, H;
          if (P) {
            var $ = P;
            if ($.tag !== y)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            H = $.stateNode;
          }
          if (!H)
            throw new Error("Missing owner for string ref " + S + ". This error is likely caused by a bug in React. Please file an issue.");
          var ee = H;
          hn(S, "ref");
          var pe = "" + S;
          if (o !== null && o.ref !== null && typeof o.ref == "function" && o.ref._stringRef === pe)
            return o.ref;
          var _e = function(Ge) {
            var He = ee.refs;
            He === _w && (He = ee.refs = {}), Ge === null ? delete He[pe] : He[pe] = Ge;
          };
          return _e._stringRef = pe, _e;
        } else {
          if (typeof S != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!p._owner)
            throw new Error("Element ref was specified as a string (" + S + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return S;
    }
    function w_(i, o) {
      var p = Object.prototype.toString.call(o);
      throw new Error("Objects are not valid as a React child (found: " + (p === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : p) + "). If you meant to render a collection of children, use an array instead.");
    }
    function vS(i) {
      {
        var o = lr(i) || "Component";
        if (o1[o])
          return;
        o1[o] = !0, u("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function ww(i) {
      var o = i._payload, p = i._init;
      return p(o);
    }
    function Cw(i) {
      function o(rt, Ot) {
        if (i) {
          var it = rt.deletions;
          it === null ? (rt.deletions = [Ot], rt.flags |= ii) : it.push(Ot);
        }
      }
      function p(rt, Ot) {
        if (!i)
          return null;
        for (var it = Ot; it !== null; )
          o(rt, it), it = it.sibling;
        return null;
      }
      function S(rt, Ot) {
        for (var it = /* @__PURE__ */ new Map(), nn = Ot; nn !== null; )
          nn.key !== null ? it.set(nn.key, nn) : it.set(nn.index, nn), nn = nn.sibling;
        return it;
      }
      function T(rt, Ot) {
        var it = US(rt, Ot);
        return it.index = 0, it.sibling = null, it;
      }
      function P(rt, Ot, it) {
        if (rt.index = it, !i)
          return rt.flags |= su, Ot;
        var nn = rt.alternate;
        if (nn !== null) {
          var On = nn.index;
          return On < Ot ? (rt.flags |= Hr, Ot) : On;
        } else
          return rt.flags |= Hr, Ot;
      }
      function H(rt) {
        return i && rt.alternate === null && (rt.flags |= Hr), rt;
      }
      function $(rt, Ot, it, nn) {
        if (Ot === null || Ot.tag !== D) {
          var On = YD(it, rt.mode, nn);
          return On.return = rt, On;
        } else {
          var Cn = T(Ot, it);
          return Cn.return = rt, Cn;
        }
      }
      function ee(rt, Ot, it, nn) {
        var On = it.type;
        if (On === _o)
          return _e(rt, Ot, it.props.children, nn, it.key);
        if (Ot !== null && (Ot.elementType === On || // Keep this check inline so it only runs on the false path:
        dU(Ot, it) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof On == "object" && On !== null && On.$$typeof === ze && ww(On) === Ot.type)) {
          var Cn = T(Ot, it.props);
          return Cn.ref = Jo(rt, Ot, it), Cn.return = rt, Cn._debugSource = it._source, Cn._debugOwner = it._owner, Cn;
        }
        var Mr = $D(it, rt.mode, nn);
        return Mr.ref = Jo(rt, Ot, it), Mr.return = rt, Mr;
      }
      function pe(rt, Ot, it, nn) {
        if (Ot === null || Ot.tag !== M || Ot.stateNode.containerInfo !== it.containerInfo || Ot.stateNode.implementation !== it.implementation) {
          var On = XD(it, rt.mode, nn);
          return On.return = rt, On;
        } else {
          var Cn = T(Ot, it.children || []);
          return Cn.return = rt, Cn;
        }
      }
      function _e(rt, Ot, it, nn, On) {
        if (Ot === null || Ot.tag !== U) {
          var Cn = Zy(it, rt.mode, nn, On);
          return Cn.return = rt, Cn;
        } else {
          var Mr = T(Ot, it);
          return Mr.return = rt, Mr;
        }
      }
      function Ge(rt, Ot, it) {
        if (typeof Ot == "string" && Ot !== "" || typeof Ot == "number") {
          var nn = YD("" + Ot, rt.mode, it);
          return nn.return = rt, nn;
        }
        if (typeof Ot == "object" && Ot !== null) {
          switch (Ot.$$typeof) {
            case _l: {
              var On = $D(Ot, rt.mode, it);
              return On.ref = Jo(rt, null, Ot), On.return = rt, On;
            }
            case ea: {
              var Cn = XD(Ot, rt.mode, it);
              return Cn.return = rt, Cn;
            }
            case ze: {
              var Mr = Ot._payload, Ir = Ot._init;
              return Ge(rt, Ir(Mr), it);
            }
          }
          if ($r(Ot) || Pr(Ot)) {
            var Ea = Zy(Ot, rt.mode, it, null);
            return Ea.return = rt, Ea;
          }
          w_(rt, Ot);
        }
        return typeof Ot == "function" && vS(rt), null;
      }
      function He(rt, Ot, it, nn) {
        var On = Ot !== null ? Ot.key : null;
        if (typeof it == "string" && it !== "" || typeof it == "number")
          return On !== null ? null : $(rt, Ot, "" + it, nn);
        if (typeof it == "object" && it !== null) {
          switch (it.$$typeof) {
            case _l:
              return it.key === On ? ee(rt, Ot, it, nn) : null;
            case ea:
              return it.key === On ? pe(rt, Ot, it, nn) : null;
            case ze: {
              var Cn = it._payload, Mr = it._init;
              return He(rt, Ot, Mr(Cn), nn);
            }
          }
          if ($r(it) || Pr(it))
            return On !== null ? null : _e(rt, Ot, it, nn, null);
          w_(rt, it);
        }
        return typeof it == "function" && vS(rt), null;
      }
      function ht(rt, Ot, it, nn, On) {
        if (typeof nn == "string" && nn !== "" || typeof nn == "number") {
          var Cn = rt.get(it) || null;
          return $(Ot, Cn, "" + nn, On);
        }
        if (typeof nn == "object" && nn !== null) {
          switch (nn.$$typeof) {
            case _l: {
              var Mr = rt.get(nn.key === null ? it : nn.key) || null;
              return ee(Ot, Mr, nn, On);
            }
            case ea: {
              var Ir = rt.get(nn.key === null ? it : nn.key) || null;
              return pe(Ot, Ir, nn, On);
            }
            case ze:
              var Ea = nn._payload, Qi = nn._init;
              return ht(rt, Ot, it, Qi(Ea), On);
          }
          if ($r(nn) || Pr(nn)) {
            var Zs = rt.get(it) || null;
            return _e(Ot, Zs, nn, On, null);
          }
          w_(Ot, nn);
        }
        return typeof nn == "function" && vS(Ot), null;
      }
      function mt(rt, Ot, it) {
        {
          if (typeof rt != "object" || rt === null)
            return Ot;
          switch (rt.$$typeof) {
            case _l:
            case ea:
              s1(rt, it);
              var nn = rt.key;
              if (typeof nn != "string")
                break;
              if (Ot === null) {
                Ot = /* @__PURE__ */ new Set(), Ot.add(nn);
                break;
              }
              if (!Ot.has(nn)) {
                Ot.add(nn);
                break;
              }
              u("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", nn);
              break;
            case ze:
              var On = rt._payload, Cn = rt._init;
              mt(Cn(On), Ot, it);
              break;
          }
        }
        return Ot;
      }
      function Lt(rt, Ot, it, nn) {
        for (var On = null, Cn = 0; Cn < it.length; Cn++) {
          var Mr = it[Cn];
          On = mt(Mr, On, rt);
        }
        for (var Ir = null, Ea = null, Qi = Ot, Zs = 0, Zi = 0, Ts = null; Qi !== null && Zi < it.length; Zi++) {
          Qi.index > Zi ? (Ts = Qi, Qi = null) : Ts = Qi.sibling;
          var wc = He(rt, Qi, it[Zi], nn);
          if (wc === null) {
            Qi === null && (Qi = Ts);
            break;
          }
          i && Qi && wc.alternate === null && o(rt, Qi), Zs = P(wc, Zs, Zi), Ea === null ? Ir = wc : Ea.sibling = wc, Ea = wc, Qi = Ts;
        }
        if (Zi === it.length) {
          if (p(rt, Qi), Pa()) {
            var Xu = Zi;
            tg(rt, Xu);
          }
          return Ir;
        }
        if (Qi === null) {
          for (; Zi < it.length; Zi++) {
            var nh = Ge(rt, it[Zi], nn);
            nh !== null && (Zs = P(nh, Zs, Zi), Ea === null ? Ir = nh : Ea.sibling = nh, Ea = nh);
          }
          if (Pa()) {
            var vf = Zi;
            tg(rt, vf);
          }
          return Ir;
        }
        for (var gf = S(rt, Qi); Zi < it.length; Zi++) {
          var Cc = ht(gf, rt, Zi, it[Zi], nn);
          Cc !== null && (i && Cc.alternate !== null && gf.delete(Cc.key === null ? Zi : Cc.key), Zs = P(Cc, Zs, Zi), Ea === null ? Ir = Cc : Ea.sibling = Cc, Ea = Cc);
        }
        if (i && gf.forEach(function(q_) {
          return o(rt, q_);
        }), Pa()) {
          var bg = Zi;
          tg(rt, bg);
        }
        return Ir;
      }
      function Ln(rt, Ot, it, nn) {
        var On = Pr(it);
        if (typeof On != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          it[Symbol.toStringTag] === "Generator" && (M_ || u("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), M_ = !0), it.entries === On && (r1 || u("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), r1 = !0);
          var Cn = On.call(it);
          if (Cn)
            for (var Mr = null, Ir = Cn.next(); !Ir.done; Ir = Cn.next()) {
              var Ea = Ir.value;
              Mr = mt(Ea, Mr, rt);
            }
        }
        var Qi = On.call(it);
        if (Qi == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Zs = null, Zi = null, Ts = Ot, wc = 0, Xu = 0, nh = null, vf = Qi.next(); Ts !== null && !vf.done; Xu++, vf = Qi.next()) {
          Ts.index > Xu ? (nh = Ts, Ts = null) : nh = Ts.sibling;
          var gf = He(rt, Ts, vf.value, nn);
          if (gf === null) {
            Ts === null && (Ts = nh);
            break;
          }
          i && Ts && gf.alternate === null && o(rt, Ts), wc = P(gf, wc, Xu), Zi === null ? Zs = gf : Zi.sibling = gf, Zi = gf, Ts = nh;
        }
        if (vf.done) {
          if (p(rt, Ts), Pa()) {
            var Cc = Xu;
            tg(rt, Cc);
          }
          return Zs;
        }
        if (Ts === null) {
          for (; !vf.done; Xu++, vf = Qi.next()) {
            var bg = Ge(rt, vf.value, nn);
            bg !== null && (wc = P(bg, wc, Xu), Zi === null ? Zs = bg : Zi.sibling = bg, Zi = bg);
          }
          if (Pa()) {
            var q_ = Xu;
            tg(rt, q_);
          }
          return Zs;
        }
        for (var j1 = S(rt, Ts); !vf.done; Xu++, vf = Qi.next()) {
          var fv = ht(j1, rt, Xu, vf.value, nn);
          fv !== null && (i && fv.alternate !== null && j1.delete(fv.key === null ? Xu : fv.key), wc = P(fv, wc, Xu), Zi === null ? Zs = fv : Zi.sibling = fv, Zi = fv);
        }
        if (i && j1.forEach(function(QG) {
          return o(rt, QG);
        }), Pa()) {
          var KG = Xu;
          tg(rt, KG);
        }
        return Zs;
      }
      function ur(rt, Ot, it, nn) {
        if (Ot !== null && Ot.tag === D) {
          p(rt, Ot.sibling);
          var On = T(Ot, it);
          return On.return = rt, On;
        }
        p(rt, Ot);
        var Cn = YD(it, rt.mode, nn);
        return Cn.return = rt, Cn;
      }
      function tr(rt, Ot, it, nn) {
        for (var On = it.key, Cn = Ot; Cn !== null; ) {
          if (Cn.key === On) {
            var Mr = it.type;
            if (Mr === _o) {
              if (Cn.tag === U) {
                p(rt, Cn.sibling);
                var Ir = T(Cn, it.props.children);
                return Ir.return = rt, Ir._debugSource = it._source, Ir._debugOwner = it._owner, Ir;
              }
            } else if (Cn.elementType === Mr || // Keep this check inline so it only runs on the false path:
            dU(Cn, it) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Mr == "object" && Mr !== null && Mr.$$typeof === ze && ww(Mr) === Cn.type) {
              p(rt, Cn.sibling);
              var Ea = T(Cn, it.props);
              return Ea.ref = Jo(rt, Cn, it), Ea.return = rt, Ea._debugSource = it._source, Ea._debugOwner = it._owner, Ea;
            }
            p(rt, Cn);
            break;
          } else
            o(rt, Cn);
          Cn = Cn.sibling;
        }
        if (it.type === _o) {
          var Qi = Zy(it.props.children, rt.mode, nn, it.key);
          return Qi.return = rt, Qi;
        } else {
          var Zs = $D(it, rt.mode, nn);
          return Zs.ref = Jo(rt, Ot, it), Zs.return = rt, Zs;
        }
      }
      function Pi(rt, Ot, it, nn) {
        for (var On = it.key, Cn = Ot; Cn !== null; ) {
          if (Cn.key === On)
            if (Cn.tag === M && Cn.stateNode.containerInfo === it.containerInfo && Cn.stateNode.implementation === it.implementation) {
              p(rt, Cn.sibling);
              var Mr = T(Cn, it.children || []);
              return Mr.return = rt, Mr;
            } else {
              p(rt, Cn);
              break;
            }
          else
            o(rt, Cn);
          Cn = Cn.sibling;
        }
        var Ir = XD(it, rt.mode, nn);
        return Ir.return = rt, Ir;
      }
      function bi(rt, Ot, it, nn) {
        var On = typeof it == "object" && it !== null && it.type === _o && it.key === null;
        if (On && (it = it.props.children), typeof it == "object" && it !== null) {
          switch (it.$$typeof) {
            case _l:
              return H(tr(rt, Ot, it, nn));
            case ea:
              return H(Pi(rt, Ot, it, nn));
            case ze:
              var Cn = it._payload, Mr = it._init;
              return bi(rt, Ot, Mr(Cn), nn);
          }
          if ($r(it))
            return Lt(rt, Ot, it, nn);
          if (Pr(it))
            return Ln(rt, Ot, it, nn);
          w_(rt, it);
        }
        return typeof it == "string" && it !== "" || typeof it == "number" ? H(ur(rt, Ot, "" + it, nn)) : (typeof it == "function" && vS(rt), p(rt, Ot));
      }
      return bi;
    }
    var Ny = Cw(!0), Rw = Cw(!1);
    function jA(i, o) {
      if (i !== null && o.child !== i.child)
        throw new Error("Resuming work not yet implemented.");
      if (o.child !== null) {
        var p = o.child, S = US(p, p.pendingProps);
        for (o.child = S, S.return = o; p.sibling !== null; )
          p = p.sibling, S = S.sibling = US(p, p.pendingProps), S.return = o;
        S.sibling = null;
      }
    }
    function Aw(i, o) {
      for (var p = i.child; p !== null; )
        pG(p, o), p = p.sibling;
    }
    var iv = {}, eh = Up(iv), Uy = Up(iv), zy = Up(iv);
    function C_(i) {
      if (i === iv)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return i;
    }
    function l1() {
      var i = C_(zy.current);
      return i;
    }
    function gS(i, o) {
      Su(zy, o, i), Su(Uy, i, i), Su(eh, iv, i);
      var p = hA(o);
      yu(eh, i), Su(eh, p, i);
    }
    function ky(i) {
      yu(eh, i), yu(Uy, i), yu(zy, i);
    }
    function dg() {
      var i = C_(eh.current);
      return i;
    }
    function R_(i) {
      C_(zy.current);
      var o = C_(eh.current), p = NM(o, i.type);
      o !== p && (Su(Uy, i, i), Su(eh, p, i));
    }
    function Iy(i) {
      Uy.current === i && (yu(eh, i), yu(Uy, i));
    }
    var Dw = 0, u1 = 1, Lw = 1, yS = 2, Ho = Up(Dw);
    function av(i, o) {
      return (i & o) !== 0;
    }
    function Fy(i) {
      return i & u1;
    }
    function ov(i, o) {
      return i & u1 | o;
    }
    function c1(i, o) {
      return i | o;
    }
    function $h(i, o) {
      Su(Ho, o, i);
    }
    function hg(i) {
      yu(Ho, i);
    }
    function Ow(i, o) {
      var p = i.memoizedState;
      return p !== null ? p.dehydrated !== null : (i.memoizedProps, !0);
    }
    function A_(i) {
      for (var o = i; o !== null; ) {
        if (o.tag === j) {
          var p = o.memoizedState;
          if (p !== null) {
            var S = p.dehydrated;
            if (S === null || Db(S) || Lb(S))
              return o;
          }
        } else if (o.tag === oe && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        o.memoizedProps.revealOrder !== void 0) {
          var T = (o.flags & dr) !== Kn;
          if (T)
            return o;
        } else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === i)
          return null;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === i)
            return null;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
      return null;
    }
    var Ec = (
      /*   */
      0
    ), es = (
      /* */
      1
    ), Yh = (
      /*  */
      2
    ), ts = (
      /*    */
      4
    ), Wl = (
      /*   */
      8
    ), f1 = [];
    function SS() {
      for (var i = 0; i < f1.length; i++) {
        var o = f1[i];
        o._workInProgressVersionPrimary = null;
      }
      f1.length = 0;
    }
    function Pw(i, o) {
      var p = o._getVersion, S = p(o._source);
      i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [o, S] : i.mutableSourceEagerHydrationData.push(o, S);
    }
    var wn = t.ReactCurrentDispatcher, jl = t.ReactCurrentBatchConfig, xS, By;
    xS = /* @__PURE__ */ new Set();
    var pg = Ct, Ri = null, Ks = null, Qs = null, Hy = !1, mg = !1, rd = 0, $A = 0, YA = 25, kt = null, ff = null, Xh = -1, d1 = !1;
    function Ki() {
      {
        var i = kt;
        ff === null ? ff = [i] : ff.push(i);
      }
    }
    function vn() {
      {
        var i = kt;
        ff !== null && (Xh++, ff[Xh] !== i && XA(i));
      }
    }
    function vg(i) {
      i != null && !$r(i) && u("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", kt, typeof i);
    }
    function XA(i) {
      {
        var o = lr(Ri);
        if (!xS.has(o) && (xS.add(o), ff !== null)) {
          for (var p = "", S = 30, T = 0; T <= Xh; T++) {
            for (var P = ff[T], H = T === Xh ? i : P, $ = T + 1 + ". " + P; $.length < S; )
              $ += " ";
            $ += H + `
`, p += $;
          }
          u(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, o, p);
        }
      }
    }
    function $l() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function h1(i, o) {
      if (d1)
        return !1;
      if (o === null)
        return u("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", kt), !1;
      i.length !== o.length && u(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, kt, "[" + o.join(", ") + "]", "[" + i.join(", ") + "]");
      for (var p = 0; p < o.length && p < i.length; p++)
        if (!In(i[p], o[p]))
          return !1;
      return !0;
    }
    function Vy(i, o, p, S, T, P) {
      pg = P, Ri = o, ff = i !== null ? i._debugHookTypes : null, Xh = -1, d1 = i !== null && i.type !== o.type, o.memoizedState = null, o.updateQueue = null, o.lanes = Ct, i !== null && i.memoizedState !== null ? wn.current = un : ff !== null ? wn.current = ut : wn.current = Nt;
      var H = p(S, T);
      if (mg) {
        var $ = 0;
        do {
          if (mg = !1, rd = 0, $ >= YA)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          $ += 1, d1 = !1, Ks = null, Qs = null, o.updateQueue = null, Xh = -1, wn.current = $n, H = p(S, T);
        } while (mg);
      }
      wn.current = ct, o._debugHookTypes = ff;
      var ee = Ks !== null && Ks.next !== null;
      if (pg = Ct, Ri = null, Ks = null, Qs = null, kt = null, ff = null, Xh = -1, i !== null && (i.flags & rn) !== (o.flags & rn) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (i.mode & Rr) !== Qn && u("Internal React error: Expected static flag was missing. Please notify the React team."), Hy = !1, ee)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return H;
    }
    function sv() {
      var i = rd !== 0;
      return rd = 0, i;
    }
    function D_(i, o, p) {
      o.updateQueue = i.updateQueue, (o.mode & wo) !== Qn ? o.flags &= ~(lu | hi | ua | Hn) : o.flags &= ~(ua | Hn), i.lanes = Dn(i.lanes, p);
    }
    function p1() {
      if (wn.current = ct, Hy) {
        for (var i = Ri.memoizedState; i !== null; ) {
          var o = i.queue;
          o !== null && (o.pending = null), i = i.next;
        }
        Hy = !1;
      }
      pg = Ct, Ri = null, Ks = null, Qs = null, ff = null, Xh = -1, kt = null, tt = !1, mg = !1, rd = 0;
    }
    function qh() {
      var i = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Qs === null ? Ri.memoizedState = Qs = i : Qs = Qs.next = i, Qs;
    }
    function id() {
      var i;
      if (Ks === null) {
        var o = Ri.alternate;
        o !== null ? i = o.memoizedState : i = null;
      } else
        i = Ks.next;
      var p;
      if (Qs === null ? p = Ri.memoizedState : p = Qs.next, p !== null)
        Qs = p, p = Qs.next, Ks = i;
      else {
        if (i === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Ks = i;
        var S = {
          memoizedState: Ks.memoizedState,
          baseState: Ks.baseState,
          baseQueue: Ks.baseQueue,
          queue: Ks.queue,
          next: null
        };
        Qs === null ? Ri.memoizedState = Qs = S : Qs = Qs.next = S;
      }
      return Qs;
    }
    function Nw() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function m1(i, o) {
      return typeof o == "function" ? o(i) : o;
    }
    function L_(i, o, p) {
      var S = qh(), T;
      p !== void 0 ? T = p(o) : T = o, S.memoizedState = S.baseState = T;
      var P = {
        pending: null,
        interleaved: null,
        lanes: Ct,
        dispatch: null,
        lastRenderedReducer: i,
        lastRenderedState: T
      };
      S.queue = P;
      var H = P.dispatch = an.bind(null, Ri, P);
      return [S.memoizedState, H];
    }
    function v1(i, o, p) {
      var S = id(), T = S.queue;
      if (T === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      T.lastRenderedReducer = i;
      var P = Ks, H = P.baseQueue, $ = T.pending;
      if ($ !== null) {
        if (H !== null) {
          var ee = H.next, pe = $.next;
          H.next = pe, $.next = ee;
        }
        P.baseQueue !== H && u("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), P.baseQueue = H = $, T.pending = null;
      }
      if (H !== null) {
        var _e = H.next, Ge = P.baseState, He = null, ht = null, mt = null, Lt = _e;
        do {
          var Ln = Lt.lane;
          if (vt(pg, Ln)) {
            if (mt !== null) {
              var tr = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Jr,
                action: Lt.action,
                hasEagerState: Lt.hasEagerState,
                eagerState: Lt.eagerState,
                next: null
              };
              mt = mt.next = tr;
            }
            if (Lt.hasEagerState)
              Ge = Lt.eagerState;
            else {
              var Pi = Lt.action;
              Ge = i(Ge, Pi);
            }
          } else {
            var ur = {
              lane: Ln,
              action: Lt.action,
              hasEagerState: Lt.hasEagerState,
              eagerState: Lt.eagerState,
              next: null
            };
            mt === null ? (ht = mt = ur, He = Ge) : mt = mt.next = ur, Ri.lanes = Pt(Ri.lanes, Ln), B1(Ln);
          }
          Lt = Lt.next;
        } while (Lt !== null && Lt !== _e);
        mt === null ? He = Ge : mt.next = ht, In(Ge, S.memoizedState) || R1(), S.memoizedState = Ge, S.baseState = He, S.baseQueue = mt, T.lastRenderedState = Ge;
      }
      var bi = T.interleaved;
      if (bi !== null) {
        var rt = bi;
        do {
          var Ot = rt.lane;
          Ri.lanes = Pt(Ri.lanes, Ot), B1(Ot), rt = rt.next;
        } while (rt !== bi);
      } else
        H === null && (T.lanes = Ct);
      var it = T.dispatch;
      return [S.memoizedState, it];
    }
    function g1(i, o, p) {
      var S = id(), T = S.queue;
      if (T === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      T.lastRenderedReducer = i;
      var P = T.dispatch, H = T.pending, $ = S.memoizedState;
      if (H !== null) {
        T.pending = null;
        var ee = H.next, pe = ee;
        do {
          var _e = pe.action;
          $ = i($, _e), pe = pe.next;
        } while (pe !== ee);
        In($, S.memoizedState) || R1(), S.memoizedState = $, S.baseQueue === null && (S.baseState = $), T.lastRenderedState = $;
      }
      return [$, P];
    }
    function qA(i, o, p) {
    }
    function Uw(i, o, p) {
    }
    function y1(i, o, p) {
      var S = Ri, T = qh(), P, H = Pa();
      if (H) {
        if (p === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        P = p(), By || P !== p() && (u("The result of getServerSnapshot should be cached to avoid an infinite loop"), By = !0);
      } else {
        if (P = o(), !By) {
          var $ = o();
          In(P, $) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), By = !0);
        }
        var ee = qw();
        if (ee === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Qt(ee, pg) || zw(S, o, P);
      }
      T.memoizedState = P;
      var pe = {
        value: P,
        getSnapshot: o
      };
      return T.queue = pe, TS(x1.bind(null, S, pe, i), [i]), S.flags |= ua, Gy(es | Wl, S1.bind(null, S, pe, P, o), void 0, null), P;
    }
    function O_(i, o, p) {
      var S = Ri, T = id(), P = o();
      if (!By) {
        var H = o();
        In(P, H) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), By = !0);
      }
      var $ = T.memoizedState, ee = !In($, P);
      ee && (T.memoizedState = P, R1());
      var pe = T.queue;
      if (jy(x1.bind(null, S, pe, i), [i]), pe.getSnapshot !== o || ee || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Qs !== null && Qs.memoizedState.tag & es) {
        S.flags |= ua, Gy(es | Wl, S1.bind(null, S, pe, P, o), void 0, null);
        var _e = qw();
        if (_e === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Qt(_e, pg) || zw(S, o, P);
      }
      return P;
    }
    function zw(i, o, p) {
      i.flags |= If;
      var S = {
        getSnapshot: o,
        value: p
      }, T = Ri.updateQueue;
      if (T === null)
        T = Nw(), Ri.updateQueue = T, T.stores = [S];
      else {
        var P = T.stores;
        P === null ? T.stores = [S] : P.push(S);
      }
    }
    function S1(i, o, p, S) {
      o.value = p, o.getSnapshot = S, _1(o) && E1(i);
    }
    function x1(i, o, p) {
      var S = function() {
        _1(o) && E1(i);
      };
      return p(S);
    }
    function _1(i) {
      var o = i.getSnapshot, p = i.value;
      try {
        var S = o();
        return !In(p, S);
      } catch {
        return !0;
      }
    }
    function E1(i) {
      var o = Vl(i, Wn);
      o !== null && Kl(o, i, Wn, Xr);
    }
    function _S(i) {
      var o = qh();
      typeof i == "function" && (i = i()), o.memoizedState = o.baseState = i;
      var p = {
        pending: null,
        interleaved: null,
        lanes: Ct,
        dispatch: null,
        lastRenderedReducer: m1,
        lastRenderedState: i
      };
      o.queue = p;
      var S = p.dispatch = or.bind(null, Ri, p);
      return [o.memoizedState, S];
    }
    function P_(i) {
      return v1(m1);
    }
    function N_(i) {
      return g1(m1);
    }
    function Gy(i, o, p, S) {
      var T = {
        tag: i,
        create: o,
        destroy: p,
        deps: S,
        // Circular
        next: null
      }, P = Ri.updateQueue;
      if (P === null)
        P = Nw(), Ri.updateQueue = P, P.lastEffect = T.next = T;
      else {
        var H = P.lastEffect;
        if (H === null)
          P.lastEffect = T.next = T;
        else {
          var $ = H.next;
          H.next = T, T.next = $, P.lastEffect = T;
        }
      }
      return T;
    }
    function U_(i) {
      var o = qh();
      {
        var p = {
          current: i
        };
        return o.memoizedState = p, p;
      }
    }
    function ES(i) {
      var o = id();
      return o.memoizedState;
    }
    function Wy(i, o, p, S) {
      var T = qh(), P = S === void 0 ? null : S;
      Ri.flags |= i, T.memoizedState = Gy(es | o, p, void 0, P);
    }
    function bS(i, o, p, S) {
      var T = id(), P = S === void 0 ? null : S, H = void 0;
      if (Ks !== null) {
        var $ = Ks.memoizedState;
        if (H = $.destroy, P !== null) {
          var ee = $.deps;
          if (h1(P, ee)) {
            T.memoizedState = Gy(o, p, H, P);
            return;
          }
        }
      }
      Ri.flags |= i, T.memoizedState = Gy(es | o, p, H, P);
    }
    function TS(i, o) {
      return (Ri.mode & wo) !== Qn ? Wy(lu | ua | Du, Wl, i, o) : Wy(ua | Du, Wl, i, o);
    }
    function jy(i, o) {
      return bS(ua, Wl, i, o);
    }
    function z_(i, o) {
      return Wy(Hn, Yh, i, o);
    }
    function MS(i, o) {
      return bS(Hn, Yh, i, o);
    }
    function k_(i, o) {
      var p = Hn;
      return p |= Fa, (Ri.mode & wo) !== Qn && (p |= hi), Wy(p, ts, i, o);
    }
    function wS(i, o) {
      return bS(Hn, ts, i, o);
    }
    function b1(i, o) {
      if (typeof o == "function") {
        var p = o, S = i();
        return p(S), function() {
          p(null);
        };
      } else if (o != null) {
        var T = o;
        T.hasOwnProperty("current") || u("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(T).join(", ") + "}");
        var P = i();
        return T.current = P, function() {
          T.current = null;
        };
      }
    }
    function CS(i, o, p) {
      typeof o != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", o !== null ? typeof o : "null");
      var S = p != null ? p.concat([i]) : null, T = Hn;
      return T |= Fa, (Ri.mode & wo) !== Qn && (T |= hi), Wy(T, ts, b1.bind(null, o, i), S);
    }
    function I_(i, o, p) {
      typeof o != "function" && u("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", o !== null ? typeof o : "null");
      var S = p != null ? p.concat([i]) : null;
      return bS(Hn, ts, b1.bind(null, o, i), S);
    }
    function KA(i, o) {
    }
    var F_ = KA;
    function T1(i, o) {
      var p = qh(), S = o === void 0 ? null : o;
      return p.memoizedState = [i, S], i;
    }
    function l(i, o) {
      var p = id(), S = o === void 0 ? null : o, T = p.memoizedState;
      if (T !== null && S !== null) {
        var P = T[1];
        if (h1(S, P))
          return T[0];
      }
      return p.memoizedState = [i, S], i;
    }
    function f(i, o) {
      var p = qh(), S = o === void 0 ? null : o, T = i();
      return p.memoizedState = [T, S], T;
    }
    function E(i, o) {
      var p = id(), S = o === void 0 ? null : o, T = p.memoizedState;
      if (T !== null && S !== null) {
        var P = T[1];
        if (h1(S, P))
          return T[0];
      }
      var H = i();
      return p.memoizedState = [H, S], H;
    }
    function w(i) {
      var o = qh();
      return o.memoizedState = i, i;
    }
    function L(i) {
      var o = id(), p = Ks, S = p.memoizedState;
      return K(o, S, i);
    }
    function B(i) {
      var o = id();
      if (Ks === null)
        return o.memoizedState = i, i;
      var p = Ks.memoizedState;
      return K(o, p, i);
    }
    function K(i, o, p) {
      var S = !We(pg);
      if (S) {
        if (!In(p, o)) {
          var T = Jn();
          Ri.lanes = Pt(Ri.lanes, T), B1(T), i.baseState = !0;
        }
        return o;
      } else
        return i.baseState && (i.baseState = !1, R1()), i.memoizedState = p, p;
    }
    function re(i, o, p) {
      var S = zu();
      yo(ys(S, qo)), i(!0);
      var T = jl.transition;
      jl.transition = {};
      var P = jl.transition;
      jl.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        i(!1), o();
      } finally {
        if (yo(S), jl.transition = T, T === null && P._updatedFibers) {
          var H = P._updatedFibers.size;
          H > 10 && s("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), P._updatedFibers.clear();
        }
      }
    }
    function fe() {
      var i = _S(!1), o = i[0], p = i[1], S = re.bind(null, p), T = qh();
      return T.memoizedState = S, [o, S];
    }
    function Ce() {
      var i = P_(), o = i[0], p = id(), S = p.memoizedState;
      return [o, S];
    }
    function ke() {
      var i = N_(), o = i[0], p = id(), S = p.memoizedState;
      return [o, S];
    }
    var tt = !1;
    function Et() {
      return tt;
    }
    function Dt() {
      var i = qh(), o = qw(), p = o.identifierPrefix, S;
      if (Pa()) {
        var T = IA();
        S = ":" + p + "R" + T;
        var P = rd++;
        P > 0 && (S += "H" + P.toString(32)), S += ":";
      } else {
        var H = $A++;
        S = ":" + p + "r" + H.toString(32) + ":";
      }
      return i.memoizedState = S, S;
    }
    function Xt() {
      var i = id(), o = i.memoizedState;
      return o;
    }
    function an(i, o, p) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var S = Ky(i), T = {
        lane: S,
        action: p,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Wr(i))
        hr(o, T);
      else {
        var P = gw(i, o, T, S);
        if (P !== null) {
          var H = mf();
          Kl(P, i, S, H), Xa(P, o, S);
        }
      }
      qa(i, S);
    }
    function or(i, o, p) {
      typeof arguments[3] == "function" && u("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var S = Ky(i), T = {
        lane: S,
        action: p,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Wr(i))
        hr(o, T);
      else {
        var P = i.alternate;
        if (i.lanes === Ct && (P === null || P.lanes === Ct)) {
          var H = o.lastRenderedReducer;
          if (H !== null) {
            var $;
            $ = wn.current, wn.current = Dr;
            try {
              var ee = o.lastRenderedState, pe = H(ee, p);
              if (T.hasEagerState = !0, T.eagerState = pe, In(pe, ee)) {
                p_(i, o, T, S);
                return;
              }
            } catch {
            } finally {
              wn.current = $;
            }
          }
        }
        var _e = gw(i, o, T, S);
        if (_e !== null) {
          var Ge = mf();
          Kl(_e, i, S, Ge), Xa(_e, o, S);
        }
      }
      qa(i, S);
    }
    function Wr(i) {
      var o = i.alternate;
      return i === Ri || o !== null && o === Ri;
    }
    function hr(i, o) {
      mg = Hy = !0;
      var p = i.pending;
      p === null ? o.next = o : (o.next = p.next, p.next = o), i.pending = o;
    }
    function Xa(i, o, p) {
      if (sr(p)) {
        var S = o.lanes;
        S = Ar(S, i.pendingLanes);
        var T = Pt(S, p);
        o.lanes = T, gp(i, T);
      }
    }
    function qa(i, o, p) {
      du(i, o);
    }
    var ct = {
      readContext: Fo,
      useCallback: $l,
      useContext: $l,
      useEffect: $l,
      useImperativeHandle: $l,
      useInsertionEffect: $l,
      useLayoutEffect: $l,
      useMemo: $l,
      useReducer: $l,
      useRef: $l,
      useState: $l,
      useDebugValue: $l,
      useDeferredValue: $l,
      useTransition: $l,
      useMutableSource: $l,
      useSyncExternalStore: $l,
      useId: $l,
      unstable_isNewReconciler: ue
    }, Nt = null, ut = null, un = null, $n = null, Sn = null, Dr = null, Bi = null;
    {
      var ga = function() {
        u("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, xn = function() {
        u("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Nt = {
        readContext: function(i) {
          return Fo(i);
        },
        useCallback: function(i, o) {
          return kt = "useCallback", Ki(), vg(o), T1(i, o);
        },
        useContext: function(i) {
          return kt = "useContext", Ki(), Fo(i);
        },
        useEffect: function(i, o) {
          return kt = "useEffect", Ki(), vg(o), TS(i, o);
        },
        useImperativeHandle: function(i, o, p) {
          return kt = "useImperativeHandle", Ki(), vg(p), CS(i, o, p);
        },
        useInsertionEffect: function(i, o) {
          return kt = "useInsertionEffect", Ki(), vg(o), z_(i, o);
        },
        useLayoutEffect: function(i, o) {
          return kt = "useLayoutEffect", Ki(), vg(o), k_(i, o);
        },
        useMemo: function(i, o) {
          kt = "useMemo", Ki(), vg(o);
          var p = wn.current;
          wn.current = Sn;
          try {
            return f(i, o);
          } finally {
            wn.current = p;
          }
        },
        useReducer: function(i, o, p) {
          kt = "useReducer", Ki();
          var S = wn.current;
          wn.current = Sn;
          try {
            return L_(i, o, p);
          } finally {
            wn.current = S;
          }
        },
        useRef: function(i) {
          return kt = "useRef", Ki(), U_(i);
        },
        useState: function(i) {
          kt = "useState", Ki();
          var o = wn.current;
          wn.current = Sn;
          try {
            return _S(i);
          } finally {
            wn.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return kt = "useDebugValue", Ki(), void 0;
        },
        useDeferredValue: function(i) {
          return kt = "useDeferredValue", Ki(), w(i);
        },
        useTransition: function() {
          return kt = "useTransition", Ki(), fe();
        },
        useMutableSource: function(i, o, p) {
          return kt = "useMutableSource", Ki(), void 0;
        },
        useSyncExternalStore: function(i, o, p) {
          return kt = "useSyncExternalStore", Ki(), y1(i, o, p);
        },
        useId: function() {
          return kt = "useId", Ki(), Dt();
        },
        unstable_isNewReconciler: ue
      }, ut = {
        readContext: function(i) {
          return Fo(i);
        },
        useCallback: function(i, o) {
          return kt = "useCallback", vn(), T1(i, o);
        },
        useContext: function(i) {
          return kt = "useContext", vn(), Fo(i);
        },
        useEffect: function(i, o) {
          return kt = "useEffect", vn(), TS(i, o);
        },
        useImperativeHandle: function(i, o, p) {
          return kt = "useImperativeHandle", vn(), CS(i, o, p);
        },
        useInsertionEffect: function(i, o) {
          return kt = "useInsertionEffect", vn(), z_(i, o);
        },
        useLayoutEffect: function(i, o) {
          return kt = "useLayoutEffect", vn(), k_(i, o);
        },
        useMemo: function(i, o) {
          kt = "useMemo", vn();
          var p = wn.current;
          wn.current = Sn;
          try {
            return f(i, o);
          } finally {
            wn.current = p;
          }
        },
        useReducer: function(i, o, p) {
          kt = "useReducer", vn();
          var S = wn.current;
          wn.current = Sn;
          try {
            return L_(i, o, p);
          } finally {
            wn.current = S;
          }
        },
        useRef: function(i) {
          return kt = "useRef", vn(), U_(i);
        },
        useState: function(i) {
          kt = "useState", vn();
          var o = wn.current;
          wn.current = Sn;
          try {
            return _S(i);
          } finally {
            wn.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return kt = "useDebugValue", vn(), void 0;
        },
        useDeferredValue: function(i) {
          return kt = "useDeferredValue", vn(), w(i);
        },
        useTransition: function() {
          return kt = "useTransition", vn(), fe();
        },
        useMutableSource: function(i, o, p) {
          return kt = "useMutableSource", vn(), void 0;
        },
        useSyncExternalStore: function(i, o, p) {
          return kt = "useSyncExternalStore", vn(), y1(i, o, p);
        },
        useId: function() {
          return kt = "useId", vn(), Dt();
        },
        unstable_isNewReconciler: ue
      }, un = {
        readContext: function(i) {
          return Fo(i);
        },
        useCallback: function(i, o) {
          return kt = "useCallback", vn(), l(i, o);
        },
        useContext: function(i) {
          return kt = "useContext", vn(), Fo(i);
        },
        useEffect: function(i, o) {
          return kt = "useEffect", vn(), jy(i, o);
        },
        useImperativeHandle: function(i, o, p) {
          return kt = "useImperativeHandle", vn(), I_(i, o, p);
        },
        useInsertionEffect: function(i, o) {
          return kt = "useInsertionEffect", vn(), MS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return kt = "useLayoutEffect", vn(), wS(i, o);
        },
        useMemo: function(i, o) {
          kt = "useMemo", vn();
          var p = wn.current;
          wn.current = Dr;
          try {
            return E(i, o);
          } finally {
            wn.current = p;
          }
        },
        useReducer: function(i, o, p) {
          kt = "useReducer", vn();
          var S = wn.current;
          wn.current = Dr;
          try {
            return v1(i, o, p);
          } finally {
            wn.current = S;
          }
        },
        useRef: function(i) {
          return kt = "useRef", vn(), ES();
        },
        useState: function(i) {
          kt = "useState", vn();
          var o = wn.current;
          wn.current = Dr;
          try {
            return P_(i);
          } finally {
            wn.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return kt = "useDebugValue", vn(), F_();
        },
        useDeferredValue: function(i) {
          return kt = "useDeferredValue", vn(), L(i);
        },
        useTransition: function() {
          return kt = "useTransition", vn(), Ce();
        },
        useMutableSource: function(i, o, p) {
          return kt = "useMutableSource", vn(), void 0;
        },
        useSyncExternalStore: function(i, o, p) {
          return kt = "useSyncExternalStore", vn(), O_(i, o);
        },
        useId: function() {
          return kt = "useId", vn(), Xt();
        },
        unstable_isNewReconciler: ue
      }, $n = {
        readContext: function(i) {
          return Fo(i);
        },
        useCallback: function(i, o) {
          return kt = "useCallback", vn(), l(i, o);
        },
        useContext: function(i) {
          return kt = "useContext", vn(), Fo(i);
        },
        useEffect: function(i, o) {
          return kt = "useEffect", vn(), jy(i, o);
        },
        useImperativeHandle: function(i, o, p) {
          return kt = "useImperativeHandle", vn(), I_(i, o, p);
        },
        useInsertionEffect: function(i, o) {
          return kt = "useInsertionEffect", vn(), MS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return kt = "useLayoutEffect", vn(), wS(i, o);
        },
        useMemo: function(i, o) {
          kt = "useMemo", vn();
          var p = wn.current;
          wn.current = Bi;
          try {
            return E(i, o);
          } finally {
            wn.current = p;
          }
        },
        useReducer: function(i, o, p) {
          kt = "useReducer", vn();
          var S = wn.current;
          wn.current = Bi;
          try {
            return g1(i, o, p);
          } finally {
            wn.current = S;
          }
        },
        useRef: function(i) {
          return kt = "useRef", vn(), ES();
        },
        useState: function(i) {
          kt = "useState", vn();
          var o = wn.current;
          wn.current = Bi;
          try {
            return N_(i);
          } finally {
            wn.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return kt = "useDebugValue", vn(), F_();
        },
        useDeferredValue: function(i) {
          return kt = "useDeferredValue", vn(), B(i);
        },
        useTransition: function() {
          return kt = "useTransition", vn(), ke();
        },
        useMutableSource: function(i, o, p) {
          return kt = "useMutableSource", vn(), void 0;
        },
        useSyncExternalStore: function(i, o, p) {
          return kt = "useSyncExternalStore", vn(), O_(i, o);
        },
        useId: function() {
          return kt = "useId", vn(), Xt();
        },
        unstable_isNewReconciler: ue
      }, Sn = {
        readContext: function(i) {
          return ga(), Fo(i);
        },
        useCallback: function(i, o) {
          return kt = "useCallback", xn(), Ki(), T1(i, o);
        },
        useContext: function(i) {
          return kt = "useContext", xn(), Ki(), Fo(i);
        },
        useEffect: function(i, o) {
          return kt = "useEffect", xn(), Ki(), TS(i, o);
        },
        useImperativeHandle: function(i, o, p) {
          return kt = "useImperativeHandle", xn(), Ki(), CS(i, o, p);
        },
        useInsertionEffect: function(i, o) {
          return kt = "useInsertionEffect", xn(), Ki(), z_(i, o);
        },
        useLayoutEffect: function(i, o) {
          return kt = "useLayoutEffect", xn(), Ki(), k_(i, o);
        },
        useMemo: function(i, o) {
          kt = "useMemo", xn(), Ki();
          var p = wn.current;
          wn.current = Sn;
          try {
            return f(i, o);
          } finally {
            wn.current = p;
          }
        },
        useReducer: function(i, o, p) {
          kt = "useReducer", xn(), Ki();
          var S = wn.current;
          wn.current = Sn;
          try {
            return L_(i, o, p);
          } finally {
            wn.current = S;
          }
        },
        useRef: function(i) {
          return kt = "useRef", xn(), Ki(), U_(i);
        },
        useState: function(i) {
          kt = "useState", xn(), Ki();
          var o = wn.current;
          wn.current = Sn;
          try {
            return _S(i);
          } finally {
            wn.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return kt = "useDebugValue", xn(), Ki(), void 0;
        },
        useDeferredValue: function(i) {
          return kt = "useDeferredValue", xn(), Ki(), w(i);
        },
        useTransition: function() {
          return kt = "useTransition", xn(), Ki(), fe();
        },
        useMutableSource: function(i, o, p) {
          return kt = "useMutableSource", xn(), Ki(), void 0;
        },
        useSyncExternalStore: function(i, o, p) {
          return kt = "useSyncExternalStore", xn(), Ki(), y1(i, o, p);
        },
        useId: function() {
          return kt = "useId", xn(), Ki(), Dt();
        },
        unstable_isNewReconciler: ue
      }, Dr = {
        readContext: function(i) {
          return ga(), Fo(i);
        },
        useCallback: function(i, o) {
          return kt = "useCallback", xn(), vn(), l(i, o);
        },
        useContext: function(i) {
          return kt = "useContext", xn(), vn(), Fo(i);
        },
        useEffect: function(i, o) {
          return kt = "useEffect", xn(), vn(), jy(i, o);
        },
        useImperativeHandle: function(i, o, p) {
          return kt = "useImperativeHandle", xn(), vn(), I_(i, o, p);
        },
        useInsertionEffect: function(i, o) {
          return kt = "useInsertionEffect", xn(), vn(), MS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return kt = "useLayoutEffect", xn(), vn(), wS(i, o);
        },
        useMemo: function(i, o) {
          kt = "useMemo", xn(), vn();
          var p = wn.current;
          wn.current = Dr;
          try {
            return E(i, o);
          } finally {
            wn.current = p;
          }
        },
        useReducer: function(i, o, p) {
          kt = "useReducer", xn(), vn();
          var S = wn.current;
          wn.current = Dr;
          try {
            return v1(i, o, p);
          } finally {
            wn.current = S;
          }
        },
        useRef: function(i) {
          return kt = "useRef", xn(), vn(), ES();
        },
        useState: function(i) {
          kt = "useState", xn(), vn();
          var o = wn.current;
          wn.current = Dr;
          try {
            return P_(i);
          } finally {
            wn.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return kt = "useDebugValue", xn(), vn(), F_();
        },
        useDeferredValue: function(i) {
          return kt = "useDeferredValue", xn(), vn(), L(i);
        },
        useTransition: function() {
          return kt = "useTransition", xn(), vn(), Ce();
        },
        useMutableSource: function(i, o, p) {
          return kt = "useMutableSource", xn(), vn(), void 0;
        },
        useSyncExternalStore: function(i, o, p) {
          return kt = "useSyncExternalStore", xn(), vn(), O_(i, o);
        },
        useId: function() {
          return kt = "useId", xn(), vn(), Xt();
        },
        unstable_isNewReconciler: ue
      }, Bi = {
        readContext: function(i) {
          return ga(), Fo(i);
        },
        useCallback: function(i, o) {
          return kt = "useCallback", xn(), vn(), l(i, o);
        },
        useContext: function(i) {
          return kt = "useContext", xn(), vn(), Fo(i);
        },
        useEffect: function(i, o) {
          return kt = "useEffect", xn(), vn(), jy(i, o);
        },
        useImperativeHandle: function(i, o, p) {
          return kt = "useImperativeHandle", xn(), vn(), I_(i, o, p);
        },
        useInsertionEffect: function(i, o) {
          return kt = "useInsertionEffect", xn(), vn(), MS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return kt = "useLayoutEffect", xn(), vn(), wS(i, o);
        },
        useMemo: function(i, o) {
          kt = "useMemo", xn(), vn();
          var p = wn.current;
          wn.current = Dr;
          try {
            return E(i, o);
          } finally {
            wn.current = p;
          }
        },
        useReducer: function(i, o, p) {
          kt = "useReducer", xn(), vn();
          var S = wn.current;
          wn.current = Dr;
          try {
            return g1(i, o, p);
          } finally {
            wn.current = S;
          }
        },
        useRef: function(i) {
          return kt = "useRef", xn(), vn(), ES();
        },
        useState: function(i) {
          kt = "useState", xn(), vn();
          var o = wn.current;
          wn.current = Dr;
          try {
            return N_(i);
          } finally {
            wn.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return kt = "useDebugValue", xn(), vn(), F_();
        },
        useDeferredValue: function(i) {
          return kt = "useDeferredValue", xn(), vn(), B(i);
        },
        useTransition: function() {
          return kt = "useTransition", xn(), vn(), ke();
        },
        useMutableSource: function(i, o, p) {
          return kt = "useMutableSource", xn(), vn(), void 0;
        },
        useSyncExternalStore: function(i, o, p) {
          return kt = "useSyncExternalStore", xn(), vn(), O_(i, o);
        },
        useId: function() {
          return kt = "useId", xn(), vn(), Xt();
        },
        unstable_isNewReconciler: ue
      };
    }
    var da = e.unstable_now, Hi = 0, qr = -1, ao = -1, Ka = -1, bc = !1, bs = !1;
    function Tc() {
      return bc;
    }
    function df() {
      bs = !0;
    }
    function Kh() {
      bc = !1, bs = !1;
    }
    function $y() {
      bc = bs, bs = !1;
    }
    function gg() {
      return Hi;
    }
    function Mc() {
      Hi = da();
    }
    function Vp(i) {
      ao = da(), i.actualStartTime < 0 && (i.actualStartTime = da());
    }
    function B_(i) {
      ao = -1;
    }
    function RS(i, o) {
      if (ao >= 0) {
        var p = da() - ao;
        i.actualDuration += p, o && (i.selfBaseDuration = p), ao = -1;
      }
    }
    function Qh(i) {
      if (qr >= 0) {
        var o = da() - qr;
        qr = -1;
        for (var p = i.return; p !== null; ) {
          switch (p.tag) {
            case b:
              var S = p.stateNode;
              S.effectDuration += o;
              return;
            case G:
              var T = p.stateNode;
              T.effectDuration += o;
              return;
          }
          p = p.return;
        }
      }
    }
    function M1(i) {
      if (Ka >= 0) {
        var o = da() - Ka;
        Ka = -1;
        for (var p = i.return; p !== null; ) {
          switch (p.tag) {
            case b:
              var S = p.stateNode;
              S !== null && (S.passiveEffectDuration += o);
              return;
            case G:
              var T = p.stateNode;
              T !== null && (T.passiveEffectDuration += o);
              return;
          }
          p = p.return;
        }
      }
    }
    function lv() {
      qr = da();
    }
    function QA() {
      Ka = da();
    }
    function ZA(i) {
      for (var o = i.child; o; )
        i.actualDuration += o.actualDuration, o = o.sibling;
    }
    function AS(i, o) {
      return {
        value: i,
        source: o,
        stack: Ml(o),
        digest: null
      };
    }
    function JA(i, o, p) {
      return {
        value: i,
        source: null,
        stack: p ?? null,
        digest: o ?? null
      };
    }
    function tV(i, o) {
      return !0;
    }
    function eD(i, o) {
      try {
        var p = tV(i, o);
        if (p === !1)
          return;
        var S = o.value, T = o.source, P = o.stack, H = P !== null ? P : "";
        if (S != null && S._suppressLogging) {
          if (i.tag === y)
            return;
          console.error(S);
        }
        var $ = T ? lr(T) : null, ee = $ ? "The above error occurred in the <" + $ + "> component:" : "The above error occurred in one of your React components:", pe;
        if (i.tag === b)
          pe = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var _e = lr(i) || "Anonymous";
          pe = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + _e + ".");
        }
        var Ge = ee + `
` + H + `

` + ("" + pe);
        console.error(Ge);
      } catch (He) {
        setTimeout(function() {
          throw He;
        });
      }
    }
    var nV = typeof WeakMap == "function" ? WeakMap : Map;
    function nN(i, o, p) {
      var S = Gh(Xr, p);
      S.tag = Kb, S.payload = {
        element: null
      };
      var T = o.value;
      return S.callback = function() {
        X5(T), eD(i, o);
      }, S;
    }
    function tD(i, o, p) {
      var S = Gh(Xr, p);
      S.tag = Kb;
      var T = i.type.getDerivedStateFromError;
      if (typeof T == "function") {
        var P = o.value;
        S.payload = function() {
          return T(P);
        }, S.callback = function() {
          hU(i), eD(i, o);
        };
      }
      var H = i.stateNode;
      return H !== null && typeof H.componentDidCatch == "function" && (S.callback = function() {
        hU(i), eD(i, o), typeof T != "function" && $5(this);
        var ee = o.value, pe = o.stack;
        this.componentDidCatch(ee, {
          componentStack: pe !== null ? pe : ""
        }), typeof T != "function" && (Be(i.lanes, Wn) || u("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", lr(i) || "Unknown"));
      }), S;
    }
    function rN(i, o, p) {
      var S = i.pingCache, T;
      if (S === null ? (S = i.pingCache = new nV(), T = /* @__PURE__ */ new Set(), S.set(o, T)) : (T = S.get(o), T === void 0 && (T = /* @__PURE__ */ new Set(), S.set(o, T))), !T.has(p)) {
        T.add(p);
        var P = q5.bind(null, i, o, p);
        Ba && H1(i, p), o.then(P, P);
      }
    }
    function rV(i, o, p, S) {
      var T = i.updateQueue;
      if (T === null) {
        var P = /* @__PURE__ */ new Set();
        P.add(p), i.updateQueue = P;
      } else
        T.add(p);
    }
    function iV(i, o) {
      var p = i.tag;
      if ((i.mode & Rr) === Qn && (p === v || p === k || p === Z)) {
        var S = i.alternate;
        S ? (i.updateQueue = S.updateQueue, i.memoizedState = S.memoizedState, i.lanes = S.lanes) : (i.updateQueue = null, i.memoizedState = null);
      }
    }
    function iN(i) {
      var o = i;
      do {
        if (o.tag === j && Ow(o))
          return o;
        o = o.return;
      } while (o !== null);
      return null;
    }
    function aN(i, o, p, S, T) {
      if ((i.mode & Rr) === Qn) {
        if (i === o)
          i.flags |= bo;
        else {
          if (i.flags |= dr, p.flags |= Sh, p.flags &= ~(uc | ds), p.tag === y) {
            var P = p.alternate;
            if (P === null)
              p.tag = J;
            else {
              var H = Gh(Xr, Wn);
              H.tag = Bo, nv(p, H, Wn);
            }
          }
          p.lanes = Pt(p.lanes, Wn);
        }
        return i;
      }
      return i.flags |= bo, i.lanes = T, i;
    }
    function aV(i, o, p, S, T) {
      if (p.flags |= ds, Ba && H1(i, T), S !== null && typeof S == "object" && typeof S.then == "function") {
        var P = S;
        iV(p), Pa() && p.mode & Rr && u_();
        var H = iN(o);
        if (H !== null) {
          H.flags &= ~Da, aN(H, o, p, i, T), H.mode & Rr && rN(i, P, T), rV(H, i, P);
          return;
        } else {
          if (!V(T)) {
            rN(i, P, T), ND();
            return;
          }
          var $ = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          S = $;
        }
      } else if (Pa() && p.mode & Rr) {
        u_();
        var ee = iN(o);
        if (ee !== null) {
          (ee.flags & bo) === Kn && (ee.flags |= Da), aN(ee, o, p, i, T), Jd(AS(S, p));
          return;
        }
      }
      S = AS(S, p), I5(S);
      var pe = o;
      do {
        switch (pe.tag) {
          case b: {
            var _e = S;
            pe.flags |= bo;
            var Ge = fi(T);
            pe.lanes = Pt(pe.lanes, Ge);
            var He = nN(pe, _e, Ge);
            Wh(pe, He);
            return;
          }
          case y:
            var ht = S, mt = pe.type, Lt = pe.stateNode;
            if ((pe.flags & dr) === Kn && (typeof mt.getDerivedStateFromError == "function" || Lt !== null && typeof Lt.componentDidCatch == "function" && !iU(Lt))) {
              pe.flags |= bo;
              var Ln = fi(T);
              pe.lanes = Pt(pe.lanes, Ln);
              var ur = tD(pe, ht, Ln);
              Wh(pe, ur);
              return;
            }
            break;
        }
        pe = pe.return;
      } while (pe !== null);
    }
    function oV() {
      return null;
    }
    var w1 = t.ReactCurrentOwner, Gp = !1, nD, C1, rD, iD, aD, DS, oD, kw;
    nD = {}, C1 = {}, rD = {}, iD = {}, aD = {}, DS = !1, oD = {}, kw = {};
    function hf(i, o, p, S) {
      i === null ? o.child = Rw(o, null, p, S) : o.child = Ny(o, i.child, p, S);
    }
    function sV(i, o, p, S) {
      o.child = Ny(o, i.child, null, S), o.child = Ny(o, null, p, S);
    }
    function oN(i, o, p, S, T) {
      if (o.type !== o.elementType) {
        var P = p.propTypes;
        P && $d(
          P,
          S,
          // Resolved props
          "prop",
          jr(p)
        );
      }
      var H = p.render, $ = o.ref, ee, pe;
      Vh(o, T), ia(o);
      {
        if (w1.current = o, si(!0), ee = Vy(i, o, H, S, $, T), pe = sv(), o.mode & Yr) {
          qi(!0);
          try {
            ee = Vy(i, o, H, S, $, T), pe = sv();
          } finally {
            qi(!1);
          }
        }
        si(!1);
      }
      return ca(), i !== null && !Gp ? (D_(i, o, T), yg(i, o, T)) : (Pa() && pe && Bb(o), o.flags |= _i, hf(i, o, ee, T), o.child);
    }
    function sN(i, o, p, S, T) {
      if (i === null) {
        var P = p.type;
        if (dG(P) && p.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        p.defaultProps === void 0) {
          var H = P;
          return H = X_(P), o.tag = Z, o.type = H, uD(o, P), lN(i, o, H, S, T);
        }
        {
          var $ = P.propTypes;
          $ && $d(
            $,
            S,
            // Resolved props
            "prop",
            jr(P)
          );
        }
        var ee = jD(p.type, null, S, o, o.mode, T);
        return ee.ref = o.ref, ee.return = o, o.child = ee, ee;
      }
      {
        var pe = p.type, _e = pe.propTypes;
        _e && $d(
          _e,
          S,
          // Resolved props
          "prop",
          jr(pe)
        );
      }
      var Ge = i.child, He = mD(i, T);
      if (!He) {
        var ht = Ge.memoizedProps, mt = p.compare;
        if (mt = mt !== null ? mt : er, mt(ht, S) && i.ref === o.ref)
          return yg(i, o, T);
      }
      o.flags |= _i;
      var Lt = US(Ge, S);
      return Lt.ref = o.ref, Lt.return = o, o.child = Lt, Lt;
    }
    function lN(i, o, p, S, T) {
      if (o.type !== o.elementType) {
        var P = o.elementType;
        if (P.$$typeof === ze) {
          var H = P, $ = H._payload, ee = H._init;
          try {
            P = ee($);
          } catch {
            P = null;
          }
          var pe = P && P.propTypes;
          pe && $d(
            pe,
            S,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            jr(P)
          );
        }
      }
      if (i !== null) {
        var _e = i.memoizedProps;
        if (er(_e, S) && i.ref === o.ref && // Prevent bailout if the implementation changed due to hot reload.
        o.type === i.type)
          if (Gp = !1, o.pendingProps = S = _e, mD(i, T))
            (i.flags & Sh) !== Kn && (Gp = !0);
          else
            return o.lanes = i.lanes, yg(i, o, T);
      }
      return sD(i, o, p, S, T);
    }
    function uN(i, o, p) {
      var S = o.pendingProps, T = S.children, P = i !== null ? i.memoizedState : null;
      if (S.mode === "hidden" || X)
        if ((o.mode & Rr) === Qn) {
          var H = {
            baseLanes: Ct,
            cachePool: null,
            transitions: null
          };
          o.memoizedState = H, Kw(o, p);
        } else if (Be(p, pl)) {
          var Ge = {
            baseLanes: Ct,
            cachePool: null,
            transitions: null
          };
          o.memoizedState = Ge;
          var He = P !== null ? P.baseLanes : p;
          Kw(o, He);
        } else {
          var $ = null, ee;
          if (P !== null) {
            var pe = P.baseLanes;
            ee = Pt(pe, p);
          } else
            ee = p;
          o.lanes = o.childLanes = pl;
          var _e = {
            baseLanes: ee,
            cachePool: $,
            transitions: null
          };
          return o.memoizedState = _e, o.updateQueue = null, Kw(o, ee), null;
        }
      else {
        var ht;
        P !== null ? (ht = Pt(P.baseLanes, p), o.memoizedState = null) : ht = p, Kw(o, ht);
      }
      return hf(i, o, T, p), o.child;
    }
    function lV(i, o, p) {
      var S = o.pendingProps;
      return hf(i, o, S, p), o.child;
    }
    function uV(i, o, p) {
      var S = o.pendingProps.children;
      return hf(i, o, S, p), o.child;
    }
    function cV(i, o, p) {
      {
        o.flags |= Hn;
        {
          var S = o.stateNode;
          S.effectDuration = 0, S.passiveEffectDuration = 0;
        }
      }
      var T = o.pendingProps, P = T.children;
      return hf(i, o, P, p), o.child;
    }
    function cN(i, o) {
      var p = o.ref;
      (i === null && p !== null || i !== null && i.ref !== p) && (o.flags |= fs, o.flags |= Ff);
    }
    function sD(i, o, p, S, T) {
      if (o.type !== o.elementType) {
        var P = p.propTypes;
        P && $d(
          P,
          S,
          // Resolved props
          "prop",
          jr(p)
        );
      }
      var H;
      {
        var $ = Xm(o, p, !0);
        H = Ty(o, $);
      }
      var ee, pe;
      Vh(o, T), ia(o);
      {
        if (w1.current = o, si(!0), ee = Vy(i, o, p, S, H, T), pe = sv(), o.mode & Yr) {
          qi(!0);
          try {
            ee = Vy(i, o, p, S, H, T), pe = sv();
          } finally {
            qi(!1);
          }
        }
        si(!1);
      }
      return ca(), i !== null && !Gp ? (D_(i, o, T), yg(i, o, T)) : (Pa() && pe && Bb(o), o.flags |= _i, hf(i, o, ee, T), o.child);
    }
    function fN(i, o, p, S, T) {
      {
        switch (CG(o)) {
          case !1: {
            var P = o.stateNode, H = o.type, $ = new H(o.memoizedProps, P.context), ee = $.state;
            P.updater.enqueueSetState(P, ee, null);
            break;
          }
          case !0: {
            o.flags |= dr, o.flags |= bo;
            var pe = new Error("Simulated error coming from DevTools"), _e = fi(T);
            o.lanes = Pt(o.lanes, _e);
            var Ge = tD(o, AS(pe, o), _e);
            Wh(o, Ge);
            break;
          }
        }
        if (o.type !== o.elementType) {
          var He = p.propTypes;
          He && $d(
            He,
            S,
            // Resolved props
            "prop",
            jr(p)
          );
        }
      }
      var ht;
      Xd(p) ? (ht = !0, n_(o)) : ht = !1, Vh(o, T);
      var mt = o.stateNode, Lt;
      mt === null ? (Fw(i, o), t1(o, p, S), n1(o, p, S, T), Lt = !0) : i === null ? Lt = jh(o, p, S, T) : Lt = WA(i, o, p, S, T);
      var Ln = lD(i, o, p, Lt, ht, T);
      {
        var ur = o.stateNode;
        Lt && ur.props !== S && (DS || u("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", lr(o) || "a component"), DS = !0);
      }
      return Ln;
    }
    function lD(i, o, p, S, T, P) {
      cN(i, o);
      var H = (o.flags & dr) !== Kn;
      if (!S && !H)
        return T && ow(o, p, !1), yg(i, o, P);
      var $ = o.stateNode;
      w1.current = o;
      var ee;
      if (H && typeof p.getDerivedStateFromError != "function")
        ee = null, B_();
      else {
        ia(o);
        {
          if (si(!0), ee = $.render(), o.mode & Yr) {
            qi(!0);
            try {
              $.render();
            } finally {
              qi(!1);
            }
          }
          si(!1);
        }
        ca();
      }
      return o.flags |= _i, i !== null && H ? sV(i, o, ee, P) : hf(i, o, ee, P), o.memoizedState = $.state, T && ow(o, p, !0), o.child;
    }
    function dN(i) {
      var o = i.stateNode;
      o.pendingContext ? iw(i, o.pendingContext, o.pendingContext !== o.context) : o.context && iw(i, o.context, !1), gS(i, o.containerInfo);
    }
    function fV(i, o, p) {
      if (dN(o), i === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var S = o.pendingProps, T = o.memoizedState, P = T.element;
      y_(i, o), x_(o, S, null, p);
      var H = o.memoizedState;
      o.stateNode;
      var $ = H.element;
      if (T.isDehydrated) {
        var ee = {
          element: $,
          isDehydrated: !1,
          cache: H.cache,
          pendingSuspenseBoundaries: H.pendingSuspenseBoundaries,
          transitions: H.transitions
        }, pe = o.updateQueue;
        if (pe.baseState = ee, o.memoizedState = ee, o.flags & Da) {
          var _e = AS(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), o);
          return hN(i, o, $, p, _e);
        } else if ($ !== P) {
          var Ge = AS(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), o);
          return hN(i, o, $, p, Ge);
        } else {
          dw(o);
          var He = Rw(o, null, $, p);
          o.child = He;
          for (var ht = He; ht; )
            ht.flags = ht.flags & ~Hr | Hs, ht = ht.sibling;
        }
      } else {
        if (Zm(), $ === P)
          return yg(i, o, p);
        hf(i, o, $, p);
      }
      return o.child;
    }
    function hN(i, o, p, S, T) {
      return Zm(), Jd(T), o.flags |= Da, hf(i, o, p, S), o.child;
    }
    function dV(i, o, p) {
      R_(o), i === null && $b(o);
      var S = o.type, T = o.pendingProps, P = i !== null ? i.memoizedProps : null, H = T.children, $ = Tb(S, T);
      return $ ? H = null : P !== null && Tb(S, P) && (o.flags |= di), cN(i, o), hf(i, o, H, p), o.child;
    }
    function hV(i, o) {
      return i === null && $b(o), null;
    }
    function pV(i, o, p, S) {
      Fw(i, o);
      var T = o.pendingProps, P = p, H = P._payload, $ = P._init, ee = $(H);
      o.type = ee;
      var pe = o.tag = hG(ee), _e = Vu(ee, T), Ge;
      switch (pe) {
        case v:
          return uD(o, ee), o.type = ee = X_(ee), Ge = sD(null, o, ee, _e, S), Ge;
        case y:
          return o.type = ee = FD(ee), Ge = fN(null, o, ee, _e, S), Ge;
        case k:
          return o.type = ee = BD(ee), Ge = oN(null, o, ee, _e, S), Ge;
        case Y: {
          if (o.type !== o.elementType) {
            var He = ee.propTypes;
            He && $d(
              He,
              _e,
              // Resolved for outer only
              "prop",
              jr(ee)
            );
          }
          return Ge = sN(
            null,
            o,
            ee,
            Vu(ee.type, _e),
            // The inner type can have defaults too
            S
          ), Ge;
        }
      }
      var ht = "";
      throw ee !== null && typeof ee == "object" && ee.$$typeof === ze && (ht = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + ee + ". " + ("Lazy element type must resolve to a class or function." + ht));
    }
    function mV(i, o, p, S, T) {
      Fw(i, o), o.tag = y;
      var P;
      return Xd(p) ? (P = !0, n_(o)) : P = !1, Vh(o, T), t1(o, p, S), n1(o, p, S, T), lD(null, o, p, !0, P, T);
    }
    function vV(i, o, p, S) {
      Fw(i, o);
      var T = o.pendingProps, P;
      {
        var H = Xm(o, p, !1);
        P = Ty(o, H);
      }
      Vh(o, S);
      var $, ee;
      ia(o);
      {
        if (p.prototype && typeof p.prototype.render == "function") {
          var pe = jr(p) || "Unknown";
          nD[pe] || (u("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", pe, pe), nD[pe] = !0);
        }
        o.mode & Yr && Hu.recordLegacyContextWarning(o, null), si(!0), w1.current = o, $ = Vy(null, o, p, T, P, S), ee = sv(), si(!1);
      }
      if (ca(), o.flags |= _i, typeof $ == "object" && $ !== null && typeof $.render == "function" && $.$$typeof === void 0) {
        var _e = jr(p) || "Unknown";
        C1[_e] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _e, _e, _e), C1[_e] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof $ == "object" && $ !== null && typeof $.render == "function" && $.$$typeof === void 0
      ) {
        {
          var Ge = jr(p) || "Unknown";
          C1[Ge] || (u("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ge, Ge, Ge), C1[Ge] = !0);
        }
        o.tag = y, o.memoizedState = null, o.updateQueue = null;
        var He = !1;
        return Xd(p) ? (He = !0, n_(o)) : He = !1, o.memoizedState = $.state !== null && $.state !== void 0 ? $.state : null, g_(o), Tw(o, $), n1(o, p, T, S), lD(null, o, p, !0, He, S);
      } else {
        if (o.tag = v, o.mode & Yr) {
          qi(!0);
          try {
            $ = Vy(null, o, p, T, P, S), ee = sv();
          } finally {
            qi(!1);
          }
        }
        return Pa() && ee && Bb(o), hf(null, o, $, S), uD(o, p), o.child;
      }
    }
    function uD(i, o) {
      {
        if (o && o.childContextTypes && u("%s(...): childContextTypes cannot be defined on a function component.", o.displayName || o.name || "Component"), i.ref !== null) {
          var p = "", S = us();
          S && (p += `

Check the render method of \`` + S + "`.");
          var T = S || "", P = i._debugSource;
          P && (T = P.fileName + ":" + P.lineNumber), aD[T] || (aD[T] = !0, u("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", p));
        }
        if (typeof o.getDerivedStateFromProps == "function") {
          var H = jr(o) || "Unknown";
          iD[H] || (u("%s: Function components do not support getDerivedStateFromProps.", H), iD[H] = !0);
        }
        if (typeof o.contextType == "object" && o.contextType !== null) {
          var $ = jr(o) || "Unknown";
          rD[$] || (u("%s: Function components do not support contextType.", $), rD[$] = !0);
        }
      }
    }
    var cD = {
      dehydrated: null,
      treeContext: null,
      retryLane: Jr
    };
    function fD(i) {
      return {
        baseLanes: i,
        cachePool: oV(),
        transitions: null
      };
    }
    function gV(i, o) {
      var p = null;
      return {
        baseLanes: Pt(i.baseLanes, o),
        cachePool: p,
        transitions: i.transitions
      };
    }
    function yV(i, o, p, S) {
      if (o !== null) {
        var T = o.memoizedState;
        if (T === null)
          return !1;
      }
      return av(i, yS);
    }
    function SV(i, o) {
      return Dn(i.childLanes, o);
    }
    function pN(i, o, p) {
      var S = o.pendingProps;
      RG(o) && (o.flags |= dr);
      var T = Ho.current, P = !1, H = (o.flags & dr) !== Kn;
      if (H || yV(T, i) ? (P = !0, o.flags &= ~dr) : (i === null || i.memoizedState !== null) && (T = c1(T, Lw)), T = Fy(T), $h(o, T), i === null) {
        $b(o);
        var $ = o.memoizedState;
        if ($ !== null) {
          var ee = $.dehydrated;
          if (ee !== null)
            return TV(o, ee);
        }
        var pe = S.children, _e = S.fallback;
        if (P) {
          var Ge = xV(o, pe, _e, p), He = o.child;
          return He.memoizedState = fD(p), o.memoizedState = cD, Ge;
        } else
          return dD(o, pe);
      } else {
        var ht = i.memoizedState;
        if (ht !== null) {
          var mt = ht.dehydrated;
          if (mt !== null)
            return MV(i, o, H, S, mt, ht, p);
        }
        if (P) {
          var Lt = S.fallback, Ln = S.children, ur = EV(i, o, Ln, Lt, p), tr = o.child, Pi = i.child.memoizedState;
          return tr.memoizedState = Pi === null ? fD(p) : gV(Pi, p), tr.childLanes = SV(i, p), o.memoizedState = cD, ur;
        } else {
          var bi = S.children, rt = _V(i, o, bi, p);
          return o.memoizedState = null, rt;
        }
      }
    }
    function dD(i, o, p) {
      var S = i.mode, T = {
        mode: "visible",
        children: o
      }, P = hD(T, S);
      return P.return = i, i.child = P, P;
    }
    function xV(i, o, p, S) {
      var T = i.mode, P = i.child, H = {
        mode: "hidden",
        children: o
      }, $, ee;
      return (T & Rr) === Qn && P !== null ? ($ = P, $.childLanes = Ct, $.pendingProps = H, i.mode & Zn && ($.actualDuration = 0, $.actualStartTime = -1, $.selfBaseDuration = 0, $.treeBaseDuration = 0), ee = Zy(p, T, S, null)) : ($ = hD(H, T), ee = Zy(p, T, S, null)), $.return = i, ee.return = i, $.sibling = ee, i.child = $, ee;
    }
    function hD(i, o, p) {
      return mU(i, o, Ct, null);
    }
    function mN(i, o) {
      return US(i, o);
    }
    function _V(i, o, p, S) {
      var T = i.child, P = T.sibling, H = mN(T, {
        mode: "visible",
        children: p
      });
      if ((o.mode & Rr) === Qn && (H.lanes = S), H.return = o, H.sibling = null, P !== null) {
        var $ = o.deletions;
        $ === null ? (o.deletions = [P], o.flags |= ii) : $.push(P);
      }
      return o.child = H, H;
    }
    function EV(i, o, p, S, T) {
      var P = o.mode, H = i.child, $ = H.sibling, ee = {
        mode: "hidden",
        children: p
      }, pe;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (P & Rr) === Qn && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        o.child !== H
      ) {
        var _e = o.child;
        pe = _e, pe.childLanes = Ct, pe.pendingProps = ee, o.mode & Zn && (pe.actualDuration = 0, pe.actualStartTime = -1, pe.selfBaseDuration = H.selfBaseDuration, pe.treeBaseDuration = H.treeBaseDuration), o.deletions = null;
      } else
        pe = mN(H, ee), pe.subtreeFlags = H.subtreeFlags & rn;
      var Ge;
      return $ !== null ? Ge = US($, S) : (Ge = Zy(S, P, T, null), Ge.flags |= Hr), Ge.return = o, pe.return = o, pe.sibling = Ge, o.child = pe, Ge;
    }
    function Iw(i, o, p, S) {
      S !== null && Jd(S), Ny(o, i.child, null, p);
      var T = o.pendingProps, P = T.children, H = dD(o, P);
      return H.flags |= Hr, o.memoizedState = null, H;
    }
    function bV(i, o, p, S, T) {
      var P = o.mode, H = {
        mode: "visible",
        children: p
      }, $ = hD(H, P), ee = Zy(S, P, T, null);
      return ee.flags |= Hr, $.return = o, ee.return = o, $.sibling = ee, o.child = $, (o.mode & Rr) !== Qn && Ny(o, i.child, null, T), ee;
    }
    function TV(i, o, p) {
      return (i.mode & Rr) === Qn ? (u("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), i.lanes = Wn) : Lb(o) ? i.lanes = Uo : i.lanes = pl, null;
    }
    function MV(i, o, p, S, T, P, H) {
      if (p)
        if (o.flags & Da) {
          o.flags &= ~Da;
          var rt = JA(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Iw(i, o, H, rt);
        } else {
          if (o.memoizedState !== null)
            return o.child = i.child, o.flags |= dr, null;
          var Ot = S.children, it = S.fallback, nn = bV(i, o, Ot, it, H), On = o.child;
          return On.memoizedState = fD(H), o.memoizedState = cD, nn;
        }
      else {
        if (Hb(), (o.mode & Rr) === Qn)
          return Iw(
            i,
            o,
            H,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (Lb(T)) {
          var $, ee, pe;
          {
            var _e = YM(T);
            $ = _e.digest, ee = _e.message, pe = _e.stack;
          }
          var Ge;
          ee ? Ge = new Error(ee) : Ge = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var He = JA(Ge, $, pe);
          return Iw(i, o, H, He);
        }
        var ht = Be(H, i.childLanes);
        if (Gp || ht) {
          var mt = qw();
          if (mt !== null) {
            var Lt = Xg(mt, H);
            if (Lt !== Jr && Lt !== P.retryLane) {
              P.retryLane = Lt;
              var Ln = Xr;
              Vl(i, Lt), Kl(mt, i, Lt, Ln);
            }
          }
          ND();
          var ur = JA(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Iw(i, o, H, ur);
        } else if (Db(T)) {
          o.flags |= dr, o.child = i.child;
          var tr = K5.bind(null, i);
          return CA(T, tr), null;
        } else {
          FA(o, T, P.treeContext);
          var Pi = S.children, bi = dD(o, Pi);
          return bi.flags |= Hs, bi;
        }
      }
    }
    function vN(i, o, p) {
      i.lanes = Pt(i.lanes, o);
      var S = i.alternate;
      S !== null && (S.lanes = Pt(S.lanes, o)), tv(i.return, o, p);
    }
    function wV(i, o, p) {
      for (var S = o; S !== null; ) {
        if (S.tag === j) {
          var T = S.memoizedState;
          T !== null && vN(S, p, i);
        } else if (S.tag === oe)
          vN(S, p, i);
        else if (S.child !== null) {
          S.child.return = S, S = S.child;
          continue;
        }
        if (S === i)
          return;
        for (; S.sibling === null; ) {
          if (S.return === null || S.return === i)
            return;
          S = S.return;
        }
        S.sibling.return = S.return, S = S.sibling;
      }
    }
    function CV(i) {
      for (var o = i, p = null; o !== null; ) {
        var S = o.alternate;
        S !== null && A_(S) === null && (p = o), o = o.sibling;
      }
      return p;
    }
    function RV(i) {
      if (i !== void 0 && i !== "forwards" && i !== "backwards" && i !== "together" && !oD[i])
        if (oD[i] = !0, typeof i == "string")
          switch (i.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', i, i.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              u('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', i, i.toLowerCase());
              break;
            }
            default:
              u('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', i);
              break;
          }
        else
          u('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', i);
    }
    function AV(i, o) {
      i !== void 0 && !kw[i] && (i !== "collapsed" && i !== "hidden" ? (kw[i] = !0, u('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', i)) : o !== "forwards" && o !== "backwards" && (kw[i] = !0, u('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', i)));
    }
    function gN(i, o) {
      {
        var p = $r(i), S = !p && typeof Pr(i) == "function";
        if (p || S) {
          var T = p ? "array" : "iterable";
          return u("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", T, o, T), !1;
        }
      }
      return !0;
    }
    function DV(i, o) {
      if ((o === "forwards" || o === "backwards") && i !== void 0 && i !== null && i !== !1)
        if ($r(i)) {
          for (var p = 0; p < i.length; p++)
            if (!gN(i[p], p))
              return;
        } else {
          var S = Pr(i);
          if (typeof S == "function") {
            var T = S.call(i);
            if (T)
              for (var P = T.next(), H = 0; !P.done; P = T.next()) {
                if (!gN(P.value, H))
                  return;
                H++;
              }
          } else
            u('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', o);
        }
    }
    function pD(i, o, p, S, T) {
      var P = i.memoizedState;
      P === null ? i.memoizedState = {
        isBackwards: o,
        rendering: null,
        renderingStartTime: 0,
        last: S,
        tail: p,
        tailMode: T
      } : (P.isBackwards = o, P.rendering = null, P.renderingStartTime = 0, P.last = S, P.tail = p, P.tailMode = T);
    }
    function yN(i, o, p) {
      var S = o.pendingProps, T = S.revealOrder, P = S.tail, H = S.children;
      RV(T), AV(P, T), DV(H, T), hf(i, o, H, p);
      var $ = Ho.current, ee = av($, yS);
      if (ee)
        $ = ov($, yS), o.flags |= dr;
      else {
        var pe = i !== null && (i.flags & dr) !== Kn;
        pe && wV(o, o.child, p), $ = Fy($);
      }
      if ($h(o, $), (o.mode & Rr) === Qn)
        o.memoizedState = null;
      else
        switch (T) {
          case "forwards": {
            var _e = CV(o.child), Ge;
            _e === null ? (Ge = o.child, o.child = null) : (Ge = _e.sibling, _e.sibling = null), pD(
              o,
              !1,
              // isBackwards
              Ge,
              _e,
              P
            );
            break;
          }
          case "backwards": {
            var He = null, ht = o.child;
            for (o.child = null; ht !== null; ) {
              var mt = ht.alternate;
              if (mt !== null && A_(mt) === null) {
                o.child = ht;
                break;
              }
              var Lt = ht.sibling;
              ht.sibling = He, He = ht, ht = Lt;
            }
            pD(
              o,
              !0,
              // isBackwards
              He,
              null,
              // last
              P
            );
            break;
          }
          case "together": {
            pD(
              o,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            o.memoizedState = null;
        }
      return o.child;
    }
    function LV(i, o, p) {
      gS(o, o.stateNode.containerInfo);
      var S = o.pendingProps;
      return i === null ? o.child = Ny(o, null, S, p) : hf(i, o, S, p), o.child;
    }
    var SN = !1;
    function OV(i, o, p) {
      var S = o.type, T = S._context, P = o.pendingProps, H = o.memoizedProps, $ = P.value;
      {
        "value" in P || SN || (SN = !0, u("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var ee = o.type.propTypes;
        ee && $d(ee, P, "prop", "Context.Provider");
      }
      if (cS(o, T, $), H !== null) {
        var pe = H.value;
        if (In(pe, $)) {
          if (H.children === P.children && !My())
            return yg(i, o, p);
        } else
          lg(o, T, p);
      }
      var _e = P.children;
      return hf(i, o, _e, p), o.child;
    }
    var xN = !1;
    function PV(i, o, p) {
      var S = o.type;
      S._context === void 0 ? S !== S.Consumer && (xN || (xN = !0, u("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : S = S._context;
      var T = o.pendingProps, P = T.children;
      typeof P != "function" && u("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Vh(o, p);
      var H = Fo(S);
      ia(o);
      var $;
      return w1.current = o, si(!0), $ = P(H), si(!1), ca(), o.flags |= _i, hf(i, o, $, p), o.child;
    }
    function R1() {
      Gp = !0;
    }
    function Fw(i, o) {
      (o.mode & Rr) === Qn && i !== null && (i.alternate = null, o.alternate = null, o.flags |= Hr);
    }
    function yg(i, o, p) {
      return i !== null && (o.dependencies = i.dependencies), B_(), B1(o.lanes), Be(p, o.childLanes) ? (jA(i, o), o.child) : null;
    }
    function NV(i, o, p) {
      {
        var S = o.return;
        if (S === null)
          throw new Error("Cannot swap the root fiber.");
        if (i.alternate = null, o.alternate = null, p.index = o.index, p.sibling = o.sibling, p.return = o.return, p.ref = o.ref, o === S.child)
          S.child = p;
        else {
          var T = S.child;
          if (T === null)
            throw new Error("Expected parent to have a child.");
          for (; T.sibling !== o; )
            if (T = T.sibling, T === null)
              throw new Error("Expected to find the previous sibling.");
          T.sibling = p;
        }
        var P = S.deletions;
        return P === null ? (S.deletions = [i], S.flags |= ii) : P.push(i), p.flags |= Hr, p;
      }
    }
    function mD(i, o) {
      var p = i.lanes;
      return !!Be(p, o);
    }
    function UV(i, o, p) {
      switch (o.tag) {
        case b:
          dN(o), o.stateNode, Zm();
          break;
        case C:
          R_(o);
          break;
        case y: {
          var S = o.type;
          Xd(S) && n_(o);
          break;
        }
        case M:
          gS(o, o.stateNode.containerInfo);
          break;
        case I: {
          var T = o.memoizedProps.value, P = o.type._context;
          cS(o, P, T);
          break;
        }
        case G:
          {
            var H = Be(p, o.childLanes);
            H && (o.flags |= Hn);
            {
              var $ = o.stateNode;
              $.effectDuration = 0, $.passiveEffectDuration = 0;
            }
          }
          break;
        case j: {
          var ee = o.memoizedState;
          if (ee !== null) {
            if (ee.dehydrated !== null)
              return $h(o, Fy(Ho.current)), o.flags |= dr, null;
            var pe = o.child, _e = pe.childLanes;
            if (Be(p, _e))
              return pN(i, o, p);
            $h(o, Fy(Ho.current));
            var Ge = yg(i, o, p);
            return Ge !== null ? Ge.sibling : null;
          } else
            $h(o, Fy(Ho.current));
          break;
        }
        case oe: {
          var He = (i.flags & dr) !== Kn, ht = Be(p, o.childLanes);
          if (He) {
            if (ht)
              return yN(i, o, p);
            o.flags |= dr;
          }
          var mt = o.memoizedState;
          if (mt !== null && (mt.rendering = null, mt.tail = null, mt.lastEffect = null), $h(o, Ho.current), ht)
            break;
          return null;
        }
        case de:
        case xe:
          return o.lanes = Ct, uN(i, o, p);
      }
      return yg(i, o, p);
    }
    function _N(i, o, p) {
      if (o._debugNeedsRemount && i !== null)
        return NV(i, o, jD(o.type, o.key, o.pendingProps, o._debugOwner || null, o.mode, o.lanes));
      if (i !== null) {
        var S = i.memoizedProps, T = o.pendingProps;
        if (S !== T || My() || // Force a re-render if the implementation changed due to hot reload:
        o.type !== i.type)
          Gp = !0;
        else {
          var P = mD(i, p);
          if (!P && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (o.flags & dr) === Kn)
            return Gp = !1, UV(i, o, p);
          (i.flags & Sh) !== Kn ? Gp = !0 : Gp = !1;
        }
      } else if (Gp = !1, Pa() && cw(o)) {
        var H = o.index, $ = td();
        fw(o, $, H);
      }
      switch (o.lanes = Ct, o.tag) {
        case _:
          return vV(i, o, o.type, p);
        case te: {
          var ee = o.elementType;
          return pV(i, o, ee, p);
        }
        case v: {
          var pe = o.type, _e = o.pendingProps, Ge = o.elementType === pe ? _e : Vu(pe, _e);
          return sD(i, o, pe, Ge, p);
        }
        case y: {
          var He = o.type, ht = o.pendingProps, mt = o.elementType === He ? ht : Vu(He, ht);
          return fN(i, o, He, mt, p);
        }
        case b:
          return fV(i, o, p);
        case C:
          return dV(i, o, p);
        case D:
          return hV(i, o);
        case j:
          return pN(i, o, p);
        case M:
          return LV(i, o, p);
        case k: {
          var Lt = o.type, Ln = o.pendingProps, ur = o.elementType === Lt ? Ln : Vu(Lt, Ln);
          return oN(i, o, Lt, ur, p);
        }
        case U:
          return lV(i, o, p);
        case N:
          return uV(i, o, p);
        case G:
          return cV(i, o, p);
        case I:
          return OV(i, o, p);
        case O:
          return PV(i, o, p);
        case Y: {
          var tr = o.type, Pi = o.pendingProps, bi = Vu(tr, Pi);
          if (o.type !== o.elementType) {
            var rt = tr.propTypes;
            rt && $d(
              rt,
              bi,
              // Resolved for outer only
              "prop",
              jr(tr)
            );
          }
          return bi = Vu(tr.type, bi), sN(i, o, tr, bi, p);
        }
        case Z:
          return lN(i, o, o.type, o.pendingProps, p);
        case J: {
          var Ot = o.type, it = o.pendingProps, nn = o.elementType === Ot ? it : Vu(Ot, it);
          return mV(i, o, Ot, nn, p);
        }
        case oe:
          return yN(i, o, p);
        case ye:
          break;
        case de:
          return uN(i, o, p);
      }
      throw new Error("Unknown unit of work tag (" + o.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function H_(i) {
      i.flags |= Hn;
    }
    function EN(i) {
      i.flags |= fs, i.flags |= Ff;
    }
    var bN, vD, TN, MN;
    bN = function(i, o, p, S) {
      for (var T = o.child; T !== null; ) {
        if (T.tag === C || T.tag === D)
          pA(i, T.stateNode);
        else if (T.tag !== M) {
          if (T.child !== null) {
            T.child.return = T, T = T.child;
            continue;
          }
        }
        if (T === o)
          return;
        for (; T.sibling === null; ) {
          if (T.return === null || T.return === o)
            return;
          T = T.return;
        }
        T.sibling.return = T.return, T = T.sibling;
      }
    }, vD = function(i, o) {
    }, TN = function(i, o, p, S, T) {
      var P = i.memoizedProps;
      if (P !== S) {
        var H = o.stateNode, $ = dg(), ee = mA(H, p, P, S, T, $);
        o.updateQueue = ee, ee && H_(o);
      }
    }, MN = function(i, o, p, S) {
      p !== S && H_(o);
    };
    function A1(i, o) {
      if (!Pa())
        switch (i.tailMode) {
          case "hidden": {
            for (var p = i.tail, S = null; p !== null; )
              p.alternate !== null && (S = p), p = p.sibling;
            S === null ? i.tail = null : S.sibling = null;
            break;
          }
          case "collapsed": {
            for (var T = i.tail, P = null; T !== null; )
              T.alternate !== null && (P = T), T = T.sibling;
            P === null ? !o && i.tail !== null ? i.tail.sibling = null : i.tail = null : P.sibling = null;
            break;
          }
        }
    }
    function Gu(i) {
      var o = i.alternate !== null && i.alternate.child === i.child, p = Ct, S = Kn;
      if (o) {
        if ((i.mode & Zn) !== Qn) {
          for (var ee = i.selfBaseDuration, pe = i.child; pe !== null; )
            p = Pt(p, Pt(pe.lanes, pe.childLanes)), S |= pe.subtreeFlags & rn, S |= pe.flags & rn, ee += pe.treeBaseDuration, pe = pe.sibling;
          i.treeBaseDuration = ee;
        } else
          for (var _e = i.child; _e !== null; )
            p = Pt(p, Pt(_e.lanes, _e.childLanes)), S |= _e.subtreeFlags & rn, S |= _e.flags & rn, _e.return = i, _e = _e.sibling;
        i.subtreeFlags |= S;
      } else {
        if ((i.mode & Zn) !== Qn) {
          for (var T = i.actualDuration, P = i.selfBaseDuration, H = i.child; H !== null; )
            p = Pt(p, Pt(H.lanes, H.childLanes)), S |= H.subtreeFlags, S |= H.flags, T += H.actualDuration, P += H.treeBaseDuration, H = H.sibling;
          i.actualDuration = T, i.treeBaseDuration = P;
        } else
          for (var $ = i.child; $ !== null; )
            p = Pt(p, Pt($.lanes, $.childLanes)), S |= $.subtreeFlags, S |= $.flags, $.return = i, $ = $.sibling;
        i.subtreeFlags |= S;
      }
      return i.childLanes = p, o;
    }
    function zV(i, o, p) {
      if (Zd() && (o.mode & Rr) !== Qn && (o.flags & dr) === Kn)
        return Zo(o), Zm(), o.flags |= Da | ds | bo, !1;
      var S = Ya(o);
      if (p !== null && p.dehydrated !== null)
        if (i === null) {
          if (!S)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (HA(o), Gu(o), (o.mode & Zn) !== Qn) {
            var T = p !== null;
            if (T) {
              var P = o.child;
              P !== null && (o.treeBaseDuration -= P.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Zm(), (o.flags & dr) === Kn && (o.memoizedState = null), o.flags |= Hn, Gu(o), (o.mode & Zn) !== Qn) {
            var H = p !== null;
            if (H) {
              var $ = o.child;
              $ !== null && (o.treeBaseDuration -= $.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return Bl(), !0;
    }
    function wN(i, o, p) {
      var S = o.pendingProps;
      switch (Ay(o), o.tag) {
        case _:
        case te:
        case Z:
        case v:
        case k:
        case U:
        case N:
        case G:
        case O:
        case Y:
          return Gu(o), null;
        case y: {
          var T = o.type;
          return Xd(T) && t_(o), Gu(o), null;
        }
        case b: {
          var P = o.stateNode;
          if (ky(o), wy(o), SS(), P.pendingContext && (P.context = P.pendingContext, P.pendingContext = null), i === null || i.child === null) {
            var H = Ya(o);
            if (H)
              H_(o);
            else if (i !== null) {
              var $ = i.memoizedState;
              // Check if this is a client root
              (!$.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (o.flags & Da) !== Kn) && (o.flags |= Bs, Bl());
            }
          }
          return vD(i, o), Gu(o), null;
        }
        case C: {
          Iy(o);
          var ee = l1(), pe = o.type;
          if (i !== null && o.stateNode != null)
            TN(i, o, pe, S, ee), i.ref !== o.ref && EN(o);
          else {
            if (!S) {
              if (o.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Gu(o), null;
            }
            var _e = dg(), Ge = Ya(o);
            if (Ge)
              BA(o, ee, _e) && H_(o);
            else {
              var He = kM(pe, S, ee, _e, o);
              bN(He, o, !1, !1), o.stateNode = He, IM(He, pe, S, ee) && H_(o);
            }
            o.ref !== null && EN(o);
          }
          return Gu(o), null;
        }
        case D: {
          var ht = S;
          if (i && o.stateNode != null) {
            var mt = i.memoizedProps;
            MN(i, o, mt, ht);
          } else {
            if (typeof ht != "string" && o.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Lt = l1(), Ln = dg(), ur = Ya(o);
            ur ? mw(o) && H_(o) : o.stateNode = vA(ht, Lt, Ln, o);
          }
          return Gu(o), null;
        }
        case j: {
          hg(o);
          var tr = o.memoizedState;
          if (i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
            var Pi = zV(i, o, tr);
            if (!Pi)
              return o.flags & bo ? o : null;
          }
          if ((o.flags & dr) !== Kn)
            return o.lanes = p, (o.mode & Zn) !== Qn && ZA(o), o;
          var bi = tr !== null, rt = i !== null && i.memoizedState !== null;
          if (bi !== rt && bi) {
            var Ot = o.child;
            if (Ot.flags |= lc, (o.mode & Rr) !== Qn) {
              var it = i === null && (o.memoizedProps.unstable_avoidThisFallback !== !0 || !me);
              it || av(Ho.current, Lw) ? k5() : ND();
            }
          }
          var nn = o.updateQueue;
          if (nn !== null && (o.flags |= Hn), Gu(o), (o.mode & Zn) !== Qn && bi) {
            var On = o.child;
            On !== null && (o.treeBaseDuration -= On.treeBaseDuration);
          }
          return null;
        }
        case M:
          return ky(o), vD(i, o), i === null && Ey(o.stateNode.containerInfo), Gu(o), null;
        case I:
          var Cn = o.type._context;
          return fS(Cn, o), Gu(o), null;
        case J: {
          var Mr = o.type;
          return Xd(Mr) && t_(o), Gu(o), null;
        }
        case oe: {
          hg(o);
          var Ir = o.memoizedState;
          if (Ir === null)
            return Gu(o), null;
          var Ea = (o.flags & dr) !== Kn, Qi = Ir.rendering;
          if (Qi === null)
            if (Ea)
              A1(Ir, !1);
            else {
              var Zs = F5() && (i === null || (i.flags & dr) === Kn);
              if (!Zs)
                for (var Zi = o.child; Zi !== null; ) {
                  var Ts = A_(Zi);
                  if (Ts !== null) {
                    Ea = !0, o.flags |= dr, A1(Ir, !1);
                    var wc = Ts.updateQueue;
                    return wc !== null && (o.updateQueue = wc, o.flags |= Hn), o.subtreeFlags = Kn, Aw(o, p), $h(o, ov(Ho.current, yS)), o.child;
                  }
                  Zi = Zi.sibling;
                }
              Ir.tail !== null && va() > YN() && (o.flags |= dr, Ea = !0, A1(Ir, !1), o.lanes = tf);
            }
          else {
            if (!Ea) {
              var Xu = A_(Qi);
              if (Xu !== null) {
                o.flags |= dr, Ea = !0;
                var nh = Xu.updateQueue;
                if (nh !== null && (o.updateQueue = nh, o.flags |= Hn), A1(Ir, !0), Ir.tail === null && Ir.tailMode === "hidden" && !Qi.alternate && !Pa())
                  return Gu(o), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                va() * 2 - Ir.renderingStartTime > YN() && p !== pl && (o.flags |= dr, Ea = !0, A1(Ir, !1), o.lanes = tf);
            }
            if (Ir.isBackwards)
              Qi.sibling = o.child, o.child = Qi;
            else {
              var vf = Ir.last;
              vf !== null ? vf.sibling = Qi : o.child = Qi, Ir.last = Qi;
            }
          }
          if (Ir.tail !== null) {
            var gf = Ir.tail;
            Ir.rendering = gf, Ir.tail = gf.sibling, Ir.renderingStartTime = va(), gf.sibling = null;
            var Cc = Ho.current;
            return Ea ? Cc = ov(Cc, yS) : Cc = Fy(Cc), $h(o, Cc), gf;
          }
          return Gu(o), null;
        }
        case ye:
          break;
        case de:
        case xe: {
          PD(o);
          var bg = o.memoizedState, q_ = bg !== null;
          if (i !== null) {
            var j1 = i.memoizedState, fv = j1 !== null;
            fv !== q_ && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !X && (o.flags |= lc);
          }
          return !q_ || (o.mode & Rr) === Qn ? Gu(o) : Be(cv, pl) && (Gu(o), o.subtreeFlags & (Hr | Hn) && (o.flags |= lc)), null;
        }
        case Re:
          return null;
        case Pe:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + o.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function kV(i, o, p) {
      switch (Ay(o), o.tag) {
        case y: {
          var S = o.type;
          Xd(S) && t_(o);
          var T = o.flags;
          return T & bo ? (o.flags = T & ~bo | dr, (o.mode & Zn) !== Qn && ZA(o), o) : null;
        }
        case b: {
          o.stateNode, ky(o), wy(o), SS();
          var P = o.flags;
          return (P & bo) !== Kn && (P & dr) === Kn ? (o.flags = P & ~bo | dr, o) : null;
        }
        case C:
          return Iy(o), null;
        case j: {
          hg(o);
          var H = o.memoizedState;
          if (H !== null && H.dehydrated !== null) {
            if (o.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Zm();
          }
          var $ = o.flags;
          return $ & bo ? (o.flags = $ & ~bo | dr, (o.mode & Zn) !== Qn && ZA(o), o) : null;
        }
        case oe:
          return hg(o), null;
        case M:
          return ky(o), null;
        case I:
          var ee = o.type._context;
          return fS(ee, o), null;
        case de:
        case xe:
          return PD(o), null;
        case Re:
          return null;
        default:
          return null;
      }
    }
    function CN(i, o, p) {
      switch (Ay(o), o.tag) {
        case y: {
          var S = o.type.childContextTypes;
          S != null && t_(o);
          break;
        }
        case b: {
          o.stateNode, ky(o), wy(o), SS();
          break;
        }
        case C: {
          Iy(o);
          break;
        }
        case M:
          ky(o);
          break;
        case j:
          hg(o);
          break;
        case oe:
          hg(o);
          break;
        case I:
          var T = o.type._context;
          fS(T, o);
          break;
        case de:
        case xe:
          PD(o);
          break;
      }
    }
    var RN = null;
    RN = /* @__PURE__ */ new Set();
    var Bw = !1, Wu = !1, IV = typeof WeakSet == "function" ? WeakSet : Set, Vn = null, V_ = null, G_ = null;
    function FV(i) {
      sc(null, function() {
        throw i;
      }), Dd();
    }
    var BV = function(i, o) {
      if (o.props = i.memoizedProps, o.state = i.memoizedState, i.mode & Zn)
        try {
          lv(), o.componentWillUnmount();
        } finally {
          Qh(i);
        }
      else
        o.componentWillUnmount();
    };
    function AN(i, o) {
      try {
        Yy(ts, i);
      } catch (p) {
        oo(i, o, p);
      }
    }
    function gD(i, o, p) {
      try {
        BV(i, p);
      } catch (S) {
        oo(i, o, S);
      }
    }
    function HV(i, o, p) {
      try {
        p.componentDidMount();
      } catch (S) {
        oo(i, o, S);
      }
    }
    function DN(i, o) {
      try {
        ON(i);
      } catch (p) {
        oo(i, o, p);
      }
    }
    function W_(i, o) {
      var p = i.ref;
      if (p !== null)
        if (typeof p == "function") {
          var S;
          try {
            if (je && Je && i.mode & Zn)
              try {
                lv(), S = p(null);
              } finally {
                Qh(i);
              }
            else
              S = p(null);
          } catch (T) {
            oo(i, o, T);
          }
          typeof S == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", lr(i));
        } else
          p.current = null;
    }
    function Hw(i, o, p) {
      try {
        p();
      } catch (S) {
        oo(i, o, S);
      }
    }
    var LN = !1;
    function VV(i, o) {
      zM(i.containerInfo), Vn = o, GV();
      var p = LN;
      return LN = !1, p;
    }
    function GV() {
      for (; Vn !== null; ) {
        var i = Vn, o = i.child;
        (i.subtreeFlags & Sr) !== Kn && o !== null ? (o.return = i, Vn = o) : WV();
      }
    }
    function WV() {
      for (; Vn !== null; ) {
        var i = Vn;
        zi(i);
        try {
          jV(i);
        } catch (p) {
          oo(i, i.return, p);
        }
        Ca();
        var o = i.sibling;
        if (o !== null) {
          o.return = i.return, Vn = o;
          return;
        }
        Vn = i.return;
      }
    }
    function jV(i) {
      var o = i.alternate, p = i.flags;
      if ((p & Bs) !== Kn) {
        switch (zi(i), i.tag) {
          case v:
          case k:
          case Z:
            break;
          case y: {
            if (o !== null) {
              var S = o.memoizedProps, T = o.memoizedState, P = i.stateNode;
              i.type === i.elementType && !DS && (P.props !== i.memoizedProps && u("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", lr(i) || "instance"), P.state !== i.memoizedState && u("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", lr(i) || "instance"));
              var H = P.getSnapshotBeforeUpdate(i.elementType === i.type ? S : Vu(i.type, S), T);
              {
                var $ = RN;
                H === void 0 && !$.has(i.type) && ($.add(i.type), u("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", lr(i)));
              }
              P.__reactInternalSnapshotBeforeUpdate = H;
            }
            break;
          }
          case b: {
            {
              var ee = i.stateNode;
              MA(ee.containerInfo);
            }
            break;
          }
          case C:
          case D:
          case M:
          case J:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Ca();
      }
    }
    function Wp(i, o, p) {
      var S = o.updateQueue, T = S !== null ? S.lastEffect : null;
      if (T !== null) {
        var P = T.next, H = P;
        do {
          if ((H.tag & i) === i) {
            var $ = H.destroy;
            H.destroy = void 0, $ !== void 0 && ((i & Wl) !== Ec ? Xc(o) : (i & ts) !== Ec && cu(o), (i & Yh) !== Ec && V1(!0), Hw(o, p, $), (i & Yh) !== Ec && V1(!1), (i & Wl) !== Ec ? vo() : (i & ts) !== Ec && Hf());
          }
          H = H.next;
        } while (H !== P);
      }
    }
    function Yy(i, o) {
      var p = o.updateQueue, S = p !== null ? p.lastEffect : null;
      if (S !== null) {
        var T = S.next, P = T;
        do {
          if ((P.tag & i) === i) {
            (i & Wl) !== Ec ? ui(o) : (i & ts) !== Ec && Pd(o);
            var H = P.create;
            (i & Yh) !== Ec && V1(!0), P.destroy = H(), (i & Yh) !== Ec && V1(!1), (i & Wl) !== Ec ? Vs() : (i & ts) !== Ec && Ou();
            {
              var $ = P.destroy;
              if ($ !== void 0 && typeof $ != "function") {
                var ee = void 0;
                (P.tag & ts) !== Kn ? ee = "useLayoutEffect" : (P.tag & Yh) !== Kn ? ee = "useInsertionEffect" : ee = "useEffect";
                var pe = void 0;
                $ === null ? pe = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof $.then == "function" ? pe = `

It looks like you wrote ` + ee + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + ee + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : pe = " You returned: " + $, u("%s must not return anything besides a function, which is used for clean-up.%s", ee, pe);
              }
            }
          }
          P = P.next;
        } while (P !== T);
      }
    }
    function $V(i, o) {
      if ((o.flags & Hn) !== Kn)
        switch (o.tag) {
          case G: {
            var p = o.stateNode.passiveEffectDuration, S = o.memoizedProps, T = S.id, P = S.onPostCommit, H = gg(), $ = o.alternate === null ? "mount" : "update";
            Tc() && ($ = "nested-update"), typeof P == "function" && P(T, $, p, H);
            var ee = o.return;
            e:
              for (; ee !== null; ) {
                switch (ee.tag) {
                  case b:
                    var pe = ee.stateNode;
                    pe.passiveEffectDuration += p;
                    break e;
                  case G:
                    var _e = ee.stateNode;
                    _e.passiveEffectDuration += p;
                    break e;
                }
                ee = ee.return;
              }
            break;
          }
        }
    }
    function YV(i, o, p, S) {
      if ((p.flags & La) !== Kn)
        switch (p.tag) {
          case v:
          case k:
          case Z: {
            if (!Wu)
              if (p.mode & Zn)
                try {
                  lv(), Yy(ts | es, p);
                } finally {
                  Qh(p);
                }
              else
                Yy(ts | es, p);
            break;
          }
          case y: {
            var T = p.stateNode;
            if (p.flags & Hn && !Wu)
              if (o === null)
                if (p.type === p.elementType && !DS && (T.props !== p.memoizedProps && u("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", lr(p) || "instance"), T.state !== p.memoizedState && u("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", lr(p) || "instance")), p.mode & Zn)
                  try {
                    lv(), T.componentDidMount();
                  } finally {
                    Qh(p);
                  }
                else
                  T.componentDidMount();
              else {
                var P = p.elementType === p.type ? o.memoizedProps : Vu(p.type, o.memoizedProps), H = o.memoizedState;
                if (p.type === p.elementType && !DS && (T.props !== p.memoizedProps && u("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", lr(p) || "instance"), T.state !== p.memoizedState && u("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", lr(p) || "instance")), p.mode & Zn)
                  try {
                    lv(), T.componentDidUpdate(P, H, T.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Qh(p);
                  }
                else
                  T.componentDidUpdate(P, H, T.__reactInternalSnapshotBeforeUpdate);
              }
            var $ = p.updateQueue;
            $ !== null && (p.type === p.elementType && !DS && (T.props !== p.memoizedProps && u("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", lr(p) || "instance"), T.state !== p.memoizedState && u("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", lr(p) || "instance")), hS(p, $, T));
            break;
          }
          case b: {
            var ee = p.updateQueue;
            if (ee !== null) {
              var pe = null;
              if (p.child !== null)
                switch (p.child.tag) {
                  case C:
                    pe = p.child.stateNode;
                    break;
                  case y:
                    pe = p.child.stateNode;
                    break;
                }
              hS(p, ee, pe);
            }
            break;
          }
          case C: {
            var _e = p.stateNode;
            if (o === null && p.flags & Hn) {
              var Ge = p.type, He = p.memoizedProps;
              BM(_e, Ge, He);
            }
            break;
          }
          case D:
            break;
          case M:
            break;
          case G: {
            {
              var ht = p.memoizedProps, mt = ht.onCommit, Lt = ht.onRender, Ln = p.stateNode.effectDuration, ur = gg(), tr = o === null ? "mount" : "update";
              Tc() && (tr = "nested-update"), typeof Lt == "function" && Lt(p.memoizedProps.id, tr, p.actualDuration, p.treeBaseDuration, p.actualStartTime, ur);
              {
                typeof mt == "function" && mt(p.memoizedProps.id, tr, Ln, ur), W5(p);
                var Pi = p.return;
                e:
                  for (; Pi !== null; ) {
                    switch (Pi.tag) {
                      case b:
                        var bi = Pi.stateNode;
                        bi.effectDuration += Ln;
                        break e;
                      case G:
                        var rt = Pi.stateNode;
                        rt.effectDuration += Ln;
                        break e;
                    }
                    Pi = Pi.return;
                  }
              }
            }
            break;
          }
          case j: {
            t5(i, p);
            break;
          }
          case oe:
          case J:
          case ye:
          case de:
          case xe:
          case Pe:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Wu || p.flags & fs && ON(p);
    }
    function XV(i) {
      switch (i.tag) {
        case v:
        case k:
        case Z: {
          if (i.mode & Zn)
            try {
              lv(), AN(i, i.return);
            } finally {
              Qh(i);
            }
          else
            AN(i, i.return);
          break;
        }
        case y: {
          var o = i.stateNode;
          typeof o.componentDidMount == "function" && HV(i, i.return, o), DN(i, i.return);
          break;
        }
        case C: {
          DN(i, i.return);
          break;
        }
      }
    }
    function qV(i, o) {
      for (var p = null, S = i; ; ) {
        if (S.tag === C) {
          if (p === null) {
            p = S;
            try {
              var T = S.stateNode;
              o ? jM(T) : bA(S.stateNode, S.memoizedProps);
            } catch (H) {
              oo(i, i.return, H);
            }
          }
        } else if (S.tag === D) {
          if (p === null)
            try {
              var P = S.stateNode;
              o ? EA(P) : TA(P, S.memoizedProps);
            } catch (H) {
              oo(i, i.return, H);
            }
        } else if (!((S.tag === de || S.tag === xe) && S.memoizedState !== null && S !== i)) {
          if (S.child !== null) {
            S.child.return = S, S = S.child;
            continue;
          }
        }
        if (S === i)
          return;
        for (; S.sibling === null; ) {
          if (S.return === null || S.return === i)
            return;
          p === S && (p = null), S = S.return;
        }
        p === S && (p = null), S.sibling.return = S.return, S = S.sibling;
      }
    }
    function ON(i) {
      var o = i.ref;
      if (o !== null) {
        var p = i.stateNode, S;
        switch (i.tag) {
          case C:
            S = p;
            break;
          default:
            S = p;
        }
        if (typeof o == "function") {
          var T;
          if (i.mode & Zn)
            try {
              lv(), T = o(S);
            } finally {
              Qh(i);
            }
          else
            T = o(S);
          typeof T == "function" && u("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", lr(i));
        } else
          o.hasOwnProperty("current") || u("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", lr(i)), o.current = S;
      }
    }
    function KV(i) {
      var o = i.alternate;
      o !== null && (o.return = null), i.return = null;
    }
    function PN(i) {
      var o = i.alternate;
      o !== null && (i.alternate = null, PN(o));
      {
        if (i.child = null, i.deletions = null, i.sibling = null, i.tag === C) {
          var p = i.stateNode;
          p !== null && Jx(p);
        }
        i.stateNode = null, i._debugOwner = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null;
      }
    }
    function QV(i) {
      for (var o = i.return; o !== null; ) {
        if (NN(o))
          return o;
        o = o.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function NN(i) {
      return i.tag === C || i.tag === b || i.tag === M;
    }
    function UN(i) {
      var o = i;
      e:
        for (; ; ) {
          for (; o.sibling === null; ) {
            if (o.return === null || NN(o.return))
              return null;
            o = o.return;
          }
          for (o.sibling.return = o.return, o = o.sibling; o.tag !== C && o.tag !== D && o.tag !== q; ) {
            if (o.flags & Hr || o.child === null || o.tag === M)
              continue e;
            o.child.return = o, o = o.child;
          }
          if (!(o.flags & Hr))
            return o.stateNode;
        }
    }
    function ZV(i) {
      var o = QV(i);
      switch (o.tag) {
        case C: {
          var p = o.stateNode;
          o.flags & di && (Xx(p), o.flags &= ~di);
          var S = UN(i);
          SD(i, S, p);
          break;
        }
        case b:
        case M: {
          var T = o.stateNode.containerInfo, P = UN(i);
          yD(i, P, T);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function yD(i, o, p) {
      var S = i.tag, T = S === C || S === D;
      if (T) {
        var P = i.stateNode;
        o ? WM(p, P, o) : VM(p, P);
      } else if (S !== M) {
        var H = i.child;
        if (H !== null) {
          yD(H, o, p);
          for (var $ = H.sibling; $ !== null; )
            yD($, o, p), $ = $.sibling;
        }
      }
    }
    function SD(i, o, p) {
      var S = i.tag, T = S === C || S === D;
      if (T) {
        var P = i.stateNode;
        o ? GM(p, P, o) : Cb(p, P);
      } else if (S !== M) {
        var H = i.child;
        if (H !== null) {
          SD(H, o, p);
          for (var $ = H.sibling; $ !== null; )
            SD($, o, p), $ = $.sibling;
        }
      }
    }
    var ju = null, jp = !1;
    function JV(i, o, p) {
      {
        var S = o;
        e:
          for (; S !== null; ) {
            switch (S.tag) {
              case C: {
                ju = S.stateNode, jp = !1;
                break e;
              }
              case b: {
                ju = S.stateNode.containerInfo, jp = !0;
                break e;
              }
              case M: {
                ju = S.stateNode.containerInfo, jp = !0;
                break e;
              }
            }
            S = S.return;
          }
        if (ju === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        zN(i, o, p), ju = null, jp = !1;
      }
      KV(p);
    }
    function Xy(i, o, p) {
      for (var S = p.child; S !== null; )
        zN(i, o, S), S = S.sibling;
    }
    function zN(i, o, p) {
      switch (gn(p), p.tag) {
        case C:
          Wu || W_(p, o);
        case D: {
          {
            var S = ju, T = jp;
            ju = null, Xy(i, o, p), ju = S, jp = T, ju !== null && (jp ? xA(ju, p.stateNode) : qx(ju, p.stateNode));
          }
          return;
        }
        case q: {
          ju !== null && (jp ? _A(ju, p.stateNode) : Rb(ju, p.stateNode));
          return;
        }
        case M: {
          {
            var P = ju, H = jp;
            ju = p.stateNode.containerInfo, jp = !0, Xy(i, o, p), ju = P, jp = H;
          }
          return;
        }
        case v:
        case k:
        case Y:
        case Z: {
          if (!Wu) {
            var $ = p.updateQueue;
            if ($ !== null) {
              var ee = $.lastEffect;
              if (ee !== null) {
                var pe = ee.next, _e = pe;
                do {
                  var Ge = _e, He = Ge.destroy, ht = Ge.tag;
                  He !== void 0 && ((ht & Yh) !== Ec ? Hw(p, o, He) : (ht & ts) !== Ec && (cu(p), p.mode & Zn ? (lv(), Hw(p, o, He), Qh(p)) : Hw(p, o, He), Hf())), _e = _e.next;
                } while (_e !== pe);
              }
            }
          }
          Xy(i, o, p);
          return;
        }
        case y: {
          if (!Wu) {
            W_(p, o);
            var mt = p.stateNode;
            typeof mt.componentWillUnmount == "function" && gD(p, o, mt);
          }
          Xy(i, o, p);
          return;
        }
        case ye: {
          Xy(i, o, p);
          return;
        }
        case de: {
          if (
            // TODO: Remove this dead flag
            p.mode & Rr
          ) {
            var Lt = Wu;
            Wu = Lt || p.memoizedState !== null, Xy(i, o, p), Wu = Lt;
          } else
            Xy(i, o, p);
          break;
        }
        default: {
          Xy(i, o, p);
          return;
        }
      }
    }
    function e5(i) {
      i.memoizedState;
    }
    function t5(i, o) {
      var p = o.memoizedState;
      if (p === null) {
        var S = o.alternate;
        if (S !== null) {
          var T = S.memoizedState;
          if (T !== null) {
            var P = T.dehydrated;
            P !== null && KM(P);
          }
        }
      }
    }
    function kN(i) {
      var o = i.updateQueue;
      if (o !== null) {
        i.updateQueue = null;
        var p = i.stateNode;
        p === null && (p = i.stateNode = new IV()), o.forEach(function(S) {
          var T = Q5.bind(null, i, S);
          if (!p.has(S)) {
            if (p.add(S), Ba)
              if (V_ !== null && G_ !== null)
                H1(G_, V_);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            S.then(T, T);
          }
        });
      }
    }
    function n5(i, o, p) {
      V_ = p, G_ = i, zi(o), IN(o, i), zi(o), V_ = null, G_ = null;
    }
    function $p(i, o, p) {
      var S = o.deletions;
      if (S !== null)
        for (var T = 0; T < S.length; T++) {
          var P = S[T];
          try {
            JV(i, o, P);
          } catch (ee) {
            oo(P, o, ee);
          }
        }
      var H = dm();
      if (o.subtreeFlags & po)
        for (var $ = o.child; $ !== null; )
          zi($), IN($, i), $ = $.sibling;
      zi(H);
    }
    function IN(i, o, p) {
      var S = i.alternate, T = i.flags;
      switch (i.tag) {
        case v:
        case k:
        case Y:
        case Z: {
          if ($p(o, i), uv(i), T & Hn) {
            try {
              Wp(Yh | es, i, i.return), Yy(Yh | es, i);
            } catch (Mr) {
              oo(i, i.return, Mr);
            }
            if (i.mode & Zn) {
              try {
                lv(), Wp(ts | es, i, i.return);
              } catch (Mr) {
                oo(i, i.return, Mr);
              }
              Qh(i);
            } else
              try {
                Wp(ts | es, i, i.return);
              } catch (Mr) {
                oo(i, i.return, Mr);
              }
          }
          return;
        }
        case y: {
          $p(o, i), uv(i), T & fs && S !== null && W_(S, S.return);
          return;
        }
        case C: {
          $p(o, i), uv(i), T & fs && S !== null && W_(S, S.return);
          {
            if (i.flags & di) {
              var P = i.stateNode;
              try {
                Xx(P);
              } catch (Mr) {
                oo(i, i.return, Mr);
              }
            }
            if (T & Hn) {
              var H = i.stateNode;
              if (H != null) {
                var $ = i.memoizedProps, ee = S !== null ? S.memoizedProps : $, pe = i.type, _e = i.updateQueue;
                if (i.updateQueue = null, _e !== null)
                  try {
                    HM(H, _e, pe, ee, $, i);
                  } catch (Mr) {
                    oo(i, i.return, Mr);
                  }
              }
            }
          }
          return;
        }
        case D: {
          if ($p(o, i), uv(i), T & Hn) {
            if (i.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var Ge = i.stateNode, He = i.memoizedProps, ht = S !== null ? S.memoizedProps : He;
            try {
              SA(Ge, ht, He);
            } catch (Mr) {
              oo(i, i.return, Mr);
            }
          }
          return;
        }
        case b: {
          if ($p(o, i), uv(i), T & Hn && S !== null) {
            var mt = S.memoizedState;
            if (mt.isDehydrated)
              try {
                qM(o.containerInfo);
              } catch (Mr) {
                oo(i, i.return, Mr);
              }
          }
          return;
        }
        case M: {
          $p(o, i), uv(i);
          return;
        }
        case j: {
          $p(o, i), uv(i);
          var Lt = i.child;
          if (Lt.flags & lc) {
            var Ln = Lt.stateNode, ur = Lt.memoizedState, tr = ur !== null;
            if (Ln.isHidden = tr, tr) {
              var Pi = Lt.alternate !== null && Lt.alternate.memoizedState !== null;
              Pi || z5();
            }
          }
          if (T & Hn) {
            try {
              e5(i);
            } catch (Mr) {
              oo(i, i.return, Mr);
            }
            kN(i);
          }
          return;
        }
        case de: {
          var bi = S !== null && S.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            i.mode & Rr
          ) {
            var rt = Wu;
            Wu = rt || bi, $p(o, i), Wu = rt;
          } else
            $p(o, i);
          if (uv(i), T & lc) {
            var Ot = i.stateNode, it = i.memoizedState, nn = it !== null, On = i;
            if (Ot.isHidden = nn, nn && !bi && (On.mode & Rr) !== Qn) {
              Vn = On;
              for (var Cn = On.child; Cn !== null; )
                Vn = Cn, i5(Cn), Cn = Cn.sibling;
            }
            qV(On, nn);
          }
          return;
        }
        case oe: {
          $p(o, i), uv(i), T & Hn && kN(i);
          return;
        }
        case ye:
          return;
        default: {
          $p(o, i), uv(i);
          return;
        }
      }
    }
    function uv(i) {
      var o = i.flags;
      if (o & Hr) {
        try {
          ZV(i);
        } catch (p) {
          oo(i, i.return, p);
        }
        i.flags &= ~Hr;
      }
      o & Hs && (i.flags &= ~Hs);
    }
    function r5(i, o, p) {
      V_ = p, G_ = o, Vn = i, FN(i, o, p), V_ = null, G_ = null;
    }
    function FN(i, o, p) {
      for (var S = (i.mode & Rr) !== Qn; Vn !== null; ) {
        var T = Vn, P = T.child;
        if (T.tag === de && S) {
          var H = T.memoizedState !== null, $ = H || Bw;
          if ($) {
            xD(i, o, p);
            continue;
          } else {
            var ee = T.alternate, pe = ee !== null && ee.memoizedState !== null, _e = pe || Wu, Ge = Bw, He = Wu;
            Bw = $, Wu = _e, Wu && !He && (Vn = T, a5(T));
            for (var ht = P; ht !== null; )
              Vn = ht, FN(
                ht,
                // New root; bubble back up to here and stop.
                o,
                p
              ), ht = ht.sibling;
            Vn = T, Bw = Ge, Wu = He, xD(i, o, p);
            continue;
          }
        }
        (T.subtreeFlags & La) !== Kn && P !== null ? (P.return = T, Vn = P) : xD(i, o, p);
      }
    }
    function xD(i, o, p) {
      for (; Vn !== null; ) {
        var S = Vn;
        if ((S.flags & La) !== Kn) {
          var T = S.alternate;
          zi(S);
          try {
            YV(o, T, S, p);
          } catch (H) {
            oo(S, S.return, H);
          }
          Ca();
        }
        if (S === i) {
          Vn = null;
          return;
        }
        var P = S.sibling;
        if (P !== null) {
          P.return = S.return, Vn = P;
          return;
        }
        Vn = S.return;
      }
    }
    function i5(i) {
      for (; Vn !== null; ) {
        var o = Vn, p = o.child;
        switch (o.tag) {
          case v:
          case k:
          case Y:
          case Z: {
            if (o.mode & Zn)
              try {
                lv(), Wp(ts, o, o.return);
              } finally {
                Qh(o);
              }
            else
              Wp(ts, o, o.return);
            break;
          }
          case y: {
            W_(o, o.return);
            var S = o.stateNode;
            typeof S.componentWillUnmount == "function" && gD(o, o.return, S);
            break;
          }
          case C: {
            W_(o, o.return);
            break;
          }
          case de: {
            var T = o.memoizedState !== null;
            if (T) {
              BN(i);
              continue;
            }
            break;
          }
        }
        p !== null ? (p.return = o, Vn = p) : BN(i);
      }
    }
    function BN(i) {
      for (; Vn !== null; ) {
        var o = Vn;
        if (o === i) {
          Vn = null;
          return;
        }
        var p = o.sibling;
        if (p !== null) {
          p.return = o.return, Vn = p;
          return;
        }
        Vn = o.return;
      }
    }
    function a5(i) {
      for (; Vn !== null; ) {
        var o = Vn, p = o.child;
        if (o.tag === de) {
          var S = o.memoizedState !== null;
          if (S) {
            HN(i);
            continue;
          }
        }
        p !== null ? (p.return = o, Vn = p) : HN(i);
      }
    }
    function HN(i) {
      for (; Vn !== null; ) {
        var o = Vn;
        zi(o);
        try {
          XV(o);
        } catch (S) {
          oo(o, o.return, S);
        }
        if (Ca(), o === i) {
          Vn = null;
          return;
        }
        var p = o.sibling;
        if (p !== null) {
          p.return = o.return, Vn = p;
          return;
        }
        Vn = o.return;
      }
    }
    function o5(i, o, p, S) {
      Vn = o, s5(o, i, p, S);
    }
    function s5(i, o, p, S) {
      for (; Vn !== null; ) {
        var T = Vn, P = T.child;
        (T.subtreeFlags & Lu) !== Kn && P !== null ? (P.return = T, Vn = P) : l5(i, o, p, S);
      }
    }
    function l5(i, o, p, S) {
      for (; Vn !== null; ) {
        var T = Vn;
        if ((T.flags & ua) !== Kn) {
          zi(T);
          try {
            u5(o, T, p, S);
          } catch (H) {
            oo(T, T.return, H);
          }
          Ca();
        }
        if (T === i) {
          Vn = null;
          return;
        }
        var P = T.sibling;
        if (P !== null) {
          P.return = T.return, Vn = P;
          return;
        }
        Vn = T.return;
      }
    }
    function u5(i, o, p, S) {
      switch (o.tag) {
        case v:
        case k:
        case Z: {
          if (o.mode & Zn) {
            QA();
            try {
              Yy(Wl | es, o);
            } finally {
              M1(o);
            }
          } else
            Yy(Wl | es, o);
          break;
        }
      }
    }
    function c5(i) {
      Vn = i, f5();
    }
    function f5() {
      for (; Vn !== null; ) {
        var i = Vn, o = i.child;
        if ((Vn.flags & ii) !== Kn) {
          var p = i.deletions;
          if (p !== null) {
            for (var S = 0; S < p.length; S++) {
              var T = p[S];
              Vn = T, p5(T, i);
            }
            {
              var P = i.alternate;
              if (P !== null) {
                var H = P.child;
                if (H !== null) {
                  P.child = null;
                  do {
                    var $ = H.sibling;
                    H.sibling = null, H = $;
                  } while (H !== null);
                }
              }
            }
            Vn = i;
          }
        }
        (i.subtreeFlags & Lu) !== Kn && o !== null ? (o.return = i, Vn = o) : d5();
      }
    }
    function d5() {
      for (; Vn !== null; ) {
        var i = Vn;
        (i.flags & ua) !== Kn && (zi(i), h5(i), Ca());
        var o = i.sibling;
        if (o !== null) {
          o.return = i.return, Vn = o;
          return;
        }
        Vn = i.return;
      }
    }
    function h5(i) {
      switch (i.tag) {
        case v:
        case k:
        case Z: {
          i.mode & Zn ? (QA(), Wp(Wl | es, i, i.return), M1(i)) : Wp(Wl | es, i, i.return);
          break;
        }
      }
    }
    function p5(i, o) {
      for (; Vn !== null; ) {
        var p = Vn;
        zi(p), v5(p, o), Ca();
        var S = p.child;
        S !== null ? (S.return = p, Vn = S) : m5(i);
      }
    }
    function m5(i) {
      for (; Vn !== null; ) {
        var o = Vn, p = o.sibling, S = o.return;
        if (PN(o), o === i) {
          Vn = null;
          return;
        }
        if (p !== null) {
          p.return = S, Vn = p;
          return;
        }
        Vn = S;
      }
    }
    function v5(i, o) {
      switch (i.tag) {
        case v:
        case k:
        case Z: {
          i.mode & Zn ? (QA(), Wp(Wl, i, o), M1(i)) : Wp(Wl, i, o);
          break;
        }
      }
    }
    function g5(i) {
      switch (i.tag) {
        case v:
        case k:
        case Z: {
          try {
            Yy(ts | es, i);
          } catch (p) {
            oo(i, i.return, p);
          }
          break;
        }
        case y: {
          var o = i.stateNode;
          try {
            o.componentDidMount();
          } catch (p) {
            oo(i, i.return, p);
          }
          break;
        }
      }
    }
    function y5(i) {
      switch (i.tag) {
        case v:
        case k:
        case Z: {
          try {
            Yy(Wl | es, i);
          } catch (o) {
            oo(i, i.return, o);
          }
          break;
        }
      }
    }
    function S5(i) {
      switch (i.tag) {
        case v:
        case k:
        case Z: {
          try {
            Wp(ts | es, i, i.return);
          } catch (p) {
            oo(i, i.return, p);
          }
          break;
        }
        case y: {
          var o = i.stateNode;
          typeof o.componentWillUnmount == "function" && gD(i, i.return, o);
          break;
        }
      }
    }
    function x5(i) {
      switch (i.tag) {
        case v:
        case k:
        case Z:
          try {
            Wp(Wl | es, i, i.return);
          } catch (o) {
            oo(i, i.return, o);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var D1 = Symbol.for;
      D1("selector.component"), D1("selector.has_pseudo_class"), D1("selector.role"), D1("selector.test_id"), D1("selector.text");
    }
    var _5 = [];
    function E5() {
      _5.forEach(function(i) {
        return i();
      });
    }
    var b5 = t.ReactCurrentActQueue;
    function T5(i) {
      {
        var o = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), p = typeof jest < "u";
        return p && o !== !1;
      }
    }
    function VN() {
      {
        var i = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !i && b5.current !== null && u("The current testing environment is not configured to support act(...)"), i;
      }
    }
    var M5 = Math.ceil, _D = t.ReactCurrentDispatcher, ED = t.ReactCurrentOwner, $u = t.ReactCurrentBatchConfig, Yp = t.ReactCurrentActQueue, Yl = (
      /*             */
      0
    ), GN = (
      /*               */
      1
    ), Yu = (
      /*                */
      2
    ), Zh = (
      /*                */
      4
    ), Sg = 0, L1 = 1, LS = 2, Vw = 3, O1 = 4, WN = 5, bD = 6, Oi = Yl, pf = null, ns = null, Xl = Ct, cv = Ct, TD = Up(Ct), ql = Sg, P1 = null, Gw = Ct, N1 = Ct, Ww = Ct, U1 = null, ad = null, MD = 0, jN = 500, $N = 1 / 0, w5 = 500, xg = null;
    function z1() {
      $N = va() + w5;
    }
    function YN() {
      return $N;
    }
    var jw = !1, wD = null, j_ = null, OS = !1, qy = null, k1 = Ct, CD = [], RD = null, C5 = 50, I1 = 0, AD = null, DD = !1, $w = !1, R5 = 50, $_ = 0, Yw = null, F1 = Xr, Xw = Ct, XN = !1;
    function qw() {
      return pf;
    }
    function mf() {
      return (Oi & (Yu | Zh)) !== Yl ? va() : (F1 !== Xr || (F1 = va()), F1);
    }
    function Ky(i) {
      var o = i.mode;
      if ((o & Rr) === Qn)
        return Wn;
      if ((Oi & Yu) !== Yl && Xl !== Ct)
        return fi(Xl);
      var p = f_() !== ig;
      if (p) {
        if ($u.transition !== null) {
          var S = $u.transition;
          S._updatedFibers || (S._updatedFibers = /* @__PURE__ */ new Set()), S._updatedFibers.add(i);
        }
        return Xw === Jr && (Xw = Jn()), Xw;
      }
      var T = zu();
      if (T !== Jr)
        return T;
      var P = gA();
      return P;
    }
    function A5(i) {
      var o = i.mode;
      return (o & Rr) === Qn ? Wn : aa();
    }
    function Kl(i, o, p, S) {
      J5(), XN && u("useInsertionEffect must not schedule updates."), DD && ($w = !0), Gr(i, p, S), (Oi & Yu) !== Ct && i === pf ? nG(o) : (Ba && qg(i, o, p), rG(o), i === pf && ((Oi & Yu) === Yl && (N1 = Pt(N1, p)), ql === O1 && Qy(i, Xl)), od(i, S), p === Wn && Oi === Yl && (o.mode & Rr) === Qn && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Yp.isBatchingLegacy && (z1(), uw()));
    }
    function D5(i, o, p) {
      var S = i.current;
      S.lanes = o, Gr(i, o, p), od(i, p);
    }
    function L5(i) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (Oi & Yu) !== Yl
      );
    }
    function od(i, o) {
      var p = i.callbackNode;
      g(i, o);
      var S = dc(i, i === pf ? Xl : Ct);
      if (S === Ct) {
        p !== null && cU(p), i.callbackNode = null, i.callbackPriority = Jr;
        return;
      }
      var T = yn(S), P = i.callbackPriority;
      if (P === T && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Yp.current !== null && p !== kD)) {
        p == null && P !== Wn && u("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      p != null && cU(p);
      var H;
      if (T === Wn)
        i.tag === qm ? (Yp.isBatchingLegacy !== null && (Yp.didScheduleLegacyUpdate = !0), lw(QN.bind(null, i))) : sw(QN.bind(null, i)), Yp.current !== null ? Yp.current.push(Km) : FM(function() {
          (Oi & (Yu | Zh)) === Yl && Km();
        }), H = null;
      else {
        var $;
        switch (xp(S)) {
          case gs:
            $ = Cm;
            break;
          case qo:
            $ = ul;
            break;
          case af:
            $ = uu;
            break;
          case yp:
            $ = Yc;
            break;
          default:
            $ = uu;
            break;
        }
        H = ID($, qN.bind(null, i));
      }
      i.callbackPriority = T, i.callbackNode = H;
    }
    function qN(i, o) {
      if (Kh(), F1 = Xr, Xw = Ct, (Oi & (Yu | Zh)) !== Yl)
        throw new Error("Should not already be working.");
      var p = i.callbackNode, S = Eg();
      if (S && i.callbackNode !== p)
        return null;
      var T = dc(i, i === pf ? Xl : Ct);
      if (T === Ct)
        return null;
      var P = !Qt(i, T) && !cn(i, T) && !o, H = P ? H5(i, T) : Qw(i, T);
      if (H !== Sg) {
        if (H === LS) {
          var $ = z(i);
          $ !== Ct && (T = $, H = LD(i, $));
        }
        if (H === L1) {
          var ee = P1;
          throw PS(i, Ct), Qy(i, T), od(i, va()), ee;
        }
        if (H === bD)
          Qy(i, T);
        else {
          var pe = !Qt(i, T), _e = i.current.alternate;
          if (pe && !P5(_e)) {
            if (H = Qw(i, T), H === LS) {
              var Ge = z(i);
              Ge !== Ct && (T = Ge, H = LD(i, Ge));
            }
            if (H === L1) {
              var He = P1;
              throw PS(i, Ct), Qy(i, T), od(i, va()), He;
            }
          }
          i.finishedWork = _e, i.finishedLanes = T, O5(i, H, T);
        }
      }
      return od(i, va()), i.callbackNode === p ? qN.bind(null, i) : null;
    }
    function LD(i, o) {
      var p = U1;
      if (Ao(i)) {
        var S = PS(i, o);
        S.flags |= Da, Tn(i.containerInfo);
      }
      var T = Qw(i, o);
      if (T !== LS) {
        var P = ad;
        ad = p, P !== null && KN(P);
      }
      return T;
    }
    function KN(i) {
      ad === null ? ad = i : ad.push.apply(ad, i);
    }
    function O5(i, o, p) {
      switch (o) {
        case Sg:
        case L1:
          throw new Error("Root did not complete. This is a bug in React.");
        case LS: {
          NS(i, ad, xg);
          break;
        }
        case Vw: {
          if (Qy(i, p), Me(p) && // do not delay if we're inside an act() scope
          !fU()) {
            var S = MD + jN - va();
            if (S > 10) {
              var T = dc(i, Ct);
              if (T !== Ct)
                break;
              var P = i.suspendedLanes;
              if (!vt(P, p)) {
                mf(), Th(i, P);
                break;
              }
              i.timeoutHandle = Mb(NS.bind(null, i, ad, xg), S);
              break;
            }
          }
          NS(i, ad, xg);
          break;
        }
        case O1: {
          if (Qy(i, p), Mt(p))
            break;
          if (!fU()) {
            var H = Pm(i, p), $ = H, ee = va() - $, pe = Z5(ee) - ee;
            if (pe > 10) {
              i.timeoutHandle = Mb(NS.bind(null, i, ad, xg), pe);
              break;
            }
          }
          NS(i, ad, xg);
          break;
        }
        case WN: {
          NS(i, ad, xg);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function P5(i) {
      for (var o = i; ; ) {
        if (o.flags & If) {
          var p = o.updateQueue;
          if (p !== null) {
            var S = p.stores;
            if (S !== null)
              for (var T = 0; T < S.length; T++) {
                var P = S[T], H = P.getSnapshot, $ = P.value;
                try {
                  if (!In(H(), $))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var ee = o.child;
        if (o.subtreeFlags & If && ee !== null) {
          ee.return = o, o = ee;
          continue;
        }
        if (o === i)
          return !0;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === i)
            return !0;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
      return !0;
    }
    function Qy(i, o) {
      o = Dn(o, Ww), o = Dn(o, N1), hc(i, o);
    }
    function QN(i) {
      if ($y(), (Oi & (Yu | Zh)) !== Yl)
        throw new Error("Should not already be working.");
      Eg();
      var o = dc(i, Ct);
      if (!Be(o, Wn))
        return od(i, va()), null;
      var p = Qw(i, o);
      if (i.tag !== qm && p === LS) {
        var S = z(i);
        S !== Ct && (o = S, p = LD(i, S));
      }
      if (p === L1) {
        var T = P1;
        throw PS(i, Ct), Qy(i, o), od(i, va()), T;
      }
      if (p === bD)
        throw new Error("Root did not complete. This is a bug in React.");
      var P = i.current.alternate;
      return i.finishedWork = P, i.finishedLanes = o, NS(i, ad, xg), od(i, va()), null;
    }
    function N5(i, o) {
      o !== Ct && (gp(i, Pt(o, Wn)), od(i, va()), (Oi & (Yu | Zh)) === Yl && (z1(), Km()));
    }
    function OD(i, o) {
      var p = Oi;
      Oi |= GN;
      try {
        return i(o);
      } finally {
        Oi = p, Oi === Yl && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Yp.isBatchingLegacy && (z1(), uw());
      }
    }
    function U5(i, o, p, S, T) {
      var P = zu(), H = $u.transition;
      try {
        return $u.transition = null, yo(gs), i(o, p, S, T);
      } finally {
        yo(P), $u.transition = H, Oi === Yl && z1();
      }
    }
    function _g(i) {
      qy !== null && qy.tag === qm && (Oi & (Yu | Zh)) === Yl && Eg();
      var o = Oi;
      Oi |= GN;
      var p = $u.transition, S = zu();
      try {
        return $u.transition = null, yo(gs), i ? i() : void 0;
      } finally {
        yo(S), $u.transition = p, Oi = o, (Oi & (Yu | Zh)) === Yl && Km();
      }
    }
    function ZN() {
      return (Oi & (Yu | Zh)) !== Yl;
    }
    function Kw(i, o) {
      Su(TD, cv, i), cv = Pt(cv, o);
    }
    function PD(i) {
      cv = TD.current, yu(TD, i);
    }
    function PS(i, o) {
      i.finishedWork = null, i.finishedLanes = Ct;
      var p = i.timeoutHandle;
      if (p !== _y && (i.timeoutHandle = _y, wb(p)), ns !== null)
        for (var S = ns.return; S !== null; ) {
          var T = S.alternate;
          CN(T, S), S = S.return;
        }
      pf = i;
      var P = US(i.current, null);
      return ns = P, Xl = cv = o, ql = Sg, P1 = null, Gw = Ct, N1 = Ct, Ww = Ct, U1 = null, ad = null, qb(), Hu.discardPendingWarnings(), P;
    }
    function JN(i, o) {
      do {
        var p = ns;
        try {
          if (h_(), p1(), Ca(), ED.current = null, p === null || p.return === null) {
            ql = L1, P1 = o, ns = null;
            return;
          }
          if (je && p.mode & Zn && RS(p, !0), Ze)
            if (ca(), o !== null && typeof o == "object" && typeof o.then == "function") {
              var S = o;
              Gs(p, S, Xl);
            } else
              Vf(p, o, Xl);
          aV(i, p.return, p, o, Xl), rU(p);
        } catch (T) {
          o = T, ns === p && p !== null ? (p = p.return, ns = p) : p = ns;
          continue;
        }
        return;
      } while (!0);
    }
    function eU() {
      var i = _D.current;
      return _D.current = ct, i === null ? ct : i;
    }
    function tU(i) {
      _D.current = i;
    }
    function z5() {
      MD = va();
    }
    function B1(i) {
      Gw = Pt(i, Gw);
    }
    function k5() {
      ql === Sg && (ql = Vw);
    }
    function ND() {
      (ql === Sg || ql === Vw || ql === LS) && (ql = O1), pf !== null && (Q(Gw) || Q(N1)) && Qy(pf, Xl);
    }
    function I5(i) {
      ql !== O1 && (ql = LS), U1 === null ? U1 = [i] : U1.push(i);
    }
    function F5() {
      return ql === Sg;
    }
    function Qw(i, o) {
      var p = Oi;
      Oi |= Yu;
      var S = eU();
      if (pf !== i || Xl !== o) {
        if (Ba) {
          var T = i.memoizedUpdaters;
          T.size > 0 && (H1(i, Xl), T.clear()), Nm(i, o);
        }
        xg = Kg(), PS(i, o);
      }
      cl(o);
      do
        try {
          B5();
          break;
        } catch (P) {
          JN(i, P);
        }
      while (!0);
      if (h_(), Oi = p, tU(S), ns !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Kc(), pf = null, Xl = Ct, ql;
    }
    function B5() {
      for (; ns !== null; )
        nU(ns);
    }
    function H5(i, o) {
      var p = Oi;
      Oi |= Yu;
      var S = eU();
      if (pf !== i || Xl !== o) {
        if (Ba) {
          var T = i.memoizedUpdaters;
          T.size > 0 && (H1(i, Xl), T.clear()), Nm(i, o);
        }
        xg = Kg(), z1(), PS(i, o);
      }
      cl(o);
      do
        try {
          V5();
          break;
        } catch (P) {
          JN(i, P);
        }
      while (!0);
      return h_(), tU(S), Oi = p, ns !== null ? (fu(), Sg) : (Kc(), pf = null, Xl = Ct, ql);
    }
    function V5() {
      for (; ns !== null && !ps(); )
        nU(ns);
    }
    function nU(i) {
      var o = i.alternate;
      zi(i);
      var p;
      (i.mode & Zn) !== Qn ? (Vp(i), p = UD(o, i, cv), RS(i, !0)) : p = UD(o, i, cv), Ca(), i.memoizedProps = i.pendingProps, p === null ? rU(i) : ns = p, ED.current = null;
    }
    function rU(i) {
      var o = i;
      do {
        var p = o.alternate, S = o.return;
        if ((o.flags & ds) === Kn) {
          zi(o);
          var T = void 0;
          if ((o.mode & Zn) === Qn ? T = wN(p, o, cv) : (Vp(o), T = wN(p, o, cv), RS(o, !1)), Ca(), T !== null) {
            ns = T;
            return;
          }
        } else {
          var P = kV(p, o);
          if (P !== null) {
            P.flags &= Av, ns = P;
            return;
          }
          if ((o.mode & Zn) !== Qn) {
            RS(o, !1);
            for (var H = o.actualDuration, $ = o.child; $ !== null; )
              H += $.actualDuration, $ = $.sibling;
            o.actualDuration = H;
          }
          if (S !== null)
            S.flags |= ds, S.subtreeFlags = Kn, S.deletions = null;
          else {
            ql = bD, ns = null;
            return;
          }
        }
        var ee = o.sibling;
        if (ee !== null) {
          ns = ee;
          return;
        }
        o = S, ns = o;
      } while (o !== null);
      ql === Sg && (ql = WN);
    }
    function NS(i, o, p) {
      var S = zu(), T = $u.transition;
      try {
        $u.transition = null, yo(gs), G5(i, o, p, S);
      } finally {
        $u.transition = T, yo(S);
      }
      return null;
    }
    function G5(i, o, p, S) {
      do
        Eg();
      while (qy !== null);
      if (eG(), (Oi & (Yu | Zh)) !== Yl)
        throw new Error("Should not already be working.");
      var T = i.finishedWork, P = i.finishedLanes;
      if (xa(P), T === null)
        return zr(), null;
      if (P === Ct && u("root.finishedLanes should not be empty during a commit. This is a bug in React."), i.finishedWork = null, i.finishedLanes = Ct, T === i.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      i.callbackNode = null, i.callbackPriority = Jr;
      var H = Pt(T.lanes, T.childLanes);
      T0(i, H), i === pf && (pf = null, ns = null, Xl = Ct), ((T.subtreeFlags & Lu) !== Kn || (T.flags & Lu) !== Kn) && (OS || (OS = !0, RD = p, ID(uu, function() {
        return Eg(), null;
      })));
      var $ = (T.subtreeFlags & (Sr | po | La | Lu)) !== Kn, ee = (T.flags & (Sr | po | La | Lu)) !== Kn;
      if ($ || ee) {
        var pe = $u.transition;
        $u.transition = null;
        var _e = zu();
        yo(gs);
        var Ge = Oi;
        Oi |= Zh, ED.current = null, VV(i, T), Mc(), n5(i, T, P), bb(i.containerInfo), i.current = T, Dm(P), r5(T, i, P), Gf(), mo(), Oi = Ge, yo(_e), $u.transition = pe;
      } else
        i.current = T, Mc();
      var He = OS;
      if (OS ? (OS = !1, qy = i, k1 = P) : ($_ = 0, Yw = null), H = i.pendingLanes, H === Ct && (j_ = null), He || sU(i.current, !1), ms(T.stateNode, S), Ba && i.memoizedUpdaters.clear(), E5(), od(i, va()), o !== null)
        for (var ht = i.onRecoverableError, mt = 0; mt < o.length; mt++) {
          var Lt = o[mt], Ln = Lt.stack, ur = Lt.digest;
          ht(Lt.value, {
            componentStack: Ln,
            digest: ur
          });
        }
      if (jw) {
        jw = !1;
        var tr = wD;
        throw wD = null, tr;
      }
      return Be(k1, Wn) && i.tag !== qm && Eg(), H = i.pendingLanes, Be(H, Wn) ? (df(), i === AD ? I1++ : (I1 = 0, AD = i)) : I1 = 0, Km(), zr(), null;
    }
    function Eg() {
      if (qy !== null) {
        var i = xp(k1), o = M0(af, i), p = $u.transition, S = zu();
        try {
          return $u.transition = null, yo(o), j5();
        } finally {
          yo(S), $u.transition = p;
        }
      }
      return !1;
    }
    function W5(i) {
      CD.push(i), OS || (OS = !0, ID(uu, function() {
        return Eg(), null;
      }));
    }
    function j5() {
      if (qy === null)
        return !1;
      var i = RD;
      RD = null;
      var o = qy, p = k1;
      if (qy = null, k1 = Ct, (Oi & (Yu | Zh)) !== Yl)
        throw new Error("Cannot flush passive effects while already rendering.");
      DD = !0, $w = !1, Nd(p);
      var S = Oi;
      Oi |= Zh, c5(o.current), o5(o, o.current, p, i);
      {
        var T = CD;
        CD = [];
        for (var P = 0; P < T.length; P++) {
          var H = T[P];
          $V(o, H);
        }
      }
      qc(), sU(o.current, !0), Oi = S, Km(), $w ? o === Yw ? $_++ : ($_ = 0, Yw = o) : $_ = 0, DD = !1, $w = !1, Sa(o);
      {
        var $ = o.current.stateNode;
        $.effectDuration = 0, $.passiveEffectDuration = 0;
      }
      return !0;
    }
    function iU(i) {
      return j_ !== null && j_.has(i);
    }
    function $5(i) {
      j_ === null ? j_ = /* @__PURE__ */ new Set([i]) : j_.add(i);
    }
    function Y5(i) {
      jw || (jw = !0, wD = i);
    }
    var X5 = Y5;
    function aU(i, o, p) {
      var S = AS(p, o), T = nN(i, S, Wn), P = nv(i, T, Wn), H = mf();
      P !== null && (Gr(P, Wn, H), od(P, H));
    }
    function oo(i, o, p) {
      if (FV(p), V1(!1), i.tag === b) {
        aU(i, i, p);
        return;
      }
      var S = null;
      for (S = o; S !== null; ) {
        if (S.tag === b) {
          aU(S, i, p);
          return;
        } else if (S.tag === y) {
          var T = S.type, P = S.stateNode;
          if (typeof T.getDerivedStateFromError == "function" || typeof P.componentDidCatch == "function" && !iU(P)) {
            var H = AS(p, i), $ = tD(S, H, Wn), ee = nv(S, $, Wn), pe = mf();
            ee !== null && (Gr(ee, Wn, pe), od(ee, pe));
            return;
          }
        }
        S = S.return;
      }
      u(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, p);
    }
    function q5(i, o, p) {
      var S = i.pingCache;
      S !== null && S.delete(o);
      var T = mf();
      Th(i, p), iG(i), pf === i && vt(Xl, p) && (ql === O1 || ql === Vw && Me(Xl) && va() - MD < jN ? PS(i, Ct) : Ww = Pt(Ww, p)), od(i, T);
    }
    function oU(i, o) {
      o === Jr && (o = A5(i));
      var p = mf(), S = Vl(i, o);
      S !== null && (Gr(S, o, p), od(S, p));
    }
    function K5(i) {
      var o = i.memoizedState, p = Jr;
      o !== null && (p = o.retryLane), oU(i, p);
    }
    function Q5(i, o) {
      var p = Jr, S;
      switch (i.tag) {
        case j:
          S = i.stateNode;
          var T = i.memoizedState;
          T !== null && (p = T.retryLane);
          break;
        case oe:
          S = i.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      S !== null && S.delete(o), oU(i, p);
    }
    function Z5(i) {
      return i < 120 ? 120 : i < 480 ? 480 : i < 1080 ? 1080 : i < 1920 ? 1920 : i < 3e3 ? 3e3 : i < 4320 ? 4320 : M5(i / 1960) * 1960;
    }
    function J5() {
      if (I1 > C5)
        throw I1 = 0, AD = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      $_ > R5 && ($_ = 0, Yw = null, u("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function eG() {
      Hu.flushLegacyContextWarning(), Hu.flushPendingUnsafeLifecycleWarnings();
    }
    function sU(i, o) {
      zi(i), Zw(i, hi, S5), o && Zw(i, lu, x5), Zw(i, hi, g5), o && Zw(i, lu, y5), Ca();
    }
    function Zw(i, o, p) {
      for (var S = i, T = null; S !== null; ) {
        var P = S.subtreeFlags & o;
        S !== T && S.child !== null && P !== Kn ? S = S.child : ((S.flags & o) !== Kn && p(S), S.sibling !== null ? S = S.sibling : S = T = S.return);
      }
    }
    var Jw = null;
    function lU(i) {
      {
        if ((Oi & Yu) !== Yl || !(i.mode & Rr))
          return;
        var o = i.tag;
        if (o !== _ && o !== b && o !== y && o !== v && o !== k && o !== Y && o !== Z)
          return;
        var p = lr(i) || "ReactComponent";
        if (Jw !== null) {
          if (Jw.has(p))
            return;
          Jw.add(p);
        } else
          Jw = /* @__PURE__ */ new Set([p]);
        var S = pa;
        try {
          zi(i), u("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          S ? zi(i) : Ca();
        }
      }
    }
    var UD;
    {
      var tG = null;
      UD = function(i, o, p) {
        var S = vU(tG, o);
        try {
          return _N(i, o, p);
        } catch (P) {
          if (Vb() || P !== null && typeof P == "object" && typeof P.then == "function")
            throw P;
          if (h_(), p1(), CN(i, o), vU(o, S), o.mode & Zn && Vp(o), sc(null, _N, null, i, o, p), kf()) {
            var T = Dd();
            typeof T == "object" && T !== null && T._suppressLogging && typeof P == "object" && P !== null && !P._suppressLogging && (P._suppressLogging = !0);
          }
          throw P;
        }
      };
    }
    var uU = !1, zD;
    zD = /* @__PURE__ */ new Set();
    function nG(i) {
      if (br && !Et())
        switch (i.tag) {
          case v:
          case k:
          case Z: {
            var o = ns && lr(ns) || "Unknown", p = o;
            if (!zD.has(p)) {
              zD.add(p);
              var S = lr(i) || "Unknown";
              u("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", S, o, o);
            }
            break;
          }
          case y: {
            uU || (u("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), uU = !0);
            break;
          }
        }
    }
    function H1(i, o) {
      if (Ba) {
        var p = i.memoizedUpdaters;
        p.forEach(function(S) {
          qg(i, S, o);
        });
      }
    }
    var kD = {};
    function ID(i, o) {
      {
        var p = Yp.current;
        return p !== null ? (p.push(o), kD) : Od(i, o);
      }
    }
    function cU(i) {
      if (i !== kD)
        return Bf(i);
    }
    function fU() {
      return Yp.current !== null;
    }
    function rG(i) {
      {
        if (i.mode & Rr) {
          if (!VN())
            return;
        } else if (!T5() || Oi !== Yl || i.tag !== v && i.tag !== k && i.tag !== Z)
          return;
        if (Yp.current === null) {
          var o = pa;
          try {
            zi(i), u(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, lr(i));
          } finally {
            o ? zi(i) : Ca();
          }
        }
      }
    }
    function iG(i) {
      i.tag !== qm && VN() && Yp.current === null && u(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function V1(i) {
      XN = i;
    }
    var Jh = null, Y_ = null, aG = function(i) {
      Jh = i;
    };
    function X_(i) {
      {
        if (Jh === null)
          return i;
        var o = Jh(i);
        return o === void 0 ? i : o.current;
      }
    }
    function FD(i) {
      return X_(i);
    }
    function BD(i) {
      {
        if (Jh === null)
          return i;
        var o = Jh(i);
        if (o === void 0) {
          if (i != null && typeof i.render == "function") {
            var p = X_(i.render);
            if (i.render !== p) {
              var S = {
                $$typeof: _n,
                render: p
              };
              return i.displayName !== void 0 && (S.displayName = i.displayName), S;
            }
          }
          return i;
        }
        return o.current;
      }
    }
    function dU(i, o) {
      {
        if (Jh === null)
          return !1;
        var p = i.elementType, S = o.type, T = !1, P = typeof S == "object" && S !== null ? S.$$typeof : null;
        switch (i.tag) {
          case y: {
            typeof S == "function" && (T = !0);
            break;
          }
          case v: {
            (typeof S == "function" || P === ze) && (T = !0);
            break;
          }
          case k: {
            (P === _n || P === ze) && (T = !0);
            break;
          }
          case Y:
          case Z: {
            (P === qe || P === ze) && (T = !0);
            break;
          }
          default:
            return !1;
        }
        if (T) {
          var H = Jh(p);
          if (H !== void 0 && H === Jh(S))
            return !0;
        }
        return !1;
      }
    }
    function hU(i) {
      {
        if (Jh === null || typeof WeakSet != "function")
          return;
        Y_ === null && (Y_ = /* @__PURE__ */ new WeakSet()), Y_.add(i);
      }
    }
    var oG = function(i, o) {
      {
        if (Jh === null)
          return;
        var p = o.staleFamilies, S = o.updatedFamilies;
        Eg(), _g(function() {
          HD(i.current, S, p);
        });
      }
    }, sG = function(i, o) {
      {
        if (i.context !== xc)
          return;
        Eg(), _g(function() {
          G1(o, i, null, null);
        });
      }
    };
    function HD(i, o, p) {
      {
        var S = i.alternate, T = i.child, P = i.sibling, H = i.tag, $ = i.type, ee = null;
        switch (H) {
          case v:
          case Z:
          case y:
            ee = $;
            break;
          case k:
            ee = $.render;
            break;
        }
        if (Jh === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var pe = !1, _e = !1;
        if (ee !== null) {
          var Ge = Jh(ee);
          Ge !== void 0 && (p.has(Ge) ? _e = !0 : o.has(Ge) && (H === y ? _e = !0 : pe = !0));
        }
        if (Y_ !== null && (Y_.has(i) || S !== null && Y_.has(S)) && (_e = !0), _e && (i._debugNeedsRemount = !0), _e || pe) {
          var He = Vl(i, Wn);
          He !== null && Kl(He, i, Wn, Xr);
        }
        T !== null && !_e && HD(T, o, p), P !== null && HD(P, o, p);
      }
    }
    var lG = function(i, o) {
      {
        var p = /* @__PURE__ */ new Set(), S = new Set(o.map(function(T) {
          return T.current;
        }));
        return VD(i.current, S, p), p;
      }
    };
    function VD(i, o, p) {
      {
        var S = i.child, T = i.sibling, P = i.tag, H = i.type, $ = null;
        switch (P) {
          case v:
          case Z:
          case y:
            $ = H;
            break;
          case k:
            $ = H.render;
            break;
        }
        var ee = !1;
        $ !== null && o.has($) && (ee = !0), ee ? uG(i, p) : S !== null && VD(S, o, p), T !== null && VD(T, o, p);
      }
    }
    function uG(i, o) {
      {
        var p = cG(i, o);
        if (p)
          return;
        for (var S = i; ; ) {
          switch (S.tag) {
            case C:
              o.add(S.stateNode);
              return;
            case M:
              o.add(S.stateNode.containerInfo);
              return;
            case b:
              o.add(S.stateNode.containerInfo);
              return;
          }
          if (S.return === null)
            throw new Error("Expected to reach root first.");
          S = S.return;
        }
      }
    }
    function cG(i, o) {
      for (var p = i, S = !1; ; ) {
        if (p.tag === C)
          S = !0, o.add(p.stateNode);
        else if (p.child !== null) {
          p.child.return = p, p = p.child;
          continue;
        }
        if (p === i)
          return S;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === i)
            return S;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
      return !1;
    }
    var GD;
    {
      GD = !1;
      try {
        var pU = Object.preventExtensions({});
      } catch {
        GD = !0;
      }
    }
    function fG(i, o, p, S) {
      this.tag = i, this.key = p, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = o, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = S, this.flags = Kn, this.subtreeFlags = Kn, this.deletions = null, this.lanes = Ct, this.childLanes = Ct, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !GD && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var th = function(i, o, p, S) {
      return new fG(i, o, p, S);
    };
    function WD(i) {
      var o = i.prototype;
      return !!(o && o.isReactComponent);
    }
    function dG(i) {
      return typeof i == "function" && !WD(i) && i.defaultProps === void 0;
    }
    function hG(i) {
      if (typeof i == "function")
        return WD(i) ? y : v;
      if (i != null) {
        var o = i.$$typeof;
        if (o === _n)
          return k;
        if (o === qe)
          return Y;
      }
      return _;
    }
    function US(i, o) {
      var p = i.alternate;
      p === null ? (p = th(i.tag, o, i.key, i.mode), p.elementType = i.elementType, p.type = i.type, p.stateNode = i.stateNode, p._debugSource = i._debugSource, p._debugOwner = i._debugOwner, p._debugHookTypes = i._debugHookTypes, p.alternate = i, i.alternate = p) : (p.pendingProps = o, p.type = i.type, p.flags = Kn, p.subtreeFlags = Kn, p.deletions = null, p.actualDuration = 0, p.actualStartTime = -1), p.flags = i.flags & rn, p.childLanes = i.childLanes, p.lanes = i.lanes, p.child = i.child, p.memoizedProps = i.memoizedProps, p.memoizedState = i.memoizedState, p.updateQueue = i.updateQueue;
      var S = i.dependencies;
      switch (p.dependencies = S === null ? null : {
        lanes: S.lanes,
        firstContext: S.firstContext
      }, p.sibling = i.sibling, p.index = i.index, p.ref = i.ref, p.selfBaseDuration = i.selfBaseDuration, p.treeBaseDuration = i.treeBaseDuration, p._debugNeedsRemount = i._debugNeedsRemount, p.tag) {
        case _:
        case v:
        case Z:
          p.type = X_(i.type);
          break;
        case y:
          p.type = FD(i.type);
          break;
        case k:
          p.type = BD(i.type);
          break;
      }
      return p;
    }
    function pG(i, o) {
      i.flags &= rn | Hr;
      var p = i.alternate;
      if (p === null)
        i.childLanes = Ct, i.lanes = o, i.child = null, i.subtreeFlags = Kn, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null, i.selfBaseDuration = 0, i.treeBaseDuration = 0;
      else {
        i.childLanes = p.childLanes, i.lanes = p.lanes, i.child = p.child, i.subtreeFlags = Kn, i.deletions = null, i.memoizedProps = p.memoizedProps, i.memoizedState = p.memoizedState, i.updateQueue = p.updateQueue, i.type = p.type;
        var S = p.dependencies;
        i.dependencies = S === null ? null : {
          lanes: S.lanes,
          firstContext: S.firstContext
        }, i.selfBaseDuration = p.selfBaseDuration, i.treeBaseDuration = p.treeBaseDuration;
      }
      return i;
    }
    function mG(i, o, p) {
      var S;
      return i === iS ? (S = Rr, o === !0 && (S |= Yr, S |= wo)) : S = Qn, Ba && (S |= Zn), th(b, null, null, S);
    }
    function jD(i, o, p, S, T, P) {
      var H = _, $ = i;
      if (typeof i == "function")
        WD(i) ? (H = y, $ = FD($)) : $ = X_($);
      else if (typeof i == "string")
        H = C;
      else
        e:
          switch (i) {
            case _o:
              return Zy(p.children, T, P, o);
            case Eo:
              H = N, T |= Yr, (T & Rr) !== Qn && (T |= wo);
              break;
            case Le:
              return vG(p, T, P, o);
            case ve:
              return gG(p, T, P, o);
            case $e:
              return yG(p, T, P, o);
            case pn:
              return mU(p, T, P, o);
            case An:
            case dt:
            case Gn:
            case cr:
            case tn:
            default: {
              if (typeof i == "object" && i !== null)
                switch (i.$$typeof) {
                  case Bt:
                    H = I;
                    break e;
                  case en:
                    H = O;
                    break e;
                  case _n:
                    H = k, $ = BD($);
                    break e;
                  case qe:
                    H = Y;
                    break e;
                  case ze:
                    H = te, $ = null;
                    break e;
                }
              var ee = "";
              {
                (i === void 0 || typeof i == "object" && i !== null && Object.keys(i).length === 0) && (ee += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var pe = S ? lr(S) : null;
                pe && (ee += `

Check the render method of \`` + pe + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (i == null ? i : typeof i) + "." + ee));
            }
          }
      var _e = th(H, p, o, T);
      return _e.elementType = i, _e.type = $, _e.lanes = P, _e._debugOwner = S, _e;
    }
    function $D(i, o, p) {
      var S = null;
      S = i._owner;
      var T = i.type, P = i.key, H = i.props, $ = jD(T, P, H, S, o, p);
      return $._debugSource = i._source, $._debugOwner = i._owner, $;
    }
    function Zy(i, o, p, S) {
      var T = th(U, i, S, o);
      return T.lanes = p, T;
    }
    function vG(i, o, p, S) {
      typeof i.id != "string" && u('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof i.id);
      var T = th(G, i, S, o | Zn);
      return T.elementType = Le, T.lanes = p, T.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, T;
    }
    function gG(i, o, p, S) {
      var T = th(j, i, S, o);
      return T.elementType = ve, T.lanes = p, T;
    }
    function yG(i, o, p, S) {
      var T = th(oe, i, S, o);
      return T.elementType = $e, T.lanes = p, T;
    }
    function mU(i, o, p, S) {
      var T = th(de, i, S, o);
      T.elementType = pn, T.lanes = p;
      var P = {
        isHidden: !1
      };
      return T.stateNode = P, T;
    }
    function YD(i, o, p) {
      var S = th(D, i, null, o);
      return S.lanes = p, S;
    }
    function SG() {
      var i = th(C, null, null, Qn);
      return i.elementType = "DELETED", i;
    }
    function xG(i) {
      var o = th(q, null, null, Qn);
      return o.stateNode = i, o;
    }
    function XD(i, o, p) {
      var S = i.children !== null ? i.children : [], T = th(M, S, i.key, o);
      return T.lanes = p, T.stateNode = {
        containerInfo: i.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: i.implementation
      }, T;
    }
    function vU(i, o) {
      return i === null && (i = th(_, null, null, Qn)), i.tag = o.tag, i.key = o.key, i.elementType = o.elementType, i.type = o.type, i.stateNode = o.stateNode, i.return = o.return, i.child = o.child, i.sibling = o.sibling, i.index = o.index, i.ref = o.ref, i.pendingProps = o.pendingProps, i.memoizedProps = o.memoizedProps, i.updateQueue = o.updateQueue, i.memoizedState = o.memoizedState, i.dependencies = o.dependencies, i.mode = o.mode, i.flags = o.flags, i.subtreeFlags = o.subtreeFlags, i.deletions = o.deletions, i.lanes = o.lanes, i.childLanes = o.childLanes, i.alternate = o.alternate, i.actualDuration = o.actualDuration, i.actualStartTime = o.actualStartTime, i.selfBaseDuration = o.selfBaseDuration, i.treeBaseDuration = o.treeBaseDuration, i._debugSource = o._debugSource, i._debugOwner = o._debugOwner, i._debugNeedsRemount = o._debugNeedsRemount, i._debugHookTypes = o._debugHookTypes, i;
    }
    function _G(i, o, p, S, T) {
      this.tag = o, this.containerInfo = i, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = _y, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Jr, this.eventTimes = _a(Ct), this.expirationTimes = _a(Xr), this.pendingLanes = Ct, this.suspendedLanes = Ct, this.pingedLanes = Ct, this.expiredLanes = Ct, this.mutableReadLanes = Ct, this.finishedLanes = Ct, this.entangledLanes = Ct, this.entanglements = _a(Ct), this.identifierPrefix = S, this.onRecoverableError = T, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var P = this.pendingUpdatersLaneMap = [], H = 0; H < ci; H++)
          P.push(/* @__PURE__ */ new Set());
      }
      switch (o) {
        case iS:
          this._debugRootType = p ? "hydrateRoot()" : "createRoot()";
          break;
        case qm:
          this._debugRootType = p ? "hydrate()" : "render()";
          break;
      }
    }
    function gU(i, o, p, S, T, P, H, $, ee, pe) {
      var _e = new _G(i, o, p, $, ee), Ge = mG(o, P);
      _e.current = Ge, Ge.stateNode = _e;
      {
        var He = {
          element: S,
          isDehydrated: p,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        Ge.memoizedState = He;
      }
      return g_(Ge), _e;
    }
    var qD = "18.2.0";
    function EG(i, o, p) {
      var S = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return qt(S), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: ea,
        key: S == null ? null : "" + S,
        children: i,
        containerInfo: o,
        implementation: p
      };
    }
    var KD, QD;
    KD = !1, QD = {};
    function yU(i) {
      if (!i)
        return xc;
      var o = $o(i), p = kA(o);
      if (o.tag === y) {
        var S = o.type;
        if (Xd(S))
          return aw(o, S, p);
      }
      return p;
    }
    function bG(i, o) {
      {
        var p = $o(i);
        if (p === void 0) {
          if (typeof i.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var S = Object.keys(i).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + S);
        }
        var T = ll(p);
        if (T === null)
          return null;
        if (T.mode & Yr) {
          var P = lr(p) || "Component";
          if (!QD[P]) {
            QD[P] = !0;
            var H = pa;
            try {
              zi(T), p.mode & Yr ? u("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", o, o, P) : u("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", o, o, P);
            } finally {
              H ? zi(H) : Ca();
            }
          }
        }
        return T.stateNode;
      }
    }
    function SU(i, o, p, S, T, P, H, $) {
      var ee = !1, pe = null;
      return gU(i, o, ee, pe, p, S, T, P, H);
    }
    function xU(i, o, p, S, T, P, H, $, ee, pe) {
      var _e = !0, Ge = gU(p, S, _e, i, T, P, H, $, ee);
      Ge.context = yU(null);
      var He = Ge.current, ht = mf(), mt = Ky(He), Lt = Gh(ht, mt);
      return Lt.callback = o ?? null, nv(He, Lt, mt), D5(Ge, mt, ht), Ge;
    }
    function G1(i, o, p, S) {
      Am(o, i);
      var T = o.current, P = mf(), H = Ky(T);
      fl(H);
      var $ = yU(p);
      o.context === null ? o.context = $ : o.pendingContext = $, br && pa !== null && !KD && (KD = !0, u(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, lr(pa) || "Unknown"));
      var ee = Gh(P, H);
      ee.payload = {
        element: i
      }, S = S === void 0 ? null : S, S !== null && (typeof S != "function" && u("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", S), ee.callback = S);
      var pe = nv(T, ee, H);
      return pe !== null && (Kl(pe, T, H, P), S_(pe, T, H)), H;
    }
    function eC(i) {
      var o = i.current;
      if (!o.child)
        return null;
      switch (o.child.tag) {
        case C:
          return o.child.stateNode;
        default:
          return o.child.stateNode;
      }
    }
    function TG(i) {
      switch (i.tag) {
        case b: {
          var o = i.stateNode;
          if (Ao(o)) {
            var p = R(o);
            N5(o, p);
          }
          break;
        }
        case j: {
          _g(function() {
            var T = Vl(i, Wn);
            if (T !== null) {
              var P = mf();
              Kl(T, i, Wn, P);
            }
          });
          var S = Wn;
          ZD(i, S);
          break;
        }
      }
    }
    function _U(i, o) {
      var p = i.memoizedState;
      p !== null && p.dehydrated !== null && (p.retryLane = Vr(p.retryLane, o));
    }
    function ZD(i, o) {
      _U(i, o);
      var p = i.alternate;
      p && _U(p, o);
    }
    function MG(i) {
      if (i.tag === j) {
        var o = zl, p = Vl(i, o);
        if (p !== null) {
          var S = mf();
          Kl(p, i, o, S);
        }
        ZD(i, o);
      }
    }
    function wG(i) {
      if (i.tag === j) {
        var o = Ky(i), p = Vl(i, o);
        if (p !== null) {
          var S = mf();
          Kl(p, i, o, S);
        }
        ZD(i, o);
      }
    }
    function EU(i) {
      var o = Ld(i);
      return o === null ? null : o.stateNode;
    }
    var bU = function(i) {
      return null;
    };
    function CG(i) {
      return bU(i);
    }
    var TU = function(i) {
      return !1;
    };
    function RG(i) {
      return TU(i);
    }
    var MU = null, wU = null, CU = null, RU = null, AU = null, DU = null, LU = null, OU = null, PU = null;
    {
      var NU = function(i, o, p) {
        var S = o[p], T = $r(i) ? i.slice() : kn({}, i);
        return p + 1 === o.length ? ($r(T) ? T.splice(S, 1) : delete T[S], T) : (T[S] = NU(i[S], o, p + 1), T);
      }, UU = function(i, o) {
        return NU(i, o, 0);
      }, zU = function(i, o, p, S) {
        var T = o[S], P = $r(i) ? i.slice() : kn({}, i);
        if (S + 1 === o.length) {
          var H = p[S];
          P[H] = P[T], $r(P) ? P.splice(T, 1) : delete P[T];
        } else
          P[T] = zU(
            // $FlowFixMe number or string is fine here
            i[T],
            o,
            p,
            S + 1
          );
        return P;
      }, kU = function(i, o, p) {
        if (o.length !== p.length) {
          s("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var S = 0; S < p.length - 1; S++)
            if (o[S] !== p[S]) {
              s("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return zU(i, o, p, 0);
      }, IU = function(i, o, p, S) {
        if (p >= o.length)
          return S;
        var T = o[p], P = $r(i) ? i.slice() : kn({}, i);
        return P[T] = IU(i[T], o, p + 1, S), P;
      }, FU = function(i, o, p) {
        return IU(i, o, 0, p);
      }, JD = function(i, o) {
        for (var p = i.memoizedState; p !== null && o > 0; )
          p = p.next, o--;
        return p;
      };
      MU = function(i, o, p, S) {
        var T = JD(i, o);
        if (T !== null) {
          var P = FU(T.memoizedState, p, S);
          T.memoizedState = P, T.baseState = P, i.memoizedProps = kn({}, i.memoizedProps);
          var H = Vl(i, Wn);
          H !== null && Kl(H, i, Wn, Xr);
        }
      }, wU = function(i, o, p) {
        var S = JD(i, o);
        if (S !== null) {
          var T = UU(S.memoizedState, p);
          S.memoizedState = T, S.baseState = T, i.memoizedProps = kn({}, i.memoizedProps);
          var P = Vl(i, Wn);
          P !== null && Kl(P, i, Wn, Xr);
        }
      }, CU = function(i, o, p, S) {
        var T = JD(i, o);
        if (T !== null) {
          var P = kU(T.memoizedState, p, S);
          T.memoizedState = P, T.baseState = P, i.memoizedProps = kn({}, i.memoizedProps);
          var H = Vl(i, Wn);
          H !== null && Kl(H, i, Wn, Xr);
        }
      }, RU = function(i, o, p) {
        i.pendingProps = FU(i.memoizedProps, o, p), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var S = Vl(i, Wn);
        S !== null && Kl(S, i, Wn, Xr);
      }, AU = function(i, o) {
        i.pendingProps = UU(i.memoizedProps, o), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var p = Vl(i, Wn);
        p !== null && Kl(p, i, Wn, Xr);
      }, DU = function(i, o, p) {
        i.pendingProps = kU(i.memoizedProps, o, p), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var S = Vl(i, Wn);
        S !== null && Kl(S, i, Wn, Xr);
      }, LU = function(i) {
        var o = Vl(i, Wn);
        o !== null && Kl(o, i, Wn, Xr);
      }, OU = function(i) {
        bU = i;
      }, PU = function(i) {
        TU = i;
      };
    }
    function AG(i) {
      var o = ll(i);
      return o === null ? null : o.stateNode;
    }
    function DG(i) {
      return null;
    }
    function LG() {
      return pa;
    }
    function OG(i) {
      var o = i.findFiberByHostInstance, p = t.ReactCurrentDispatcher;
      return vp({
        bundleType: i.bundleType,
        version: i.version,
        rendererPackageName: i.rendererPackageName,
        rendererConfig: i.rendererConfig,
        overrideHookState: MU,
        overrideHookStateDeletePath: wU,
        overrideHookStateRenamePath: CU,
        overrideProps: RU,
        overridePropsDeletePath: AU,
        overridePropsRenamePath: DU,
        setErrorHandler: OU,
        setSuspenseHandler: PU,
        scheduleUpdate: LU,
        currentDispatcherRef: p,
        findHostInstanceByFiber: AG,
        findFiberByHostInstance: o || DG,
        // React Refresh
        findHostInstancesForRefresh: lG,
        scheduleRefresh: oG,
        scheduleRoot: sG,
        setRefreshHandler: aG,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: LG,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: qD
      });
    }
    var BU = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(i) {
      console.error(i);
    };
    function e2(i) {
      this._internalRoot = i;
    }
    tC.prototype.render = e2.prototype.render = function(i) {
      var o = this._internalRoot;
      if (o === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? u("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : nC(arguments[1]) ? u("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && u("You passed a second argument to root.render(...) but it only accepts one argument.");
        var p = o.containerInfo;
        if (p.nodeType !== ka) {
          var S = EU(o.current);
          S && S.parentNode !== p && u("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      G1(i, o, null, null);
    }, tC.prototype.unmount = e2.prototype.unmount = function() {
      typeof arguments[0] == "function" && u("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var i = this._internalRoot;
      if (i !== null) {
        this._internalRoot = null;
        var o = i.containerInfo;
        ZN() && u("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), _g(function() {
          G1(null, i, null, null);
        }), tw(o);
      }
    };
    function PG(i, o) {
      if (!nC(i))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      HU(i);
      var p = !1, S = !1, T = "", P = BU;
      o != null && (o.hydrate ? s("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof o == "object" && o !== null && o.$$typeof === _l && u(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), o.unstable_strictMode === !0 && (p = !0), o.identifierPrefix !== void 0 && (T = o.identifierPrefix), o.onRecoverableError !== void 0 && (P = o.onRecoverableError), o.transitionCallbacks !== void 0 && o.transitionCallbacks);
      var H = SU(i, iS, null, p, S, T, P);
      J0(H.current, i);
      var $ = i.nodeType === ka ? i.parentNode : i;
      return Fu($), new e2(H);
    }
    function tC(i) {
      this._internalRoot = i;
    }
    function NG(i) {
      i && Zg(i);
    }
    tC.prototype.unstable_scheduleHydration = NG;
    function UG(i, o, p) {
      if (!nC(i))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      HU(i), o === void 0 && u("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var S = p ?? null, T = p != null && p.hydratedSources || null, P = !1, H = !1, $ = "", ee = BU;
      p != null && (p.unstable_strictMode === !0 && (P = !0), p.identifierPrefix !== void 0 && ($ = p.identifierPrefix), p.onRecoverableError !== void 0 && (ee = p.onRecoverableError));
      var pe = xU(o, null, i, iS, S, P, H, $, ee);
      if (J0(pe.current, i), Fu(i), T)
        for (var _e = 0; _e < T.length; _e++) {
          var Ge = T[_e];
          Pw(pe, Ge);
        }
      return new tC(pe);
    }
    function nC(i) {
      return !!(i && (i.nodeType === Ns || i.nodeType === Ra || i.nodeType === Aa || !ce));
    }
    function W1(i) {
      return !!(i && (i.nodeType === Ns || i.nodeType === Ra || i.nodeType === Aa || i.nodeType === ka && i.nodeValue === " react-mount-point-unstable "));
    }
    function HU(i) {
      i.nodeType === Ns && i.tagName && i.tagName.toUpperCase() === "BODY" && u("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), eS(i) && (i._reactRootContainer ? u("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : u("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var zG = t.ReactCurrentOwner, VU;
    VU = function(i) {
      if (i._reactRootContainer && i.nodeType !== ka) {
        var o = EU(i._reactRootContainer.current);
        o && o.parentNode !== i && u("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var p = !!i._reactRootContainer, S = t2(i), T = !!(S && Ym(S));
      T && !p && u("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), i.nodeType === Ns && i.tagName && i.tagName.toUpperCase() === "BODY" && u("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function t2(i) {
      return i ? i.nodeType === Ra ? i.documentElement : i.firstChild : null;
    }
    function GU() {
    }
    function kG(i, o, p, S, T) {
      if (T) {
        if (typeof S == "function") {
          var P = S;
          S = function() {
            var He = eC(H);
            P.call(He);
          };
        }
        var H = xU(
          o,
          S,
          i,
          qm,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          GU
        );
        i._reactRootContainer = H, J0(H.current, i);
        var $ = i.nodeType === ka ? i.parentNode : i;
        return Fu($), _g(), H;
      } else {
        for (var ee; ee = i.lastChild; )
          i.removeChild(ee);
        if (typeof S == "function") {
          var pe = S;
          S = function() {
            var He = eC(_e);
            pe.call(He);
          };
        }
        var _e = SU(
          i,
          qm,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          GU
        );
        i._reactRootContainer = _e, J0(_e.current, i);
        var Ge = i.nodeType === ka ? i.parentNode : i;
        return Fu(Ge), _g(function() {
          G1(o, _e, p, S);
        }), _e;
      }
    }
    function IG(i, o) {
      i !== null && typeof i != "function" && u("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", o, i);
    }
    function rC(i, o, p, S, T) {
      VU(p), IG(T === void 0 ? null : T, "render");
      var P = p._reactRootContainer, H;
      if (!P)
        H = kG(p, o, i, T, S);
      else {
        if (H = P, typeof T == "function") {
          var $ = T;
          T = function() {
            var ee = eC(H);
            $.call(ee);
          };
        }
        G1(o, H, i, T);
      }
      return eC(H);
    }
    function FG(i) {
      {
        var o = zG.current;
        if (o !== null && o.stateNode !== null) {
          var p = o.stateNode._warnedAboutRefsInRender;
          p || u("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", jr(o.type) || "A component"), o.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return i == null ? null : i.nodeType === Ns ? i : bG(i, "findDOMNode");
    }
    function BG(i, o, p) {
      if (u("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !W1(o))
        throw new Error("Target container is not a DOM element.");
      {
        var S = eS(o) && o._reactRootContainer === void 0;
        S && u("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return rC(null, i, o, !0, p);
    }
    function HG(i, o, p) {
      if (u("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !W1(o))
        throw new Error("Target container is not a DOM element.");
      {
        var S = eS(o) && o._reactRootContainer === void 0;
        S && u("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return rC(null, i, o, !1, p);
    }
    function VG(i, o, p, S) {
      if (u("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !W1(p))
        throw new Error("Target container is not a DOM element.");
      if (i == null || !Fs(i))
        throw new Error("parentComponent must be a valid React Component");
      return rC(i, o, p, !1, S);
    }
    function GG(i) {
      if (!W1(i))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var o = eS(i) && i._reactRootContainer === void 0;
        o && u("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (i._reactRootContainer) {
        {
          var p = t2(i), S = p && !Ym(p);
          S && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return _g(function() {
          rC(null, null, i, !1, function() {
            i._reactRootContainer = null, tw(i);
          });
        }), !0;
      } else {
        {
          var T = t2(i), P = !!(T && Ym(T)), H = i.nodeType === Ns && W1(i.parentNode) && !!i.parentNode._reactRootContainer;
          P && u("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", H ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    Pn(TG), xx(MG), Ep(wG), R0(zu), bp(Sp), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && u("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), ic(OM), wd(OD, U5, _g);
    function WG(i, o) {
      var p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!nC(o))
        throw new Error("Target container is not a DOM element.");
      return EG(i, o, null, p);
    }
    function jG(i, o, p, S) {
      return VG(i, o, p, S);
    }
    var n2 = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Ym, qs, Zf, Ll, oc, OD]
    };
    function $G(i, o) {
      return n2.usingClientEntryPoint || u('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), PG(i, o);
    }
    function YG(i, o, p) {
      return n2.usingClientEntryPoint || u('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), UG(i, o, p);
    }
    function XG(i) {
      return ZN() && u("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), _g(i);
    }
    var qG = OG({
      findFiberByHostInstance: Jv,
      bundleType: 1,
      version: qD,
      rendererPackageName: "react-dom"
    });
    if (!qG && nt && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var WU = window.location.protocol;
      /^(https?|file):$/.test(WU) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (WU === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    ld.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = n2, ld.createPortal = WG, ld.createRoot = $G, ld.findDOMNode = FG, ld.flushSync = XG, ld.hydrate = BG, ld.hydrateRoot = YG, ld.render = HG, ld.unmountComponentAtNode = GG, ld.unstable_batchedUpdates = OD, ld.unstable_renderSubtreeIntoContainer = jG, ld.version = qD, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), ld;
}
function RI() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(RI);
    } catch (n) {
      console.error(n);
    }
  }
}
process.env.NODE_ENV === "production" ? (RI(), mL.exports = a6()) : mL.exports = o6();
var $T = mL.exports;
const AI = /* @__PURE__ */ GE($T);
var vL, oC = $T;
if (process.env.NODE_ENV === "production")
  vL = oC.createRoot, oC.hydrateRoot;
else {
  var t3 = oC.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  vL = function(n, e) {
    t3.usingClientEntryPoint = !0;
    try {
      return oC.createRoot(n, e);
    } finally {
      t3.usingClientEntryPoint = !1;
    }
  };
}
var le = px();
const Ne = /* @__PURE__ */ GE(le), s6 = /* @__PURE__ */ ZG({
  __proto__: null,
  default: Ne
}, [le]);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const kR = "153", jS = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, $S = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, DI = 0, gL = 1, LI = 2, l6 = 3, OI = 0, IR = 1, pT = 2, Zp = 3, Fg = 0, bf = 1, mv = 2, u6 = 2, kg = 0, tx = 1, yL = 2, SL = 3, xL = 4, PI = 5, XS = 100, NI = 101, UI = 102, _L = 103, EL = 104, zI = 200, kI = 201, II = 202, FI = 203, zO = 204, kO = 205, BI = 206, HI = 207, VI = 208, GI = 209, WI = 210, jI = 0, $I = 1, YI = 2, mR = 3, XI = 4, qI = 5, KI = 6, QI = 7, YT = 0, ZI = 1, JI = 2, em = 0, eF = 1, tF = 2, nF = 3, IO = 4, rF = 5, FR = 300, f0 = 301, d0 = 302, bT = 303, TT = 304, WE = 306, MT = 1e3, Dc = 1001, wT = 1002, el = 1003, vR = 1004, c6 = 1004, mT = 1005, f6 = 1005, tl = 1006, FO = 1007, d6 = 1007, h0 = 1008, h6 = 1008, Sv = 1009, iF = 1010, aF = 1011, BR = 1012, BO = 1013, Ug = 1014, vv = 1015, UE = 1016, HO = 1017, VO = 1018, s0 = 1020, oF = 1021, dd = 1023, sF = 1024, lF = 1025, l0 = 1026, sx = 1027, uF = 1028, GO = 1029, cF = 1030, WO = 1031, jO = 1033, aR = 33776, oR = 33777, sR = 33778, lR = 33779, bL = 35840, TL = 35841, ML = 35842, wL = 35843, fF = 36196, CL = 37492, RL = 37496, AL = 37808, DL = 37809, LL = 37810, OL = 37811, PL = 37812, NL = 37813, UL = 37814, zL = 37815, kL = 37816, IL = 37817, FL = 37818, BL = 37819, HL = 37820, VL = 37821, uR = 36492, dF = 36283, GL = 36284, WL = 36285, jL = 36286, hF = 2200, pF = 2201, mF = 2202, CT = 2300, RT = 2301, cR = 2302, KS = 2400, QS = 2401, AT = 2402, HR = 2500, $O = 2501, p6 = 0, m6 = 1, v6 = 2, YO = 3e3, u0 = 3001, vF = 3200, gF = 3201, S0 = 0, yF = 1, c0 = "", ai = "srgb", nm = "srgb-linear", XO = "display-p3", g6 = 0, fR = 7680, y6 = 7681, S6 = 7682, x6 = 7683, _6 = 34055, E6 = 34056, b6 = 5386, T6 = 512, M6 = 513, w6 = 514, C6 = 515, R6 = 516, A6 = 517, D6 = 518, SF = 519, xF = 512, _F = 513, EF = 514, bF = 515, TF = 516, MF = 517, wF = 518, CF = 519, DT = 35044, L6 = 35048, O6 = 35040, P6 = 35045, N6 = 35049, U6 = 35041, z6 = 35046, k6 = 35050, I6 = 35042, F6 = "100", $L = "300 es", gR = 1035, gv = 2e3, LT = 2001;
class Tv {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const a = this._listeners[e];
    if (a !== void 0) {
      const s = a.indexOf(t);
      s !== -1 && a.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const a = r.slice(0);
      for (let s = 0, u = a.length; s < u; s++)
        a[s].call(this, e);
      e.target = null;
    }
  }
}
const Rc = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let n3 = 1234567;
const nx = Math.PI / 180, zE = 180 / Math.PI;
function sh() {
  const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Rc[n & 255] + Rc[n >> 8 & 255] + Rc[n >> 16 & 255] + Rc[n >> 24 & 255] + "-" + Rc[e & 255] + Rc[e >> 8 & 255] + "-" + Rc[e >> 16 & 15 | 64] + Rc[e >> 24 & 255] + "-" + Rc[t & 63 | 128] + Rc[t >> 8 & 255] + "-" + Rc[t >> 16 & 255] + Rc[t >> 24 & 255] + Rc[r & 255] + Rc[r >> 8 & 255] + Rc[r >> 16 & 255] + Rc[r >> 24 & 255]).toLowerCase();
}
function ws(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function qO(n, e) {
  return (n % e + e) % e;
}
function B6(n, e, t, r, a) {
  return r + (n - e) * (a - r) / (t - e);
}
function H6(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function vT(n, e, t) {
  return (1 - t) * n + t * e;
}
function V6(n, e, t, r) {
  return vT(n, e, 1 - Math.exp(-t * r));
}
function G6(n, e = 1) {
  return e - Math.abs(qO(n, e * 2) - e);
}
function W6(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n));
}
function j6(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10));
}
function $6(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function Y6(n, e) {
  return n + Math.random() * (e - n);
}
function X6(n) {
  return n * (0.5 - Math.random());
}
function q6(n) {
  n !== void 0 && (n3 = n);
  let e = n3 += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function K6(n) {
  return n * nx;
}
function Q6(n) {
  return n * zE;
}
function YL(n) {
  return (n & n - 1) === 0 && n !== 0;
}
function RF(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function yR(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function Z6(n, e, t, r, a) {
  const s = Math.cos, u = Math.sin, h = s(t / 2), v = u(t / 2), y = s((e + r) / 2), _ = u((e + r) / 2), b = s((e - r) / 2), M = u((e - r) / 2), C = s((r - e) / 2), D = u((r - e) / 2);
  switch (a) {
    case "XYX":
      n.set(h * _, v * b, v * M, h * y);
      break;
    case "YZY":
      n.set(v * M, h * _, v * b, h * y);
      break;
    case "ZXZ":
      n.set(v * b, v * M, h * _, h * y);
      break;
    case "XZX":
      n.set(h * _, v * D, v * C, h * y);
      break;
    case "YXY":
      n.set(v * C, h * _, v * D, h * y);
      break;
    case "ZYZ":
      n.set(v * D, v * C, h * _, h * y);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + a);
  }
}
function oh(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function gi(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const J6 = {
  DEG2RAD: nx,
  RAD2DEG: zE,
  generateUUID: sh,
  clamp: ws,
  euclideanModulo: qO,
  mapLinear: B6,
  inverseLerp: H6,
  lerp: vT,
  damp: V6,
  pingpong: G6,
  smoothstep: W6,
  smootherstep: j6,
  randInt: $6,
  randFloat: Y6,
  randFloatSpread: X6,
  seededRandom: q6,
  degToRad: K6,
  radToDeg: Q6,
  isPowerOfTwo: YL,
  ceilPowerOfTwo: RF,
  floorPowerOfTwo: yR,
  setQuaternionFromProperEuler: Z6,
  normalize: gi,
  denormalize: oh
};
class It {
  constructor(e = 0, t = 0) {
    It.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, a = e.elements;
    return this.x = a[0] * t + a[3] * r + a[6], this.y = a[1] * t + a[4] * r + a[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(ws(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t), a = Math.sin(t), s = this.x - e.x, u = this.y - e.y;
    return this.x = s * r - u * a + e.x, this.y = s * a + u * r + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class vi {
  constructor(e, t, r, a, s, u, h, v, y) {
    vi.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, a, s, u, h, v, y);
  }
  set(e, t, r, a, s, u, h, v, y) {
    const _ = this.elements;
    return _[0] = e, _[1] = a, _[2] = h, _[3] = t, _[4] = s, _[5] = v, _[6] = r, _[7] = u, _[8] = y, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, a = t.elements, s = this.elements, u = r[0], h = r[3], v = r[6], y = r[1], _ = r[4], b = r[7], M = r[2], C = r[5], D = r[8], U = a[0], N = a[3], O = a[6], I = a[1], k = a[4], G = a[7], j = a[2], Y = a[5], Z = a[8];
    return s[0] = u * U + h * I + v * j, s[3] = u * N + h * k + v * Y, s[6] = u * O + h * G + v * Z, s[1] = y * U + _ * I + b * j, s[4] = y * N + _ * k + b * Y, s[7] = y * O + _ * G + b * Z, s[2] = M * U + C * I + D * j, s[5] = M * N + C * k + D * Y, s[8] = M * O + C * G + D * Z, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[1], a = e[2], s = e[3], u = e[4], h = e[5], v = e[6], y = e[7], _ = e[8];
    return t * u * _ - t * h * y - r * s * _ + r * h * v + a * s * y - a * u * v;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], a = e[2], s = e[3], u = e[4], h = e[5], v = e[6], y = e[7], _ = e[8], b = _ * u - h * y, M = h * v - _ * s, C = y * s - u * v, D = t * b + r * M + a * C;
    if (D === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const U = 1 / D;
    return e[0] = b * U, e[1] = (a * y - _ * r) * U, e[2] = (h * r - a * u) * U, e[3] = M * U, e[4] = (_ * t - a * v) * U, e[5] = (a * s - h * t) * U, e[6] = C * U, e[7] = (r * v - y * t) * U, e[8] = (u * t - r * s) * U, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, r, a, s, u, h) {
    const v = Math.cos(s), y = Math.sin(s);
    return this.set(
      r * v,
      r * y,
      -r * (v * u + y * h) + u + e,
      -a * y,
      a * v,
      -a * (-y * u + v * h) + h + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(a2.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(a2.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(a2.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      r,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let a = 0; a < 9; a++)
      if (t[a] !== r[a])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const a2 = /* @__PURE__ */ new vi();
function AF(n) {
  for (let e = n.length - 1; e >= 0; --e)
    if (n[e] >= 65535)
      return !0;
  return !1;
}
const e8 = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function ME(n, e) {
  return new e8[n](e);
}
function OT(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
const r3 = {};
function gT(n) {
  n in r3 || (r3[n] = !0, console.warn(n));
}
function LE(n) {
  return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function o2(n) {
  return n < 31308e-7 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
const t8 = /* @__PURE__ */ new vi().fromArray([
  0.8224621,
  0.0331941,
  0.0170827,
  0.177538,
  0.9668058,
  0.0723974,
  -1e-7,
  1e-7,
  0.9105199
]), n8 = /* @__PURE__ */ new vi().fromArray([
  1.2249401,
  -0.0420569,
  -0.0196376,
  -0.2249404,
  1.0420571,
  -0.0786361,
  1e-7,
  0,
  1.0982735
]);
function r8(n) {
  return n.convertSRGBToLinear().applyMatrix3(n8);
}
function i8(n) {
  return n.applyMatrix3(t8).convertLinearToSRGB();
}
const a8 = {
  [nm]: (n) => n,
  [ai]: (n) => n.convertSRGBToLinear(),
  [XO]: r8
}, o8 = {
  [nm]: (n) => n,
  [ai]: (n) => n.convertLinearToSRGB(),
  [XO]: i8
}, tp = {
  enabled: !0,
  get legacyMode() {
    return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled;
  },
  set legacyMode(n) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !n;
  },
  get workingColorSpace() {
    return nm;
  },
  set workingColorSpace(n) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(n, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return n;
    const r = a8[e], a = o8[t];
    if (r === void 0 || a === void 0)
      throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`);
    return a(r(n));
  },
  fromWorkingColorSpace: function(n, e) {
    return this.convert(n, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(n, e) {
    return this.convert(n, e, this.workingColorSpace);
  }
};
let K_;
class KO {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      K_ === void 0 && (K_ = OT("canvas")), K_.width = e.width, K_.height = e.height;
      const r = K_.getContext("2d");
      e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), t = K_;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = OT("canvas");
      t.width = e.width, t.height = e.height;
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const a = r.getImageData(0, 0, e.width, e.height), s = a.data;
      for (let u = 0; u < s.length; u++)
        s[u] = LE(s[u] / 255) * 255;
      return r.putImageData(a, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(LE(t[r] / 255) * 255) : t[r] = LE(t[r]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let s8 = 0;
class ZS {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: s8++ }), this.uuid = sh(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const r = {
      uuid: this.uuid,
      url: ""
    }, a = this.data;
    if (a !== null) {
      let s;
      if (Array.isArray(a)) {
        s = [];
        for (let u = 0, h = a.length; u < h; u++)
          a[u].isDataTexture ? s.push(s2(a[u].image)) : s.push(s2(a[u]));
      } else
        s = s2(a);
      r.url = s;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function s2(n) {
  return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? KO.getDataURL(n) : n.data ? {
    data: Array.from(n.data),
    width: n.width,
    height: n.height,
    type: n.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let l8 = 0;
class Rs extends Tv {
  constructor(e = Rs.DEFAULT_IMAGE, t = Rs.DEFAULT_MAPPING, r = Dc, a = Dc, s = tl, u = h0, h = dd, v = Sv, y = Rs.DEFAULT_ANISOTROPY, _ = c0) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: l8++ }), this.uuid = sh(), this.name = "", this.source = new ZS(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = r, this.wrapT = a, this.magFilter = s, this.minFilter = u, this.anisotropy = y, this.format = h, this.internalFormat = null, this.type = v, this.offset = new It(0, 0), this.repeat = new It(1, 1), this.center = new It(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new vi(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof _ == "string" ? this.colorSpace = _ : (gT("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = _ === u0 ? ai : c0), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const r = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (r.userData = this.userData), t || (e.textures[this.uuid] = r), r;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== FR)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case MT:
          e.x = e.x - Math.floor(e.x);
          break;
        case Dc:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case wT:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case MT:
          e.y = e.y - Math.floor(e.y);
          break;
        case Dc:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case wT:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  get encoding() {
    return gT("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === ai ? u0 : YO;
  }
  set encoding(e) {
    gT("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === u0 ? ai : c0;
  }
}
Rs.DEFAULT_IMAGE = null;
Rs.DEFAULT_MAPPING = FR;
Rs.DEFAULT_ANISOTROPY = 1;
class Ua {
  constructor(e = 0, t = 0, r = 0, a = 1) {
    Ua.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = r, this.w = a;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, a) {
    return this.x = e, this.y = t, this.z = r, this.w = a, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, a = this.z, s = this.w, u = e.elements;
    return this.x = u[0] * t + u[4] * r + u[8] * a + u[12] * s, this.y = u[1] * t + u[5] * r + u[9] * a + u[13] * s, this.z = u[2] * t + u[6] * r + u[10] * a + u[14] * s, this.w = u[3] * t + u[7] * r + u[11] * a + u[15] * s, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, a, s;
    const v = e.elements, y = v[0], _ = v[4], b = v[8], M = v[1], C = v[5], D = v[9], U = v[2], N = v[6], O = v[10];
    if (Math.abs(_ - M) < 0.01 && Math.abs(b - U) < 0.01 && Math.abs(D - N) < 0.01) {
      if (Math.abs(_ + M) < 0.1 && Math.abs(b + U) < 0.1 && Math.abs(D + N) < 0.1 && Math.abs(y + C + O - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const k = (y + 1) / 2, G = (C + 1) / 2, j = (O + 1) / 2, Y = (_ + M) / 4, Z = (b + U) / 4, te = (D + N) / 4;
      return k > G && k > j ? k < 0.01 ? (r = 0, a = 0.707106781, s = 0.707106781) : (r = Math.sqrt(k), a = Y / r, s = Z / r) : G > j ? G < 0.01 ? (r = 0.707106781, a = 0, s = 0.707106781) : (a = Math.sqrt(G), r = Y / a, s = te / a) : j < 0.01 ? (r = 0.707106781, a = 0.707106781, s = 0) : (s = Math.sqrt(j), r = Z / s, a = te / s), this.set(r, a, s, t), this;
    }
    let I = Math.sqrt((N - D) * (N - D) + (b - U) * (b - U) + (M - _) * (M - _));
    return Math.abs(I) < 1e-3 && (I = 1), this.x = (N - D) / I, this.y = (b - U) / I, this.z = (M - _) / I, this.w = Math.acos((y + C + O - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this.w = e.w + (t.w - e.w) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class rm extends Tv {
  constructor(e = 1, t = 1, r = {}) {
    super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Ua(0, 0, e, t), this.scissorTest = !1, this.viewport = new Ua(0, 0, e, t);
    const a = { width: e, height: t, depth: 1 };
    r.encoding !== void 0 && (gT("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), r.colorSpace = r.encoding === u0 ? ai : c0), this.texture = new Rs(a, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !1, this.texture.internalFormat = r.internalFormat !== void 0 ? r.internalFormat : null, this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : tl, this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0, this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1, this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null, this.samples = r.samples !== void 0 ? r.samples : 0;
  }
  setSize(e, t, r = 1) {
    (this.width !== e || this.height !== t || this.depth !== r) && (this.width = e, this.height = t, this.depth = r, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = r, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new ZS(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class VR extends Rs {
  constructor(e = null, t = 1, r = 1, a = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: r, depth: a }, this.magFilter = el, this.minFilter = el, this.wrapR = Dc, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class u8 extends rm {
  constructor(e = 1, t = 1, r = 1) {
    super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new VR(null, e, t, r), this.texture.isRenderTargetTexture = !0;
  }
}
class QO extends Rs {
  constructor(e = null, t = 1, r = 1, a = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: r, depth: a }, this.magFilter = el, this.minFilter = el, this.wrapR = Dc, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class c8 extends rm {
  constructor(e = 1, t = 1, r = 1) {
    super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new QO(null, e, t, r), this.texture.isRenderTargetTexture = !0;
  }
}
class f8 extends rm {
  constructor(e = 1, t = 1, r = 1, a = {}) {
    super(e, t, a), this.isWebGLMultipleRenderTargets = !0;
    const s = this.texture;
    this.texture = [];
    for (let u = 0; u < r; u++)
      this.texture[u] = s.clone(), this.texture[u].isRenderTargetTexture = !0;
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      this.width = e, this.height = t, this.depth = r;
      for (let a = 0, s = this.texture.length; a < s; a++)
        this.texture[a].image.width = e, this.texture[a].image.height = t, this.texture[a].image.depth = r;
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, r = e.texture.length; t < r; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class Oc {
  constructor(e = 0, t = 0, r = 0, a = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = a;
  }
  static slerpFlat(e, t, r, a, s, u, h) {
    let v = r[a + 0], y = r[a + 1], _ = r[a + 2], b = r[a + 3];
    const M = s[u + 0], C = s[u + 1], D = s[u + 2], U = s[u + 3];
    if (h === 0) {
      e[t + 0] = v, e[t + 1] = y, e[t + 2] = _, e[t + 3] = b;
      return;
    }
    if (h === 1) {
      e[t + 0] = M, e[t + 1] = C, e[t + 2] = D, e[t + 3] = U;
      return;
    }
    if (b !== U || v !== M || y !== C || _ !== D) {
      let N = 1 - h;
      const O = v * M + y * C + _ * D + b * U, I = O >= 0 ? 1 : -1, k = 1 - O * O;
      if (k > Number.EPSILON) {
        const j = Math.sqrt(k), Y = Math.atan2(j, O * I);
        N = Math.sin(N * Y) / j, h = Math.sin(h * Y) / j;
      }
      const G = h * I;
      if (v = v * N + M * G, y = y * N + C * G, _ = _ * N + D * G, b = b * N + U * G, N === 1 - h) {
        const j = 1 / Math.sqrt(v * v + y * y + _ * _ + b * b);
        v *= j, y *= j, _ *= j, b *= j;
      }
    }
    e[t] = v, e[t + 1] = y, e[t + 2] = _, e[t + 3] = b;
  }
  static multiplyQuaternionsFlat(e, t, r, a, s, u) {
    const h = r[a], v = r[a + 1], y = r[a + 2], _ = r[a + 3], b = s[u], M = s[u + 1], C = s[u + 2], D = s[u + 3];
    return e[t] = h * D + _ * b + v * C - y * M, e[t + 1] = v * D + _ * M + y * b - h * C, e[t + 2] = y * D + _ * C + h * M - v * b, e[t + 3] = _ * D - h * b - v * M - y * C, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, r, a) {
    return this._x = e, this._y = t, this._z = r, this._w = a, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const r = e._x, a = e._y, s = e._z, u = e._order, h = Math.cos, v = Math.sin, y = h(r / 2), _ = h(a / 2), b = h(s / 2), M = v(r / 2), C = v(a / 2), D = v(s / 2);
    switch (u) {
      case "XYZ":
        this._x = M * _ * b + y * C * D, this._y = y * C * b - M * _ * D, this._z = y * _ * D + M * C * b, this._w = y * _ * b - M * C * D;
        break;
      case "YXZ":
        this._x = M * _ * b + y * C * D, this._y = y * C * b - M * _ * D, this._z = y * _ * D - M * C * b, this._w = y * _ * b + M * C * D;
        break;
      case "ZXY":
        this._x = M * _ * b - y * C * D, this._y = y * C * b + M * _ * D, this._z = y * _ * D + M * C * b, this._w = y * _ * b - M * C * D;
        break;
      case "ZYX":
        this._x = M * _ * b - y * C * D, this._y = y * C * b + M * _ * D, this._z = y * _ * D - M * C * b, this._w = y * _ * b + M * C * D;
        break;
      case "YZX":
        this._x = M * _ * b + y * C * D, this._y = y * C * b + M * _ * D, this._z = y * _ * D - M * C * b, this._w = y * _ * b - M * C * D;
        break;
      case "XZY":
        this._x = M * _ * b - y * C * D, this._y = y * C * b - M * _ * D, this._z = y * _ * D + M * C * b, this._w = y * _ * b + M * C * D;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + u);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2, a = Math.sin(r);
    return this._x = e.x * a, this._y = e.y * a, this._z = e.z * a, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, r = t[0], a = t[4], s = t[8], u = t[1], h = t[5], v = t[9], y = t[2], _ = t[6], b = t[10], M = r + h + b;
    if (M > 0) {
      const C = 0.5 / Math.sqrt(M + 1);
      this._w = 0.25 / C, this._x = (_ - v) * C, this._y = (s - y) * C, this._z = (u - a) * C;
    } else if (r > h && r > b) {
      const C = 2 * Math.sqrt(1 + r - h - b);
      this._w = (_ - v) / C, this._x = 0.25 * C, this._y = (a + u) / C, this._z = (s + y) / C;
    } else if (h > b) {
      const C = 2 * Math.sqrt(1 + h - r - b);
      this._w = (s - y) / C, this._x = (a + u) / C, this._y = 0.25 * C, this._z = (v + _) / C;
    } else {
      const C = 2 * Math.sqrt(1 + b - r - h);
      this._w = (u - a) / C, this._x = (s + y) / C, this._y = (v + _) / C, this._z = 0.25 * C;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(ws(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0)
      return this;
    const a = Math.min(1, t / r);
    return this.slerp(e, a), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x, a = e._y, s = e._z, u = e._w, h = t._x, v = t._y, y = t._z, _ = t._w;
    return this._x = r * _ + u * h + a * y - s * v, this._y = a * _ + u * v + s * h - r * y, this._z = s * _ + u * y + r * v - a * h, this._w = u * _ - r * h - a * v - s * y, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const r = this._x, a = this._y, s = this._z, u = this._w;
    let h = u * e._w + r * e._x + a * e._y + s * e._z;
    if (h < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, h = -h) : this.copy(e), h >= 1)
      return this._w = u, this._x = r, this._y = a, this._z = s, this;
    const v = 1 - h * h;
    if (v <= Number.EPSILON) {
      const C = 1 - t;
      return this._w = C * u + t * this._w, this._x = C * r + t * this._x, this._y = C * a + t * this._y, this._z = C * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const y = Math.sqrt(v), _ = Math.atan2(y, h), b = Math.sin((1 - t) * _) / y, M = Math.sin(t * _) / y;
    return this._w = u * b + this._w * M, this._x = r * b + this._x * M, this._y = a * b + this._y * M, this._z = s * b + this._z * M, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), r = Math.sqrt(e), a = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(a),
      r * Math.sin(s),
      r * Math.cos(s),
      t * Math.sin(a)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class be {
  constructor(e = 0, t = 0, r = 0) {
    be.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r;
  }
  set(e, t, r) {
    return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(i3.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(i3.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, a = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * r + s[6] * a, this.y = s[1] * t + s[4] * r + s[7] * a, this.z = s[2] * t + s[5] * r + s[8] * a, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, a = this.z, s = e.elements, u = 1 / (s[3] * t + s[7] * r + s[11] * a + s[15]);
    return this.x = (s[0] * t + s[4] * r + s[8] * a + s[12]) * u, this.y = (s[1] * t + s[5] * r + s[9] * a + s[13]) * u, this.z = (s[2] * t + s[6] * r + s[10] * a + s[14]) * u, this;
  }
  applyQuaternion(e) {
    const t = this.x, r = this.y, a = this.z, s = e.x, u = e.y, h = e.z, v = e.w, y = v * t + u * a - h * r, _ = v * r + h * t - s * a, b = v * a + s * r - u * t, M = -s * t - u * r - h * a;
    return this.x = y * v + M * -s + _ * -h - b * -u, this.y = _ * v + M * -u + b * -s - y * -h, this.z = b * v + M * -h + y * -u - _ * -s, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, r = this.y, a = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * r + s[8] * a, this.y = s[1] * t + s[5] * r + s[9] * a, this.z = s[2] * t + s[6] * r + s[10] * a, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x, a = e.y, s = e.z, u = t.x, h = t.y, v = t.z;
    return this.x = a * v - s * h, this.y = s * u - r * v, this.z = r * h - a * u, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return l2.copy(this).projectOnVector(e), this.sub(l2);
  }
  reflect(e) {
    return this.sub(l2.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(ws(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y, a = this.z - e.z;
    return t * t + r * r + a * a;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const a = Math.sin(t) * e;
    return this.x = a * Math.sin(r), this.y = Math.cos(t) * e, this.z = a * Math.cos(r), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), a = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = r, this.z = a, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, r = Math.sqrt(1 - e ** 2);
    return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const l2 = /* @__PURE__ */ new be(), i3 = /* @__PURE__ */ new Oc();
class Mv {
  constructor(e = new be(1 / 0, 1 / 0, 1 / 0), t = new be(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(Mg.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(Mg.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = Mg.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if (e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0)
      e.boundingBox === null && e.computeBoundingBox(), Q_.copy(e.boundingBox), Q_.applyMatrix4(e.matrixWorld), this.union(Q_);
    else {
      const a = e.geometry;
      if (a !== void 0)
        if (t && a.attributes !== void 0 && a.attributes.position !== void 0) {
          const s = a.attributes.position;
          for (let u = 0, h = s.count; u < h; u++)
            Mg.fromBufferAttribute(s, u).applyMatrix4(e.matrixWorld), this.expandByPoint(Mg);
        } else
          a.boundingBox === null && a.computeBoundingBox(), Q_.copy(a.boundingBox), Q_.applyMatrix4(e.matrixWorld), this.union(Q_);
    }
    const r = e.children;
    for (let a = 0, s = r.length; a < s; a++)
      this.expandByObject(r[a], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Mg), Mg.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, r;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(X1), sC.subVectors(this.max, X1), Z_.subVectors(e.a, X1), J_.subVectors(e.b, X1), eE.subVectors(e.c, X1), Jy.subVectors(J_, Z_), e0.subVectors(eE, J_), zS.subVectors(Z_, eE);
    let t = [
      0,
      -Jy.z,
      Jy.y,
      0,
      -e0.z,
      e0.y,
      0,
      -zS.z,
      zS.y,
      Jy.z,
      0,
      -Jy.x,
      e0.z,
      0,
      -e0.x,
      zS.z,
      0,
      -zS.x,
      -Jy.y,
      Jy.x,
      0,
      -e0.y,
      e0.x,
      0,
      -zS.y,
      zS.x,
      0
    ];
    return !u2(t, Z_, J_, eE, sC) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !u2(t, Z_, J_, eE, sC)) ? !1 : (lC.crossVectors(Jy, e0), t = [lC.x, lC.y, lC.z], u2(t, Z_, J_, eE, sC));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Mg).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Mg).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Tg[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Tg[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Tg[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Tg[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Tg[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Tg[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Tg[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Tg[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Tg), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Tg = [
  /* @__PURE__ */ new be(),
  /* @__PURE__ */ new be(),
  /* @__PURE__ */ new be(),
  /* @__PURE__ */ new be(),
  /* @__PURE__ */ new be(),
  /* @__PURE__ */ new be(),
  /* @__PURE__ */ new be(),
  /* @__PURE__ */ new be()
], Mg = /* @__PURE__ */ new be(), Q_ = /* @__PURE__ */ new Mv(), Z_ = /* @__PURE__ */ new be(), J_ = /* @__PURE__ */ new be(), eE = /* @__PURE__ */ new be(), Jy = /* @__PURE__ */ new be(), e0 = /* @__PURE__ */ new be(), zS = /* @__PURE__ */ new be(), X1 = /* @__PURE__ */ new be(), sC = /* @__PURE__ */ new be(), lC = /* @__PURE__ */ new be(), kS = /* @__PURE__ */ new be();
function u2(n, e, t, r, a) {
  for (let s = 0, u = n.length - 3; s <= u; s += 3) {
    kS.fromArray(n, s);
    const h = a.x * Math.abs(kS.x) + a.y * Math.abs(kS.y) + a.z * Math.abs(kS.z), v = e.dot(kS), y = t.dot(kS), _ = r.dot(kS);
    if (Math.max(-Math.max(v, y, _), Math.min(v, y, _)) > h)
      return !1;
  }
  return !0;
}
const d8 = /* @__PURE__ */ new Mv(), q1 = /* @__PURE__ */ new be(), c2 = /* @__PURE__ */ new be();
class sm {
  constructor(e = new be(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : d8.setFromPoints(e).getCenter(r);
    let a = 0;
    for (let s = 0, u = e.length; s < u; s++)
      a = Math.max(a, r.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(a), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    q1.subVectors(e, this.center);
    const t = q1.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t), a = (r - this.radius) * 0.5;
      this.center.addScaledVector(q1, a / r), this.radius += a;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (c2.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(q1.copy(e.center).add(c2)), this.expandByPoint(q1.copy(e.center).sub(c2))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const wg = /* @__PURE__ */ new be(), f2 = /* @__PURE__ */ new be(), uC = /* @__PURE__ */ new be(), t0 = /* @__PURE__ */ new be(), d2 = /* @__PURE__ */ new be(), cC = /* @__PURE__ */ new be(), h2 = /* @__PURE__ */ new be();
class mx {
  constructor(e = new be(), t = new be(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, wg)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = wg.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (wg.copy(this.origin).addScaledVector(this.direction, t), wg.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, a) {
    f2.copy(e).add(t).multiplyScalar(0.5), uC.copy(t).sub(e).normalize(), t0.copy(this.origin).sub(f2);
    const s = e.distanceTo(t) * 0.5, u = -this.direction.dot(uC), h = t0.dot(this.direction), v = -t0.dot(uC), y = t0.lengthSq(), _ = Math.abs(1 - u * u);
    let b, M, C, D;
    if (_ > 0)
      if (b = u * v - h, M = u * h - v, D = s * _, b >= 0)
        if (M >= -D)
          if (M <= D) {
            const U = 1 / _;
            b *= U, M *= U, C = b * (b + u * M + 2 * h) + M * (u * b + M + 2 * v) + y;
          } else
            M = s, b = Math.max(0, -(u * M + h)), C = -b * b + M * (M + 2 * v) + y;
        else
          M = -s, b = Math.max(0, -(u * M + h)), C = -b * b + M * (M + 2 * v) + y;
      else
        M <= -D ? (b = Math.max(0, -(-u * s + h)), M = b > 0 ? -s : Math.min(Math.max(-s, -v), s), C = -b * b + M * (M + 2 * v) + y) : M <= D ? (b = 0, M = Math.min(Math.max(-s, -v), s), C = M * (M + 2 * v) + y) : (b = Math.max(0, -(u * s + h)), M = b > 0 ? s : Math.min(Math.max(-s, -v), s), C = -b * b + M * (M + 2 * v) + y);
    else
      M = u > 0 ? -s : s, b = Math.max(0, -(u * M + h)), C = -b * b + M * (M + 2 * v) + y;
    return r && r.copy(this.origin).addScaledVector(this.direction, b), a && a.copy(f2).addScaledVector(uC, M), C;
  }
  intersectSphere(e, t) {
    wg.subVectors(e.center, this.origin);
    const r = wg.dot(this.direction), a = wg.dot(wg) - r * r, s = e.radius * e.radius;
    if (a > s)
      return null;
    const u = Math.sqrt(s - a), h = r - u, v = r + u;
    return v < 0 ? null : h < 0 ? this.at(v, t) : this.at(h, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, a, s, u, h, v;
    const y = 1 / this.direction.x, _ = 1 / this.direction.y, b = 1 / this.direction.z, M = this.origin;
    return y >= 0 ? (r = (e.min.x - M.x) * y, a = (e.max.x - M.x) * y) : (r = (e.max.x - M.x) * y, a = (e.min.x - M.x) * y), _ >= 0 ? (s = (e.min.y - M.y) * _, u = (e.max.y - M.y) * _) : (s = (e.max.y - M.y) * _, u = (e.min.y - M.y) * _), r > u || s > a || ((s > r || isNaN(r)) && (r = s), (u < a || isNaN(a)) && (a = u), b >= 0 ? (h = (e.min.z - M.z) * b, v = (e.max.z - M.z) * b) : (h = (e.max.z - M.z) * b, v = (e.min.z - M.z) * b), r > v || h > a) || ((h > r || r !== r) && (r = h), (v < a || a !== a) && (a = v), a < 0) ? null : this.at(r >= 0 ? r : a, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, wg) !== null;
  }
  intersectTriangle(e, t, r, a, s) {
    d2.subVectors(t, e), cC.subVectors(r, e), h2.crossVectors(d2, cC);
    let u = this.direction.dot(h2), h;
    if (u > 0) {
      if (a)
        return null;
      h = 1;
    } else if (u < 0)
      h = -1, u = -u;
    else
      return null;
    t0.subVectors(this.origin, e);
    const v = h * this.direction.dot(cC.crossVectors(t0, cC));
    if (v < 0)
      return null;
    const y = h * this.direction.dot(d2.cross(t0));
    if (y < 0 || v + y > u)
      return null;
    const _ = -h * t0.dot(h2);
    return _ < 0 ? null : this.at(_ / u, s);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ei {
  constructor(e, t, r, a, s, u, h, v, y, _, b, M, C, D, U, N) {
    ei.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, a, s, u, h, v, y, _, b, M, C, D, U, N);
  }
  set(e, t, r, a, s, u, h, v, y, _, b, M, C, D, U, N) {
    const O = this.elements;
    return O[0] = e, O[4] = t, O[8] = r, O[12] = a, O[1] = s, O[5] = u, O[9] = h, O[13] = v, O[2] = y, O[6] = _, O[10] = b, O[14] = M, O[3] = C, O[7] = D, O[11] = U, O[15] = N, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new ei().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
  }
  copyPosition(e) {
    const t = this.elements, r = e.elements;
    return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, r) {
    return this.set(
      e.x,
      t.x,
      r.x,
      0,
      e.y,
      t.y,
      r.y,
      0,
      e.z,
      t.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, r = e.elements, a = 1 / tE.setFromMatrixColumn(e, 0).length(), s = 1 / tE.setFromMatrixColumn(e, 1).length(), u = 1 / tE.setFromMatrixColumn(e, 2).length();
    return t[0] = r[0] * a, t[1] = r[1] * a, t[2] = r[2] * a, t[3] = 0, t[4] = r[4] * s, t[5] = r[5] * s, t[6] = r[6] * s, t[7] = 0, t[8] = r[8] * u, t[9] = r[9] * u, t[10] = r[10] * u, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, r = e.x, a = e.y, s = e.z, u = Math.cos(r), h = Math.sin(r), v = Math.cos(a), y = Math.sin(a), _ = Math.cos(s), b = Math.sin(s);
    if (e.order === "XYZ") {
      const M = u * _, C = u * b, D = h * _, U = h * b;
      t[0] = v * _, t[4] = -v * b, t[8] = y, t[1] = C + D * y, t[5] = M - U * y, t[9] = -h * v, t[2] = U - M * y, t[6] = D + C * y, t[10] = u * v;
    } else if (e.order === "YXZ") {
      const M = v * _, C = v * b, D = y * _, U = y * b;
      t[0] = M + U * h, t[4] = D * h - C, t[8] = u * y, t[1] = u * b, t[5] = u * _, t[9] = -h, t[2] = C * h - D, t[6] = U + M * h, t[10] = u * v;
    } else if (e.order === "ZXY") {
      const M = v * _, C = v * b, D = y * _, U = y * b;
      t[0] = M - U * h, t[4] = -u * b, t[8] = D + C * h, t[1] = C + D * h, t[5] = u * _, t[9] = U - M * h, t[2] = -u * y, t[6] = h, t[10] = u * v;
    } else if (e.order === "ZYX") {
      const M = u * _, C = u * b, D = h * _, U = h * b;
      t[0] = v * _, t[4] = D * y - C, t[8] = M * y + U, t[1] = v * b, t[5] = U * y + M, t[9] = C * y - D, t[2] = -y, t[6] = h * v, t[10] = u * v;
    } else if (e.order === "YZX") {
      const M = u * v, C = u * y, D = h * v, U = h * y;
      t[0] = v * _, t[4] = U - M * b, t[8] = D * b + C, t[1] = b, t[5] = u * _, t[9] = -h * _, t[2] = -y * _, t[6] = C * b + D, t[10] = M - U * b;
    } else if (e.order === "XZY") {
      const M = u * v, C = u * y, D = h * v, U = h * y;
      t[0] = v * _, t[4] = -b, t[8] = y * _, t[1] = M * b + U, t[5] = u * _, t[9] = C * b - D, t[2] = D * b - C, t[6] = h * _, t[10] = U * b + M;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(h8, e, p8);
  }
  lookAt(e, t, r) {
    const a = this.elements;
    return rh.subVectors(e, t), rh.lengthSq() === 0 && (rh.z = 1), rh.normalize(), n0.crossVectors(r, rh), n0.lengthSq() === 0 && (Math.abs(r.z) === 1 ? rh.x += 1e-4 : rh.z += 1e-4, rh.normalize(), n0.crossVectors(r, rh)), n0.normalize(), fC.crossVectors(rh, n0), a[0] = n0.x, a[4] = fC.x, a[8] = rh.x, a[1] = n0.y, a[5] = fC.y, a[9] = rh.y, a[2] = n0.z, a[6] = fC.z, a[10] = rh.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, a = t.elements, s = this.elements, u = r[0], h = r[4], v = r[8], y = r[12], _ = r[1], b = r[5], M = r[9], C = r[13], D = r[2], U = r[6], N = r[10], O = r[14], I = r[3], k = r[7], G = r[11], j = r[15], Y = a[0], Z = a[4], te = a[8], J = a[12], q = a[1], oe = a[5], ye = a[9], de = a[13], xe = a[2], Re = a[6], Pe = a[10], Te = a[14], ue = a[3], we = a[7], X = a[11], me = a[15];
    return s[0] = u * Y + h * q + v * xe + y * ue, s[4] = u * Z + h * oe + v * Re + y * we, s[8] = u * te + h * ye + v * Pe + y * X, s[12] = u * J + h * de + v * Te + y * me, s[1] = _ * Y + b * q + M * xe + C * ue, s[5] = _ * Z + b * oe + M * Re + C * we, s[9] = _ * te + b * ye + M * Pe + C * X, s[13] = _ * J + b * de + M * Te + C * me, s[2] = D * Y + U * q + N * xe + O * ue, s[6] = D * Z + U * oe + N * Re + O * we, s[10] = D * te + U * ye + N * Pe + O * X, s[14] = D * J + U * de + N * Te + O * me, s[3] = I * Y + k * q + G * xe + j * ue, s[7] = I * Z + k * oe + G * Re + j * we, s[11] = I * te + k * ye + G * Pe + j * X, s[15] = I * J + k * de + G * Te + j * me, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[4], a = e[8], s = e[12], u = e[1], h = e[5], v = e[9], y = e[13], _ = e[2], b = e[6], M = e[10], C = e[14], D = e[3], U = e[7], N = e[11], O = e[15];
    return D * (+s * v * b - a * y * b - s * h * M + r * y * M + a * h * C - r * v * C) + U * (+t * v * C - t * y * M + s * u * M - a * u * C + a * y * _ - s * v * _) + N * (+t * y * b - t * h * C - s * u * b + r * u * C + s * h * _ - r * y * _) + O * (-a * h * _ - t * v * b + t * h * M + a * u * b - r * u * M + r * v * _);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, r) {
    const a = this.elements;
    return e.isVector3 ? (a[12] = e.x, a[13] = e.y, a[14] = e.z) : (a[12] = e, a[13] = t, a[14] = r), this;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], a = e[2], s = e[3], u = e[4], h = e[5], v = e[6], y = e[7], _ = e[8], b = e[9], M = e[10], C = e[11], D = e[12], U = e[13], N = e[14], O = e[15], I = b * N * y - U * M * y + U * v * C - h * N * C - b * v * O + h * M * O, k = D * M * y - _ * N * y - D * v * C + u * N * C + _ * v * O - u * M * O, G = _ * U * y - D * b * y + D * h * C - u * U * C - _ * h * O + u * b * O, j = D * b * v - _ * U * v - D * h * M + u * U * M + _ * h * N - u * b * N, Y = t * I + r * k + a * G + s * j;
    if (Y === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const Z = 1 / Y;
    return e[0] = I * Z, e[1] = (U * M * s - b * N * s - U * a * C + r * N * C + b * a * O - r * M * O) * Z, e[2] = (h * N * s - U * v * s + U * a * y - r * N * y - h * a * O + r * v * O) * Z, e[3] = (b * v * s - h * M * s - b * a * y + r * M * y + h * a * C - r * v * C) * Z, e[4] = k * Z, e[5] = (_ * N * s - D * M * s + D * a * C - t * N * C - _ * a * O + t * M * O) * Z, e[6] = (D * v * s - u * N * s - D * a * y + t * N * y + u * a * O - t * v * O) * Z, e[7] = (u * M * s - _ * v * s + _ * a * y - t * M * y - u * a * C + t * v * C) * Z, e[8] = G * Z, e[9] = (D * b * s - _ * U * s - D * r * C + t * U * C + _ * r * O - t * b * O) * Z, e[10] = (u * U * s - D * h * s + D * r * y - t * U * y - u * r * O + t * h * O) * Z, e[11] = (_ * h * s - u * b * s - _ * r * y + t * b * y + u * r * C - t * h * C) * Z, e[12] = j * Z, e[13] = (_ * U * a - D * b * a + D * r * M - t * U * M - _ * r * N + t * b * N) * Z, e[14] = (D * h * a - u * U * a - D * r * v + t * U * v + u * r * N - t * h * N) * Z, e[15] = (u * b * a - _ * h * a + _ * r * v - t * b * v - u * r * M + t * h * M) * Z, this;
  }
  scale(e) {
    const t = this.elements, r = e.x, a = e.y, s = e.z;
    return t[0] *= r, t[4] *= a, t[8] *= s, t[1] *= r, t[5] *= a, t[9] *= s, t[2] *= r, t[6] *= a, t[10] *= s, t[3] *= r, t[7] *= a, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], a = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, a));
  }
  makeTranslation(e, t, r) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t), a = Math.sin(t), s = 1 - r, u = e.x, h = e.y, v = e.z, y = s * u, _ = s * h;
    return this.set(
      y * u + r,
      y * h - a * v,
      y * v + a * h,
      0,
      y * h + a * v,
      _ * h + r,
      _ * v - a * u,
      0,
      y * v - a * h,
      _ * v + a * u,
      s * v * v + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, r, a, s, u) {
    return this.set(
      1,
      r,
      s,
      0,
      e,
      1,
      u,
      0,
      t,
      a,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, r) {
    const a = this.elements, s = t._x, u = t._y, h = t._z, v = t._w, y = s + s, _ = u + u, b = h + h, M = s * y, C = s * _, D = s * b, U = u * _, N = u * b, O = h * b, I = v * y, k = v * _, G = v * b, j = r.x, Y = r.y, Z = r.z;
    return a[0] = (1 - (U + O)) * j, a[1] = (C + G) * j, a[2] = (D - k) * j, a[3] = 0, a[4] = (C - G) * Y, a[5] = (1 - (M + O)) * Y, a[6] = (N + I) * Y, a[7] = 0, a[8] = (D + k) * Z, a[9] = (N - I) * Z, a[10] = (1 - (M + U)) * Z, a[11] = 0, a[12] = e.x, a[13] = e.y, a[14] = e.z, a[15] = 1, this;
  }
  decompose(e, t, r) {
    const a = this.elements;
    let s = tE.set(a[0], a[1], a[2]).length();
    const u = tE.set(a[4], a[5], a[6]).length(), h = tE.set(a[8], a[9], a[10]).length();
    this.determinant() < 0 && (s = -s), e.x = a[12], e.y = a[13], e.z = a[14], Xp.copy(this);
    const y = 1 / s, _ = 1 / u, b = 1 / h;
    return Xp.elements[0] *= y, Xp.elements[1] *= y, Xp.elements[2] *= y, Xp.elements[4] *= _, Xp.elements[5] *= _, Xp.elements[6] *= _, Xp.elements[8] *= b, Xp.elements[9] *= b, Xp.elements[10] *= b, t.setFromRotationMatrix(Xp), r.x = s, r.y = u, r.z = h, this;
  }
  makePerspective(e, t, r, a, s, u, h = gv) {
    const v = this.elements, y = 2 * s / (t - e), _ = 2 * s / (r - a), b = (t + e) / (t - e), M = (r + a) / (r - a);
    let C, D;
    if (h === gv)
      C = -(u + s) / (u - s), D = -2 * u * s / (u - s);
    else if (h === LT)
      C = -u / (u - s), D = -u * s / (u - s);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + h);
    return v[0] = y, v[4] = 0, v[8] = b, v[12] = 0, v[1] = 0, v[5] = _, v[9] = M, v[13] = 0, v[2] = 0, v[6] = 0, v[10] = C, v[14] = D, v[3] = 0, v[7] = 0, v[11] = -1, v[15] = 0, this;
  }
  makeOrthographic(e, t, r, a, s, u, h = gv) {
    const v = this.elements, y = 1 / (t - e), _ = 1 / (r - a), b = 1 / (u - s), M = (t + e) * y, C = (r + a) * _;
    let D, U;
    if (h === gv)
      D = (u + s) * b, U = -2 * b;
    else if (h === LT)
      D = s * b, U = -1 * b;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + h);
    return v[0] = 2 * y, v[4] = 0, v[8] = 0, v[12] = -M, v[1] = 0, v[5] = 2 * _, v[9] = 0, v[13] = -C, v[2] = 0, v[6] = 0, v[10] = U, v[14] = -D, v[3] = 0, v[7] = 0, v[11] = 0, v[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let a = 0; a < 16; a++)
      if (t[a] !== r[a])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
  }
}
const tE = /* @__PURE__ */ new be(), Xp = /* @__PURE__ */ new ei(), h8 = /* @__PURE__ */ new be(0, 0, 0), p8 = /* @__PURE__ */ new be(1, 1, 1), n0 = /* @__PURE__ */ new be(), fC = /* @__PURE__ */ new be(), rh = /* @__PURE__ */ new be(), a3 = /* @__PURE__ */ new ei(), o3 = /* @__PURE__ */ new Oc();
class XT {
  constructor(e = 0, t = 0, r = 0, a = XT.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = a;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, r, a = this._order) {
    return this._x = e, this._y = t, this._z = r, this._order = a, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const a = e.elements, s = a[0], u = a[4], h = a[8], v = a[1], y = a[5], _ = a[9], b = a[2], M = a[6], C = a[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(ws(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(-_, C), this._z = Math.atan2(-u, s)) : (this._x = Math.atan2(M, y), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-ws(_, -1, 1)), Math.abs(_) < 0.9999999 ? (this._y = Math.atan2(h, C), this._z = Math.atan2(v, y)) : (this._y = Math.atan2(-b, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(ws(M, -1, 1)), Math.abs(M) < 0.9999999 ? (this._y = Math.atan2(-b, C), this._z = Math.atan2(-u, y)) : (this._y = 0, this._z = Math.atan2(v, s));
        break;
      case "ZYX":
        this._y = Math.asin(-ws(b, -1, 1)), Math.abs(b) < 0.9999999 ? (this._x = Math.atan2(M, C), this._z = Math.atan2(v, s)) : (this._x = 0, this._z = Math.atan2(-u, y));
        break;
      case "YZX":
        this._z = Math.asin(ws(v, -1, 1)), Math.abs(v) < 0.9999999 ? (this._x = Math.atan2(-_, y), this._y = Math.atan2(-b, s)) : (this._x = 0, this._y = Math.atan2(h, C));
        break;
      case "XZY":
        this._z = Math.asin(-ws(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(M, y), this._y = Math.atan2(h, s)) : (this._x = Math.atan2(-_, C), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return a3.makeRotationFromQuaternion(e), this.setFromRotationMatrix(a3, t, r);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return o3.setFromEuler(this), this.setFromQuaternion(o3, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
XT.DEFAULT_ORDER = "XYZ";
class rx {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let m8 = 0;
const s3 = /* @__PURE__ */ new be(), nE = /* @__PURE__ */ new Oc(), Cg = /* @__PURE__ */ new ei(), dC = /* @__PURE__ */ new be(), K1 = /* @__PURE__ */ new be(), v8 = /* @__PURE__ */ new be(), g8 = /* @__PURE__ */ new Oc(), l3 = /* @__PURE__ */ new be(1, 0, 0), u3 = /* @__PURE__ */ new be(0, 1, 0), c3 = /* @__PURE__ */ new be(0, 0, 1), y8 = { type: "added" }, f3 = { type: "removed" };
class ha extends Tv {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: m8++ }), this.uuid = sh(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ha.DEFAULT_UP.clone();
    const e = new be(), t = new XT(), r = new Oc(), a = new be(1, 1, 1);
    function s() {
      r.setFromEuler(t, !1);
    }
    function u() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(s), r._onChange(u), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: a
      },
      modelViewMatrix: {
        value: new ei()
      },
      normalMatrix: {
        value: new vi()
      }
    }), this.matrix = new ei(), this.matrixWorld = new ei(), this.matrixAutoUpdate = ha.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = ha.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new rx(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return nE.setFromAxisAngle(e, t), this.quaternion.multiply(nE), this;
  }
  rotateOnWorldAxis(e, t) {
    return nE.setFromAxisAngle(e, t), this.quaternion.premultiply(nE), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(l3, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(u3, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(c3, e);
  }
  translateOnAxis(e, t) {
    return s3.copy(e).applyQuaternion(this.quaternion), this.position.add(s3.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(l3, e);
  }
  translateY(e) {
    return this.translateOnAxis(u3, e);
  }
  translateZ(e) {
    return this.translateOnAxis(c3, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Cg.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, r) {
    e.isVector3 ? dC.copy(e) : dC.set(e, t, r);
    const a = this.parent;
    this.updateWorldMatrix(!0, !1), K1.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Cg.lookAt(K1, dC, this.up) : Cg.lookAt(dC, K1, this.up), this.quaternion.setFromRotationMatrix(Cg), a && (Cg.extractRotation(a.matrixWorld), nE.setFromRotationMatrix(Cg), this.quaternion.premultiply(nE.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(y8)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++)
        this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(f3)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      t.parent = null, t.dispatchEvent(f3);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Cg.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Cg.multiply(e.parent.matrixWorld)), e.applyMatrix4(Cg), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let r = 0, a = this.children.length; r < a; r++) {
      const u = this.children[r].getObjectByProperty(e, t);
      if (u !== void 0)
        return u;
    }
  }
  getObjectsByProperty(e, t) {
    let r = [];
    this[e] === t && r.push(this);
    for (let a = 0, s = this.children.length; a < s; a++) {
      const u = this.children[a].getObjectsByProperty(e, t);
      u.length > 0 && (r = r.concat(u));
    }
    return r;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(K1, e, v8), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(K1, g8, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, a = t.length; r < a; r++)
      t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let r = 0, a = t.length; r < a; r++)
      t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let r = 0, a = t.length; r < a; r++) {
      const s = t[r];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const a = this.children;
      for (let s = 0, u = a.length; s < u; s++) {
        const h = a[s];
        h.matrixWorldAutoUpdate === !0 && h.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", r = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, r.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const a = {};
    a.uuid = this.uuid, a.type = this.type, this.name !== "" && (a.name = this.name), this.castShadow === !0 && (a.castShadow = !0), this.receiveShadow === !0 && (a.receiveShadow = !0), this.visible === !1 && (a.visible = !1), this.frustumCulled === !1 && (a.frustumCulled = !1), this.renderOrder !== 0 && (a.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), a.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (a.matrixAutoUpdate = !1), this.isInstancedMesh && (a.type = "InstancedMesh", a.count = this.count, a.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (a.instanceColor = this.instanceColor.toJSON()));
    function s(h, v) {
      return h[v.uuid] === void 0 && (h[v.uuid] = v.toJSON(e)), v.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? a.background = this.background.toJSON() : this.background.isTexture && (a.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (a.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      a.geometry = s(e.geometries, this.geometry);
      const h = this.geometry.parameters;
      if (h !== void 0 && h.shapes !== void 0) {
        const v = h.shapes;
        if (Array.isArray(v))
          for (let y = 0, _ = v.length; y < _; y++) {
            const b = v[y];
            s(e.shapes, b);
          }
        else
          s(e.shapes, v);
      }
    }
    if (this.isSkinnedMesh && (a.bindMode = this.bindMode, a.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), a.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const h = [];
        for (let v = 0, y = this.material.length; v < y; v++)
          h.push(s(e.materials, this.material[v]));
        a.material = h;
      } else
        a.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      a.children = [];
      for (let h = 0; h < this.children.length; h++)
        a.children.push(this.children[h].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      a.animations = [];
      for (let h = 0; h < this.animations.length; h++) {
        const v = this.animations[h];
        a.animations.push(s(e.animations, v));
      }
    }
    if (t) {
      const h = u(e.geometries), v = u(e.materials), y = u(e.textures), _ = u(e.images), b = u(e.shapes), M = u(e.skeletons), C = u(e.animations), D = u(e.nodes);
      h.length > 0 && (r.geometries = h), v.length > 0 && (r.materials = v), y.length > 0 && (r.textures = y), _.length > 0 && (r.images = _), b.length > 0 && (r.shapes = b), M.length > 0 && (r.skeletons = M), C.length > 0 && (r.animations = C), D.length > 0 && (r.nodes = D);
    }
    return r.object = a, r;
    function u(h) {
      const v = [];
      for (const y in h) {
        const _ = h[y];
        delete _.metadata, v.push(_);
      }
      return v;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let r = 0; r < e.children.length; r++) {
        const a = e.children[r];
        this.add(a.clone());
      }
    return this;
  }
}
ha.DEFAULT_UP = /* @__PURE__ */ new be(0, 1, 0);
ha.DEFAULT_MATRIX_AUTO_UPDATE = !0;
ha.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const qp = /* @__PURE__ */ new be(), Rg = /* @__PURE__ */ new be(), p2 = /* @__PURE__ */ new be(), Ag = /* @__PURE__ */ new be(), rE = /* @__PURE__ */ new be(), iE = /* @__PURE__ */ new be(), d3 = /* @__PURE__ */ new be(), m2 = /* @__PURE__ */ new be(), v2 = /* @__PURE__ */ new be(), g2 = /* @__PURE__ */ new be();
let hC = !1;
class fd {
  constructor(e = new be(), t = new be(), r = new be()) {
    this.a = e, this.b = t, this.c = r;
  }
  static getNormal(e, t, r, a) {
    a.subVectors(r, t), qp.subVectors(e, t), a.cross(qp);
    const s = a.lengthSq();
    return s > 0 ? a.multiplyScalar(1 / Math.sqrt(s)) : a.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, r, a, s) {
    qp.subVectors(a, t), Rg.subVectors(r, t), p2.subVectors(e, t);
    const u = qp.dot(qp), h = qp.dot(Rg), v = qp.dot(p2), y = Rg.dot(Rg), _ = Rg.dot(p2), b = u * y - h * h;
    if (b === 0)
      return s.set(-2, -1, -1);
    const M = 1 / b, C = (y * v - h * _) * M, D = (u * _ - h * v) * M;
    return s.set(1 - C - D, D, C);
  }
  static containsPoint(e, t, r, a) {
    return this.getBarycoord(e, t, r, a, Ag), Ag.x >= 0 && Ag.y >= 0 && Ag.x + Ag.y <= 1;
  }
  static getUV(e, t, r, a, s, u, h, v) {
    return hC === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), hC = !0), this.getInterpolation(e, t, r, a, s, u, h, v);
  }
  static getInterpolation(e, t, r, a, s, u, h, v) {
    return this.getBarycoord(e, t, r, a, Ag), v.setScalar(0), v.addScaledVector(s, Ag.x), v.addScaledVector(u, Ag.y), v.addScaledVector(h, Ag.z), v;
  }
  static isFrontFacing(e, t, r, a) {
    return qp.subVectors(r, t), Rg.subVectors(e, t), qp.cross(Rg).dot(a) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, a) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[a]), this;
  }
  setFromAttributeAndIndices(e, t, r, a) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, a), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return qp.subVectors(this.c, this.b), Rg.subVectors(this.a, this.b), qp.cross(Rg).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return fd.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return fd.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, r, a, s) {
    return hC === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), hC = !0), fd.getInterpolation(e, this.a, this.b, this.c, t, r, a, s);
  }
  getInterpolation(e, t, r, a, s) {
    return fd.getInterpolation(e, this.a, this.b, this.c, t, r, a, s);
  }
  containsPoint(e) {
    return fd.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return fd.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a, a = this.b, s = this.c;
    let u, h;
    rE.subVectors(a, r), iE.subVectors(s, r), m2.subVectors(e, r);
    const v = rE.dot(m2), y = iE.dot(m2);
    if (v <= 0 && y <= 0)
      return t.copy(r);
    v2.subVectors(e, a);
    const _ = rE.dot(v2), b = iE.dot(v2);
    if (_ >= 0 && b <= _)
      return t.copy(a);
    const M = v * b - _ * y;
    if (M <= 0 && v >= 0 && _ <= 0)
      return u = v / (v - _), t.copy(r).addScaledVector(rE, u);
    g2.subVectors(e, s);
    const C = rE.dot(g2), D = iE.dot(g2);
    if (D >= 0 && C <= D)
      return t.copy(s);
    const U = C * y - v * D;
    if (U <= 0 && y >= 0 && D <= 0)
      return h = y / (y - D), t.copy(r).addScaledVector(iE, h);
    const N = _ * D - C * b;
    if (N <= 0 && b - _ >= 0 && C - D >= 0)
      return d3.subVectors(s, a), h = (b - _) / (b - _ + (C - D)), t.copy(a).addScaledVector(d3, h);
    const O = 1 / (N + U + M);
    return u = U * O, h = M * O, t.copy(r).addScaledVector(rE, u).addScaledVector(iE, h);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let S8 = 0;
class Ku extends Tv {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: S8++ }), this.uuid = sh(), this.name = "", this.type = "Material", this.blending = tx, this.side = Fg, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = zO, this.blendDst = kO, this.blendEquation = XS, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = mR, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = SF, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = fR, this.stencilZFail = fR, this.stencilZPass = fR, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const a = this[t];
        if (a === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        a && a.isColor ? a.set(r) : a && a.isVector3 && r && r.isVector3 ? a.copy(r) : this[t] = r;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (r.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (r.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== tx && (r.blending = this.blending), this.side !== Fg && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.colorWrite = this.colorWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (r.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (r.flatShading = this.flatShading), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), this.fog === !1 && (r.fog = !1), Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function a(s) {
      const u = [];
      for (const h in s) {
        const v = s[h];
        delete v.metadata, u.push(v);
      }
      return u;
    }
    if (t) {
      const s = a(e.textures), u = a(e.images);
      s.length > 0 && (r.textures = s), u.length > 0 && (r.images = u);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const a = t.length;
      r = new Array(a);
      for (let s = 0; s !== a; ++s)
        r[s] = t[s].clone();
    }
    return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const DF = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Kp = { h: 0, s: 0, l: 0 }, pC = { h: 0, s: 0, l: 0 };
function y2(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n;
}
let Un = class {
  constructor(e, t, r) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, r);
  }
  set(e, t, r) {
    if (t === void 0 && r === void 0) {
      const a = e;
      a && a.isColor ? this.copy(a) : typeof a == "number" ? this.setHex(a) : typeof a == "string" && this.setStyle(a);
    } else
      this.setRGB(e, t, r);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = ai) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, tp.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, r, a = tp.workingColorSpace) {
    return this.r = e, this.g = t, this.b = r, tp.toWorkingColorSpace(this, a), this;
  }
  setHSL(e, t, r, a = tp.workingColorSpace) {
    if (e = qO(e, 1), t = ws(t, 0, 1), r = ws(r, 0, 1), t === 0)
      this.r = this.g = this.b = r;
    else {
      const s = r <= 0.5 ? r * (1 + t) : r + t - r * t, u = 2 * r - s;
      this.r = y2(u, s, e + 1 / 3), this.g = y2(u, s, e), this.b = y2(u, s, e - 1 / 3);
    }
    return tp.toWorkingColorSpace(this, a), this;
  }
  setStyle(e, t = ai) {
    function r(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let a;
    if (a = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let s;
      const u = a[1], h = a[2];
      switch (u) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return r(s[4]), this.setRGB(
              Math.min(255, parseInt(s[1], 10)) / 255,
              Math.min(255, parseInt(s[2], 10)) / 255,
              Math.min(255, parseInt(s[3], 10)) / 255,
              t
            );
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return r(s[4]), this.setRGB(
              Math.min(100, parseInt(s[1], 10)) / 100,
              Math.min(100, parseInt(s[2], 10)) / 100,
              Math.min(100, parseInt(s[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return r(s[4]), this.setHSL(
              parseFloat(s[1]) / 360,
              parseFloat(s[2]) / 100,
              parseFloat(s[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (a = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = a[1], u = s.length;
      if (u === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (u === 6)
        return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = ai) {
    const r = DF[e.toLowerCase()];
    return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = LE(e.r), this.g = LE(e.g), this.b = LE(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = o2(e.r), this.g = o2(e.g), this.b = o2(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = ai) {
    return tp.fromWorkingColorSpace(Ac.copy(this), e), Math.round(ws(Ac.r * 255, 0, 255)) * 65536 + Math.round(ws(Ac.g * 255, 0, 255)) * 256 + Math.round(ws(Ac.b * 255, 0, 255));
  }
  getHexString(e = ai) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = tp.workingColorSpace) {
    tp.fromWorkingColorSpace(Ac.copy(this), t);
    const r = Ac.r, a = Ac.g, s = Ac.b, u = Math.max(r, a, s), h = Math.min(r, a, s);
    let v, y;
    const _ = (h + u) / 2;
    if (h === u)
      v = 0, y = 0;
    else {
      const b = u - h;
      switch (y = _ <= 0.5 ? b / (u + h) : b / (2 - u - h), u) {
        case r:
          v = (a - s) / b + (a < s ? 6 : 0);
          break;
        case a:
          v = (s - r) / b + 2;
          break;
        case s:
          v = (r - a) / b + 4;
          break;
      }
      v /= 6;
    }
    return e.h = v, e.s = y, e.l = _, e;
  }
  getRGB(e, t = tp.workingColorSpace) {
    return tp.fromWorkingColorSpace(Ac.copy(this), t), e.r = Ac.r, e.g = Ac.g, e.b = Ac.b, e;
  }
  getStyle(e = ai) {
    tp.fromWorkingColorSpace(Ac.copy(this), e);
    const t = Ac.r, r = Ac.g, a = Ac.b;
    return e !== ai ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${a.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(a * 255)})`;
  }
  offsetHSL(e, t, r) {
    return this.getHSL(Kp), Kp.h += e, Kp.s += t, Kp.l += r, this.setHSL(Kp.h, Kp.s, Kp.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, r) {
    return this.r = e.r + (t.r - e.r) * r, this.g = e.g + (t.g - e.g) * r, this.b = e.b + (t.b - e.b) * r, this;
  }
  lerpHSL(e, t) {
    this.getHSL(Kp), e.getHSL(pC);
    const r = vT(Kp.h, pC.h, t), a = vT(Kp.s, pC.s, t), s = vT(Kp.l, pC.l, t);
    return this.setHSL(r, a, s), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, r = this.g, a = this.b, s = e.elements;
    return this.r = s[0] * t + s[3] * r + s[6] * a, this.g = s[1] * t + s[4] * r + s[7] * a, this.b = s[2] * t + s[5] * r + s[8] * a, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const Ac = /* @__PURE__ */ new Un();
Un.NAMES = DF;
class x0 extends Ku {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Un(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = YT, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Pg = /* @__PURE__ */ x8();
function x8() {
  const n = new ArrayBuffer(4), e = new Float32Array(n), t = new Uint32Array(n), r = new Uint32Array(512), a = new Uint32Array(512);
  for (let v = 0; v < 256; ++v) {
    const y = v - 127;
    y < -27 ? (r[v] = 0, r[v | 256] = 32768, a[v] = 24, a[v | 256] = 24) : y < -14 ? (r[v] = 1024 >> -y - 14, r[v | 256] = 1024 >> -y - 14 | 32768, a[v] = -y - 1, a[v | 256] = -y - 1) : y <= 15 ? (r[v] = y + 15 << 10, r[v | 256] = y + 15 << 10 | 32768, a[v] = 13, a[v | 256] = 13) : y < 128 ? (r[v] = 31744, r[v | 256] = 64512, a[v] = 24, a[v | 256] = 24) : (r[v] = 31744, r[v | 256] = 64512, a[v] = 13, a[v | 256] = 13);
  }
  const s = new Uint32Array(2048), u = new Uint32Array(64), h = new Uint32Array(64);
  for (let v = 1; v < 1024; ++v) {
    let y = v << 13, _ = 0;
    for (; !(y & 8388608); )
      y <<= 1, _ -= 8388608;
    y &= -8388609, _ += 947912704, s[v] = y | _;
  }
  for (let v = 1024; v < 2048; ++v)
    s[v] = 939524096 + (v - 1024 << 13);
  for (let v = 1; v < 31; ++v)
    u[v] = v << 23;
  u[31] = 1199570944, u[32] = 2147483648;
  for (let v = 33; v < 63; ++v)
    u[v] = 2147483648 + (v - 32 << 23);
  u[63] = 3347054592;
  for (let v = 1; v < 64; ++v)
    v !== 32 && (h[v] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: a,
    mantissaTable: s,
    exponentTable: u,
    offsetTable: h
  };
}
function ud(n) {
  Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = ws(n, -65504, 65504), Pg.floatView[0] = n;
  const e = Pg.uint32View[0], t = e >> 23 & 511;
  return Pg.baseTable[t] + ((e & 8388607) >> Pg.shiftTable[t]);
}
function cT(n) {
  const e = n >> 10;
  return Pg.uint32View[0] = Pg.mantissaTable[Pg.offsetTable[e] + (n & 1023)] + Pg.exponentTable[e], Pg.floatView[0];
}
const _8 = {
  toHalfFloat: ud,
  fromHalfFloat: cT
}, xl = /* @__PURE__ */ new be(), mC = /* @__PURE__ */ new It();
class so {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r, this.usage = DT, this.updateRange = { offset: 0, count: -1 }, this.gpuType = vv, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, r) {
    e *= this.itemSize, r *= t.itemSize;
    for (let a = 0, s = this.itemSize; a < s; a++)
      this.array[e + a] = t.array[r + a];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        mC.fromBufferAttribute(this, t), mC.applyMatrix3(e), this.setXY(t, mC.x, mC.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        xl.fromBufferAttribute(this, t), xl.applyMatrix3(e), this.setXYZ(t, xl.x, xl.y, xl.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      xl.fromBufferAttribute(this, t), xl.applyMatrix4(e), this.setXYZ(t, xl.x, xl.y, xl.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      xl.fromBufferAttribute(this, t), xl.applyNormalMatrix(e), this.setXYZ(t, xl.x, xl.y, xl.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      xl.fromBufferAttribute(this, t), xl.transformDirection(e), this.setXYZ(t, xl.x, xl.y, xl.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = oh(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = oh(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = oh(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = oh(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.normalized && (t = gi(t, this.array), r = gi(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, a) {
    return e *= this.itemSize, this.normalized && (t = gi(t, this.array), r = gi(r, this.array), a = gi(a, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = a, this;
  }
  setXYZW(e, t, r, a, s) {
    return e *= this.itemSize, this.normalized && (t = gi(t, this.array), r = gi(r, this.array), a = gi(a, this.array), s = gi(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = a, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== DT && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
  copyColorsArray() {
    console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
  }
  copyVector2sArray() {
    console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
  }
  copyVector3sArray() {
    console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
  }
  copyVector4sArray() {
    console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
  }
}
class E8 extends so {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class b8 extends so {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class T8 extends so {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class M8 extends so {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class ZO extends so {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class w8 extends so {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class JO extends so {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class C8 extends so {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = cT(this.array[e * this.itemSize]);
    return this.normalized && (t = oh(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize] = ud(t), this;
  }
  getY(e) {
    let t = cT(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = oh(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize + 1] = ud(t), this;
  }
  getZ(e) {
    let t = cT(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = oh(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize + 2] = ud(t), this;
  }
  getW(e) {
    let t = cT(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = oh(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize + 3] = ud(t), this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.normalized && (t = gi(t, this.array), r = gi(r, this.array)), this.array[e + 0] = ud(t), this.array[e + 1] = ud(r), this;
  }
  setXYZ(e, t, r, a) {
    return e *= this.itemSize, this.normalized && (t = gi(t, this.array), r = gi(r, this.array), a = gi(a, this.array)), this.array[e + 0] = ud(t), this.array[e + 1] = ud(r), this.array[e + 2] = ud(a), this;
  }
  setXYZW(e, t, r, a, s) {
    return e *= this.itemSize, this.normalized && (t = gi(t, this.array), r = gi(r, this.array), a = gi(a, this.array), s = gi(s, this.array)), this.array[e + 0] = ud(t), this.array[e + 1] = ud(r), this.array[e + 2] = ud(a), this.array[e + 3] = ud(s), this;
  }
}
class nr extends so {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
class R8 extends so {
  constructor(e, t, r) {
    super(new Float64Array(e), t, r);
  }
}
let A8 = 0;
const ep = /* @__PURE__ */ new ei(), S2 = /* @__PURE__ */ new ha(), aE = /* @__PURE__ */ new be(), ih = /* @__PURE__ */ new Mv(), Q1 = /* @__PURE__ */ new Mv(), xu = /* @__PURE__ */ new be();
class yi extends Tv {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: A8++ }), this.uuid = sh(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (AF(e) ? JO : ZO)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: r
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const r = this.attributes.normal;
    if (r !== void 0) {
      const s = new vi().getNormalMatrix(e);
      r.applyNormalMatrix(s), r.needsUpdate = !0;
    }
    const a = this.attributes.tangent;
    return a !== void 0 && (a.transformDirection(e), a.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return ep.makeRotationFromQuaternion(e), this.applyMatrix4(ep), this;
  }
  rotateX(e) {
    return ep.makeRotationX(e), this.applyMatrix4(ep), this;
  }
  rotateY(e) {
    return ep.makeRotationY(e), this.applyMatrix4(ep), this;
  }
  rotateZ(e) {
    return ep.makeRotationZ(e), this.applyMatrix4(ep), this;
  }
  translate(e, t, r) {
    return ep.makeTranslation(e, t, r), this.applyMatrix4(ep), this;
  }
  scale(e, t, r) {
    return ep.makeScale(e, t, r), this.applyMatrix4(ep), this;
  }
  lookAt(e) {
    return S2.lookAt(e), S2.updateMatrix(), this.applyMatrix4(S2.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(aE).negate(), this.translate(aE.x, aE.y, aE.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, a = e.length; r < a; r++) {
      const s = e[r];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new nr(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Mv());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new be(-1 / 0, -1 / 0, -1 / 0),
        new be(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let r = 0, a = t.length; r < a; r++) {
          const s = t[r];
          ih.setFromBufferAttribute(s), this.morphTargetsRelative ? (xu.addVectors(this.boundingBox.min, ih.min), this.boundingBox.expandByPoint(xu), xu.addVectors(this.boundingBox.max, ih.max), this.boundingBox.expandByPoint(xu)) : (this.boundingBox.expandByPoint(ih.min), this.boundingBox.expandByPoint(ih.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new sm());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new be(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if (ih.setFromBufferAttribute(e), t)
        for (let s = 0, u = t.length; s < u; s++) {
          const h = t[s];
          Q1.setFromBufferAttribute(h), this.morphTargetsRelative ? (xu.addVectors(ih.min, Q1.min), ih.expandByPoint(xu), xu.addVectors(ih.max, Q1.max), ih.expandByPoint(xu)) : (ih.expandByPoint(Q1.min), ih.expandByPoint(Q1.max));
        }
      ih.getCenter(r);
      let a = 0;
      for (let s = 0, u = e.count; s < u; s++)
        xu.fromBufferAttribute(e, s), a = Math.max(a, r.distanceToSquared(xu));
      if (t)
        for (let s = 0, u = t.length; s < u; s++) {
          const h = t[s], v = this.morphTargetsRelative;
          for (let y = 0, _ = h.count; y < _; y++)
            xu.fromBufferAttribute(h, y), v && (aE.fromBufferAttribute(e, y), xu.add(aE)), a = Math.max(a, r.distanceToSquared(xu));
        }
      this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const r = e.array, a = t.position.array, s = t.normal.array, u = t.uv.array, h = a.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new so(new Float32Array(4 * h), 4));
    const v = this.getAttribute("tangent").array, y = [], _ = [];
    for (let q = 0; q < h; q++)
      y[q] = new be(), _[q] = new be();
    const b = new be(), M = new be(), C = new be(), D = new It(), U = new It(), N = new It(), O = new be(), I = new be();
    function k(q, oe, ye) {
      b.fromArray(a, q * 3), M.fromArray(a, oe * 3), C.fromArray(a, ye * 3), D.fromArray(u, q * 2), U.fromArray(u, oe * 2), N.fromArray(u, ye * 2), M.sub(b), C.sub(b), U.sub(D), N.sub(D);
      const de = 1 / (U.x * N.y - N.x * U.y);
      isFinite(de) && (O.copy(M).multiplyScalar(N.y).addScaledVector(C, -U.y).multiplyScalar(de), I.copy(C).multiplyScalar(U.x).addScaledVector(M, -N.x).multiplyScalar(de), y[q].add(O), y[oe].add(O), y[ye].add(O), _[q].add(I), _[oe].add(I), _[ye].add(I));
    }
    let G = this.groups;
    G.length === 0 && (G = [{
      start: 0,
      count: r.length
    }]);
    for (let q = 0, oe = G.length; q < oe; ++q) {
      const ye = G[q], de = ye.start, xe = ye.count;
      for (let Re = de, Pe = de + xe; Re < Pe; Re += 3)
        k(
          r[Re + 0],
          r[Re + 1],
          r[Re + 2]
        );
    }
    const j = new be(), Y = new be(), Z = new be(), te = new be();
    function J(q) {
      Z.fromArray(s, q * 3), te.copy(Z);
      const oe = y[q];
      j.copy(oe), j.sub(Z.multiplyScalar(Z.dot(oe))).normalize(), Y.crossVectors(te, oe);
      const de = Y.dot(_[q]) < 0 ? -1 : 1;
      v[q * 4] = j.x, v[q * 4 + 1] = j.y, v[q * 4 + 2] = j.z, v[q * 4 + 3] = de;
    }
    for (let q = 0, oe = G.length; q < oe; ++q) {
      const ye = G[q], de = ye.start, xe = ye.count;
      for (let Re = de, Pe = de + xe; Re < Pe; Re += 3)
        J(r[Re + 0]), J(r[Re + 1]), J(r[Re + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        r = new so(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r);
      else
        for (let M = 0, C = r.count; M < C; M++)
          r.setXYZ(M, 0, 0, 0);
      const a = new be(), s = new be(), u = new be(), h = new be(), v = new be(), y = new be(), _ = new be(), b = new be();
      if (e)
        for (let M = 0, C = e.count; M < C; M += 3) {
          const D = e.getX(M + 0), U = e.getX(M + 1), N = e.getX(M + 2);
          a.fromBufferAttribute(t, D), s.fromBufferAttribute(t, U), u.fromBufferAttribute(t, N), _.subVectors(u, s), b.subVectors(a, s), _.cross(b), h.fromBufferAttribute(r, D), v.fromBufferAttribute(r, U), y.fromBufferAttribute(r, N), h.add(_), v.add(_), y.add(_), r.setXYZ(D, h.x, h.y, h.z), r.setXYZ(U, v.x, v.y, v.z), r.setXYZ(N, y.x, y.y, y.z);
        }
      else
        for (let M = 0, C = t.count; M < C; M += 3)
          a.fromBufferAttribute(t, M + 0), s.fromBufferAttribute(t, M + 1), u.fromBufferAttribute(t, M + 2), _.subVectors(u, s), b.subVectors(a, s), _.cross(b), r.setXYZ(M + 0, _.x, _.y, _.z), r.setXYZ(M + 1, _.x, _.y, _.z), r.setXYZ(M + 2, _.x, _.y, _.z);
      this.normalizeNormals(), r.needsUpdate = !0;
    }
  }
  merge() {
    return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."), this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      xu.fromBufferAttribute(e, t), xu.normalize(), e.setXYZ(t, xu.x, xu.y, xu.z);
  }
  toNonIndexed() {
    function e(h, v) {
      const y = h.array, _ = h.itemSize, b = h.normalized, M = new y.constructor(v.length * _);
      let C = 0, D = 0;
      for (let U = 0, N = v.length; U < N; U++) {
        h.isInterleavedBufferAttribute ? C = v[U] * h.data.stride + h.offset : C = v[U] * _;
        for (let O = 0; O < _; O++)
          M[D++] = y[C++];
      }
      return new so(M, _, b);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new yi(), r = this.index.array, a = this.attributes;
    for (const h in a) {
      const v = a[h], y = e(v, r);
      t.setAttribute(h, y);
    }
    const s = this.morphAttributes;
    for (const h in s) {
      const v = [], y = s[h];
      for (let _ = 0, b = y.length; _ < b; _++) {
        const M = y[_], C = e(M, r);
        v.push(C);
      }
      t.morphAttributes[h] = v;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const u = this.groups;
    for (let h = 0, v = u.length; h < v; h++) {
      const y = u[h];
      t.addGroup(y.start, y.count, y.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const v = this.parameters;
      for (const y in v)
        v[y] !== void 0 && (e[y] = v[y]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const r = this.attributes;
    for (const v in r) {
      const y = r[v];
      e.data.attributes[v] = y.toJSON(e.data);
    }
    const a = {};
    let s = !1;
    for (const v in this.morphAttributes) {
      const y = this.morphAttributes[v], _ = [];
      for (let b = 0, M = y.length; b < M; b++) {
        const C = y[b];
        _.push(C.toJSON(e.data));
      }
      _.length > 0 && (a[v] = _, s = !0);
    }
    s && (e.data.morphAttributes = a, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const u = this.groups;
    u.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(u)));
    const h = this.boundingSphere;
    return h !== null && (e.data.boundingSphere = {
      center: h.center.toArray(),
      radius: h.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const a = e.attributes;
    for (const y in a) {
      const _ = a[y];
      this.setAttribute(y, _.clone(t));
    }
    const s = e.morphAttributes;
    for (const y in s) {
      const _ = [], b = s[y];
      for (let M = 0, C = b.length; M < C; M++)
        _.push(b[M].clone(t));
      this.morphAttributes[y] = _;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const u = e.groups;
    for (let y = 0, _ = u.length; y < _; y++) {
      const b = u[y];
      this.addGroup(b.start, b.count, b.materialIndex);
    }
    const h = e.boundingBox;
    h !== null && (this.boundingBox = h.clone());
    const v = e.boundingSphere;
    return v !== null && (this.boundingSphere = v.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const h3 = /* @__PURE__ */ new ei(), IS = /* @__PURE__ */ new mx(), vC = /* @__PURE__ */ new sm(), p3 = /* @__PURE__ */ new be(), oE = /* @__PURE__ */ new be(), sE = /* @__PURE__ */ new be(), lE = /* @__PURE__ */ new be(), x2 = /* @__PURE__ */ new be(), gC = /* @__PURE__ */ new be(), yC = /* @__PURE__ */ new It(), SC = /* @__PURE__ */ new It(), xC = /* @__PURE__ */ new It(), m3 = /* @__PURE__ */ new be(), v3 = /* @__PURE__ */ new be(), g3 = /* @__PURE__ */ new be(), _C = /* @__PURE__ */ new be(), EC = /* @__PURE__ */ new be();
class qu extends ha {
  constructor(e = new yi(), t = new x0()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const a = t[r[0]];
      if (a !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, u = a.length; s < u; s++) {
          const h = a[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[h] = s;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const r = this.geometry, a = r.attributes.position, s = r.morphAttributes.position, u = r.morphTargetsRelative;
    t.fromBufferAttribute(a, e);
    const h = this.morphTargetInfluences;
    if (s && h) {
      gC.set(0, 0, 0);
      for (let v = 0, y = s.length; v < y; v++) {
        const _ = h[v], b = s[v];
        _ !== 0 && (x2.fromBufferAttribute(b, e), u ? gC.addScaledVector(x2, _) : gC.addScaledVector(x2.sub(t), _));
      }
      t.add(gC);
    }
    return t;
  }
  raycast(e, t) {
    const r = this.geometry, a = this.material, s = this.matrixWorld;
    a !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(), vC.copy(r.boundingSphere), vC.applyMatrix4(s), IS.copy(e.ray).recast(e.near), !(vC.containsPoint(IS.origin) === !1 && (IS.intersectSphere(vC, p3) === null || IS.origin.distanceToSquared(p3) > (e.far - e.near) ** 2)) && (h3.copy(s).invert(), IS.copy(e.ray).applyMatrix4(h3), !(r.boundingBox !== null && IS.intersectsBox(r.boundingBox) === !1) && this._computeIntersections(e, t, IS)));
  }
  _computeIntersections(e, t, r) {
    let a;
    const s = this.geometry, u = this.material, h = s.index, v = s.attributes.position, y = s.attributes.uv, _ = s.attributes.uv1, b = s.attributes.normal, M = s.groups, C = s.drawRange;
    if (h !== null)
      if (Array.isArray(u))
        for (let D = 0, U = M.length; D < U; D++) {
          const N = M[D], O = u[N.materialIndex], I = Math.max(N.start, C.start), k = Math.min(h.count, Math.min(N.start + N.count, C.start + C.count));
          for (let G = I, j = k; G < j; G += 3) {
            const Y = h.getX(G), Z = h.getX(G + 1), te = h.getX(G + 2);
            a = bC(this, O, e, r, y, _, b, Y, Z, te), a && (a.faceIndex = Math.floor(G / 3), a.face.materialIndex = N.materialIndex, t.push(a));
          }
        }
      else {
        const D = Math.max(0, C.start), U = Math.min(h.count, C.start + C.count);
        for (let N = D, O = U; N < O; N += 3) {
          const I = h.getX(N), k = h.getX(N + 1), G = h.getX(N + 2);
          a = bC(this, u, e, r, y, _, b, I, k, G), a && (a.faceIndex = Math.floor(N / 3), t.push(a));
        }
      }
    else if (v !== void 0)
      if (Array.isArray(u))
        for (let D = 0, U = M.length; D < U; D++) {
          const N = M[D], O = u[N.materialIndex], I = Math.max(N.start, C.start), k = Math.min(v.count, Math.min(N.start + N.count, C.start + C.count));
          for (let G = I, j = k; G < j; G += 3) {
            const Y = G, Z = G + 1, te = G + 2;
            a = bC(this, O, e, r, y, _, b, Y, Z, te), a && (a.faceIndex = Math.floor(G / 3), a.face.materialIndex = N.materialIndex, t.push(a));
          }
        }
      else {
        const D = Math.max(0, C.start), U = Math.min(v.count, C.start + C.count);
        for (let N = D, O = U; N < O; N += 3) {
          const I = N, k = N + 1, G = N + 2;
          a = bC(this, u, e, r, y, _, b, I, k, G), a && (a.faceIndex = Math.floor(N / 3), t.push(a));
        }
      }
  }
}
function D8(n, e, t, r, a, s, u, h) {
  let v;
  if (e.side === bf ? v = r.intersectTriangle(u, s, a, !0, h) : v = r.intersectTriangle(a, s, u, e.side === Fg, h), v === null)
    return null;
  EC.copy(h), EC.applyMatrix4(n.matrixWorld);
  const y = t.ray.origin.distanceTo(EC);
  return y < t.near || y > t.far ? null : {
    distance: y,
    point: EC.clone(),
    object: n
  };
}
function bC(n, e, t, r, a, s, u, h, v, y) {
  n.getVertexPosition(h, oE), n.getVertexPosition(v, sE), n.getVertexPosition(y, lE);
  const _ = D8(n, e, t, r, oE, sE, lE, _C);
  if (_) {
    a && (yC.fromBufferAttribute(a, h), SC.fromBufferAttribute(a, v), xC.fromBufferAttribute(a, y), _.uv = fd.getInterpolation(_C, oE, sE, lE, yC, SC, xC, new It())), s && (yC.fromBufferAttribute(s, h), SC.fromBufferAttribute(s, v), xC.fromBufferAttribute(s, y), _.uv1 = fd.getInterpolation(_C, oE, sE, lE, yC, SC, xC, new It()), _.uv2 = _.uv1), u && (m3.fromBufferAttribute(u, h), v3.fromBufferAttribute(u, v), g3.fromBufferAttribute(u, y), _.normal = fd.getInterpolation(_C, oE, sE, lE, m3, v3, g3, new be()), _.normal.dot(r.direction) > 0 && _.normal.multiplyScalar(-1));
    const b = {
      a: h,
      b: v,
      c: y,
      normal: new be(),
      materialIndex: 0
    };
    fd.getNormal(oE, sE, lE, b.normal), _.face = b;
  }
  return _;
}
class _0 extends yi {
  constructor(e = 1, t = 1, r = 1, a = 1, s = 1, u = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: r,
      widthSegments: a,
      heightSegments: s,
      depthSegments: u
    };
    const h = this;
    a = Math.floor(a), s = Math.floor(s), u = Math.floor(u);
    const v = [], y = [], _ = [], b = [];
    let M = 0, C = 0;
    D("z", "y", "x", -1, -1, r, t, e, u, s, 0), D("z", "y", "x", 1, -1, r, t, -e, u, s, 1), D("x", "z", "y", 1, 1, e, r, t, a, u, 2), D("x", "z", "y", 1, -1, e, r, -t, a, u, 3), D("x", "y", "z", 1, -1, e, t, r, a, s, 4), D("x", "y", "z", -1, -1, e, t, -r, a, s, 5), this.setIndex(v), this.setAttribute("position", new nr(y, 3)), this.setAttribute("normal", new nr(_, 3)), this.setAttribute("uv", new nr(b, 2));
    function D(U, N, O, I, k, G, j, Y, Z, te, J) {
      const q = G / Z, oe = j / te, ye = G / 2, de = j / 2, xe = Y / 2, Re = Z + 1, Pe = te + 1;
      let Te = 0, ue = 0;
      const we = new be();
      for (let X = 0; X < Pe; X++) {
        const me = X * oe - de;
        for (let ce = 0; ce < Re; ce++) {
          const Ue = ce * q - ye;
          we[U] = Ue * I, we[N] = me * k, we[O] = xe, y.push(we.x, we.y, we.z), we[U] = 0, we[N] = 0, we[O] = Y > 0 ? 1 : -1, _.push(we.x, we.y, we.z), b.push(ce / Z), b.push(1 - X / te), Te += 1;
        }
      }
      for (let X = 0; X < te; X++)
        for (let me = 0; me < Z; me++) {
          const ce = M + me + Re * X, Ue = M + me + Re * (X + 1), Oe = M + (me + 1) + Re * (X + 1), Ze = M + (me + 1) + Re * X;
          v.push(ce, Ue, Ze), v.push(Ue, Oe, Ze), ue += 6;
        }
      h.addGroup(C, ue, J), C += ue, M += Te;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new _0(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function kE(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const r in n[t]) {
      const a = n[t][r];
      a && (a.isColor || a.isMatrix3 || a.isMatrix4 || a.isVector2 || a.isVector3 || a.isVector4 || a.isTexture || a.isQuaternion) ? a.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][r] = null) : e[t][r] = a.clone() : Array.isArray(a) ? e[t][r] = a.slice() : e[t][r] = a;
    }
  }
  return e;
}
function xf(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = kE(n[t]);
    for (const a in r)
      e[a] = r[a];
  }
  return e;
}
function L8(n) {
  const e = [];
  for (let t = 0; t < n.length; t++)
    e.push(n[t].clone());
  return e;
}
function LF(n) {
  return n.getRenderTarget() === null ? n.outputColorSpace : nm;
}
const OF = { clone: kE, merge: xf };
var O8 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, P8 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class _v extends Ku {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = O8, this.fragmentShader = P8, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1
      // set to use shader texture LOD
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = kE(e.uniforms), this.uniformsGroups = L8(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const a in this.uniforms) {
      const u = this.uniforms[a].value;
      u && u.isTexture ? t.uniforms[a] = {
        type: "t",
        value: u.toJSON(e).uuid
      } : u && u.isColor ? t.uniforms[a] = {
        type: "c",
        value: u.getHex()
      } : u && u.isVector2 ? t.uniforms[a] = {
        type: "v2",
        value: u.toArray()
      } : u && u.isVector3 ? t.uniforms[a] = {
        type: "v3",
        value: u.toArray()
      } : u && u.isVector4 ? t.uniforms[a] = {
        type: "v4",
        value: u.toArray()
      } : u && u.isMatrix3 ? t.uniforms[a] = {
        type: "m3",
        value: u.toArray()
      } : u && u.isMatrix4 ? t.uniforms[a] = {
        type: "m4",
        value: u.toArray()
      } : t.uniforms[a] = {
        value: u
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const r = {};
    for (const a in this.extensions)
      this.extensions[a] === !0 && (r[a] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class qT extends ha {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ei(), this.projectionMatrix = new ei(), this.projectionMatrixInverse = new ei(), this.coordinateSystem = gv;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Cs extends qT {
  constructor(e = 50, t = 1, r = 0.1, a = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = a, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = zE * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(nx * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return zE * 2 * Math.atan(
      Math.tan(nx * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, r, a, s, u) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = a, this.view.width = s, this.view.height = u, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(nx * 0.5 * this.fov) / this.zoom, r = 2 * t, a = this.aspect * r, s = -0.5 * a;
    const u = this.view;
    if (this.view !== null && this.view.enabled) {
      const v = u.fullWidth, y = u.fullHeight;
      s += u.offsetX * a / v, t -= u.offsetY * r / y, a *= u.width / v, r *= u.height / y;
    }
    const h = this.filmOffset;
    h !== 0 && (s += e * h / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + a, t, t - r, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const uE = -90, cE = 1;
class PF extends ha {
  constructor(e, t, r) {
    super(), this.type = "CubeCamera", this.renderTarget = r, this.coordinateSystem = null;
    const a = new Cs(uE, cE, e, t);
    a.layers = this.layers, this.add(a);
    const s = new Cs(uE, cE, e, t);
    s.layers = this.layers, this.add(s);
    const u = new Cs(uE, cE, e, t);
    u.layers = this.layers, this.add(u);
    const h = new Cs(uE, cE, e, t);
    h.layers = this.layers, this.add(h);
    const v = new Cs(uE, cE, e, t);
    v.layers = this.layers, this.add(v);
    const y = new Cs(uE, cE, e, t);
    y.layers = this.layers, this.add(y);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [r, a, s, u, h, v] = t;
    for (const y of t)
      this.remove(y);
    if (e === gv)
      r.up.set(0, 1, 0), r.lookAt(1, 0, 0), a.up.set(0, 1, 0), a.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), u.up.set(0, 0, 1), u.lookAt(0, -1, 0), h.up.set(0, 1, 0), h.lookAt(0, 0, 1), v.up.set(0, 1, 0), v.lookAt(0, 0, -1);
    else if (e === LT)
      r.up.set(0, -1, 0), r.lookAt(-1, 0, 0), a.up.set(0, -1, 0), a.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), u.up.set(0, 0, -1), u.lookAt(0, -1, 0), h.up.set(0, -1, 0), h.lookAt(0, 0, 1), v.up.set(0, -1, 0), v.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const y of t)
      this.add(y), y.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const r = this.renderTarget;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [a, s, u, h, v, y] = this.children, _ = e.getRenderTarget(), b = e.toneMapping, M = e.xr.enabled;
    e.toneMapping = em, e.xr.enabled = !1;
    const C = r.texture.generateMipmaps;
    r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(t, a), e.setRenderTarget(r, 1), e.render(t, s), e.setRenderTarget(r, 2), e.render(t, u), e.setRenderTarget(r, 3), e.render(t, h), e.setRenderTarget(r, 4), e.render(t, v), r.texture.generateMipmaps = C, e.setRenderTarget(r, 5), e.render(t, y), e.setRenderTarget(_), e.toneMapping = b, e.xr.enabled = M, r.texture.needsPMREMUpdate = !0;
  }
}
class KT extends Rs {
  constructor(e, t, r, a, s, u, h, v, y, _) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : f0, super(e, t, r, a, s, u, h, v, y, _), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class NF extends rm {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const r = { width: e, height: e, depth: 1 }, a = [r, r, r, r, r, r];
    t.encoding !== void 0 && (gT("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === u0 ? ai : c0), this.texture = new KT(a, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : tl;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const r = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, a = new _0(5, 5, 5), s = new _v({
      name: "CubemapFromEquirect",
      uniforms: kE(r.uniforms),
      vertexShader: r.vertexShader,
      fragmentShader: r.fragmentShader,
      side: bf,
      blending: kg
    });
    s.uniforms.tEquirect.value = t;
    const u = new qu(a, s), h = t.minFilter;
    return t.minFilter === h0 && (t.minFilter = tl), new PF(1, 10, this).update(e, u), t.minFilter = h, u.geometry.dispose(), u.material.dispose(), this;
  }
  clear(e, t, r, a) {
    const s = e.getRenderTarget();
    for (let u = 0; u < 6; u++)
      e.setRenderTarget(this, u), e.clear(t, r, a);
    e.setRenderTarget(s);
  }
}
const _2 = /* @__PURE__ */ new be(), N8 = /* @__PURE__ */ new be(), U8 = /* @__PURE__ */ new vi();
class pv {
  constructor(e = new be(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, r, a) {
    return this.normal.set(e, t, r), this.constant = a, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const a = _2.subVectors(r, t).cross(N8.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(a, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const r = e.delta(_2), a = this.normal.dot(r);
    if (a === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / a;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(r, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
    return t < 0 && r > 0 || r < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || U8.getNormalMatrix(e), a = this.coplanarPoint(_2).applyMatrix4(e), s = this.normal.applyMatrix3(r).normalize();
    return this.constant = -a.dot(s), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const FS = /* @__PURE__ */ new sm(), TC = /* @__PURE__ */ new be();
class GR {
  constructor(e = new pv(), t = new pv(), r = new pv(), a = new pv(), s = new pv(), u = new pv()) {
    this.planes = [e, t, r, a, s, u];
  }
  set(e, t, r, a, s, u) {
    const h = this.planes;
    return h[0].copy(e), h[1].copy(t), h[2].copy(r), h[3].copy(a), h[4].copy(s), h[5].copy(u), this;
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++)
      t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, t = gv) {
    const r = this.planes, a = e.elements, s = a[0], u = a[1], h = a[2], v = a[3], y = a[4], _ = a[5], b = a[6], M = a[7], C = a[8], D = a[9], U = a[10], N = a[11], O = a[12], I = a[13], k = a[14], G = a[15];
    if (r[0].setComponents(v - s, M - y, N - C, G - O).normalize(), r[1].setComponents(v + s, M + y, N + C, G + O).normalize(), r[2].setComponents(v + u, M + _, N + D, G + I).normalize(), r[3].setComponents(v - u, M - _, N - D, G - I).normalize(), r[4].setComponents(v - h, M - b, N - U, G - k).normalize(), t === gv)
      r[5].setComponents(v + h, M + b, N + U, G + k).normalize();
    else if (t === LT)
      r[5].setComponents(h, b, U, k).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), FS.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), FS.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(FS);
  }
  intersectsSprite(e) {
    return FS.center.set(0, 0, 0), FS.radius = 0.7071067811865476, FS.applyMatrix4(e.matrixWorld), this.intersectsSphere(FS);
  }
  intersectsSphere(e) {
    const t = this.planes, r = e.center, a = -e.radius;
    for (let s = 0; s < 6; s++)
      if (t[s].distanceToPoint(r) < a)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const a = t[r];
      if (TC.x = a.normal.x > 0 ? e.max.x : e.min.x, TC.y = a.normal.y > 0 ? e.max.y : e.min.y, TC.z = a.normal.z > 0 ? e.max.z : e.min.z, a.distanceToPoint(TC) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function UF() {
  let n = null, e = !1, t = null, r = null;
  function a(s, u) {
    t(s, u), r = n.requestAnimationFrame(a);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (r = n.requestAnimationFrame(a), e = !0);
    },
    stop: function() {
      n.cancelAnimationFrame(r), e = !1;
    },
    setAnimationLoop: function(s) {
      t = s;
    },
    setContext: function(s) {
      n = s;
    }
  };
}
function z8(n, e) {
  const t = e.isWebGL2, r = /* @__PURE__ */ new WeakMap();
  function a(y, _) {
    const b = y.array, M = y.usage, C = n.createBuffer();
    n.bindBuffer(_, C), n.bufferData(_, b, M), y.onUploadCallback();
    let D;
    if (b instanceof Float32Array)
      D = n.FLOAT;
    else if (b instanceof Uint16Array)
      if (y.isFloat16BufferAttribute)
        if (t)
          D = n.HALF_FLOAT;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        D = n.UNSIGNED_SHORT;
    else if (b instanceof Int16Array)
      D = n.SHORT;
    else if (b instanceof Uint32Array)
      D = n.UNSIGNED_INT;
    else if (b instanceof Int32Array)
      D = n.INT;
    else if (b instanceof Int8Array)
      D = n.BYTE;
    else if (b instanceof Uint8Array)
      D = n.UNSIGNED_BYTE;
    else if (b instanceof Uint8ClampedArray)
      D = n.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + b);
    return {
      buffer: C,
      type: D,
      bytesPerElement: b.BYTES_PER_ELEMENT,
      version: y.version
    };
  }
  function s(y, _, b) {
    const M = _.array, C = _.updateRange;
    n.bindBuffer(b, y), C.count === -1 ? n.bufferSubData(b, 0, M) : (t ? n.bufferSubData(
      b,
      C.offset * M.BYTES_PER_ELEMENT,
      M,
      C.offset,
      C.count
    ) : n.bufferSubData(
      b,
      C.offset * M.BYTES_PER_ELEMENT,
      M.subarray(C.offset, C.offset + C.count)
    ), C.count = -1), _.onUploadCallback();
  }
  function u(y) {
    return y.isInterleavedBufferAttribute && (y = y.data), r.get(y);
  }
  function h(y) {
    y.isInterleavedBufferAttribute && (y = y.data);
    const _ = r.get(y);
    _ && (n.deleteBuffer(_.buffer), r.delete(y));
  }
  function v(y, _) {
    if (y.isGLBufferAttribute) {
      const M = r.get(y);
      (!M || M.version < y.version) && r.set(y, {
        buffer: y.buffer,
        type: y.type,
        bytesPerElement: y.elementSize,
        version: y.version
      });
      return;
    }
    y.isInterleavedBufferAttribute && (y = y.data);
    const b = r.get(y);
    b === void 0 ? r.set(y, a(y, _)) : b.version < y.version && (s(b.buffer, y, _), b.version = y.version);
  }
  return {
    get: u,
    remove: h,
    update: v
  };
}
class jE extends yi {
  constructor(e = 1, t = 1, r = 1, a = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: r,
      heightSegments: a
    };
    const s = e / 2, u = t / 2, h = Math.floor(r), v = Math.floor(a), y = h + 1, _ = v + 1, b = e / h, M = t / v, C = [], D = [], U = [], N = [];
    for (let O = 0; O < _; O++) {
      const I = O * M - u;
      for (let k = 0; k < y; k++) {
        const G = k * b - s;
        D.push(G, -I, 0), U.push(0, 0, 1), N.push(k / h), N.push(1 - O / v);
      }
    }
    for (let O = 0; O < v; O++)
      for (let I = 0; I < h; I++) {
        const k = I + y * O, G = I + y * (O + 1), j = I + 1 + y * (O + 1), Y = I + 1 + y * O;
        C.push(k, G, Y), C.push(G, j, Y);
      }
    this.setIndex(C), this.setAttribute("position", new nr(D, 3)), this.setAttribute("normal", new nr(U, 3)), this.setAttribute("uv", new nr(N, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new jE(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var k8 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, I8 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, F8 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, B8 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, H8 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, V8 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, G8 = "vec3 transformed = vec3( position );", W8 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, j8 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, $8 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Y8 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, X8 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, q8 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, K8 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Q8 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Z8 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, J8 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, eW = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, tW = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, nW = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, rW = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, iW = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, aW = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, oW = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, sW = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, lW = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, uW = "gl_FragColor = linearToOutputTexel( gl_FragColor );", cW = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, fW = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, dW = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, hW = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, pW = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, mW = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, vW = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, gW = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, yW = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, SW = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, xW = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, _W = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, EW = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, bW = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, TW = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, MW = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, wW = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, CW = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, RW = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, AW = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, DW = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, LW = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`, OW = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, PW = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, NW = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, UW = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, zW = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, kW = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, IW = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, FW = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, BW = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`, HW = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, VW = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, GW = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, WW = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, jW = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, $W = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, YW = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, XW = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, qW = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, KW = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`, QW = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, ZW = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, JW = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, ej = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, tj = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, nj = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, rj = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, ij = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, aj = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, oj = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, sj = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, lj = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, uj = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, cj = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, fj = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, dj = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, hj = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, pj = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, mj = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, vj = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, gj = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, yj = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Sj = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, xj = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, _j = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Ej = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, bj = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Tj = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Mj = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, wj = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, Cj = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Rj = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Aj = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Dj = `#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Lj = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Oj = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, Pj = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, Nj = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Uj = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, zj = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, kj = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, Ij = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Fj = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, Bj = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Hj = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, Vj = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Gj = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, Wj = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, jj = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, $j = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Yj = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Xj = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, qj = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Kj = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, Qj = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Zj = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, Jj = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, e9 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, t9 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, n9 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, r9 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, i9 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, a9 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, o9 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, s9 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, l9 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, u9 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, c9 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, f9 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, mi = {
  alphamap_fragment: k8,
  alphamap_pars_fragment: I8,
  alphatest_fragment: F8,
  alphatest_pars_fragment: B8,
  aomap_fragment: H8,
  aomap_pars_fragment: V8,
  begin_vertex: G8,
  beginnormal_vertex: W8,
  bsdfs: j8,
  iridescence_fragment: $8,
  bumpmap_pars_fragment: Y8,
  clipping_planes_fragment: X8,
  clipping_planes_pars_fragment: q8,
  clipping_planes_pars_vertex: K8,
  clipping_planes_vertex: Q8,
  color_fragment: Z8,
  color_pars_fragment: J8,
  color_pars_vertex: eW,
  color_vertex: tW,
  common: nW,
  cube_uv_reflection_fragment: rW,
  defaultnormal_vertex: iW,
  displacementmap_pars_vertex: aW,
  displacementmap_vertex: oW,
  emissivemap_fragment: sW,
  emissivemap_pars_fragment: lW,
  encodings_fragment: uW,
  encodings_pars_fragment: cW,
  envmap_fragment: fW,
  envmap_common_pars_fragment: dW,
  envmap_pars_fragment: hW,
  envmap_pars_vertex: pW,
  envmap_physical_pars_fragment: wW,
  envmap_vertex: mW,
  fog_vertex: vW,
  fog_pars_vertex: gW,
  fog_fragment: yW,
  fog_pars_fragment: SW,
  gradientmap_pars_fragment: xW,
  lightmap_fragment: _W,
  lightmap_pars_fragment: EW,
  lights_lambert_fragment: bW,
  lights_lambert_pars_fragment: TW,
  lights_pars_begin: MW,
  lights_toon_fragment: CW,
  lights_toon_pars_fragment: RW,
  lights_phong_fragment: AW,
  lights_phong_pars_fragment: DW,
  lights_physical_fragment: LW,
  lights_physical_pars_fragment: OW,
  lights_fragment_begin: PW,
  lights_fragment_maps: NW,
  lights_fragment_end: UW,
  logdepthbuf_fragment: zW,
  logdepthbuf_pars_fragment: kW,
  logdepthbuf_pars_vertex: IW,
  logdepthbuf_vertex: FW,
  map_fragment: BW,
  map_pars_fragment: HW,
  map_particle_fragment: VW,
  map_particle_pars_fragment: GW,
  metalnessmap_fragment: WW,
  metalnessmap_pars_fragment: jW,
  morphcolor_vertex: $W,
  morphnormal_vertex: YW,
  morphtarget_pars_vertex: XW,
  morphtarget_vertex: qW,
  normal_fragment_begin: KW,
  normal_fragment_maps: QW,
  normal_pars_fragment: ZW,
  normal_pars_vertex: JW,
  normal_vertex: ej,
  normalmap_pars_fragment: tj,
  clearcoat_normal_fragment_begin: nj,
  clearcoat_normal_fragment_maps: rj,
  clearcoat_pars_fragment: ij,
  iridescence_pars_fragment: aj,
  output_fragment: oj,
  packing: sj,
  premultiplied_alpha_fragment: lj,
  project_vertex: uj,
  dithering_fragment: cj,
  dithering_pars_fragment: fj,
  roughnessmap_fragment: dj,
  roughnessmap_pars_fragment: hj,
  shadowmap_pars_fragment: pj,
  shadowmap_pars_vertex: mj,
  shadowmap_vertex: vj,
  shadowmask_pars_fragment: gj,
  skinbase_vertex: yj,
  skinning_pars_vertex: Sj,
  skinning_vertex: xj,
  skinnormal_vertex: _j,
  specularmap_fragment: Ej,
  specularmap_pars_fragment: bj,
  tonemapping_fragment: Tj,
  tonemapping_pars_fragment: Mj,
  transmission_fragment: wj,
  transmission_pars_fragment: Cj,
  uv_pars_fragment: Rj,
  uv_pars_vertex: Aj,
  uv_vertex: Dj,
  worldpos_vertex: Lj,
  background_vert: Oj,
  background_frag: Pj,
  backgroundCube_vert: Nj,
  backgroundCube_frag: Uj,
  cube_vert: zj,
  cube_frag: kj,
  depth_vert: Ij,
  depth_frag: Fj,
  distanceRGBA_vert: Bj,
  distanceRGBA_frag: Hj,
  equirect_vert: Vj,
  equirect_frag: Gj,
  linedashed_vert: Wj,
  linedashed_frag: jj,
  meshbasic_vert: $j,
  meshbasic_frag: Yj,
  meshlambert_vert: Xj,
  meshlambert_frag: qj,
  meshmatcap_vert: Kj,
  meshmatcap_frag: Qj,
  meshnormal_vert: Zj,
  meshnormal_frag: Jj,
  meshphong_vert: e9,
  meshphong_frag: t9,
  meshphysical_vert: n9,
  meshphysical_frag: r9,
  meshtoon_vert: i9,
  meshtoon_frag: a9,
  points_vert: o9,
  points_frag: s9,
  shadow_vert: l9,
  shadow_frag: u9,
  sprite_vert: c9,
  sprite_frag: f9
}, bn = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Un(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new vi() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new vi() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new vi() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new vi() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new vi() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new vi() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new vi() },
    normalScale: { value: /* @__PURE__ */ new It(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new vi() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new vi() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new vi() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new vi() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Un(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Un(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new vi() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new vi() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Un(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new It(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new vi() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new vi() },
    alphaTest: { value: 0 }
  }
}, Jp = {
  basic: {
    uniforms: /* @__PURE__ */ xf([
      bn.common,
      bn.specularmap,
      bn.envmap,
      bn.aomap,
      bn.lightmap,
      bn.fog
    ]),
    vertexShader: mi.meshbasic_vert,
    fragmentShader: mi.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ xf([
      bn.common,
      bn.specularmap,
      bn.envmap,
      bn.aomap,
      bn.lightmap,
      bn.emissivemap,
      bn.bumpmap,
      bn.normalmap,
      bn.displacementmap,
      bn.fog,
      bn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Un(0) }
      }
    ]),
    vertexShader: mi.meshlambert_vert,
    fragmentShader: mi.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ xf([
      bn.common,
      bn.specularmap,
      bn.envmap,
      bn.aomap,
      bn.lightmap,
      bn.emissivemap,
      bn.bumpmap,
      bn.normalmap,
      bn.displacementmap,
      bn.fog,
      bn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Un(0) },
        specular: { value: /* @__PURE__ */ new Un(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: mi.meshphong_vert,
    fragmentShader: mi.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ xf([
      bn.common,
      bn.envmap,
      bn.aomap,
      bn.lightmap,
      bn.emissivemap,
      bn.bumpmap,
      bn.normalmap,
      bn.displacementmap,
      bn.roughnessmap,
      bn.metalnessmap,
      bn.fog,
      bn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Un(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: mi.meshphysical_vert,
    fragmentShader: mi.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ xf([
      bn.common,
      bn.aomap,
      bn.lightmap,
      bn.emissivemap,
      bn.bumpmap,
      bn.normalmap,
      bn.displacementmap,
      bn.gradientmap,
      bn.fog,
      bn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Un(0) }
      }
    ]),
    vertexShader: mi.meshtoon_vert,
    fragmentShader: mi.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ xf([
      bn.common,
      bn.bumpmap,
      bn.normalmap,
      bn.displacementmap,
      bn.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: mi.meshmatcap_vert,
    fragmentShader: mi.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ xf([
      bn.points,
      bn.fog
    ]),
    vertexShader: mi.points_vert,
    fragmentShader: mi.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ xf([
      bn.common,
      bn.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: mi.linedashed_vert,
    fragmentShader: mi.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ xf([
      bn.common,
      bn.displacementmap
    ]),
    vertexShader: mi.depth_vert,
    fragmentShader: mi.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ xf([
      bn.common,
      bn.bumpmap,
      bn.normalmap,
      bn.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: mi.meshnormal_vert,
    fragmentShader: mi.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ xf([
      bn.sprite,
      bn.fog
    ]),
    vertexShader: mi.sprite_vert,
    fragmentShader: mi.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new vi() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: mi.background_vert,
    fragmentShader: mi.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: mi.backgroundCube_vert,
    fragmentShader: mi.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: mi.cube_vert,
    fragmentShader: mi.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: mi.equirect_vert,
    fragmentShader: mi.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ xf([
      bn.common,
      bn.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new be() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: mi.distanceRGBA_vert,
    fragmentShader: mi.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ xf([
      bn.lights,
      bn.fog,
      {
        color: { value: /* @__PURE__ */ new Un(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: mi.shadow_vert,
    fragmentShader: mi.shadow_frag
  }
};
Jp.physical = {
  uniforms: /* @__PURE__ */ xf([
    Jp.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new vi() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new vi() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new It(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new vi() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new vi() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new vi() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Un(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new vi() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new vi() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new vi() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new It() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new vi() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Un(0) },
      specularColor: { value: /* @__PURE__ */ new Un(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new vi() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new vi() },
      anisotropyVector: { value: /* @__PURE__ */ new It() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new vi() }
    }
  ]),
  vertexShader: mi.meshphysical_vert,
  fragmentShader: mi.meshphysical_frag
};
const MC = { r: 0, b: 0, g: 0 };
function d9(n, e, t, r, a, s, u) {
  const h = new Un(0);
  let v = s === !0 ? 0 : 1, y, _, b = null, M = 0, C = null;
  function D(N, O) {
    let I = !1, k = O.isScene === !0 ? O.background : null;
    switch (k && k.isTexture && (k = (O.backgroundBlurriness > 0 ? t : e).get(k)), k === null ? U(h, v) : k && k.isColor && (U(k, 1), I = !0), n.xr.getEnvironmentBlendMode()) {
      case "opaque":
        I = !0;
        break;
      case "additive":
        r.buffers.color.setClear(0, 0, 0, 1, u), I = !0;
        break;
      case "alpha-blend":
        r.buffers.color.setClear(0, 0, 0, 0, u), I = !0;
        break;
    }
    (n.autoClear || I) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), k && (k.isCubeTexture || k.mapping === WE) ? (_ === void 0 && (_ = new qu(
      new _0(1, 1, 1),
      new _v({
        name: "BackgroundCubeMaterial",
        uniforms: kE(Jp.backgroundCube.uniforms),
        vertexShader: Jp.backgroundCube.vertexShader,
        fragmentShader: Jp.backgroundCube.fragmentShader,
        side: bf,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), _.geometry.deleteAttribute("normal"), _.geometry.deleteAttribute("uv"), _.onBeforeRender = function(Y, Z, te) {
      this.matrixWorld.copyPosition(te.matrixWorld);
    }, Object.defineProperty(_.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), a.update(_)), _.material.uniforms.envMap.value = k, _.material.uniforms.flipEnvMap.value = k.isCubeTexture && k.isRenderTargetTexture === !1 ? -1 : 1, _.material.uniforms.backgroundBlurriness.value = O.backgroundBlurriness, _.material.uniforms.backgroundIntensity.value = O.backgroundIntensity, _.material.toneMapped = k.colorSpace !== ai, (b !== k || M !== k.version || C !== n.toneMapping) && (_.material.needsUpdate = !0, b = k, M = k.version, C = n.toneMapping), _.layers.enableAll(), N.unshift(_, _.geometry, _.material, 0, 0, null)) : k && k.isTexture && (y === void 0 && (y = new qu(
      new jE(2, 2),
      new _v({
        name: "BackgroundMaterial",
        uniforms: kE(Jp.background.uniforms),
        vertexShader: Jp.background.vertexShader,
        fragmentShader: Jp.background.fragmentShader,
        side: Fg,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), y.geometry.deleteAttribute("normal"), Object.defineProperty(y.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), a.update(y)), y.material.uniforms.t2D.value = k, y.material.uniforms.backgroundIntensity.value = O.backgroundIntensity, y.material.toneMapped = k.colorSpace !== ai, k.matrixAutoUpdate === !0 && k.updateMatrix(), y.material.uniforms.uvTransform.value.copy(k.matrix), (b !== k || M !== k.version || C !== n.toneMapping) && (y.material.needsUpdate = !0, b = k, M = k.version, C = n.toneMapping), y.layers.enableAll(), N.unshift(y, y.geometry, y.material, 0, 0, null));
  }
  function U(N, O) {
    N.getRGB(MC, LF(n)), r.buffers.color.setClear(MC.r, MC.g, MC.b, O, u);
  }
  return {
    getClearColor: function() {
      return h;
    },
    setClearColor: function(N, O = 1) {
      h.set(N), v = O, U(h, v);
    },
    getClearAlpha: function() {
      return v;
    },
    setClearAlpha: function(N) {
      v = N, U(h, v);
    },
    render: D
  };
}
function h9(n, e, t, r) {
  const a = n.getParameter(n.MAX_VERTEX_ATTRIBS), s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"), u = r.isWebGL2 || s !== null, h = {}, v = N(null);
  let y = v, _ = !1;
  function b(xe, Re, Pe, Te, ue) {
    let we = !1;
    if (u) {
      const X = U(Te, Pe, Re);
      y !== X && (y = X, C(y.object)), we = O(xe, Te, Pe, ue), we && I(xe, Te, Pe, ue);
    } else {
      const X = Re.wireframe === !0;
      (y.geometry !== Te.id || y.program !== Pe.id || y.wireframe !== X) && (y.geometry = Te.id, y.program = Pe.id, y.wireframe = X, we = !0);
    }
    ue !== null && t.update(ue, n.ELEMENT_ARRAY_BUFFER), (we || _) && (_ = !1, te(xe, Re, Pe, Te), ue !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(ue).buffer));
  }
  function M() {
    return r.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function C(xe) {
    return r.isWebGL2 ? n.bindVertexArray(xe) : s.bindVertexArrayOES(xe);
  }
  function D(xe) {
    return r.isWebGL2 ? n.deleteVertexArray(xe) : s.deleteVertexArrayOES(xe);
  }
  function U(xe, Re, Pe) {
    const Te = Pe.wireframe === !0;
    let ue = h[xe.id];
    ue === void 0 && (ue = {}, h[xe.id] = ue);
    let we = ue[Re.id];
    we === void 0 && (we = {}, ue[Re.id] = we);
    let X = we[Te];
    return X === void 0 && (X = N(M()), we[Te] = X), X;
  }
  function N(xe) {
    const Re = [], Pe = [], Te = [];
    for (let ue = 0; ue < a; ue++)
      Re[ue] = 0, Pe[ue] = 0, Te[ue] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Re,
      enabledAttributes: Pe,
      attributeDivisors: Te,
      object: xe,
      attributes: {},
      index: null
    };
  }
  function O(xe, Re, Pe, Te) {
    const ue = y.attributes, we = Re.attributes;
    let X = 0;
    const me = Pe.getAttributes();
    for (const ce in me)
      if (me[ce].location >= 0) {
        const Oe = ue[ce];
        let Ze = we[ce];
        if (Ze === void 0 && (ce === "instanceMatrix" && xe.instanceMatrix && (Ze = xe.instanceMatrix), ce === "instanceColor" && xe.instanceColor && (Ze = xe.instanceColor)), Oe === void 0 || Oe.attribute !== Ze || Ze && Oe.data !== Ze.data)
          return !0;
        X++;
      }
    return y.attributesNum !== X || y.index !== Te;
  }
  function I(xe, Re, Pe, Te) {
    const ue = {}, we = Re.attributes;
    let X = 0;
    const me = Pe.getAttributes();
    for (const ce in me)
      if (me[ce].location >= 0) {
        let Oe = we[ce];
        Oe === void 0 && (ce === "instanceMatrix" && xe.instanceMatrix && (Oe = xe.instanceMatrix), ce === "instanceColor" && xe.instanceColor && (Oe = xe.instanceColor));
        const Ze = {};
        Ze.attribute = Oe, Oe && Oe.data && (Ze.data = Oe.data), ue[ce] = Ze, X++;
      }
    y.attributes = ue, y.attributesNum = X, y.index = Te;
  }
  function k() {
    const xe = y.newAttributes;
    for (let Re = 0, Pe = xe.length; Re < Pe; Re++)
      xe[Re] = 0;
  }
  function G(xe) {
    j(xe, 0);
  }
  function j(xe, Re) {
    const Pe = y.newAttributes, Te = y.enabledAttributes, ue = y.attributeDivisors;
    Pe[xe] = 1, Te[xe] === 0 && (n.enableVertexAttribArray(xe), Te[xe] = 1), ue[xe] !== Re && ((r.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](xe, Re), ue[xe] = Re);
  }
  function Y() {
    const xe = y.newAttributes, Re = y.enabledAttributes;
    for (let Pe = 0, Te = Re.length; Pe < Te; Pe++)
      Re[Pe] !== xe[Pe] && (n.disableVertexAttribArray(Pe), Re[Pe] = 0);
  }
  function Z(xe, Re, Pe, Te, ue, we, X) {
    X === !0 ? n.vertexAttribIPointer(xe, Re, Pe, ue, we) : n.vertexAttribPointer(xe, Re, Pe, Te, ue, we);
  }
  function te(xe, Re, Pe, Te) {
    if (r.isWebGL2 === !1 && (xe.isInstancedMesh || Te.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    k();
    const ue = Te.attributes, we = Pe.getAttributes(), X = Re.defaultAttributeValues;
    for (const me in we) {
      const ce = we[me];
      if (ce.location >= 0) {
        let Ue = ue[me];
        if (Ue === void 0 && (me === "instanceMatrix" && xe.instanceMatrix && (Ue = xe.instanceMatrix), me === "instanceColor" && xe.instanceColor && (Ue = xe.instanceColor)), Ue !== void 0) {
          const Oe = Ue.normalized, Ze = Ue.itemSize, je = t.get(Ue);
          if (je === void 0)
            continue;
          const Je = je.buffer, at = je.type, xt = je.bytesPerElement, $t = r.isWebGL2 === !0 && (at === n.INT || at === n.UNSIGNED_INT || Ue.gpuType === BO);
          if (Ue.isInterleavedBufferAttribute) {
            const Ht = Ue.data, he = Ht.stride, nt = Ue.offset;
            if (Ht.isInstancedInterleavedBuffer) {
              for (let et = 0; et < ce.locationSize; et++)
                j(ce.location + et, Ht.meshPerAttribute);
              xe.isInstancedMesh !== !0 && Te._maxInstanceCount === void 0 && (Te._maxInstanceCount = Ht.meshPerAttribute * Ht.count);
            } else
              for (let et = 0; et < ce.locationSize; et++)
                G(ce.location + et);
            n.bindBuffer(n.ARRAY_BUFFER, Je);
            for (let et = 0; et < ce.locationSize; et++)
              Z(
                ce.location + et,
                Ze / ce.locationSize,
                at,
                Oe,
                he * xt,
                (nt + Ze / ce.locationSize * et) * xt,
                $t
              );
          } else {
            if (Ue.isInstancedBufferAttribute) {
              for (let Ht = 0; Ht < ce.locationSize; Ht++)
                j(ce.location + Ht, Ue.meshPerAttribute);
              xe.isInstancedMesh !== !0 && Te._maxInstanceCount === void 0 && (Te._maxInstanceCount = Ue.meshPerAttribute * Ue.count);
            } else
              for (let Ht = 0; Ht < ce.locationSize; Ht++)
                G(ce.location + Ht);
            n.bindBuffer(n.ARRAY_BUFFER, Je);
            for (let Ht = 0; Ht < ce.locationSize; Ht++)
              Z(
                ce.location + Ht,
                Ze / ce.locationSize,
                at,
                Oe,
                Ze * xt,
                Ze / ce.locationSize * Ht * xt,
                $t
              );
          }
        } else if (X !== void 0) {
          const Oe = X[me];
          if (Oe !== void 0)
            switch (Oe.length) {
              case 2:
                n.vertexAttrib2fv(ce.location, Oe);
                break;
              case 3:
                n.vertexAttrib3fv(ce.location, Oe);
                break;
              case 4:
                n.vertexAttrib4fv(ce.location, Oe);
                break;
              default:
                n.vertexAttrib1fv(ce.location, Oe);
            }
        }
      }
    }
    Y();
  }
  function J() {
    ye();
    for (const xe in h) {
      const Re = h[xe];
      for (const Pe in Re) {
        const Te = Re[Pe];
        for (const ue in Te)
          D(Te[ue].object), delete Te[ue];
        delete Re[Pe];
      }
      delete h[xe];
    }
  }
  function q(xe) {
    if (h[xe.id] === void 0)
      return;
    const Re = h[xe.id];
    for (const Pe in Re) {
      const Te = Re[Pe];
      for (const ue in Te)
        D(Te[ue].object), delete Te[ue];
      delete Re[Pe];
    }
    delete h[xe.id];
  }
  function oe(xe) {
    for (const Re in h) {
      const Pe = h[Re];
      if (Pe[xe.id] === void 0)
        continue;
      const Te = Pe[xe.id];
      for (const ue in Te)
        D(Te[ue].object), delete Te[ue];
      delete Pe[xe.id];
    }
  }
  function ye() {
    de(), _ = !0, y !== v && (y = v, C(y.object));
  }
  function de() {
    v.geometry = null, v.program = null, v.wireframe = !1;
  }
  return {
    setup: b,
    reset: ye,
    resetDefaultState: de,
    dispose: J,
    releaseStatesOfGeometry: q,
    releaseStatesOfProgram: oe,
    initAttributes: k,
    enableAttribute: G,
    disableUnusedAttributes: Y
  };
}
function p9(n, e, t, r) {
  const a = r.isWebGL2;
  let s;
  function u(y) {
    s = y;
  }
  function h(y, _) {
    n.drawArrays(s, y, _), t.update(_, s, 1);
  }
  function v(y, _, b) {
    if (b === 0)
      return;
    let M, C;
    if (a)
      M = n, C = "drawArraysInstanced";
    else if (M = e.get("ANGLE_instanced_arrays"), C = "drawArraysInstancedANGLE", M === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    M[C](s, y, _, b), t.update(_, s, b);
  }
  this.setMode = u, this.render = h, this.renderInstances = v;
}
function m9(n, e, t) {
  let r;
  function a() {
    if (r !== void 0)
      return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const Z = e.get("EXT_texture_filter_anisotropic");
      r = n.getParameter(Z.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      r = 0;
    return r;
  }
  function s(Z) {
    if (Z === "highp") {
      if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
        return "highp";
      Z = "mediump";
    }
    return Z === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const u = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext";
  let h = t.precision !== void 0 ? t.precision : "highp";
  const v = s(h);
  v !== h && (console.warn("THREE.WebGLRenderer:", h, "not supported, using", v, "instead."), h = v);
  const y = u || e.has("WEBGL_draw_buffers"), _ = t.logarithmicDepthBuffer === !0, b = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), M = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), C = n.getParameter(n.MAX_TEXTURE_SIZE), D = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), U = n.getParameter(n.MAX_VERTEX_ATTRIBS), N = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), O = n.getParameter(n.MAX_VARYING_VECTORS), I = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), k = M > 0, G = u || e.has("OES_texture_float"), j = k && G, Y = u ? n.getParameter(n.MAX_SAMPLES) : 0;
  return {
    isWebGL2: u,
    drawBuffers: y,
    getMaxAnisotropy: a,
    getMaxPrecision: s,
    precision: h,
    logarithmicDepthBuffer: _,
    maxTextures: b,
    maxVertexTextures: M,
    maxTextureSize: C,
    maxCubemapSize: D,
    maxAttributes: U,
    maxVertexUniforms: N,
    maxVaryings: O,
    maxFragmentUniforms: I,
    vertexTextures: k,
    floatFragmentTextures: G,
    floatVertexTextures: j,
    maxSamples: Y
  };
}
function v9(n) {
  const e = this;
  let t = null, r = 0, a = !1, s = !1;
  const u = new pv(), h = new vi(), v = { value: null, needsUpdate: !1 };
  this.uniform = v, this.numPlanes = 0, this.numIntersection = 0, this.init = function(b, M) {
    const C = b.length !== 0 || M || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    r !== 0 || a;
    return a = M, r = b.length, C;
  }, this.beginShadows = function() {
    s = !0, _(null);
  }, this.endShadows = function() {
    s = !1;
  }, this.setGlobalState = function(b, M) {
    t = _(b, M, 0);
  }, this.setState = function(b, M, C) {
    const D = b.clippingPlanes, U = b.clipIntersection, N = b.clipShadows, O = n.get(b);
    if (!a || D === null || D.length === 0 || s && !N)
      s ? _(null) : y();
    else {
      const I = s ? 0 : r, k = I * 4;
      let G = O.clippingState || null;
      v.value = G, G = _(D, M, k, C);
      for (let j = 0; j !== k; ++j)
        G[j] = t[j];
      O.clippingState = G, this.numIntersection = U ? this.numPlanes : 0, this.numPlanes += I;
    }
  };
  function y() {
    v.value !== t && (v.value = t, v.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0;
  }
  function _(b, M, C, D) {
    const U = b !== null ? b.length : 0;
    let N = null;
    if (U !== 0) {
      if (N = v.value, D !== !0 || N === null) {
        const O = C + U * 4, I = M.matrixWorldInverse;
        h.getNormalMatrix(I), (N === null || N.length < O) && (N = new Float32Array(O));
        for (let k = 0, G = C; k !== U; ++k, G += 4)
          u.copy(b[k]).applyMatrix4(I, h), u.normal.toArray(N, G), N[G + 3] = u.constant;
      }
      v.value = N, v.needsUpdate = !0;
    }
    return e.numPlanes = U, e.numIntersection = 0, N;
  }
}
function g9(n) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(u, h) {
    return h === bT ? u.mapping = f0 : h === TT && (u.mapping = d0), u;
  }
  function r(u) {
    if (u && u.isTexture && u.isRenderTargetTexture === !1) {
      const h = u.mapping;
      if (h === bT || h === TT)
        if (e.has(u)) {
          const v = e.get(u).texture;
          return t(v, u.mapping);
        } else {
          const v = u.image;
          if (v && v.height > 0) {
            const y = new NF(v.height / 2);
            return y.fromEquirectangularTexture(n, u), e.set(u, y), u.addEventListener("dispose", a), t(y.texture, u.mapping);
          } else
            return null;
        }
    }
    return u;
  }
  function a(u) {
    const h = u.target;
    h.removeEventListener("dispose", a);
    const v = e.get(h);
    v !== void 0 && (e.delete(h), v.dispose());
  }
  function s() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: s
  };
}
class zg extends qT {
  constructor(e = -1, t = 1, r = 1, a = -1, s = 0.1, u = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = r, this.bottom = a, this.near = s, this.far = u, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, r, a, s, u) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = a, this.view.width = s, this.view.height = u, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, a = (this.top + this.bottom) / 2;
    let s = r - e, u = r + e, h = a + t, v = a - t;
    if (this.view !== null && this.view.enabled) {
      const y = (this.right - this.left) / this.view.fullWidth / this.zoom, _ = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += y * this.view.offsetX, u = s + y * this.view.width, h -= _ * this.view.offsetY, v = h - _ * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, u, h, v, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const wE = 4, y3 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], qS = 20, E2 = /* @__PURE__ */ new zg(), S3 = /* @__PURE__ */ new Un();
let b2 = null;
const YS = (1 + Math.sqrt(5)) / 2, fE = 1 / YS, x3 = [
  /* @__PURE__ */ new be(1, 1, 1),
  /* @__PURE__ */ new be(-1, 1, 1),
  /* @__PURE__ */ new be(1, 1, -1),
  /* @__PURE__ */ new be(-1, 1, -1),
  /* @__PURE__ */ new be(0, YS, fE),
  /* @__PURE__ */ new be(0, YS, -fE),
  /* @__PURE__ */ new be(fE, 0, YS),
  /* @__PURE__ */ new be(-fE, 0, YS),
  /* @__PURE__ */ new be(YS, fE, 0),
  /* @__PURE__ */ new be(-YS, fE, 0)
];
class XL {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, r = 0.1, a = 100) {
    b2 = this._renderer.getRenderTarget(), this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(e, r, a, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = b3(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = E3(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(b2), e.scissorTest = !1, wC(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === f0 || e.mapping === d0 ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), b2 = this._renderer.getRenderTarget();
    const r = t || this._allocateTargets();
    return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, r = {
      magFilter: tl,
      minFilter: tl,
      generateMipmaps: !1,
      type: UE,
      format: dd,
      colorSpace: nm,
      depthBuffer: !1
    }, a = _3(e, t, r);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = _3(e, t, r);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = y9(s)), this._blurMaterial = S9(s, e, t);
    }
    return a;
  }
  _compileMaterial(e) {
    const t = new qu(this._lodPlanes[0], e);
    this._renderer.compile(t, E2);
  }
  _sceneToCubeUV(e, t, r, a) {
    const h = new Cs(90, 1, t, r), v = [1, -1, 1, 1, 1, 1], y = [1, 1, 1, -1, -1, -1], _ = this._renderer, b = _.autoClear, M = _.toneMapping;
    _.getClearColor(S3), _.toneMapping = em, _.autoClear = !1;
    const C = new x0({
      name: "PMREM.Background",
      side: bf,
      depthWrite: !1,
      depthTest: !1
    }), D = new qu(new _0(), C);
    let U = !1;
    const N = e.background;
    N ? N.isColor && (C.color.copy(N), e.background = null, U = !0) : (C.color.copy(S3), U = !0);
    for (let O = 0; O < 6; O++) {
      const I = O % 3;
      I === 0 ? (h.up.set(0, v[O], 0), h.lookAt(y[O], 0, 0)) : I === 1 ? (h.up.set(0, 0, v[O]), h.lookAt(0, y[O], 0)) : (h.up.set(0, v[O], 0), h.lookAt(0, 0, y[O]));
      const k = this._cubeSize;
      wC(a, I * k, O > 2 ? k : 0, k, k), _.setRenderTarget(a), U && _.render(D, h), _.render(e, h);
    }
    D.geometry.dispose(), D.material.dispose(), _.toneMapping = M, _.autoClear = b, e.background = N;
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer, a = e.mapping === f0 || e.mapping === d0;
    a ? (this._cubemapMaterial === null && (this._cubemapMaterial = b3()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = E3());
    const s = a ? this._cubemapMaterial : this._equirectMaterial, u = new qu(this._lodPlanes[0], s), h = s.uniforms;
    h.envMap.value = e;
    const v = this._cubeSize;
    wC(t, 0, 0, 3 * v, 2 * v), r.setRenderTarget(t), r.render(u, E2);
  }
  _applyPMREM(e) {
    const t = this._renderer, r = t.autoClear;
    t.autoClear = !1;
    for (let a = 1; a < this._lodPlanes.length; a++) {
      const s = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1]), u = x3[(a - 1) % x3.length];
      this._blur(e, a - 1, a, s, u);
    }
    t.autoClear = r;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, r, a, s) {
    const u = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      u,
      t,
      r,
      a,
      "latitudinal",
      s
    ), this._halfBlur(
      u,
      e,
      r,
      r,
      a,
      "longitudinal",
      s
    );
  }
  _halfBlur(e, t, r, a, s, u, h) {
    const v = this._renderer, y = this._blurMaterial;
    u !== "latitudinal" && u !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const _ = 3, b = new qu(this._lodPlanes[a], y), M = y.uniforms, C = this._sizeLods[r] - 1, D = isFinite(s) ? Math.PI / (2 * C) : 2 * Math.PI / (2 * qS - 1), U = s / D, N = isFinite(s) ? 1 + Math.floor(_ * U) : qS;
    N > qS && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${N} samples when the maximum is set to ${qS}`);
    const O = [];
    let I = 0;
    for (let Z = 0; Z < qS; ++Z) {
      const te = Z / U, J = Math.exp(-te * te / 2);
      O.push(J), Z === 0 ? I += J : Z < N && (I += 2 * J);
    }
    for (let Z = 0; Z < O.length; Z++)
      O[Z] = O[Z] / I;
    M.envMap.value = e.texture, M.samples.value = N, M.weights.value = O, M.latitudinal.value = u === "latitudinal", h && (M.poleAxis.value = h);
    const { _lodMax: k } = this;
    M.dTheta.value = D, M.mipInt.value = k - r;
    const G = this._sizeLods[a], j = 3 * G * (a > k - wE ? a - k + wE : 0), Y = 4 * (this._cubeSize - G);
    wC(t, j, Y, 3 * G, 2 * G), v.setRenderTarget(t), v.render(b, E2);
  }
}
function y9(n) {
  const e = [], t = [], r = [];
  let a = n;
  const s = n - wE + 1 + y3.length;
  for (let u = 0; u < s; u++) {
    const h = Math.pow(2, a);
    t.push(h);
    let v = 1 / h;
    u > n - wE ? v = y3[u - n + wE - 1] : u === 0 && (v = 0), r.push(v);
    const y = 1 / (h - 2), _ = -y, b = 1 + y, M = [_, _, b, _, b, b, _, _, b, b, _, b], C = 6, D = 6, U = 3, N = 2, O = 1, I = new Float32Array(U * D * C), k = new Float32Array(N * D * C), G = new Float32Array(O * D * C);
    for (let Y = 0; Y < C; Y++) {
      const Z = Y % 3 * 2 / 3 - 1, te = Y > 2 ? 0 : -1, J = [
        Z,
        te,
        0,
        Z + 2 / 3,
        te,
        0,
        Z + 2 / 3,
        te + 1,
        0,
        Z,
        te,
        0,
        Z + 2 / 3,
        te + 1,
        0,
        Z,
        te + 1,
        0
      ];
      I.set(J, U * D * Y), k.set(M, N * D * Y);
      const q = [Y, Y, Y, Y, Y, Y];
      G.set(q, O * D * Y);
    }
    const j = new yi();
    j.setAttribute("position", new so(I, U)), j.setAttribute("uv", new so(k, N)), j.setAttribute("faceIndex", new so(G, O)), e.push(j), a > wE && a--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function _3(n, e, t) {
  const r = new rm(n, e, t);
  return r.texture.mapping = WE, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r;
}
function wC(n, e, t, r, a) {
  n.viewport.set(e, t, r, a), n.scissor.set(e, t, r, a);
}
function S9(n, e, t) {
  const r = new Float32Array(qS), a = new be(0, 1, 0);
  return new _v({
    name: "SphericalGaussianBlur",
    defines: {
      n: qS,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: a }
    },
    vertexShader: eP(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: kg,
    depthTest: !1,
    depthWrite: !1
  });
}
function E3() {
  return new _v({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: eP(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: kg,
    depthTest: !1,
    depthWrite: !1
  });
}
function b3() {
  return new _v({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: eP(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: kg,
    depthTest: !1,
    depthWrite: !1
  });
}
function eP() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function x9(n) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function r(h) {
    if (h && h.isTexture) {
      const v = h.mapping, y = v === bT || v === TT, _ = v === f0 || v === d0;
      if (y || _)
        if (h.isRenderTargetTexture && h.needsPMREMUpdate === !0) {
          h.needsPMREMUpdate = !1;
          let b = e.get(h);
          return t === null && (t = new XL(n)), b = y ? t.fromEquirectangular(h, b) : t.fromCubemap(h, b), e.set(h, b), b.texture;
        } else {
          if (e.has(h))
            return e.get(h).texture;
          {
            const b = h.image;
            if (y && b && b.height > 0 || _ && b && a(b)) {
              t === null && (t = new XL(n));
              const M = y ? t.fromEquirectangular(h) : t.fromCubemap(h);
              return e.set(h, M), h.addEventListener("dispose", s), M.texture;
            } else
              return null;
          }
        }
    }
    return h;
  }
  function a(h) {
    let v = 0;
    const y = 6;
    for (let _ = 0; _ < y; _++)
      h[_] !== void 0 && v++;
    return v === y;
  }
  function s(h) {
    const v = h.target;
    v.removeEventListener("dispose", s);
    const y = e.get(v);
    y !== void 0 && (e.delete(v), y.dispose());
  }
  function u() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: r,
    dispose: u
  };
}
function _9(n) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0)
      return e[r];
    let a;
    switch (r) {
      case "WEBGL_depth_texture":
        a = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        a = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        a = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        a = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        a = n.getExtension(r);
    }
    return e[r] = a, a;
  }
  return {
    has: function(r) {
      return t(r) !== null;
    },
    init: function(r) {
      r.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(r) {
      const a = t(r);
      return a === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), a;
    }
  };
}
function E9(n, e, t, r) {
  const a = {}, s = /* @__PURE__ */ new WeakMap();
  function u(b) {
    const M = b.target;
    M.index !== null && e.remove(M.index);
    for (const D in M.attributes)
      e.remove(M.attributes[D]);
    for (const D in M.morphAttributes) {
      const U = M.morphAttributes[D];
      for (let N = 0, O = U.length; N < O; N++)
        e.remove(U[N]);
    }
    M.removeEventListener("dispose", u), delete a[M.id];
    const C = s.get(M);
    C && (e.remove(C), s.delete(M)), r.releaseStatesOfGeometry(M), M.isInstancedBufferGeometry === !0 && delete M._maxInstanceCount, t.memory.geometries--;
  }
  function h(b, M) {
    return a[M.id] === !0 || (M.addEventListener("dispose", u), a[M.id] = !0, t.memory.geometries++), M;
  }
  function v(b) {
    const M = b.attributes;
    for (const D in M)
      e.update(M[D], n.ARRAY_BUFFER);
    const C = b.morphAttributes;
    for (const D in C) {
      const U = C[D];
      for (let N = 0, O = U.length; N < O; N++)
        e.update(U[N], n.ARRAY_BUFFER);
    }
  }
  function y(b) {
    const M = [], C = b.index, D = b.attributes.position;
    let U = 0;
    if (C !== null) {
      const I = C.array;
      U = C.version;
      for (let k = 0, G = I.length; k < G; k += 3) {
        const j = I[k + 0], Y = I[k + 1], Z = I[k + 2];
        M.push(j, Y, Y, Z, Z, j);
      }
    } else {
      const I = D.array;
      U = D.version;
      for (let k = 0, G = I.length / 3 - 1; k < G; k += 3) {
        const j = k + 0, Y = k + 1, Z = k + 2;
        M.push(j, Y, Y, Z, Z, j);
      }
    }
    const N = new (AF(M) ? JO : ZO)(M, 1);
    N.version = U;
    const O = s.get(b);
    O && e.remove(O), s.set(b, N);
  }
  function _(b) {
    const M = s.get(b);
    if (M) {
      const C = b.index;
      C !== null && M.version < C.version && y(b);
    } else
      y(b);
    return s.get(b);
  }
  return {
    get: h,
    update: v,
    getWireframeAttribute: _
  };
}
function b9(n, e, t, r) {
  const a = r.isWebGL2;
  let s;
  function u(M) {
    s = M;
  }
  let h, v;
  function y(M) {
    h = M.type, v = M.bytesPerElement;
  }
  function _(M, C) {
    n.drawElements(s, C, h, M * v), t.update(C, s, 1);
  }
  function b(M, C, D) {
    if (D === 0)
      return;
    let U, N;
    if (a)
      U = n, N = "drawElementsInstanced";
    else if (U = e.get("ANGLE_instanced_arrays"), N = "drawElementsInstancedANGLE", U === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    U[N](s, C, h, M * v, D), t.update(C, s, D);
  }
  this.setMode = u, this.setIndex = y, this.render = _, this.renderInstances = b;
}
function T9(n) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function r(s, u, h) {
    switch (t.calls++, u) {
      case n.TRIANGLES:
        t.triangles += h * (s / 3);
        break;
      case n.LINES:
        t.lines += h * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += h * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += h * s;
        break;
      case n.POINTS:
        t.points += h * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", u);
        break;
    }
  }
  function a() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: a,
    update: r
  };
}
function M9(n, e) {
  return n[0] - e[0];
}
function w9(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function C9(n, e, t) {
  const r = {}, a = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), u = new Ua(), h = [];
  for (let y = 0; y < 8; y++)
    h[y] = [y, 0];
  function v(y, _, b) {
    const M = y.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const D = _.morphAttributes.position || _.morphAttributes.normal || _.morphAttributes.color, U = D !== void 0 ? D.length : 0;
      let N = s.get(_);
      if (N === void 0 || N.count !== U) {
        let Re = function() {
          de.dispose(), s.delete(_), _.removeEventListener("dispose", Re);
        };
        var C = Re;
        N !== void 0 && N.texture.dispose();
        const k = _.morphAttributes.position !== void 0, G = _.morphAttributes.normal !== void 0, j = _.morphAttributes.color !== void 0, Y = _.morphAttributes.position || [], Z = _.morphAttributes.normal || [], te = _.morphAttributes.color || [];
        let J = 0;
        k === !0 && (J = 1), G === !0 && (J = 2), j === !0 && (J = 3);
        let q = _.attributes.position.count * J, oe = 1;
        q > e.maxTextureSize && (oe = Math.ceil(q / e.maxTextureSize), q = e.maxTextureSize);
        const ye = new Float32Array(q * oe * 4 * U), de = new VR(ye, q, oe, U);
        de.type = vv, de.needsUpdate = !0;
        const xe = J * 4;
        for (let Pe = 0; Pe < U; Pe++) {
          const Te = Y[Pe], ue = Z[Pe], we = te[Pe], X = q * oe * 4 * Pe;
          for (let me = 0; me < Te.count; me++) {
            const ce = me * xe;
            k === !0 && (u.fromBufferAttribute(Te, me), ye[X + ce + 0] = u.x, ye[X + ce + 1] = u.y, ye[X + ce + 2] = u.z, ye[X + ce + 3] = 0), G === !0 && (u.fromBufferAttribute(ue, me), ye[X + ce + 4] = u.x, ye[X + ce + 5] = u.y, ye[X + ce + 6] = u.z, ye[X + ce + 7] = 0), j === !0 && (u.fromBufferAttribute(we, me), ye[X + ce + 8] = u.x, ye[X + ce + 9] = u.y, ye[X + ce + 10] = u.z, ye[X + ce + 11] = we.itemSize === 4 ? u.w : 1);
          }
        }
        N = {
          count: U,
          texture: de,
          size: new It(q, oe)
        }, s.set(_, N), _.addEventListener("dispose", Re);
      }
      let O = 0;
      for (let k = 0; k < M.length; k++)
        O += M[k];
      const I = _.morphTargetsRelative ? 1 : 1 - O;
      b.getUniforms().setValue(n, "morphTargetBaseInfluence", I), b.getUniforms().setValue(n, "morphTargetInfluences", M), b.getUniforms().setValue(n, "morphTargetsTexture", N.texture, t), b.getUniforms().setValue(n, "morphTargetsTextureSize", N.size);
    } else {
      const D = M === void 0 ? 0 : M.length;
      let U = r[_.id];
      if (U === void 0 || U.length !== D) {
        U = [];
        for (let G = 0; G < D; G++)
          U[G] = [G, 0];
        r[_.id] = U;
      }
      for (let G = 0; G < D; G++) {
        const j = U[G];
        j[0] = G, j[1] = M[G];
      }
      U.sort(w9);
      for (let G = 0; G < 8; G++)
        G < D && U[G][1] ? (h[G][0] = U[G][0], h[G][1] = U[G][1]) : (h[G][0] = Number.MAX_SAFE_INTEGER, h[G][1] = 0);
      h.sort(M9);
      const N = _.morphAttributes.position, O = _.morphAttributes.normal;
      let I = 0;
      for (let G = 0; G < 8; G++) {
        const j = h[G], Y = j[0], Z = j[1];
        Y !== Number.MAX_SAFE_INTEGER && Z ? (N && _.getAttribute("morphTarget" + G) !== N[Y] && _.setAttribute("morphTarget" + G, N[Y]), O && _.getAttribute("morphNormal" + G) !== O[Y] && _.setAttribute("morphNormal" + G, O[Y]), a[G] = Z, I += Z) : (N && _.hasAttribute("morphTarget" + G) === !0 && _.deleteAttribute("morphTarget" + G), O && _.hasAttribute("morphNormal" + G) === !0 && _.deleteAttribute("morphNormal" + G), a[G] = 0);
      }
      const k = _.morphTargetsRelative ? 1 : 1 - I;
      b.getUniforms().setValue(n, "morphTargetBaseInfluence", k), b.getUniforms().setValue(n, "morphTargetInfluences", a);
    }
  }
  return {
    update: v
  };
}
function R9(n, e, t, r) {
  let a = /* @__PURE__ */ new WeakMap();
  function s(v) {
    const y = r.render.frame, _ = v.geometry, b = e.get(v, _);
    return a.get(b) !== y && (e.update(b), a.set(b, y)), v.isInstancedMesh && (v.hasEventListener("dispose", h) === !1 && v.addEventListener("dispose", h), t.update(v.instanceMatrix, n.ARRAY_BUFFER), v.instanceColor !== null && t.update(v.instanceColor, n.ARRAY_BUFFER)), b;
  }
  function u() {
    a = /* @__PURE__ */ new WeakMap();
  }
  function h(v) {
    const y = v.target;
    y.removeEventListener("dispose", h), t.remove(y.instanceMatrix), y.instanceColor !== null && t.remove(y.instanceColor);
  }
  return {
    update: s,
    dispose: u
  };
}
const zF = /* @__PURE__ */ new Rs(), kF = /* @__PURE__ */ new VR(), IF = /* @__PURE__ */ new QO(), FF = /* @__PURE__ */ new KT(), T3 = [], M3 = [], w3 = new Float32Array(16), C3 = new Float32Array(9), R3 = new Float32Array(4);
function $E(n, e, t) {
  const r = n[0];
  if (r <= 0 || r > 0)
    return n;
  const a = e * t;
  let s = T3[a];
  if (s === void 0 && (s = new Float32Array(a), T3[a] = s), e !== 0) {
    r.toArray(s, 0);
    for (let u = 1, h = 0; u !== e; ++u)
      h += t, n[u].toArray(s, h);
  }
  return s;
}
function Ql(n, e) {
  if (n.length !== e.length)
    return !1;
  for (let t = 0, r = n.length; t < r; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}
function Zl(n, e) {
  for (let t = 0, r = e.length; t < r; t++)
    n[t] = e[t];
}
function WR(n, e) {
  let t = M3[e];
  t === void 0 && (t = new Int32Array(e), M3[e] = t);
  for (let r = 0; r !== e; ++r)
    t[r] = n.allocateTextureUnit();
  return t;
}
function A9(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e);
}
function D9(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Ql(t, e))
      return;
    n.uniform2fv(this.addr, e), Zl(t, e);
  }
}
function L9(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (Ql(t, e))
      return;
    n.uniform3fv(this.addr, e), Zl(t, e);
  }
}
function O9(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Ql(t, e))
      return;
    n.uniform4fv(this.addr, e), Zl(t, e);
  }
}
function P9(n, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (Ql(t, e))
      return;
    n.uniformMatrix2fv(this.addr, !1, e), Zl(t, e);
  } else {
    if (Ql(t, r))
      return;
    R3.set(r), n.uniformMatrix2fv(this.addr, !1, R3), Zl(t, r);
  }
}
function N9(n, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (Ql(t, e))
      return;
    n.uniformMatrix3fv(this.addr, !1, e), Zl(t, e);
  } else {
    if (Ql(t, r))
      return;
    C3.set(r), n.uniformMatrix3fv(this.addr, !1, C3), Zl(t, r);
  }
}
function U9(n, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (Ql(t, e))
      return;
    n.uniformMatrix4fv(this.addr, !1, e), Zl(t, e);
  } else {
    if (Ql(t, r))
      return;
    w3.set(r), n.uniformMatrix4fv(this.addr, !1, w3), Zl(t, r);
  }
}
function z9(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e);
}
function k9(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Ql(t, e))
      return;
    n.uniform2iv(this.addr, e), Zl(t, e);
  }
}
function I9(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Ql(t, e))
      return;
    n.uniform3iv(this.addr, e), Zl(t, e);
  }
}
function F9(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Ql(t, e))
      return;
    n.uniform4iv(this.addr, e), Zl(t, e);
  }
}
function B9(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e);
}
function H9(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Ql(t, e))
      return;
    n.uniform2uiv(this.addr, e), Zl(t, e);
  }
}
function V9(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Ql(t, e))
      return;
    n.uniform3uiv(this.addr, e), Zl(t, e);
  }
}
function G9(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Ql(t, e))
      return;
    n.uniform4uiv(this.addr, e), Zl(t, e);
  }
}
function W9(n, e, t) {
  const r = this.cache, a = t.allocateTextureUnit();
  r[0] !== a && (n.uniform1i(this.addr, a), r[0] = a), t.setTexture2D(e || zF, a);
}
function j9(n, e, t) {
  const r = this.cache, a = t.allocateTextureUnit();
  r[0] !== a && (n.uniform1i(this.addr, a), r[0] = a), t.setTexture3D(e || IF, a);
}
function $9(n, e, t) {
  const r = this.cache, a = t.allocateTextureUnit();
  r[0] !== a && (n.uniform1i(this.addr, a), r[0] = a), t.setTextureCube(e || FF, a);
}
function Y9(n, e, t) {
  const r = this.cache, a = t.allocateTextureUnit();
  r[0] !== a && (n.uniform1i(this.addr, a), r[0] = a), t.setTexture2DArray(e || kF, a);
}
function X9(n) {
  switch (n) {
    case 5126:
      return A9;
    case 35664:
      return D9;
    case 35665:
      return L9;
    case 35666:
      return O9;
    case 35674:
      return P9;
    case 35675:
      return N9;
    case 35676:
      return U9;
    case 5124:
    case 35670:
      return z9;
    case 35667:
    case 35671:
      return k9;
    case 35668:
    case 35672:
      return I9;
    case 35669:
    case 35673:
      return F9;
    case 5125:
      return B9;
    case 36294:
      return H9;
    case 36295:
      return V9;
    case 36296:
      return G9;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return W9;
    case 35679:
    case 36299:
    case 36307:
      return j9;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return $9;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Y9;
  }
}
function q9(n, e) {
  n.uniform1fv(this.addr, e);
}
function K9(n, e) {
  const t = $E(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function Q9(n, e) {
  const t = $E(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function Z9(n, e) {
  const t = $E(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function J9(n, e) {
  const t = $E(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function e7(n, e) {
  const t = $E(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function t7(n, e) {
  const t = $E(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function n7(n, e) {
  n.uniform1iv(this.addr, e);
}
function r7(n, e) {
  n.uniform2iv(this.addr, e);
}
function i7(n, e) {
  n.uniform3iv(this.addr, e);
}
function a7(n, e) {
  n.uniform4iv(this.addr, e);
}
function o7(n, e) {
  n.uniform1uiv(this.addr, e);
}
function s7(n, e) {
  n.uniform2uiv(this.addr, e);
}
function l7(n, e) {
  n.uniform3uiv(this.addr, e);
}
function u7(n, e) {
  n.uniform4uiv(this.addr, e);
}
function c7(n, e, t) {
  const r = this.cache, a = e.length, s = WR(t, a);
  Ql(r, s) || (n.uniform1iv(this.addr, s), Zl(r, s));
  for (let u = 0; u !== a; ++u)
    t.setTexture2D(e[u] || zF, s[u]);
}
function f7(n, e, t) {
  const r = this.cache, a = e.length, s = WR(t, a);
  Ql(r, s) || (n.uniform1iv(this.addr, s), Zl(r, s));
  for (let u = 0; u !== a; ++u)
    t.setTexture3D(e[u] || IF, s[u]);
}
function d7(n, e, t) {
  const r = this.cache, a = e.length, s = WR(t, a);
  Ql(r, s) || (n.uniform1iv(this.addr, s), Zl(r, s));
  for (let u = 0; u !== a; ++u)
    t.setTextureCube(e[u] || FF, s[u]);
}
function h7(n, e, t) {
  const r = this.cache, a = e.length, s = WR(t, a);
  Ql(r, s) || (n.uniform1iv(this.addr, s), Zl(r, s));
  for (let u = 0; u !== a; ++u)
    t.setTexture2DArray(e[u] || kF, s[u]);
}
function p7(n) {
  switch (n) {
    case 5126:
      return q9;
    case 35664:
      return K9;
    case 35665:
      return Q9;
    case 35666:
      return Z9;
    case 35674:
      return J9;
    case 35675:
      return e7;
    case 35676:
      return t7;
    case 5124:
    case 35670:
      return n7;
    case 35667:
    case 35671:
      return r7;
    case 35668:
    case 35672:
      return i7;
    case 35669:
    case 35673:
      return a7;
    case 5125:
      return o7;
    case 36294:
      return s7;
    case 36295:
      return l7;
    case 36296:
      return u7;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return c7;
    case 35679:
    case 36299:
    case 36307:
      return f7;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return d7;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return h7;
  }
}
class m7 {
  constructor(e, t, r) {
    this.id = e, this.addr = r, this.cache = [], this.setValue = X9(t.type);
  }
}
class v7 {
  constructor(e, t, r) {
    this.id = e, this.addr = r, this.cache = [], this.size = t.size, this.setValue = p7(t.type);
  }
}
class g7 {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, r) {
    const a = this.seq;
    for (let s = 0, u = a.length; s !== u; ++s) {
      const h = a[s];
      h.setValue(e, t[h.id], r);
    }
  }
}
const T2 = /(\w+)(\])?(\[|\.)?/g;
function A3(n, e) {
  n.seq.push(e), n.map[e.id] = e;
}
function y7(n, e, t) {
  const r = n.name, a = r.length;
  for (T2.lastIndex = 0; ; ) {
    const s = T2.exec(r), u = T2.lastIndex;
    let h = s[1];
    const v = s[2] === "]", y = s[3];
    if (v && (h = h | 0), y === void 0 || y === "[" && u + 2 === a) {
      A3(t, y === void 0 ? new m7(h, n, e) : new v7(h, n, e));
      break;
    } else {
      let b = t.map[h];
      b === void 0 && (b = new g7(h), A3(t, b)), t = b;
    }
  }
}
class dR {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let a = 0; a < r; ++a) {
      const s = e.getActiveUniform(t, a), u = e.getUniformLocation(t, s.name);
      y7(s, u, this);
    }
  }
  setValue(e, t, r, a) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, r, a);
  }
  setOptional(e, t, r) {
    const a = t[r];
    a !== void 0 && this.setValue(e, r, a);
  }
  static upload(e, t, r, a) {
    for (let s = 0, u = t.length; s !== u; ++s) {
      const h = t[s], v = r[h.id];
      v.needsUpdate !== !1 && h.setValue(e, v.value, a);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let a = 0, s = e.length; a !== s; ++a) {
      const u = e[a];
      u.id in t && r.push(u);
    }
    return r;
  }
}
function D3(n, e, t) {
  const r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
let S7 = 0;
function x7(n, e) {
  const t = n.split(`
`), r = [], a = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
  for (let u = a; u < s; u++) {
    const h = u + 1;
    r.push(`${h === e ? ">" : " "} ${h}: ${t[u]}`);
  }
  return r.join(`
`);
}
function _7(n) {
  switch (n) {
    case nm:
      return ["Linear", "( value )"];
    case ai:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", n), ["Linear", "( value )"];
  }
}
function L3(n, e, t) {
  const r = n.getShaderParameter(e, n.COMPILE_STATUS), a = n.getShaderInfoLog(e).trim();
  if (r && a === "")
    return "";
  const s = /ERROR: 0:(\d+)/.exec(a);
  if (s) {
    const u = parseInt(s[1]);
    return t.toUpperCase() + `

` + a + `

` + x7(n.getShaderSource(e), u);
  } else
    return a;
}
function E7(n, e) {
  const t = _7(e);
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function b7(n, e) {
  let t;
  switch (e) {
    case eF:
      t = "Linear";
      break;
    case tF:
      t = "Reinhard";
      break;
    case nF:
      t = "OptimizedCineon";
      break;
    case IO:
      t = "ACESFilmic";
      break;
    case rF:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function T7(n) {
  return [
    n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(fT).join(`
`);
}
function M7(n) {
  const e = [];
  for (const t in n) {
    const r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function w7(n, e) {
  const t = {}, r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let a = 0; a < r; a++) {
    const s = n.getActiveAttrib(e, a), u = s.name;
    let h = 1;
    s.type === n.FLOAT_MAT2 && (h = 2), s.type === n.FLOAT_MAT3 && (h = 3), s.type === n.FLOAT_MAT4 && (h = 4), t[u] = {
      type: s.type,
      location: n.getAttribLocation(e, u),
      locationSize: h
    };
  }
  return t;
}
function fT(n) {
  return n !== "";
}
function O3(n, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function P3(n, e) {
  return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const C7 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function qL(n) {
  return n.replace(C7, R7);
}
function R7(n, e) {
  const t = mi[e];
  if (t === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return qL(t);
}
const A7 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function N3(n) {
  return n.replace(A7, D7);
}
function D7(n, e, t, r) {
  let a = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    a += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return a;
}
function U3(n) {
  let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
  return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function L7(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return n.shadowMapType === IR ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === pT ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === Zp && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function O7(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case f0:
      case d0:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case WE:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function P7(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case d0:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function N7(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case YT:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case ZI:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case JI:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function U7(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null)
    return null;
  const t = Math.log2(e) - 2, r = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: r, maxMip: t };
}
function z7(n, e, t, r) {
  const a = n.getContext(), s = t.defines;
  let u = t.vertexShader, h = t.fragmentShader;
  const v = L7(t), y = O7(t), _ = P7(t), b = N7(t), M = U7(t), C = t.isWebGL2 ? "" : T7(t), D = M7(s), U = a.createProgram();
  let N, O, I = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (N = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    D
  ].filter(fT).join(`
`), N.length > 0 && (N += `
`), O = [
    C,
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    D
  ].filter(fT).join(`
`), O.length > 0 && (O += `
`)) : (N = [
    U3(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    D,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + _ : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + v : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(fT).join(`
`), O = [
    C,
    U3(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    D,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + y : "",
    t.envMap ? "#define " + _ : "",
    t.envMap ? "#define " + b : "",
    M ? "#define CUBEUV_TEXEL_WIDTH " + M.texelWidth : "",
    M ? "#define CUBEUV_TEXEL_HEIGHT " + M.texelHeight : "",
    M ? "#define CUBEUV_MAX_MIP " + M.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + v : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== em ? "#define TONE_MAPPING" : "",
    t.toneMapping !== em ? mi.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== em ? b7("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    mi.encodings_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    E7("linearToOutputTexel", t.outputColorSpace),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(fT).join(`
`)), u = qL(u), u = O3(u, t), u = P3(u, t), h = qL(h), h = O3(h, t), h = P3(h, t), u = N3(u), h = N3(h), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (I = `#version 300 es
`, N = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + N, O = [
    "#define varying in",
    t.glslVersion === $L ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === $L ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + O);
  const k = I + N + u, G = I + O + h, j = D3(a, a.VERTEX_SHADER, k), Y = D3(a, a.FRAGMENT_SHADER, G);
  if (a.attachShader(U, j), a.attachShader(U, Y), t.index0AttributeName !== void 0 ? a.bindAttribLocation(U, 0, t.index0AttributeName) : t.morphTargets === !0 && a.bindAttribLocation(U, 0, "position"), a.linkProgram(U), n.debug.checkShaderErrors) {
    const J = a.getProgramInfoLog(U).trim(), q = a.getShaderInfoLog(j).trim(), oe = a.getShaderInfoLog(Y).trim();
    let ye = !0, de = !0;
    if (a.getProgramParameter(U, a.LINK_STATUS) === !1)
      if (ye = !1, typeof n.debug.onShaderError == "function")
        n.debug.onShaderError(a, U, j, Y);
      else {
        const xe = L3(a, j, "vertex"), Re = L3(a, Y, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " + a.getError() + " - VALIDATE_STATUS " + a.getProgramParameter(U, a.VALIDATE_STATUS) + `

Program Info Log: ` + J + `
` + xe + `
` + Re
        );
      }
    else
      J !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", J) : (q === "" || oe === "") && (de = !1);
    de && (this.diagnostics = {
      runnable: ye,
      programLog: J,
      vertexShader: {
        log: q,
        prefix: N
      },
      fragmentShader: {
        log: oe,
        prefix: O
      }
    });
  }
  a.deleteShader(j), a.deleteShader(Y);
  let Z;
  this.getUniforms = function() {
    return Z === void 0 && (Z = new dR(a, U)), Z;
  };
  let te;
  return this.getAttributes = function() {
    return te === void 0 && (te = w7(a, U)), te;
  }, this.destroy = function() {
    r.releaseStatesOfProgram(this), a.deleteProgram(U), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = S7++, this.cacheKey = e, this.usedTimes = 1, this.program = U, this.vertexShader = j, this.fragmentShader = Y, this;
}
let k7 = 0;
class I7 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, r = e.fragmentShader, a = this._getShaderStage(t), s = this._getShaderStage(r), u = this._getShaderCacheForMaterial(e);
    return u.has(a) === !1 && (u.add(a), a.usedTimes++), u.has(s) === !1 && (u.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let r = t.get(e);
    return r === void 0 && (r = /* @__PURE__ */ new Set(), t.set(e, r)), r;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let r = t.get(e);
    return r === void 0 && (r = new F7(e), t.set(e, r)), r;
  }
}
class F7 {
  constructor(e) {
    this.id = k7++, this.code = e, this.usedTimes = 0;
  }
}
function B7(n, e, t, r, a, s, u) {
  const h = new rx(), v = new I7(), y = [], _ = a.isWebGL2, b = a.logarithmicDepthBuffer, M = a.vertexTextures;
  let C = a.precision;
  const D = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function U(J) {
    return J === 0 ? "uv" : `uv${J}`;
  }
  function N(J, q, oe, ye, de) {
    const xe = ye.fog, Re = de.geometry, Pe = J.isMeshStandardMaterial ? ye.environment : null, Te = (J.isMeshStandardMaterial ? t : e).get(J.envMap || Pe), ue = Te && Te.mapping === WE ? Te.image.height : null, we = D[J.type];
    J.precision !== null && (C = a.getMaxPrecision(J.precision), C !== J.precision && console.warn("THREE.WebGLProgram.getParameters:", J.precision, "not supported, using", C, "instead."));
    const X = Re.morphAttributes.position || Re.morphAttributes.normal || Re.morphAttributes.color, me = X !== void 0 ? X.length : 0;
    let ce = 0;
    Re.morphAttributes.position !== void 0 && (ce = 1), Re.morphAttributes.normal !== void 0 && (ce = 2), Re.morphAttributes.color !== void 0 && (ce = 3);
    let Ue, Oe, Ze, je;
    if (we) {
      const ti = Jp[we];
      Ue = ti.vertexShader, Oe = ti.fragmentShader;
    } else
      Ue = J.vertexShader, Oe = J.fragmentShader, v.update(J), Ze = v.getVertexShaderID(J), je = v.getFragmentShaderID(J);
    const Je = n.getRenderTarget(), at = de.isInstancedMesh === !0, xt = !!J.map, $t = !!J.matcap, Ht = !!Te, he = !!J.aoMap, nt = !!J.lightMap, et = !!J.bumpMap, Rt = !!J.normalMap, gt = !!J.displacementMap, Jt = !!J.emissiveMap, Kt = !!J.metalnessMap, qt = !!J.roughnessMap, hn = J.anisotropy > 0, Rn = J.clearcoat > 0, Yn = J.iridescence > 0, se = J.sheen > 0, ae = J.transmission > 0, Ke = hn && !!J.anisotropyMap, wt = Rn && !!J.clearcoatMap, _t = Rn && !!J.clearcoatNormalMap, Vt = Rn && !!J.clearcoatRoughnessMap, fn = Yn && !!J.iridescenceMap, Wt = Yn && !!J.iridescenceThicknessMap, Ee = se && !!J.sheenColorMap, Xe = se && !!J.sheenRoughnessMap, St = !!J.specularMap, Ut = !!J.specularColorMap, Se = !!J.specularIntensityMap, Ye = ae && !!J.transmissionMap, bt = ae && !!J.thicknessMap, Tt = !!J.gradientMap, ge = !!J.alphaMap, zt = J.alphaTest > 0, Fe = !!J.extensions, ft = !!Re.attributes.uv1, ln = !!Re.attributes.uv2, zn = !!Re.attributes.uv3;
    return {
      isWebGL2: _,
      shaderID: we,
      shaderType: J.type,
      shaderName: J.name,
      vertexShader: Ue,
      fragmentShader: Oe,
      defines: J.defines,
      customVertexShaderID: Ze,
      customFragmentShaderID: je,
      isRawShaderMaterial: J.isRawShaderMaterial === !0,
      glslVersion: J.glslVersion,
      precision: C,
      instancing: at,
      instancingColor: at && de.instanceColor !== null,
      supportsVertexTextures: M,
      outputColorSpace: Je === null ? n.outputColorSpace : Je.isXRRenderTarget === !0 ? Je.texture.colorSpace : nm,
      map: xt,
      matcap: $t,
      envMap: Ht,
      envMapMode: Ht && Te.mapping,
      envMapCubeUVHeight: ue,
      aoMap: he,
      lightMap: nt,
      bumpMap: et,
      normalMap: Rt,
      displacementMap: M && gt,
      emissiveMap: Jt,
      normalMapObjectSpace: Rt && J.normalMapType === yF,
      normalMapTangentSpace: Rt && J.normalMapType === S0,
      metalnessMap: Kt,
      roughnessMap: qt,
      anisotropy: hn,
      anisotropyMap: Ke,
      clearcoat: Rn,
      clearcoatMap: wt,
      clearcoatNormalMap: _t,
      clearcoatRoughnessMap: Vt,
      iridescence: Yn,
      iridescenceMap: fn,
      iridescenceThicknessMap: Wt,
      sheen: se,
      sheenColorMap: Ee,
      sheenRoughnessMap: Xe,
      specularMap: St,
      specularColorMap: Ut,
      specularIntensityMap: Se,
      transmission: ae,
      transmissionMap: Ye,
      thicknessMap: bt,
      gradientMap: Tt,
      opaque: J.transparent === !1 && J.blending === tx,
      alphaMap: ge,
      alphaTest: zt,
      combine: J.combine,
      //
      mapUv: xt && U(J.map.channel),
      aoMapUv: he && U(J.aoMap.channel),
      lightMapUv: nt && U(J.lightMap.channel),
      bumpMapUv: et && U(J.bumpMap.channel),
      normalMapUv: Rt && U(J.normalMap.channel),
      displacementMapUv: gt && U(J.displacementMap.channel),
      emissiveMapUv: Jt && U(J.emissiveMap.channel),
      metalnessMapUv: Kt && U(J.metalnessMap.channel),
      roughnessMapUv: qt && U(J.roughnessMap.channel),
      anisotropyMapUv: Ke && U(J.anisotropyMap.channel),
      clearcoatMapUv: wt && U(J.clearcoatMap.channel),
      clearcoatNormalMapUv: _t && U(J.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Vt && U(J.clearcoatRoughnessMap.channel),
      iridescenceMapUv: fn && U(J.iridescenceMap.channel),
      iridescenceThicknessMapUv: Wt && U(J.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ee && U(J.sheenColorMap.channel),
      sheenRoughnessMapUv: Xe && U(J.sheenRoughnessMap.channel),
      specularMapUv: St && U(J.specularMap.channel),
      specularColorMapUv: Ut && U(J.specularColorMap.channel),
      specularIntensityMapUv: Se && U(J.specularIntensityMap.channel),
      transmissionMapUv: Ye && U(J.transmissionMap.channel),
      thicknessMapUv: bt && U(J.thicknessMap.channel),
      alphaMapUv: ge && U(J.alphaMap.channel),
      //
      vertexTangents: !!Re.attributes.tangent && (Rt || hn),
      vertexColors: J.vertexColors,
      vertexAlphas: J.vertexColors === !0 && !!Re.attributes.color && Re.attributes.color.itemSize === 4,
      vertexUv1s: ft,
      vertexUv2s: ln,
      vertexUv3s: zn,
      pointsUvs: de.isPoints === !0 && !!Re.attributes.uv && (xt || ge),
      fog: !!xe,
      useFog: J.fog === !0,
      fogExp2: xe && xe.isFogExp2,
      flatShading: J.flatShading === !0,
      sizeAttenuation: J.sizeAttenuation === !0,
      logarithmicDepthBuffer: b,
      skinning: de.isSkinnedMesh === !0,
      morphTargets: Re.morphAttributes.position !== void 0,
      morphNormals: Re.morphAttributes.normal !== void 0,
      morphColors: Re.morphAttributes.color !== void 0,
      morphTargetsCount: me,
      morphTextureStride: ce,
      numDirLights: q.directional.length,
      numPointLights: q.point.length,
      numSpotLights: q.spot.length,
      numSpotLightMaps: q.spotLightMap.length,
      numRectAreaLights: q.rectArea.length,
      numHemiLights: q.hemi.length,
      numDirLightShadows: q.directionalShadowMap.length,
      numPointLightShadows: q.pointShadowMap.length,
      numSpotLightShadows: q.spotShadowMap.length,
      numSpotLightShadowsWithMaps: q.numSpotLightShadowsWithMaps,
      numClippingPlanes: u.numPlanes,
      numClipIntersection: u.numIntersection,
      dithering: J.dithering,
      shadowMapEnabled: n.shadowMap.enabled && oe.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: J.toneMapped ? n.toneMapping : em,
      useLegacyLights: n.useLegacyLights,
      premultipliedAlpha: J.premultipliedAlpha,
      doubleSided: J.side === mv,
      flipSided: J.side === bf,
      useDepthPacking: J.depthPacking >= 0,
      depthPacking: J.depthPacking || 0,
      index0AttributeName: J.index0AttributeName,
      extensionDerivatives: Fe && J.extensions.derivatives === !0,
      extensionFragDepth: Fe && J.extensions.fragDepth === !0,
      extensionDrawBuffers: Fe && J.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: Fe && J.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: _ || r.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: _ || r.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: _ || r.has("EXT_shader_texture_lod"),
      customProgramCacheKey: J.customProgramCacheKey()
    };
  }
  function O(J) {
    const q = [];
    if (J.shaderID ? q.push(J.shaderID) : (q.push(J.customVertexShaderID), q.push(J.customFragmentShaderID)), J.defines !== void 0)
      for (const oe in J.defines)
        q.push(oe), q.push(J.defines[oe]);
    return J.isRawShaderMaterial === !1 && (I(q, J), k(q, J), q.push(n.outputColorSpace)), q.push(J.customProgramCacheKey), q.join();
  }
  function I(J, q) {
    J.push(q.precision), J.push(q.outputColorSpace), J.push(q.envMapMode), J.push(q.envMapCubeUVHeight), J.push(q.mapUv), J.push(q.alphaMapUv), J.push(q.lightMapUv), J.push(q.aoMapUv), J.push(q.bumpMapUv), J.push(q.normalMapUv), J.push(q.displacementMapUv), J.push(q.emissiveMapUv), J.push(q.metalnessMapUv), J.push(q.roughnessMapUv), J.push(q.anisotropyMapUv), J.push(q.clearcoatMapUv), J.push(q.clearcoatNormalMapUv), J.push(q.clearcoatRoughnessMapUv), J.push(q.iridescenceMapUv), J.push(q.iridescenceThicknessMapUv), J.push(q.sheenColorMapUv), J.push(q.sheenRoughnessMapUv), J.push(q.specularMapUv), J.push(q.specularColorMapUv), J.push(q.specularIntensityMapUv), J.push(q.transmissionMapUv), J.push(q.thicknessMapUv), J.push(q.combine), J.push(q.fogExp2), J.push(q.sizeAttenuation), J.push(q.morphTargetsCount), J.push(q.morphAttributeCount), J.push(q.numDirLights), J.push(q.numPointLights), J.push(q.numSpotLights), J.push(q.numSpotLightMaps), J.push(q.numHemiLights), J.push(q.numRectAreaLights), J.push(q.numDirLightShadows), J.push(q.numPointLightShadows), J.push(q.numSpotLightShadows), J.push(q.numSpotLightShadowsWithMaps), J.push(q.shadowMapType), J.push(q.toneMapping), J.push(q.numClippingPlanes), J.push(q.numClipIntersection), J.push(q.depthPacking);
  }
  function k(J, q) {
    h.disableAll(), q.isWebGL2 && h.enable(0), q.supportsVertexTextures && h.enable(1), q.instancing && h.enable(2), q.instancingColor && h.enable(3), q.matcap && h.enable(4), q.envMap && h.enable(5), q.normalMapObjectSpace && h.enable(6), q.normalMapTangentSpace && h.enable(7), q.clearcoat && h.enable(8), q.iridescence && h.enable(9), q.alphaTest && h.enable(10), q.vertexColors && h.enable(11), q.vertexAlphas && h.enable(12), q.vertexUv1s && h.enable(13), q.vertexUv2s && h.enable(14), q.vertexUv3s && h.enable(15), q.vertexTangents && h.enable(16), q.anisotropy && h.enable(17), J.push(h.mask), h.disableAll(), q.fog && h.enable(0), q.useFog && h.enable(1), q.flatShading && h.enable(2), q.logarithmicDepthBuffer && h.enable(3), q.skinning && h.enable(4), q.morphTargets && h.enable(5), q.morphNormals && h.enable(6), q.morphColors && h.enable(7), q.premultipliedAlpha && h.enable(8), q.shadowMapEnabled && h.enable(9), q.useLegacyLights && h.enable(10), q.doubleSided && h.enable(11), q.flipSided && h.enable(12), q.useDepthPacking && h.enable(13), q.dithering && h.enable(14), q.transmission && h.enable(15), q.sheen && h.enable(16), q.opaque && h.enable(17), q.pointsUvs && h.enable(18), J.push(h.mask);
  }
  function G(J) {
    const q = D[J.type];
    let oe;
    if (q) {
      const ye = Jp[q];
      oe = OF.clone(ye.uniforms);
    } else
      oe = J.uniforms;
    return oe;
  }
  function j(J, q) {
    let oe;
    for (let ye = 0, de = y.length; ye < de; ye++) {
      const xe = y[ye];
      if (xe.cacheKey === q) {
        oe = xe, ++oe.usedTimes;
        break;
      }
    }
    return oe === void 0 && (oe = new z7(n, q, J, s), y.push(oe)), oe;
  }
  function Y(J) {
    if (--J.usedTimes === 0) {
      const q = y.indexOf(J);
      y[q] = y[y.length - 1], y.pop(), J.destroy();
    }
  }
  function Z(J) {
    v.remove(J);
  }
  function te() {
    v.dispose();
  }
  return {
    getParameters: N,
    getProgramCacheKey: O,
    getUniforms: G,
    acquireProgram: j,
    releaseProgram: Y,
    releaseShaderCache: Z,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: y,
    dispose: te
  };
}
function H7() {
  let n = /* @__PURE__ */ new WeakMap();
  function e(s) {
    let u = n.get(s);
    return u === void 0 && (u = {}, n.set(s, u)), u;
  }
  function t(s) {
    n.delete(s);
  }
  function r(s, u, h) {
    n.get(s)[u] = h;
  }
  function a() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: r,
    dispose: a
  };
}
function V7(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id;
}
function z3(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id;
}
function k3() {
  const n = [];
  let e = 0;
  const t = [], r = [], a = [];
  function s() {
    e = 0, t.length = 0, r.length = 0, a.length = 0;
  }
  function u(b, M, C, D, U, N) {
    let O = n[e];
    return O === void 0 ? (O = {
      id: b.id,
      object: b,
      geometry: M,
      material: C,
      groupOrder: D,
      renderOrder: b.renderOrder,
      z: U,
      group: N
    }, n[e] = O) : (O.id = b.id, O.object = b, O.geometry = M, O.material = C, O.groupOrder = D, O.renderOrder = b.renderOrder, O.z = U, O.group = N), e++, O;
  }
  function h(b, M, C, D, U, N) {
    const O = u(b, M, C, D, U, N);
    C.transmission > 0 ? r.push(O) : C.transparent === !0 ? a.push(O) : t.push(O);
  }
  function v(b, M, C, D, U, N) {
    const O = u(b, M, C, D, U, N);
    C.transmission > 0 ? r.unshift(O) : C.transparent === !0 ? a.unshift(O) : t.unshift(O);
  }
  function y(b, M) {
    t.length > 1 && t.sort(b || V7), r.length > 1 && r.sort(M || z3), a.length > 1 && a.sort(M || z3);
  }
  function _() {
    for (let b = e, M = n.length; b < M; b++) {
      const C = n[b];
      if (C.id === null)
        break;
      C.id = null, C.object = null, C.geometry = null, C.material = null, C.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: a,
    init: s,
    push: h,
    unshift: v,
    finish: _,
    sort: y
  };
}
function G7() {
  let n = /* @__PURE__ */ new WeakMap();
  function e(r, a) {
    const s = n.get(r);
    let u;
    return s === void 0 ? (u = new k3(), n.set(r, [u])) : a >= s.length ? (u = new k3(), s.push(u)) : u = s[a], u;
  }
  function t() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function W7() {
  const n = {};
  return {
    get: function(e) {
      if (n[e.id] !== void 0)
        return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new be(),
            color: new Un()
          };
          break;
        case "SpotLight":
          t = {
            position: new be(),
            direction: new be(),
            color: new Un(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new be(),
            color: new Un(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new be(),
            skyColor: new Un(),
            groundColor: new Un()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Un(),
            position: new be(),
            halfWidth: new be(),
            halfHeight: new be()
          };
          break;
      }
      return n[e.id] = t, t;
    }
  };
}
function j7() {
  const n = {};
  return {
    get: function(e) {
      if (n[e.id] !== void 0)
        return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new It()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new It()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new It(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return n[e.id] = t, t;
    }
  };
}
let $7 = 0;
function Y7(n, e) {
  return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0);
}
function X7(n, e) {
  const t = new W7(), r = j7(), a = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0
  };
  for (let _ = 0; _ < 9; _++)
    a.probe.push(new be());
  const s = new be(), u = new ei(), h = new ei();
  function v(_, b) {
    let M = 0, C = 0, D = 0;
    for (let oe = 0; oe < 9; oe++)
      a.probe[oe].set(0, 0, 0);
    let U = 0, N = 0, O = 0, I = 0, k = 0, G = 0, j = 0, Y = 0, Z = 0, te = 0;
    _.sort(Y7);
    const J = b === !0 ? Math.PI : 1;
    for (let oe = 0, ye = _.length; oe < ye; oe++) {
      const de = _[oe], xe = de.color, Re = de.intensity, Pe = de.distance, Te = de.shadow && de.shadow.map ? de.shadow.map.texture : null;
      if (de.isAmbientLight)
        M += xe.r * Re * J, C += xe.g * Re * J, D += xe.b * Re * J;
      else if (de.isLightProbe)
        for (let ue = 0; ue < 9; ue++)
          a.probe[ue].addScaledVector(de.sh.coefficients[ue], Re);
      else if (de.isDirectionalLight) {
        const ue = t.get(de);
        if (ue.color.copy(de.color).multiplyScalar(de.intensity * J), de.castShadow) {
          const we = de.shadow, X = r.get(de);
          X.shadowBias = we.bias, X.shadowNormalBias = we.normalBias, X.shadowRadius = we.radius, X.shadowMapSize = we.mapSize, a.directionalShadow[U] = X, a.directionalShadowMap[U] = Te, a.directionalShadowMatrix[U] = de.shadow.matrix, G++;
        }
        a.directional[U] = ue, U++;
      } else if (de.isSpotLight) {
        const ue = t.get(de);
        ue.position.setFromMatrixPosition(de.matrixWorld), ue.color.copy(xe).multiplyScalar(Re * J), ue.distance = Pe, ue.coneCos = Math.cos(de.angle), ue.penumbraCos = Math.cos(de.angle * (1 - de.penumbra)), ue.decay = de.decay, a.spot[O] = ue;
        const we = de.shadow;
        if (de.map && (a.spotLightMap[Z] = de.map, Z++, we.updateMatrices(de), de.castShadow && te++), a.spotLightMatrix[O] = we.matrix, de.castShadow) {
          const X = r.get(de);
          X.shadowBias = we.bias, X.shadowNormalBias = we.normalBias, X.shadowRadius = we.radius, X.shadowMapSize = we.mapSize, a.spotShadow[O] = X, a.spotShadowMap[O] = Te, Y++;
        }
        O++;
      } else if (de.isRectAreaLight) {
        const ue = t.get(de);
        ue.color.copy(xe).multiplyScalar(Re), ue.halfWidth.set(de.width * 0.5, 0, 0), ue.halfHeight.set(0, de.height * 0.5, 0), a.rectArea[I] = ue, I++;
      } else if (de.isPointLight) {
        const ue = t.get(de);
        if (ue.color.copy(de.color).multiplyScalar(de.intensity * J), ue.distance = de.distance, ue.decay = de.decay, de.castShadow) {
          const we = de.shadow, X = r.get(de);
          X.shadowBias = we.bias, X.shadowNormalBias = we.normalBias, X.shadowRadius = we.radius, X.shadowMapSize = we.mapSize, X.shadowCameraNear = we.camera.near, X.shadowCameraFar = we.camera.far, a.pointShadow[N] = X, a.pointShadowMap[N] = Te, a.pointShadowMatrix[N] = de.shadow.matrix, j++;
        }
        a.point[N] = ue, N++;
      } else if (de.isHemisphereLight) {
        const ue = t.get(de);
        ue.skyColor.copy(de.color).multiplyScalar(Re * J), ue.groundColor.copy(de.groundColor).multiplyScalar(Re * J), a.hemi[k] = ue, k++;
      }
    }
    I > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (a.rectAreaLTC1 = bn.LTC_FLOAT_1, a.rectAreaLTC2 = bn.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (a.rectAreaLTC1 = bn.LTC_HALF_1, a.rectAreaLTC2 = bn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), a.ambient[0] = M, a.ambient[1] = C, a.ambient[2] = D;
    const q = a.hash;
    (q.directionalLength !== U || q.pointLength !== N || q.spotLength !== O || q.rectAreaLength !== I || q.hemiLength !== k || q.numDirectionalShadows !== G || q.numPointShadows !== j || q.numSpotShadows !== Y || q.numSpotMaps !== Z) && (a.directional.length = U, a.spot.length = O, a.rectArea.length = I, a.point.length = N, a.hemi.length = k, a.directionalShadow.length = G, a.directionalShadowMap.length = G, a.pointShadow.length = j, a.pointShadowMap.length = j, a.spotShadow.length = Y, a.spotShadowMap.length = Y, a.directionalShadowMatrix.length = G, a.pointShadowMatrix.length = j, a.spotLightMatrix.length = Y + Z - te, a.spotLightMap.length = Z, a.numSpotLightShadowsWithMaps = te, q.directionalLength = U, q.pointLength = N, q.spotLength = O, q.rectAreaLength = I, q.hemiLength = k, q.numDirectionalShadows = G, q.numPointShadows = j, q.numSpotShadows = Y, q.numSpotMaps = Z, a.version = $7++);
  }
  function y(_, b) {
    let M = 0, C = 0, D = 0, U = 0, N = 0;
    const O = b.matrixWorldInverse;
    for (let I = 0, k = _.length; I < k; I++) {
      const G = _[I];
      if (G.isDirectionalLight) {
        const j = a.directional[M];
        j.direction.setFromMatrixPosition(G.matrixWorld), s.setFromMatrixPosition(G.target.matrixWorld), j.direction.sub(s), j.direction.transformDirection(O), M++;
      } else if (G.isSpotLight) {
        const j = a.spot[D];
        j.position.setFromMatrixPosition(G.matrixWorld), j.position.applyMatrix4(O), j.direction.setFromMatrixPosition(G.matrixWorld), s.setFromMatrixPosition(G.target.matrixWorld), j.direction.sub(s), j.direction.transformDirection(O), D++;
      } else if (G.isRectAreaLight) {
        const j = a.rectArea[U];
        j.position.setFromMatrixPosition(G.matrixWorld), j.position.applyMatrix4(O), h.identity(), u.copy(G.matrixWorld), u.premultiply(O), h.extractRotation(u), j.halfWidth.set(G.width * 0.5, 0, 0), j.halfHeight.set(0, G.height * 0.5, 0), j.halfWidth.applyMatrix4(h), j.halfHeight.applyMatrix4(h), U++;
      } else if (G.isPointLight) {
        const j = a.point[C];
        j.position.setFromMatrixPosition(G.matrixWorld), j.position.applyMatrix4(O), C++;
      } else if (G.isHemisphereLight) {
        const j = a.hemi[N];
        j.direction.setFromMatrixPosition(G.matrixWorld), j.direction.transformDirection(O), N++;
      }
    }
  }
  return {
    setup: v,
    setupView: y,
    state: a
  };
}
function I3(n, e) {
  const t = new X7(n, e), r = [], a = [];
  function s() {
    r.length = 0, a.length = 0;
  }
  function u(b) {
    r.push(b);
  }
  function h(b) {
    a.push(b);
  }
  function v(b) {
    t.setup(r, b);
  }
  function y(b) {
    t.setupView(r, b);
  }
  return {
    init: s,
    state: {
      lightsArray: r,
      shadowsArray: a,
      lights: t
    },
    setupLights: v,
    setupLightsView: y,
    pushLight: u,
    pushShadow: h
  };
}
function q7(n, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function r(s, u = 0) {
    const h = t.get(s);
    let v;
    return h === void 0 ? (v = new I3(n, e), t.set(s, [v])) : u >= h.length ? (v = new I3(n, e), h.push(v)) : v = h[u], v;
  }
  function a() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: a
  };
}
class tP extends Ku {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = vF, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class nP extends Ku {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const K7 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, Q7 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Z7(n, e, t) {
  let r = new GR();
  const a = new It(), s = new It(), u = new Ua(), h = new tP({ depthPacking: gF }), v = new nP(), y = {}, _ = t.maxTextureSize, b = { [Fg]: bf, [bf]: Fg, [mv]: mv }, M = new _v({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new It() },
      radius: { value: 4 }
    },
    vertexShader: K7,
    fragmentShader: Q7
  }), C = M.clone();
  C.defines.HORIZONTAL_PASS = 1;
  const D = new yi();
  D.setAttribute(
    "position",
    new so(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const U = new qu(D, M), N = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = IR;
  let O = this.type;
  this.render = function(j, Y, Z) {
    if (N.enabled === !1 || N.autoUpdate === !1 && N.needsUpdate === !1 || j.length === 0)
      return;
    const te = n.getRenderTarget(), J = n.getActiveCubeFace(), q = n.getActiveMipmapLevel(), oe = n.state;
    oe.setBlending(kg), oe.buffers.color.setClear(1, 1, 1, 1), oe.buffers.depth.setTest(!0), oe.setScissorTest(!1);
    const ye = O !== Zp && this.type === Zp, de = O === Zp && this.type !== Zp;
    for (let xe = 0, Re = j.length; xe < Re; xe++) {
      const Pe = j[xe], Te = Pe.shadow;
      if (Te === void 0) {
        console.warn("THREE.WebGLShadowMap:", Pe, "has no shadow.");
        continue;
      }
      if (Te.autoUpdate === !1 && Te.needsUpdate === !1)
        continue;
      a.copy(Te.mapSize);
      const ue = Te.getFrameExtents();
      if (a.multiply(ue), s.copy(Te.mapSize), (a.x > _ || a.y > _) && (a.x > _ && (s.x = Math.floor(_ / ue.x), a.x = s.x * ue.x, Te.mapSize.x = s.x), a.y > _ && (s.y = Math.floor(_ / ue.y), a.y = s.y * ue.y, Te.mapSize.y = s.y)), Te.map === null || ye === !0 || de === !0) {
        const X = this.type !== Zp ? { minFilter: el, magFilter: el } : {};
        Te.map !== null && Te.map.dispose(), Te.map = new rm(a.x, a.y, X), Te.map.texture.name = Pe.name + ".shadowMap", Te.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(Te.map), n.clear();
      const we = Te.getViewportCount();
      for (let X = 0; X < we; X++) {
        const me = Te.getViewport(X);
        u.set(
          s.x * me.x,
          s.y * me.y,
          s.x * me.z,
          s.y * me.w
        ), oe.viewport(u), Te.updateMatrices(Pe, X), r = Te.getFrustum(), G(Y, Z, Te.camera, Pe, this.type);
      }
      Te.isPointLightShadow !== !0 && this.type === Zp && I(Te, Z), Te.needsUpdate = !1;
    }
    O = this.type, N.needsUpdate = !1, n.setRenderTarget(te, J, q);
  };
  function I(j, Y) {
    const Z = e.update(U);
    M.defines.VSM_SAMPLES !== j.blurSamples && (M.defines.VSM_SAMPLES = j.blurSamples, C.defines.VSM_SAMPLES = j.blurSamples, M.needsUpdate = !0, C.needsUpdate = !0), j.mapPass === null && (j.mapPass = new rm(a.x, a.y)), M.uniforms.shadow_pass.value = j.map.texture, M.uniforms.resolution.value = j.mapSize, M.uniforms.radius.value = j.radius, n.setRenderTarget(j.mapPass), n.clear(), n.renderBufferDirect(Y, null, Z, M, U, null), C.uniforms.shadow_pass.value = j.mapPass.texture, C.uniforms.resolution.value = j.mapSize, C.uniforms.radius.value = j.radius, n.setRenderTarget(j.map), n.clear(), n.renderBufferDirect(Y, null, Z, C, U, null);
  }
  function k(j, Y, Z, te) {
    let J = null;
    const q = Z.isPointLight === !0 ? j.customDistanceMaterial : j.customDepthMaterial;
    if (q !== void 0)
      J = q;
    else if (J = Z.isPointLight === !0 ? v : h, n.localClippingEnabled && Y.clipShadows === !0 && Array.isArray(Y.clippingPlanes) && Y.clippingPlanes.length !== 0 || Y.displacementMap && Y.displacementScale !== 0 || Y.alphaMap && Y.alphaTest > 0 || Y.map && Y.alphaTest > 0) {
      const oe = J.uuid, ye = Y.uuid;
      let de = y[oe];
      de === void 0 && (de = {}, y[oe] = de);
      let xe = de[ye];
      xe === void 0 && (xe = J.clone(), de[ye] = xe), J = xe;
    }
    if (J.visible = Y.visible, J.wireframe = Y.wireframe, te === Zp ? J.side = Y.shadowSide !== null ? Y.shadowSide : Y.side : J.side = Y.shadowSide !== null ? Y.shadowSide : b[Y.side], J.alphaMap = Y.alphaMap, J.alphaTest = Y.alphaTest, J.map = Y.map, J.clipShadows = Y.clipShadows, J.clippingPlanes = Y.clippingPlanes, J.clipIntersection = Y.clipIntersection, J.displacementMap = Y.displacementMap, J.displacementScale = Y.displacementScale, J.displacementBias = Y.displacementBias, J.wireframeLinewidth = Y.wireframeLinewidth, J.linewidth = Y.linewidth, Z.isPointLight === !0 && J.isMeshDistanceMaterial === !0) {
      const oe = n.properties.get(J);
      oe.light = Z;
    }
    return J;
  }
  function G(j, Y, Z, te, J) {
    if (j.visible === !1)
      return;
    if (j.layers.test(Y.layers) && (j.isMesh || j.isLine || j.isPoints) && (j.castShadow || j.receiveShadow && J === Zp) && (!j.frustumCulled || r.intersectsObject(j))) {
      j.modelViewMatrix.multiplyMatrices(Z.matrixWorldInverse, j.matrixWorld);
      const ye = e.update(j), de = j.material;
      if (Array.isArray(de)) {
        const xe = ye.groups;
        for (let Re = 0, Pe = xe.length; Re < Pe; Re++) {
          const Te = xe[Re], ue = de[Te.materialIndex];
          if (ue && ue.visible) {
            const we = k(j, ue, te, J);
            n.renderBufferDirect(Z, null, ye, we, j, Te);
          }
        }
      } else if (de.visible) {
        const xe = k(j, de, te, J);
        n.renderBufferDirect(Z, null, ye, xe, j, null);
      }
    }
    const oe = j.children;
    for (let ye = 0, de = oe.length; ye < de; ye++)
      G(oe[ye], Y, Z, te, J);
  }
}
function J7(n, e, t) {
  const r = t.isWebGL2;
  function a() {
    let ge = !1;
    const zt = new Ua();
    let Fe = null;
    const ft = new Ua(0, 0, 0, 0);
    return {
      setMask: function(ln) {
        Fe !== ln && !ge && (n.colorMask(ln, ln, ln, ln), Fe = ln);
      },
      setLocked: function(ln) {
        ge = ln;
      },
      setClear: function(ln, zn, yr, ti, rr) {
        rr === !0 && (ln *= ti, zn *= ti, yr *= ti), zt.set(ln, zn, yr, ti), ft.equals(zt) === !1 && (n.clearColor(ln, zn, yr, ti), ft.copy(zt));
      },
      reset: function() {
        ge = !1, Fe = null, ft.set(-1, 0, 0, 0);
      }
    };
  }
  function s() {
    let ge = !1, zt = null, Fe = null, ft = null;
    return {
      setTest: function(ln) {
        ln ? Je(n.DEPTH_TEST) : at(n.DEPTH_TEST);
      },
      setMask: function(ln) {
        zt !== ln && !ge && (n.depthMask(ln), zt = ln);
      },
      setFunc: function(ln) {
        if (Fe !== ln) {
          switch (ln) {
            case jI:
              n.depthFunc(n.NEVER);
              break;
            case $I:
              n.depthFunc(n.ALWAYS);
              break;
            case YI:
              n.depthFunc(n.LESS);
              break;
            case mR:
              n.depthFunc(n.LEQUAL);
              break;
            case XI:
              n.depthFunc(n.EQUAL);
              break;
            case qI:
              n.depthFunc(n.GEQUAL);
              break;
            case KI:
              n.depthFunc(n.GREATER);
              break;
            case QI:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          Fe = ln;
        }
      },
      setLocked: function(ln) {
        ge = ln;
      },
      setClear: function(ln) {
        ft !== ln && (n.clearDepth(ln), ft = ln);
      },
      reset: function() {
        ge = !1, zt = null, Fe = null, ft = null;
      }
    };
  }
  function u() {
    let ge = !1, zt = null, Fe = null, ft = null, ln = null, zn = null, yr = null, ti = null, rr = null;
    return {
      setTest: function(vr) {
        ge || (vr ? Je(n.STENCIL_TEST) : at(n.STENCIL_TEST));
      },
      setMask: function(vr) {
        zt !== vr && !ge && (n.stencilMask(vr), zt = vr);
      },
      setFunc: function(vr, Ai, oi) {
        (Fe !== vr || ft !== Ai || ln !== oi) && (n.stencilFunc(vr, Ai, oi), Fe = vr, ft = Ai, ln = oi);
      },
      setOp: function(vr, Ai, oi) {
        (zn !== vr || yr !== Ai || ti !== oi) && (n.stencilOp(vr, Ai, oi), zn = vr, yr = Ai, ti = oi);
      },
      setLocked: function(vr) {
        ge = vr;
      },
      setClear: function(vr) {
        rr !== vr && (n.clearStencil(vr), rr = vr);
      },
      reset: function() {
        ge = !1, zt = null, Fe = null, ft = null, ln = null, zn = null, yr = null, ti = null, rr = null;
      }
    };
  }
  const h = new a(), v = new s(), y = new u(), _ = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap();
  let M = {}, C = {}, D = /* @__PURE__ */ new WeakMap(), U = [], N = null, O = !1, I = null, k = null, G = null, j = null, Y = null, Z = null, te = null, J = !1, q = null, oe = null, ye = null, de = null, xe = null;
  const Re = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let Pe = !1, Te = 0;
  const ue = n.getParameter(n.VERSION);
  ue.indexOf("WebGL") !== -1 ? (Te = parseFloat(/^WebGL (\d)/.exec(ue)[1]), Pe = Te >= 1) : ue.indexOf("OpenGL ES") !== -1 && (Te = parseFloat(/^OpenGL ES (\d)/.exec(ue)[1]), Pe = Te >= 2);
  let we = null, X = {};
  const me = n.getParameter(n.SCISSOR_BOX), ce = n.getParameter(n.VIEWPORT), Ue = new Ua().fromArray(me), Oe = new Ua().fromArray(ce);
  function Ze(ge, zt, Fe, ft) {
    const ln = new Uint8Array(4), zn = n.createTexture();
    n.bindTexture(ge, zn), n.texParameteri(ge, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(ge, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let yr = 0; yr < Fe; yr++)
      r && (ge === n.TEXTURE_3D || ge === n.TEXTURE_2D_ARRAY) ? n.texImage3D(zt, 0, n.RGBA, 1, 1, ft, 0, n.RGBA, n.UNSIGNED_BYTE, ln) : n.texImage2D(zt + yr, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, ln);
    return zn;
  }
  const je = {};
  je[n.TEXTURE_2D] = Ze(n.TEXTURE_2D, n.TEXTURE_2D, 1), je[n.TEXTURE_CUBE_MAP] = Ze(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r && (je[n.TEXTURE_2D_ARRAY] = Ze(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), je[n.TEXTURE_3D] = Ze(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)), h.setClear(0, 0, 0, 1), v.setClear(1), y.setClear(0), Je(n.DEPTH_TEST), v.setFunc(mR), gt(!1), Jt(gL), Je(n.CULL_FACE), et(kg);
  function Je(ge) {
    M[ge] !== !0 && (n.enable(ge), M[ge] = !0);
  }
  function at(ge) {
    M[ge] !== !1 && (n.disable(ge), M[ge] = !1);
  }
  function xt(ge, zt) {
    return C[ge] !== zt ? (n.bindFramebuffer(ge, zt), C[ge] = zt, r && (ge === n.DRAW_FRAMEBUFFER && (C[n.FRAMEBUFFER] = zt), ge === n.FRAMEBUFFER && (C[n.DRAW_FRAMEBUFFER] = zt)), !0) : !1;
  }
  function $t(ge, zt) {
    let Fe = U, ft = !1;
    if (ge)
      if (Fe = D.get(zt), Fe === void 0 && (Fe = [], D.set(zt, Fe)), ge.isWebGLMultipleRenderTargets) {
        const ln = ge.texture;
        if (Fe.length !== ln.length || Fe[0] !== n.COLOR_ATTACHMENT0) {
          for (let zn = 0, yr = ln.length; zn < yr; zn++)
            Fe[zn] = n.COLOR_ATTACHMENT0 + zn;
          Fe.length = ln.length, ft = !0;
        }
      } else
        Fe[0] !== n.COLOR_ATTACHMENT0 && (Fe[0] = n.COLOR_ATTACHMENT0, ft = !0);
    else
      Fe[0] !== n.BACK && (Fe[0] = n.BACK, ft = !0);
    ft && (t.isWebGL2 ? n.drawBuffers(Fe) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Fe));
  }
  function Ht(ge) {
    return N !== ge ? (n.useProgram(ge), N = ge, !0) : !1;
  }
  const he = {
    [XS]: n.FUNC_ADD,
    [NI]: n.FUNC_SUBTRACT,
    [UI]: n.FUNC_REVERSE_SUBTRACT
  };
  if (r)
    he[_L] = n.MIN, he[EL] = n.MAX;
  else {
    const ge = e.get("EXT_blend_minmax");
    ge !== null && (he[_L] = ge.MIN_EXT, he[EL] = ge.MAX_EXT);
  }
  const nt = {
    [zI]: n.ZERO,
    [kI]: n.ONE,
    [II]: n.SRC_COLOR,
    [zO]: n.SRC_ALPHA,
    [WI]: n.SRC_ALPHA_SATURATE,
    [VI]: n.DST_COLOR,
    [BI]: n.DST_ALPHA,
    [FI]: n.ONE_MINUS_SRC_COLOR,
    [kO]: n.ONE_MINUS_SRC_ALPHA,
    [GI]: n.ONE_MINUS_DST_COLOR,
    [HI]: n.ONE_MINUS_DST_ALPHA
  };
  function et(ge, zt, Fe, ft, ln, zn, yr, ti) {
    if (ge === kg) {
      O === !0 && (at(n.BLEND), O = !1);
      return;
    }
    if (O === !1 && (Je(n.BLEND), O = !0), ge !== PI) {
      if (ge !== I || ti !== J) {
        if ((k !== XS || Y !== XS) && (n.blendEquation(n.FUNC_ADD), k = XS, Y = XS), ti)
          switch (ge) {
            case tx:
              n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case yL:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case SL:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case xL:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ge);
              break;
          }
        else
          switch (ge) {
            case tx:
              n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case yL:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case SL:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case xL:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ge);
              break;
          }
        G = null, j = null, Z = null, te = null, I = ge, J = ti;
      }
      return;
    }
    ln = ln || zt, zn = zn || Fe, yr = yr || ft, (zt !== k || ln !== Y) && (n.blendEquationSeparate(he[zt], he[ln]), k = zt, Y = ln), (Fe !== G || ft !== j || zn !== Z || yr !== te) && (n.blendFuncSeparate(nt[Fe], nt[ft], nt[zn], nt[yr]), G = Fe, j = ft, Z = zn, te = yr), I = ge, J = !1;
  }
  function Rt(ge, zt) {
    ge.side === mv ? at(n.CULL_FACE) : Je(n.CULL_FACE);
    let Fe = ge.side === bf;
    zt && (Fe = !Fe), gt(Fe), ge.blending === tx && ge.transparent === !1 ? et(kg) : et(ge.blending, ge.blendEquation, ge.blendSrc, ge.blendDst, ge.blendEquationAlpha, ge.blendSrcAlpha, ge.blendDstAlpha, ge.premultipliedAlpha), v.setFunc(ge.depthFunc), v.setTest(ge.depthTest), v.setMask(ge.depthWrite), h.setMask(ge.colorWrite);
    const ft = ge.stencilWrite;
    y.setTest(ft), ft && (y.setMask(ge.stencilWriteMask), y.setFunc(ge.stencilFunc, ge.stencilRef, ge.stencilFuncMask), y.setOp(ge.stencilFail, ge.stencilZFail, ge.stencilZPass)), qt(ge.polygonOffset, ge.polygonOffsetFactor, ge.polygonOffsetUnits), ge.alphaToCoverage === !0 ? Je(n.SAMPLE_ALPHA_TO_COVERAGE) : at(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function gt(ge) {
    q !== ge && (ge ? n.frontFace(n.CW) : n.frontFace(n.CCW), q = ge);
  }
  function Jt(ge) {
    ge !== DI ? (Je(n.CULL_FACE), ge !== oe && (ge === gL ? n.cullFace(n.BACK) : ge === LI ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : at(n.CULL_FACE), oe = ge;
  }
  function Kt(ge) {
    ge !== ye && (Pe && n.lineWidth(ge), ye = ge);
  }
  function qt(ge, zt, Fe) {
    ge ? (Je(n.POLYGON_OFFSET_FILL), (de !== zt || xe !== Fe) && (n.polygonOffset(zt, Fe), de = zt, xe = Fe)) : at(n.POLYGON_OFFSET_FILL);
  }
  function hn(ge) {
    ge ? Je(n.SCISSOR_TEST) : at(n.SCISSOR_TEST);
  }
  function Rn(ge) {
    ge === void 0 && (ge = n.TEXTURE0 + Re - 1), we !== ge && (n.activeTexture(ge), we = ge);
  }
  function Yn(ge, zt, Fe) {
    Fe === void 0 && (we === null ? Fe = n.TEXTURE0 + Re - 1 : Fe = we);
    let ft = X[Fe];
    ft === void 0 && (ft = { type: void 0, texture: void 0 }, X[Fe] = ft), (ft.type !== ge || ft.texture !== zt) && (we !== Fe && (n.activeTexture(Fe), we = Fe), n.bindTexture(ge, zt || je[ge]), ft.type = ge, ft.texture = zt);
  }
  function se() {
    const ge = X[we];
    ge !== void 0 && ge.type !== void 0 && (n.bindTexture(ge.type, null), ge.type = void 0, ge.texture = void 0);
  }
  function ae() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function Ke() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function wt() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function _t() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function Vt() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function fn() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function Wt() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function Ee() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function Xe() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function St() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function Ut(ge) {
    Ue.equals(ge) === !1 && (n.scissor(ge.x, ge.y, ge.z, ge.w), Ue.copy(ge));
  }
  function Se(ge) {
    Oe.equals(ge) === !1 && (n.viewport(ge.x, ge.y, ge.z, ge.w), Oe.copy(ge));
  }
  function Ye(ge, zt) {
    let Fe = b.get(zt);
    Fe === void 0 && (Fe = /* @__PURE__ */ new WeakMap(), b.set(zt, Fe));
    let ft = Fe.get(ge);
    ft === void 0 && (ft = n.getUniformBlockIndex(zt, ge.name), Fe.set(ge, ft));
  }
  function bt(ge, zt) {
    const ft = b.get(zt).get(ge);
    _.get(zt) !== ft && (n.uniformBlockBinding(zt, ft, ge.__bindingPointIndex), _.set(zt, ft));
  }
  function Tt() {
    n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), r === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), M = {}, we = null, X = {}, C = {}, D = /* @__PURE__ */ new WeakMap(), U = [], N = null, O = !1, I = null, k = null, G = null, j = null, Y = null, Z = null, te = null, J = !1, q = null, oe = null, ye = null, de = null, xe = null, Ue.set(0, 0, n.canvas.width, n.canvas.height), Oe.set(0, 0, n.canvas.width, n.canvas.height), h.reset(), v.reset(), y.reset();
  }
  return {
    buffers: {
      color: h,
      depth: v,
      stencil: y
    },
    enable: Je,
    disable: at,
    bindFramebuffer: xt,
    drawBuffers: $t,
    useProgram: Ht,
    setBlending: et,
    setMaterial: Rt,
    setFlipSided: gt,
    setCullFace: Jt,
    setLineWidth: Kt,
    setPolygonOffset: qt,
    setScissorTest: hn,
    activeTexture: Rn,
    bindTexture: Yn,
    unbindTexture: se,
    compressedTexImage2D: ae,
    compressedTexImage3D: Ke,
    texImage2D: Xe,
    texImage3D: St,
    updateUBOMapping: Ye,
    uniformBlockBinding: bt,
    texStorage2D: Wt,
    texStorage3D: Ee,
    texSubImage2D: wt,
    texSubImage3D: _t,
    compressedTexSubImage2D: Vt,
    compressedTexSubImage3D: fn,
    scissor: Ut,
    viewport: Se,
    reset: Tt
  };
}
function e$(n, e, t, r, a, s, u) {
  const h = a.isWebGL2, v = a.maxTextures, y = a.maxCubemapSize, _ = a.maxTextureSize, b = a.maxSamples, M = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, C = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), D = /* @__PURE__ */ new WeakMap();
  let U;
  const N = /* @__PURE__ */ new WeakMap();
  let O = !1;
  try {
    O = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function I(se, ae) {
    return O ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(se, ae)
    ) : OT("canvas");
  }
  function k(se, ae, Ke, wt) {
    let _t = 1;
    if ((se.width > wt || se.height > wt) && (_t = wt / Math.max(se.width, se.height)), _t < 1 || ae === !0)
      if (typeof HTMLImageElement < "u" && se instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && se instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && se instanceof ImageBitmap) {
        const Vt = ae ? yR : Math.floor, fn = Vt(_t * se.width), Wt = Vt(_t * se.height);
        U === void 0 && (U = I(fn, Wt));
        const Ee = Ke ? I(fn, Wt) : U;
        return Ee.width = fn, Ee.height = Wt, Ee.getContext("2d").drawImage(se, 0, 0, fn, Wt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + se.width + "x" + se.height + ") to (" + fn + "x" + Wt + ")."), Ee;
      } else
        return "data" in se && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + se.width + "x" + se.height + ")."), se;
    return se;
  }
  function G(se) {
    return YL(se.width) && YL(se.height);
  }
  function j(se) {
    return h ? !1 : se.wrapS !== Dc || se.wrapT !== Dc || se.minFilter !== el && se.minFilter !== tl;
  }
  function Y(se, ae) {
    return se.generateMipmaps && ae && se.minFilter !== el && se.minFilter !== tl;
  }
  function Z(se) {
    n.generateMipmap(se);
  }
  function te(se, ae, Ke, wt, _t = !1) {
    if (h === !1)
      return ae;
    if (se !== null) {
      if (n[se] !== void 0)
        return n[se];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + se + "'");
    }
    let Vt = ae;
    return ae === n.RED && (Ke === n.FLOAT && (Vt = n.R32F), Ke === n.HALF_FLOAT && (Vt = n.R16F), Ke === n.UNSIGNED_BYTE && (Vt = n.R8)), ae === n.RG && (Ke === n.FLOAT && (Vt = n.RG32F), Ke === n.HALF_FLOAT && (Vt = n.RG16F), Ke === n.UNSIGNED_BYTE && (Vt = n.RG8)), ae === n.RGBA && (Ke === n.FLOAT && (Vt = n.RGBA32F), Ke === n.HALF_FLOAT && (Vt = n.RGBA16F), Ke === n.UNSIGNED_BYTE && (Vt = wt === ai && _t === !1 ? n.SRGB8_ALPHA8 : n.RGBA8), Ke === n.UNSIGNED_SHORT_4_4_4_4 && (Vt = n.RGBA4), Ke === n.UNSIGNED_SHORT_5_5_5_1 && (Vt = n.RGB5_A1)), (Vt === n.R16F || Vt === n.R32F || Vt === n.RG16F || Vt === n.RG32F || Vt === n.RGBA16F || Vt === n.RGBA32F) && e.get("EXT_color_buffer_float"), Vt;
  }
  function J(se, ae, Ke) {
    return Y(se, Ke) === !0 || se.isFramebufferTexture && se.minFilter !== el && se.minFilter !== tl ? Math.log2(Math.max(ae.width, ae.height)) + 1 : se.mipmaps !== void 0 && se.mipmaps.length > 0 ? se.mipmaps.length : se.isCompressedTexture && Array.isArray(se.image) ? ae.mipmaps.length : 1;
  }
  function q(se) {
    return se === el || se === vR || se === mT ? n.NEAREST : n.LINEAR;
  }
  function oe(se) {
    const ae = se.target;
    ae.removeEventListener("dispose", oe), de(ae), ae.isVideoTexture && D.delete(ae);
  }
  function ye(se) {
    const ae = se.target;
    ae.removeEventListener("dispose", ye), Re(ae);
  }
  function de(se) {
    const ae = r.get(se);
    if (ae.__webglInit === void 0)
      return;
    const Ke = se.source, wt = N.get(Ke);
    if (wt) {
      const _t = wt[ae.__cacheKey];
      _t.usedTimes--, _t.usedTimes === 0 && xe(se), Object.keys(wt).length === 0 && N.delete(Ke);
    }
    r.remove(se);
  }
  function xe(se) {
    const ae = r.get(se);
    n.deleteTexture(ae.__webglTexture);
    const Ke = se.source, wt = N.get(Ke);
    delete wt[ae.__cacheKey], u.memory.textures--;
  }
  function Re(se) {
    const ae = se.texture, Ke = r.get(se), wt = r.get(ae);
    if (wt.__webglTexture !== void 0 && (n.deleteTexture(wt.__webglTexture), u.memory.textures--), se.depthTexture && se.depthTexture.dispose(), se.isWebGLCubeRenderTarget)
      for (let _t = 0; _t < 6; _t++)
        n.deleteFramebuffer(Ke.__webglFramebuffer[_t]), Ke.__webglDepthbuffer && n.deleteRenderbuffer(Ke.__webglDepthbuffer[_t]);
    else {
      if (n.deleteFramebuffer(Ke.__webglFramebuffer), Ke.__webglDepthbuffer && n.deleteRenderbuffer(Ke.__webglDepthbuffer), Ke.__webglMultisampledFramebuffer && n.deleteFramebuffer(Ke.__webglMultisampledFramebuffer), Ke.__webglColorRenderbuffer)
        for (let _t = 0; _t < Ke.__webglColorRenderbuffer.length; _t++)
          Ke.__webglColorRenderbuffer[_t] && n.deleteRenderbuffer(Ke.__webglColorRenderbuffer[_t]);
      Ke.__webglDepthRenderbuffer && n.deleteRenderbuffer(Ke.__webglDepthRenderbuffer);
    }
    if (se.isWebGLMultipleRenderTargets)
      for (let _t = 0, Vt = ae.length; _t < Vt; _t++) {
        const fn = r.get(ae[_t]);
        fn.__webglTexture && (n.deleteTexture(fn.__webglTexture), u.memory.textures--), r.remove(ae[_t]);
      }
    r.remove(ae), r.remove(se);
  }
  let Pe = 0;
  function Te() {
    Pe = 0;
  }
  function ue() {
    const se = Pe;
    return se >= v && console.warn("THREE.WebGLTextures: Trying to use " + se + " texture units while this GPU supports only " + v), Pe += 1, se;
  }
  function we(se) {
    const ae = [];
    return ae.push(se.wrapS), ae.push(se.wrapT), ae.push(se.wrapR || 0), ae.push(se.magFilter), ae.push(se.minFilter), ae.push(se.anisotropy), ae.push(se.internalFormat), ae.push(se.format), ae.push(se.type), ae.push(se.generateMipmaps), ae.push(se.premultiplyAlpha), ae.push(se.flipY), ae.push(se.unpackAlignment), ae.push(se.colorSpace), ae.join();
  }
  function X(se, ae) {
    const Ke = r.get(se);
    if (se.isVideoTexture && Rn(se), se.isRenderTargetTexture === !1 && se.version > 0 && Ke.__version !== se.version) {
      const wt = se.image;
      if (wt === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (wt.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        xt(Ke, se, ae);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, Ke.__webglTexture, n.TEXTURE0 + ae);
  }
  function me(se, ae) {
    const Ke = r.get(se);
    if (se.version > 0 && Ke.__version !== se.version) {
      xt(Ke, se, ae);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, Ke.__webglTexture, n.TEXTURE0 + ae);
  }
  function ce(se, ae) {
    const Ke = r.get(se);
    if (se.version > 0 && Ke.__version !== se.version) {
      xt(Ke, se, ae);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, Ke.__webglTexture, n.TEXTURE0 + ae);
  }
  function Ue(se, ae) {
    const Ke = r.get(se);
    if (se.version > 0 && Ke.__version !== se.version) {
      $t(Ke, se, ae);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, Ke.__webglTexture, n.TEXTURE0 + ae);
  }
  const Oe = {
    [MT]: n.REPEAT,
    [Dc]: n.CLAMP_TO_EDGE,
    [wT]: n.MIRRORED_REPEAT
  }, Ze = {
    [el]: n.NEAREST,
    [vR]: n.NEAREST_MIPMAP_NEAREST,
    [mT]: n.NEAREST_MIPMAP_LINEAR,
    [tl]: n.LINEAR,
    [FO]: n.LINEAR_MIPMAP_NEAREST,
    [h0]: n.LINEAR_MIPMAP_LINEAR
  }, je = {
    [xF]: n.NEVER,
    [CF]: n.ALWAYS,
    [_F]: n.LESS,
    [bF]: n.LEQUAL,
    [EF]: n.EQUAL,
    [wF]: n.GEQUAL,
    [TF]: n.GREATER,
    [MF]: n.NOTEQUAL
  };
  function Je(se, ae, Ke) {
    if (Ke ? (n.texParameteri(se, n.TEXTURE_WRAP_S, Oe[ae.wrapS]), n.texParameteri(se, n.TEXTURE_WRAP_T, Oe[ae.wrapT]), (se === n.TEXTURE_3D || se === n.TEXTURE_2D_ARRAY) && n.texParameteri(se, n.TEXTURE_WRAP_R, Oe[ae.wrapR]), n.texParameteri(se, n.TEXTURE_MAG_FILTER, Ze[ae.magFilter]), n.texParameteri(se, n.TEXTURE_MIN_FILTER, Ze[ae.minFilter])) : (n.texParameteri(se, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(se, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), (se === n.TEXTURE_3D || se === n.TEXTURE_2D_ARRAY) && n.texParameteri(se, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE), (ae.wrapS !== Dc || ae.wrapT !== Dc) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(se, n.TEXTURE_MAG_FILTER, q(ae.magFilter)), n.texParameteri(se, n.TEXTURE_MIN_FILTER, q(ae.minFilter)), ae.minFilter !== el && ae.minFilter !== tl && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), ae.compareFunction && (n.texParameteri(se, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(se, n.TEXTURE_COMPARE_FUNC, je[ae.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      const wt = e.get("EXT_texture_filter_anisotropic");
      if (ae.magFilter === el || ae.minFilter !== mT && ae.minFilter !== h0 || ae.type === vv && e.has("OES_texture_float_linear") === !1 || h === !1 && ae.type === UE && e.has("OES_texture_half_float_linear") === !1)
        return;
      (ae.anisotropy > 1 || r.get(ae).__currentAnisotropy) && (n.texParameterf(se, wt.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(ae.anisotropy, a.getMaxAnisotropy())), r.get(ae).__currentAnisotropy = ae.anisotropy);
    }
  }
  function at(se, ae) {
    let Ke = !1;
    se.__webglInit === void 0 && (se.__webglInit = !0, ae.addEventListener("dispose", oe));
    const wt = ae.source;
    let _t = N.get(wt);
    _t === void 0 && (_t = {}, N.set(wt, _t));
    const Vt = we(ae);
    if (Vt !== se.__cacheKey) {
      _t[Vt] === void 0 && (_t[Vt] = {
        texture: n.createTexture(),
        usedTimes: 0
      }, u.memory.textures++, Ke = !0), _t[Vt].usedTimes++;
      const fn = _t[se.__cacheKey];
      fn !== void 0 && (_t[se.__cacheKey].usedTimes--, fn.usedTimes === 0 && xe(ae)), se.__cacheKey = Vt, se.__webglTexture = _t[Vt].texture;
    }
    return Ke;
  }
  function xt(se, ae, Ke) {
    let wt = n.TEXTURE_2D;
    (ae.isDataArrayTexture || ae.isCompressedArrayTexture) && (wt = n.TEXTURE_2D_ARRAY), ae.isData3DTexture && (wt = n.TEXTURE_3D);
    const _t = at(se, ae), Vt = ae.source;
    t.bindTexture(wt, se.__webglTexture, n.TEXTURE0 + Ke);
    const fn = r.get(Vt);
    if (Vt.version !== fn.__version || _t === !0) {
      t.activeTexture(n.TEXTURE0 + Ke), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, ae.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ae.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, ae.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const Wt = j(ae) && G(ae.image) === !1;
      let Ee = k(ae.image, Wt, !1, _);
      Ee = Yn(ae, Ee);
      const Xe = G(Ee) || h, St = s.convert(ae.format, ae.colorSpace);
      let Ut = s.convert(ae.type), Se = te(ae.internalFormat, St, Ut, ae.colorSpace);
      Je(wt, ae, Xe);
      let Ye;
      const bt = ae.mipmaps, Tt = h && ae.isVideoTexture !== !0, ge = fn.__version === void 0 || _t === !0, zt = J(ae, Ee, Xe);
      if (ae.isDepthTexture)
        Se = n.DEPTH_COMPONENT, h ? ae.type === vv ? Se = n.DEPTH_COMPONENT32F : ae.type === Ug ? Se = n.DEPTH_COMPONENT24 : ae.type === s0 ? Se = n.DEPTH24_STENCIL8 : Se = n.DEPTH_COMPONENT16 : ae.type === vv && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), ae.format === l0 && Se === n.DEPTH_COMPONENT && ae.type !== BR && ae.type !== Ug && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), ae.type = Ug, Ut = s.convert(ae.type)), ae.format === sx && Se === n.DEPTH_COMPONENT && (Se = n.DEPTH_STENCIL, ae.type !== s0 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), ae.type = s0, Ut = s.convert(ae.type))), ge && (Tt ? t.texStorage2D(n.TEXTURE_2D, 1, Se, Ee.width, Ee.height) : t.texImage2D(n.TEXTURE_2D, 0, Se, Ee.width, Ee.height, 0, St, Ut, null));
      else if (ae.isDataTexture)
        if (bt.length > 0 && Xe) {
          Tt && ge && t.texStorage2D(n.TEXTURE_2D, zt, Se, bt[0].width, bt[0].height);
          for (let Fe = 0, ft = bt.length; Fe < ft; Fe++)
            Ye = bt[Fe], Tt ? t.texSubImage2D(n.TEXTURE_2D, Fe, 0, 0, Ye.width, Ye.height, St, Ut, Ye.data) : t.texImage2D(n.TEXTURE_2D, Fe, Se, Ye.width, Ye.height, 0, St, Ut, Ye.data);
          ae.generateMipmaps = !1;
        } else
          Tt ? (ge && t.texStorage2D(n.TEXTURE_2D, zt, Se, Ee.width, Ee.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Ee.width, Ee.height, St, Ut, Ee.data)) : t.texImage2D(n.TEXTURE_2D, 0, Se, Ee.width, Ee.height, 0, St, Ut, Ee.data);
      else if (ae.isCompressedTexture)
        if (ae.isCompressedArrayTexture) {
          Tt && ge && t.texStorage3D(n.TEXTURE_2D_ARRAY, zt, Se, bt[0].width, bt[0].height, Ee.depth);
          for (let Fe = 0, ft = bt.length; Fe < ft; Fe++)
            Ye = bt[Fe], ae.format !== dd ? St !== null ? Tt ? t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Fe, 0, 0, 0, Ye.width, Ye.height, Ee.depth, St, Ye.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, Fe, Se, Ye.width, Ye.height, Ee.depth, 0, Ye.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Tt ? t.texSubImage3D(n.TEXTURE_2D_ARRAY, Fe, 0, 0, 0, Ye.width, Ye.height, Ee.depth, St, Ut, Ye.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, Fe, Se, Ye.width, Ye.height, Ee.depth, 0, St, Ut, Ye.data);
        } else {
          Tt && ge && t.texStorage2D(n.TEXTURE_2D, zt, Se, bt[0].width, bt[0].height);
          for (let Fe = 0, ft = bt.length; Fe < ft; Fe++)
            Ye = bt[Fe], ae.format !== dd ? St !== null ? Tt ? t.compressedTexSubImage2D(n.TEXTURE_2D, Fe, 0, 0, Ye.width, Ye.height, St, Ye.data) : t.compressedTexImage2D(n.TEXTURE_2D, Fe, Se, Ye.width, Ye.height, 0, Ye.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Tt ? t.texSubImage2D(n.TEXTURE_2D, Fe, 0, 0, Ye.width, Ye.height, St, Ut, Ye.data) : t.texImage2D(n.TEXTURE_2D, Fe, Se, Ye.width, Ye.height, 0, St, Ut, Ye.data);
        }
      else if (ae.isDataArrayTexture)
        Tt ? (ge && t.texStorage3D(n.TEXTURE_2D_ARRAY, zt, Se, Ee.width, Ee.height, Ee.depth), t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Ee.width, Ee.height, Ee.depth, St, Ut, Ee.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, Se, Ee.width, Ee.height, Ee.depth, 0, St, Ut, Ee.data);
      else if (ae.isData3DTexture)
        Tt ? (ge && t.texStorage3D(n.TEXTURE_3D, zt, Se, Ee.width, Ee.height, Ee.depth), t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Ee.width, Ee.height, Ee.depth, St, Ut, Ee.data)) : t.texImage3D(n.TEXTURE_3D, 0, Se, Ee.width, Ee.height, Ee.depth, 0, St, Ut, Ee.data);
      else if (ae.isFramebufferTexture) {
        if (ge)
          if (Tt)
            t.texStorage2D(n.TEXTURE_2D, zt, Se, Ee.width, Ee.height);
          else {
            let Fe = Ee.width, ft = Ee.height;
            for (let ln = 0; ln < zt; ln++)
              t.texImage2D(n.TEXTURE_2D, ln, Se, Fe, ft, 0, St, Ut, null), Fe >>= 1, ft >>= 1;
          }
      } else if (bt.length > 0 && Xe) {
        Tt && ge && t.texStorage2D(n.TEXTURE_2D, zt, Se, bt[0].width, bt[0].height);
        for (let Fe = 0, ft = bt.length; Fe < ft; Fe++)
          Ye = bt[Fe], Tt ? t.texSubImage2D(n.TEXTURE_2D, Fe, 0, 0, St, Ut, Ye) : t.texImage2D(n.TEXTURE_2D, Fe, Se, St, Ut, Ye);
        ae.generateMipmaps = !1;
      } else
        Tt ? (ge && t.texStorage2D(n.TEXTURE_2D, zt, Se, Ee.width, Ee.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, St, Ut, Ee)) : t.texImage2D(n.TEXTURE_2D, 0, Se, St, Ut, Ee);
      Y(ae, Xe) && Z(wt), fn.__version = Vt.version, ae.onUpdate && ae.onUpdate(ae);
    }
    se.__version = ae.version;
  }
  function $t(se, ae, Ke) {
    if (ae.image.length !== 6)
      return;
    const wt = at(se, ae), _t = ae.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, se.__webglTexture, n.TEXTURE0 + Ke);
    const Vt = r.get(_t);
    if (_t.version !== Vt.__version || wt === !0) {
      t.activeTexture(n.TEXTURE0 + Ke), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, ae.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ae.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, ae.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const fn = ae.isCompressedTexture || ae.image[0].isCompressedTexture, Wt = ae.image[0] && ae.image[0].isDataTexture, Ee = [];
      for (let Fe = 0; Fe < 6; Fe++)
        !fn && !Wt ? Ee[Fe] = k(ae.image[Fe], !1, !0, y) : Ee[Fe] = Wt ? ae.image[Fe].image : ae.image[Fe], Ee[Fe] = Yn(ae, Ee[Fe]);
      const Xe = Ee[0], St = G(Xe) || h, Ut = s.convert(ae.format, ae.colorSpace), Se = s.convert(ae.type), Ye = te(ae.internalFormat, Ut, Se, ae.colorSpace), bt = h && ae.isVideoTexture !== !0, Tt = Vt.__version === void 0 || wt === !0;
      let ge = J(ae, Xe, St);
      Je(n.TEXTURE_CUBE_MAP, ae, St);
      let zt;
      if (fn) {
        bt && Tt && t.texStorage2D(n.TEXTURE_CUBE_MAP, ge, Ye, Xe.width, Xe.height);
        for (let Fe = 0; Fe < 6; Fe++) {
          zt = Ee[Fe].mipmaps;
          for (let ft = 0; ft < zt.length; ft++) {
            const ln = zt[ft];
            ae.format !== dd ? Ut !== null ? bt ? t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ft, 0, 0, ln.width, ln.height, Ut, ln.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ft, Ye, ln.width, ln.height, 0, ln.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : bt ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ft, 0, 0, ln.width, ln.height, Ut, Se, ln.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ft, Ye, ln.width, ln.height, 0, Ut, Se, ln.data);
          }
        }
      } else {
        zt = ae.mipmaps, bt && Tt && (zt.length > 0 && ge++, t.texStorage2D(n.TEXTURE_CUBE_MAP, ge, Ye, Ee[0].width, Ee[0].height));
        for (let Fe = 0; Fe < 6; Fe++)
          if (Wt) {
            bt ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, 0, 0, 0, Ee[Fe].width, Ee[Fe].height, Ut, Se, Ee[Fe].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, 0, Ye, Ee[Fe].width, Ee[Fe].height, 0, Ut, Se, Ee[Fe].data);
            for (let ft = 0; ft < zt.length; ft++) {
              const zn = zt[ft].image[Fe].image;
              bt ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ft + 1, 0, 0, zn.width, zn.height, Ut, Se, zn.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ft + 1, Ye, zn.width, zn.height, 0, Ut, Se, zn.data);
            }
          } else {
            bt ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, 0, 0, 0, Ut, Se, Ee[Fe]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, 0, Ye, Ut, Se, Ee[Fe]);
            for (let ft = 0; ft < zt.length; ft++) {
              const ln = zt[ft];
              bt ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ft + 1, 0, 0, Ut, Se, ln.image[Fe]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, ft + 1, Ye, Ut, Se, ln.image[Fe]);
            }
          }
      }
      Y(ae, St) && Z(n.TEXTURE_CUBE_MAP), Vt.__version = _t.version, ae.onUpdate && ae.onUpdate(ae);
    }
    se.__version = ae.version;
  }
  function Ht(se, ae, Ke, wt, _t) {
    const Vt = s.convert(Ke.format, Ke.colorSpace), fn = s.convert(Ke.type), Wt = te(Ke.internalFormat, Vt, fn, Ke.colorSpace);
    r.get(ae).__hasExternalTextures || (_t === n.TEXTURE_3D || _t === n.TEXTURE_2D_ARRAY ? t.texImage3D(_t, 0, Wt, ae.width, ae.height, ae.depth, 0, Vt, fn, null) : t.texImage2D(_t, 0, Wt, ae.width, ae.height, 0, Vt, fn, null)), t.bindFramebuffer(n.FRAMEBUFFER, se), hn(ae) ? M.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, wt, _t, r.get(Ke).__webglTexture, 0, qt(ae)) : (_t === n.TEXTURE_2D || _t >= n.TEXTURE_CUBE_MAP_POSITIVE_X && _t <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, wt, _t, r.get(Ke).__webglTexture, 0), t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function he(se, ae, Ke) {
    if (n.bindRenderbuffer(n.RENDERBUFFER, se), ae.depthBuffer && !ae.stencilBuffer) {
      let wt = n.DEPTH_COMPONENT16;
      if (Ke || hn(ae)) {
        const _t = ae.depthTexture;
        _t && _t.isDepthTexture && (_t.type === vv ? wt = n.DEPTH_COMPONENT32F : _t.type === Ug && (wt = n.DEPTH_COMPONENT24));
        const Vt = qt(ae);
        hn(ae) ? M.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Vt, wt, ae.width, ae.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, Vt, wt, ae.width, ae.height);
      } else
        n.renderbufferStorage(n.RENDERBUFFER, wt, ae.width, ae.height);
      n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, se);
    } else if (ae.depthBuffer && ae.stencilBuffer) {
      const wt = qt(ae);
      Ke && hn(ae) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, wt, n.DEPTH24_STENCIL8, ae.width, ae.height) : hn(ae) ? M.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, wt, n.DEPTH24_STENCIL8, ae.width, ae.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, ae.width, ae.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, se);
    } else {
      const wt = ae.isWebGLMultipleRenderTargets === !0 ? ae.texture : [ae.texture];
      for (let _t = 0; _t < wt.length; _t++) {
        const Vt = wt[_t], fn = s.convert(Vt.format, Vt.colorSpace), Wt = s.convert(Vt.type), Ee = te(Vt.internalFormat, fn, Wt, Vt.colorSpace), Xe = qt(ae);
        Ke && hn(ae) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Xe, Ee, ae.width, ae.height) : hn(ae) ? M.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Xe, Ee, ae.width, ae.height) : n.renderbufferStorage(n.RENDERBUFFER, Ee, ae.width, ae.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function nt(se, ae) {
    if (ae && ae.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(n.FRAMEBUFFER, se), !(ae.depthTexture && ae.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!r.get(ae.depthTexture).__webglTexture || ae.depthTexture.image.width !== ae.width || ae.depthTexture.image.height !== ae.height) && (ae.depthTexture.image.width = ae.width, ae.depthTexture.image.height = ae.height, ae.depthTexture.needsUpdate = !0), X(ae.depthTexture, 0);
    const wt = r.get(ae.depthTexture).__webglTexture, _t = qt(ae);
    if (ae.depthTexture.format === l0)
      hn(ae) ? M.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, wt, 0, _t) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, wt, 0);
    else if (ae.depthTexture.format === sx)
      hn(ae) ? M.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, wt, 0, _t) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, wt, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function et(se) {
    const ae = r.get(se), Ke = se.isWebGLCubeRenderTarget === !0;
    if (se.depthTexture && !ae.__autoAllocateDepthBuffer) {
      if (Ke)
        throw new Error("target.depthTexture not supported in Cube render targets");
      nt(ae.__webglFramebuffer, se);
    } else if (Ke) {
      ae.__webglDepthbuffer = [];
      for (let wt = 0; wt < 6; wt++)
        t.bindFramebuffer(n.FRAMEBUFFER, ae.__webglFramebuffer[wt]), ae.__webglDepthbuffer[wt] = n.createRenderbuffer(), he(ae.__webglDepthbuffer[wt], se, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, ae.__webglFramebuffer), ae.__webglDepthbuffer = n.createRenderbuffer(), he(ae.__webglDepthbuffer, se, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Rt(se, ae, Ke) {
    const wt = r.get(se);
    ae !== void 0 && Ht(wt.__webglFramebuffer, se, se.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D), Ke !== void 0 && et(se);
  }
  function gt(se) {
    const ae = se.texture, Ke = r.get(se), wt = r.get(ae);
    se.addEventListener("dispose", ye), se.isWebGLMultipleRenderTargets !== !0 && (wt.__webglTexture === void 0 && (wt.__webglTexture = n.createTexture()), wt.__version = ae.version, u.memory.textures++);
    const _t = se.isWebGLCubeRenderTarget === !0, Vt = se.isWebGLMultipleRenderTargets === !0, fn = G(se) || h;
    if (_t) {
      Ke.__webglFramebuffer = [];
      for (let Wt = 0; Wt < 6; Wt++)
        Ke.__webglFramebuffer[Wt] = n.createFramebuffer();
    } else {
      if (Ke.__webglFramebuffer = n.createFramebuffer(), Vt)
        if (a.drawBuffers) {
          const Wt = se.texture;
          for (let Ee = 0, Xe = Wt.length; Ee < Xe; Ee++) {
            const St = r.get(Wt[Ee]);
            St.__webglTexture === void 0 && (St.__webglTexture = n.createTexture(), u.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (h && se.samples > 0 && hn(se) === !1) {
        const Wt = Vt ? ae : [ae];
        Ke.__webglMultisampledFramebuffer = n.createFramebuffer(), Ke.__webglColorRenderbuffer = [], t.bindFramebuffer(n.FRAMEBUFFER, Ke.__webglMultisampledFramebuffer);
        for (let Ee = 0; Ee < Wt.length; Ee++) {
          const Xe = Wt[Ee];
          Ke.__webglColorRenderbuffer[Ee] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, Ke.__webglColorRenderbuffer[Ee]);
          const St = s.convert(Xe.format, Xe.colorSpace), Ut = s.convert(Xe.type), Se = te(Xe.internalFormat, St, Ut, Xe.colorSpace, se.isXRRenderTarget === !0), Ye = qt(se);
          n.renderbufferStorageMultisample(n.RENDERBUFFER, Ye, Se, se.width, se.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ee, n.RENDERBUFFER, Ke.__webglColorRenderbuffer[Ee]);
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null), se.depthBuffer && (Ke.__webglDepthRenderbuffer = n.createRenderbuffer(), he(Ke.__webglDepthRenderbuffer, se, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (_t) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, wt.__webglTexture), Je(n.TEXTURE_CUBE_MAP, ae, fn);
      for (let Wt = 0; Wt < 6; Wt++)
        Ht(Ke.__webglFramebuffer[Wt], se, ae, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Wt);
      Y(ae, fn) && Z(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Vt) {
      const Wt = se.texture;
      for (let Ee = 0, Xe = Wt.length; Ee < Xe; Ee++) {
        const St = Wt[Ee], Ut = r.get(St);
        t.bindTexture(n.TEXTURE_2D, Ut.__webglTexture), Je(n.TEXTURE_2D, St, fn), Ht(Ke.__webglFramebuffer, se, St, n.COLOR_ATTACHMENT0 + Ee, n.TEXTURE_2D), Y(St, fn) && Z(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Wt = n.TEXTURE_2D;
      (se.isWebGL3DRenderTarget || se.isWebGLArrayRenderTarget) && (h ? Wt = se.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Wt, wt.__webglTexture), Je(Wt, ae, fn), Ht(Ke.__webglFramebuffer, se, ae, n.COLOR_ATTACHMENT0, Wt), Y(ae, fn) && Z(Wt), t.unbindTexture();
    }
    se.depthBuffer && et(se);
  }
  function Jt(se) {
    const ae = G(se) || h, Ke = se.isWebGLMultipleRenderTargets === !0 ? se.texture : [se.texture];
    for (let wt = 0, _t = Ke.length; wt < _t; wt++) {
      const Vt = Ke[wt];
      if (Y(Vt, ae)) {
        const fn = se.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D, Wt = r.get(Vt).__webglTexture;
        t.bindTexture(fn, Wt), Z(fn), t.unbindTexture();
      }
    }
  }
  function Kt(se) {
    if (h && se.samples > 0 && hn(se) === !1) {
      const ae = se.isWebGLMultipleRenderTargets ? se.texture : [se.texture], Ke = se.width, wt = se.height;
      let _t = n.COLOR_BUFFER_BIT;
      const Vt = [], fn = se.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, Wt = r.get(se), Ee = se.isWebGLMultipleRenderTargets === !0;
      if (Ee)
        for (let Xe = 0; Xe < ae.length; Xe++)
          t.bindFramebuffer(n.FRAMEBUFFER, Wt.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Xe, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, Wt.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Xe, n.TEXTURE_2D, null, 0);
      t.bindFramebuffer(n.READ_FRAMEBUFFER, Wt.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Wt.__webglFramebuffer);
      for (let Xe = 0; Xe < ae.length; Xe++) {
        Vt.push(n.COLOR_ATTACHMENT0 + Xe), se.depthBuffer && Vt.push(fn);
        const St = Wt.__ignoreDepthValues !== void 0 ? Wt.__ignoreDepthValues : !1;
        if (St === !1 && (se.depthBuffer && (_t |= n.DEPTH_BUFFER_BIT), se.stencilBuffer && (_t |= n.STENCIL_BUFFER_BIT)), Ee && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Wt.__webglColorRenderbuffer[Xe]), St === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [fn]), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [fn])), Ee) {
          const Ut = r.get(ae[Xe]).__webglTexture;
          n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, Ut, 0);
        }
        n.blitFramebuffer(0, 0, Ke, wt, 0, 0, Ke, wt, _t, n.NEAREST), C && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, Vt);
      }
      if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), Ee)
        for (let Xe = 0; Xe < ae.length; Xe++) {
          t.bindFramebuffer(n.FRAMEBUFFER, Wt.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Xe, n.RENDERBUFFER, Wt.__webglColorRenderbuffer[Xe]);
          const St = r.get(ae[Xe]).__webglTexture;
          t.bindFramebuffer(n.FRAMEBUFFER, Wt.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Xe, n.TEXTURE_2D, St, 0);
        }
      t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Wt.__webglMultisampledFramebuffer);
    }
  }
  function qt(se) {
    return Math.min(b, se.samples);
  }
  function hn(se) {
    const ae = r.get(se);
    return h && se.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && ae.__useRenderToTexture !== !1;
  }
  function Rn(se) {
    const ae = u.render.frame;
    D.get(se) !== ae && (D.set(se, ae), se.update());
  }
  function Yn(se, ae) {
    const Ke = se.colorSpace, wt = se.format, _t = se.type;
    return se.isCompressedTexture === !0 || se.format === gR || Ke !== nm && Ke !== c0 && (Ke === ai ? h === !1 ? e.has("EXT_sRGB") === !0 && wt === dd ? (se.format = gR, se.minFilter = tl, se.generateMipmaps = !1) : ae = KO.sRGBToLinear(ae) : (wt !== dd || _t !== Sv) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", Ke)), ae;
  }
  this.allocateTextureUnit = ue, this.resetTextureUnits = Te, this.setTexture2D = X, this.setTexture2DArray = me, this.setTexture3D = ce, this.setTextureCube = Ue, this.rebindTextures = Rt, this.setupRenderTarget = gt, this.updateRenderTargetMipmap = Jt, this.updateMultisampleRenderTarget = Kt, this.setupDepthRenderbuffer = et, this.setupFrameBufferTexture = Ht, this.useMultisampledRTT = hn;
}
function BF(n, e, t) {
  const r = t.isWebGL2;
  function a(s, u = c0) {
    let h;
    if (s === Sv)
      return n.UNSIGNED_BYTE;
    if (s === HO)
      return n.UNSIGNED_SHORT_4_4_4_4;
    if (s === VO)
      return n.UNSIGNED_SHORT_5_5_5_1;
    if (s === iF)
      return n.BYTE;
    if (s === aF)
      return n.SHORT;
    if (s === BR)
      return n.UNSIGNED_SHORT;
    if (s === BO)
      return n.INT;
    if (s === Ug)
      return n.UNSIGNED_INT;
    if (s === vv)
      return n.FLOAT;
    if (s === UE)
      return r ? n.HALF_FLOAT : (h = e.get("OES_texture_half_float"), h !== null ? h.HALF_FLOAT_OES : null);
    if (s === oF)
      return n.ALPHA;
    if (s === dd)
      return n.RGBA;
    if (s === sF)
      return n.LUMINANCE;
    if (s === lF)
      return n.LUMINANCE_ALPHA;
    if (s === l0)
      return n.DEPTH_COMPONENT;
    if (s === sx)
      return n.DEPTH_STENCIL;
    if (s === gR)
      return h = e.get("EXT_sRGB"), h !== null ? h.SRGB_ALPHA_EXT : null;
    if (s === uF)
      return n.RED;
    if (s === GO)
      return n.RED_INTEGER;
    if (s === cF)
      return n.RG;
    if (s === WO)
      return n.RG_INTEGER;
    if (s === jO)
      return n.RGBA_INTEGER;
    if (s === aR || s === oR || s === sR || s === lR)
      if (u === ai)
        if (h = e.get("WEBGL_compressed_texture_s3tc_srgb"), h !== null) {
          if (s === aR)
            return h.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === oR)
            return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === sR)
            return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === lR)
            return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (h = e.get("WEBGL_compressed_texture_s3tc"), h !== null) {
        if (s === aR)
          return h.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === oR)
          return h.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === sR)
          return h.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === lR)
          return h.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (s === bL || s === TL || s === ML || s === wL)
      if (h = e.get("WEBGL_compressed_texture_pvrtc"), h !== null) {
        if (s === bL)
          return h.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === TL)
          return h.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === ML)
          return h.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === wL)
          return h.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (s === fF)
      return h = e.get("WEBGL_compressed_texture_etc1"), h !== null ? h.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (s === CL || s === RL)
      if (h = e.get("WEBGL_compressed_texture_etc"), h !== null) {
        if (s === CL)
          return u === ai ? h.COMPRESSED_SRGB8_ETC2 : h.COMPRESSED_RGB8_ETC2;
        if (s === RL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : h.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (s === AL || s === DL || s === LL || s === OL || s === PL || s === NL || s === UL || s === zL || s === kL || s === IL || s === FL || s === BL || s === HL || s === VL)
      if (h = e.get("WEBGL_compressed_texture_astc"), h !== null) {
        if (s === AL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : h.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === DL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : h.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === LL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : h.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === OL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : h.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === PL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : h.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === NL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : h.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === UL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : h.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === zL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : h.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === kL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : h.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === IL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : h.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === FL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : h.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === BL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : h.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === HL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : h.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === VL)
          return u === ai ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : h.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (s === uR)
      if (h = e.get("EXT_texture_compression_bptc"), h !== null) {
        if (s === uR)
          return u === ai ? h.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : h.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    if (s === dF || s === GL || s === WL || s === jL)
      if (h = e.get("EXT_texture_compression_rgtc"), h !== null) {
        if (s === uR)
          return h.COMPRESSED_RED_RGTC1_EXT;
        if (s === GL)
          return h.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === WL)
          return h.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === jL)
          return h.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return s === s0 ? r ? n.UNSIGNED_INT_24_8 : (h = e.get("WEBGL_depth_texture"), h !== null ? h.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null;
  }
  return { convert: a };
}
class HF extends Cs {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class CE extends ha {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const t$ = { type: "move" };
class M2 {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new CE(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new CE(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new be(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new be()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new CE(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new be(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new be()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const r of e.hand.values())
          this._getHandJoint(t, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, r) {
    let a = null, s = null, u = null;
    const h = this._targetRay, v = this._grip, y = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (y && e.hand) {
        u = !0;
        for (const U of e.hand.values()) {
          const N = t.getJointPose(U, r), O = this._getHandJoint(y, U);
          N !== null && (O.matrix.fromArray(N.transform.matrix), O.matrix.decompose(O.position, O.rotation, O.scale), O.matrixWorldNeedsUpdate = !0, O.jointRadius = N.radius), O.visible = N !== null;
        }
        const _ = y.joints["index-finger-tip"], b = y.joints["thumb-tip"], M = _.position.distanceTo(b.position), C = 0.02, D = 5e-3;
        y.inputState.pinching && M > C + D ? (y.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !y.inputState.pinching && M <= C - D && (y.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        v !== null && e.gripSpace && (s = t.getPose(e.gripSpace, r), s !== null && (v.matrix.fromArray(s.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (v.hasLinearVelocity = !0, v.linearVelocity.copy(s.linearVelocity)) : v.hasLinearVelocity = !1, s.angularVelocity ? (v.hasAngularVelocity = !0, v.angularVelocity.copy(s.angularVelocity)) : v.hasAngularVelocity = !1));
      h !== null && (a = t.getPose(e.targetRaySpace, r), a === null && s !== null && (a = s), a !== null && (h.matrix.fromArray(a.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), h.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (h.hasLinearVelocity = !0, h.linearVelocity.copy(a.linearVelocity)) : h.hasLinearVelocity = !1, a.angularVelocity ? (h.hasAngularVelocity = !0, h.angularVelocity.copy(a.angularVelocity)) : h.hasAngularVelocity = !1, this.dispatchEvent(t$)));
    }
    return h !== null && (h.visible = a !== null), v !== null && (v.visible = s !== null), y !== null && (y.visible = u !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const r = new CE();
      r.matrixAutoUpdate = !1, r.visible = !1, e.joints[t.jointName] = r, e.add(r);
    }
    return e.joints[t.jointName];
  }
}
class VF extends Rs {
  constructor(e, t, r, a, s, u, h, v, y, _) {
    if (_ = _ !== void 0 ? _ : l0, _ !== l0 && _ !== sx)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    r === void 0 && _ === l0 && (r = Ug), r === void 0 && _ === sx && (r = s0), super(null, a, s, u, h, v, _, r, y), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = h !== void 0 ? h : el, this.minFilter = v !== void 0 ? v : el, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
class n$ extends Tv {
  constructor(e, t) {
    super();
    const r = this;
    let a = null, s = 1, u = null, h = "local-floor", v = 1, y = null, _ = null, b = null, M = null, C = null, D = null;
    const U = t.getContextAttributes();
    let N = null, O = null;
    const I = [], k = [];
    let G = null;
    const j = new Cs();
    j.layers.enable(1), j.viewport = new Ua();
    const Y = new Cs();
    Y.layers.enable(2), Y.viewport = new Ua();
    const Z = [j, Y], te = new HF();
    te.layers.enable(1), te.layers.enable(2);
    let J = null, q = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getCamera = function() {
    }, this.setUserCamera = function(ce) {
      G = ce;
    }, this.getController = function(ce) {
      let Ue = I[ce];
      return Ue === void 0 && (Ue = new M2(), I[ce] = Ue), Ue.getTargetRaySpace();
    }, this.getControllerGrip = function(ce) {
      let Ue = I[ce];
      return Ue === void 0 && (Ue = new M2(), I[ce] = Ue), Ue.getGripSpace();
    }, this.getHand = function(ce) {
      let Ue = I[ce];
      return Ue === void 0 && (Ue = new M2(), I[ce] = Ue), Ue.getHandSpace();
    };
    function oe(ce) {
      const Ue = k.indexOf(ce.inputSource);
      if (Ue === -1)
        return;
      const Oe = I[Ue];
      Oe !== void 0 && (Oe.update(ce.inputSource, ce.frame, y || u), Oe.dispatchEvent({ type: ce.type, data: ce.inputSource }));
    }
    function ye() {
      a.removeEventListener("select", oe), a.removeEventListener("selectstart", oe), a.removeEventListener("selectend", oe), a.removeEventListener("squeeze", oe), a.removeEventListener("squeezestart", oe), a.removeEventListener("squeezeend", oe), a.removeEventListener("end", ye), a.removeEventListener("inputsourceschange", de);
      for (let ce = 0; ce < I.length; ce++) {
        const Ue = k[ce];
        Ue !== null && (k[ce] = null, I[ce].disconnect(Ue));
      }
      J = null, q = null, e.setRenderTarget(N), C = null, M = null, b = null, a = null, O = null, me.stop(), r.isPresenting = !1, r.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(ce) {
      s = ce, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(ce) {
      h = ce, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return y || u;
    }, this.setReferenceSpace = function(ce) {
      y = ce;
    }, this.getBaseLayer = function() {
      return M !== null ? M : C;
    }, this.getBinding = function() {
      return b;
    }, this.getFrame = function() {
      return D;
    }, this.getSession = function() {
      return a;
    }, this.setSession = async function(ce) {
      if (a = ce, a !== null) {
        if (N = e.getRenderTarget(), a.addEventListener("select", oe), a.addEventListener("selectstart", oe), a.addEventListener("selectend", oe), a.addEventListener("squeeze", oe), a.addEventListener("squeezestart", oe), a.addEventListener("squeezeend", oe), a.addEventListener("end", ye), a.addEventListener("inputsourceschange", de), U.xrCompatible !== !0 && await t.makeXRCompatible(), a.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const Ue = {
            antialias: a.renderState.layers === void 0 ? U.antialias : !0,
            alpha: !0,
            depth: U.depth,
            stencil: U.stencil,
            framebufferScaleFactor: s
          };
          C = new XRWebGLLayer(a, t, Ue), a.updateRenderState({ baseLayer: C }), O = new rm(
            C.framebufferWidth,
            C.framebufferHeight,
            {
              format: dd,
              type: Sv,
              colorSpace: e.outputColorSpace,
              stencilBuffer: U.stencil
            }
          );
        } else {
          let Ue = null, Oe = null, Ze = null;
          U.depth && (Ze = U.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, Ue = U.stencil ? sx : l0, Oe = U.stencil ? s0 : Ug);
          const je = {
            colorFormat: t.RGBA8,
            depthFormat: Ze,
            scaleFactor: s
          };
          b = new XRWebGLBinding(a, t), M = b.createProjectionLayer(je), a.updateRenderState({ layers: [M] }), O = new rm(
            M.textureWidth,
            M.textureHeight,
            {
              format: dd,
              type: Sv,
              depthTexture: new VF(M.textureWidth, M.textureHeight, Oe, void 0, void 0, void 0, void 0, void 0, void 0, Ue),
              stencilBuffer: U.stencil,
              colorSpace: e.outputColorSpace,
              samples: U.antialias ? 4 : 0
            }
          );
          const Je = e.properties.get(O);
          Je.__ignoreDepthValues = M.ignoreDepthValues;
        }
        O.isXRRenderTarget = !0, this.setFoveation(v), y = null, u = await a.requestReferenceSpace(h), me.setContext(a), me.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (a !== null)
        return a.environmentBlendMode;
    };
    function de(ce) {
      for (let Ue = 0; Ue < ce.removed.length; Ue++) {
        const Oe = ce.removed[Ue], Ze = k.indexOf(Oe);
        Ze >= 0 && (k[Ze] = null, I[Ze].disconnect(Oe));
      }
      for (let Ue = 0; Ue < ce.added.length; Ue++) {
        const Oe = ce.added[Ue];
        let Ze = k.indexOf(Oe);
        if (Ze === -1) {
          for (let Je = 0; Je < I.length; Je++)
            if (Je >= k.length) {
              k.push(Oe), Ze = Je;
              break;
            } else if (k[Je] === null) {
              k[Je] = Oe, Ze = Je;
              break;
            }
          if (Ze === -1)
            break;
        }
        const je = I[Ze];
        je && je.connect(Oe);
      }
    }
    const xe = new be(), Re = new be();
    function Pe(ce, Ue, Oe) {
      xe.setFromMatrixPosition(Ue.matrixWorld), Re.setFromMatrixPosition(Oe.matrixWorld);
      const Ze = xe.distanceTo(Re), je = Ue.projectionMatrix.elements, Je = Oe.projectionMatrix.elements, at = je[14] / (je[10] - 1), xt = je[14] / (je[10] + 1), $t = (je[9] + 1) / je[5], Ht = (je[9] - 1) / je[5], he = (je[8] - 1) / je[0], nt = (Je[8] + 1) / Je[0], et = at * he, Rt = at * nt, gt = Ze / (-he + nt), Jt = gt * -he;
      Ue.matrixWorld.decompose(ce.position, ce.quaternion, ce.scale), ce.translateX(Jt), ce.translateZ(gt), ce.matrixWorld.compose(ce.position, ce.quaternion, ce.scale), ce.matrixWorldInverse.copy(ce.matrixWorld).invert();
      const Kt = at + gt, qt = xt + gt, hn = et - Jt, Rn = Rt + (Ze - Jt), Yn = $t * xt / qt * Kt, se = Ht * xt / qt * Kt;
      ce.projectionMatrix.makePerspective(hn, Rn, Yn, se, Kt, qt), ce.projectionMatrixInverse.copy(ce.projectionMatrix).invert();
    }
    function Te(ce, Ue) {
      Ue === null ? ce.matrixWorld.copy(ce.matrix) : ce.matrixWorld.multiplyMatrices(Ue.matrixWorld, ce.matrix), ce.matrixWorldInverse.copy(ce.matrixWorld).invert();
    }
    this.updateCameraXR = function(ce) {
      if (a === null)
        return ce;
      G && (ce = G), te.near = Y.near = j.near = ce.near, te.far = Y.far = j.far = ce.far, (J !== te.near || q !== te.far) && (a.updateRenderState({
        depthNear: te.near,
        depthFar: te.far
      }), J = te.near, q = te.far);
      const Ue = ce.parent, Oe = te.cameras;
      Te(te, Ue);
      for (let Ze = 0; Ze < Oe.length; Ze++)
        Te(Oe[Ze], Ue);
      return Oe.length === 2 ? Pe(te, j, Y) : te.projectionMatrix.copy(j.projectionMatrix), G && ue(te, Ue), te;
    };
    function ue(ce, Ue) {
      const Oe = G;
      Ue === null ? Oe.matrix.copy(ce.matrixWorld) : (Oe.matrix.copy(Ue.matrixWorld), Oe.matrix.invert(), Oe.matrix.multiply(ce.matrixWorld)), Oe.matrix.decompose(Oe.position, Oe.quaternion, Oe.scale), Oe.updateMatrixWorld(!0);
      const Ze = Oe.children;
      for (let je = 0, Je = Ze.length; je < Je; je++)
        Ze[je].updateMatrixWorld(!0);
      Oe.projectionMatrix.copy(ce.projectionMatrix), Oe.projectionMatrixInverse.copy(ce.projectionMatrixInverse), Oe.isPerspectiveCamera && (Oe.fov = zE * 2 * Math.atan(1 / Oe.projectionMatrix.elements[5]), Oe.zoom = 1);
    }
    this.getFoveation = function() {
      if (!(M === null && C === null))
        return v;
    }, this.setFoveation = function(ce) {
      v = ce, M !== null && (M.fixedFoveation = ce), C !== null && C.fixedFoveation !== void 0 && (C.fixedFoveation = ce);
    };
    let we = null;
    function X(ce, Ue) {
      if (_ = Ue.getViewerPose(y || u), D = Ue, _ !== null) {
        const Oe = _.views;
        C !== null && (e.setRenderTargetFramebuffer(O, C.framebuffer), e.setRenderTarget(O));
        let Ze = !1;
        Oe.length !== te.cameras.length && (te.cameras.length = 0, Ze = !0);
        for (let je = 0; je < Oe.length; je++) {
          const Je = Oe[je];
          let at = null;
          if (C !== null)
            at = C.getViewport(Je);
          else {
            const $t = b.getViewSubImage(M, Je);
            at = $t.viewport, je === 0 && (e.setRenderTargetTextures(
              O,
              $t.colorTexture,
              M.ignoreDepthValues ? void 0 : $t.depthStencilTexture
            ), e.setRenderTarget(O));
          }
          let xt = Z[je];
          xt === void 0 && (xt = new Cs(), xt.layers.enable(je), xt.viewport = new Ua(), Z[je] = xt), xt.matrix.fromArray(Je.transform.matrix), xt.matrix.decompose(xt.position, xt.quaternion, xt.scale), xt.projectionMatrix.fromArray(Je.projectionMatrix), xt.projectionMatrixInverse.copy(xt.projectionMatrix).invert(), xt.viewport.set(at.x, at.y, at.width, at.height), je === 0 && (te.matrix.copy(xt.matrix), te.matrix.decompose(te.position, te.quaternion, te.scale)), Ze === !0 && te.cameras.push(xt);
        }
      }
      for (let Oe = 0; Oe < I.length; Oe++) {
        const Ze = k[Oe], je = I[Oe];
        Ze !== null && je !== void 0 && je.update(Ze, Ue, y || u);
      }
      we && we(ce, Ue), Ue.detectedPlanes && r.dispatchEvent({ type: "planesdetected", data: Ue }), D = null;
    }
    const me = new UF();
    me.setAnimationLoop(X), this.setAnimationLoop = function(ce) {
      we = ce;
    }, this.dispose = function() {
    };
  }
}
function r$(n, e) {
  function t(N, O) {
    N.matrixAutoUpdate === !0 && N.updateMatrix(), O.value.copy(N.matrix);
  }
  function r(N, O) {
    O.color.getRGB(N.fogColor.value, LF(n)), O.isFog ? (N.fogNear.value = O.near, N.fogFar.value = O.far) : O.isFogExp2 && (N.fogDensity.value = O.density);
  }
  function a(N, O, I, k, G) {
    O.isMeshBasicMaterial || O.isMeshLambertMaterial ? s(N, O) : O.isMeshToonMaterial ? (s(N, O), b(N, O)) : O.isMeshPhongMaterial ? (s(N, O), _(N, O)) : O.isMeshStandardMaterial ? (s(N, O), M(N, O), O.isMeshPhysicalMaterial && C(N, O, G)) : O.isMeshMatcapMaterial ? (s(N, O), D(N, O)) : O.isMeshDepthMaterial ? s(N, O) : O.isMeshDistanceMaterial ? (s(N, O), U(N, O)) : O.isMeshNormalMaterial ? s(N, O) : O.isLineBasicMaterial ? (u(N, O), O.isLineDashedMaterial && h(N, O)) : O.isPointsMaterial ? v(N, O, I, k) : O.isSpriteMaterial ? y(N, O) : O.isShadowMaterial ? (N.color.value.copy(O.color), N.opacity.value = O.opacity) : O.isShaderMaterial && (O.uniformsNeedUpdate = !1);
  }
  function s(N, O) {
    N.opacity.value = O.opacity, O.color && N.diffuse.value.copy(O.color), O.emissive && N.emissive.value.copy(O.emissive).multiplyScalar(O.emissiveIntensity), O.map && (N.map.value = O.map, t(O.map, N.mapTransform)), O.alphaMap && (N.alphaMap.value = O.alphaMap, t(O.alphaMap, N.alphaMapTransform)), O.bumpMap && (N.bumpMap.value = O.bumpMap, t(O.bumpMap, N.bumpMapTransform), N.bumpScale.value = O.bumpScale, O.side === bf && (N.bumpScale.value *= -1)), O.normalMap && (N.normalMap.value = O.normalMap, t(O.normalMap, N.normalMapTransform), N.normalScale.value.copy(O.normalScale), O.side === bf && N.normalScale.value.negate()), O.displacementMap && (N.displacementMap.value = O.displacementMap, t(O.displacementMap, N.displacementMapTransform), N.displacementScale.value = O.displacementScale, N.displacementBias.value = O.displacementBias), O.emissiveMap && (N.emissiveMap.value = O.emissiveMap, t(O.emissiveMap, N.emissiveMapTransform)), O.specularMap && (N.specularMap.value = O.specularMap, t(O.specularMap, N.specularMapTransform)), O.alphaTest > 0 && (N.alphaTest.value = O.alphaTest);
    const I = e.get(O).envMap;
    if (I && (N.envMap.value = I, N.flipEnvMap.value = I.isCubeTexture && I.isRenderTargetTexture === !1 ? -1 : 1, N.reflectivity.value = O.reflectivity, N.ior.value = O.ior, N.refractionRatio.value = O.refractionRatio), O.lightMap) {
      N.lightMap.value = O.lightMap;
      const k = n.useLegacyLights === !0 ? Math.PI : 1;
      N.lightMapIntensity.value = O.lightMapIntensity * k, t(O.lightMap, N.lightMapTransform);
    }
    O.aoMap && (N.aoMap.value = O.aoMap, N.aoMapIntensity.value = O.aoMapIntensity, t(O.aoMap, N.aoMapTransform));
  }
  function u(N, O) {
    N.diffuse.value.copy(O.color), N.opacity.value = O.opacity, O.map && (N.map.value = O.map, t(O.map, N.mapTransform));
  }
  function h(N, O) {
    N.dashSize.value = O.dashSize, N.totalSize.value = O.dashSize + O.gapSize, N.scale.value = O.scale;
  }
  function v(N, O, I, k) {
    N.diffuse.value.copy(O.color), N.opacity.value = O.opacity, N.size.value = O.size * I, N.scale.value = k * 0.5, O.map && (N.map.value = O.map, t(O.map, N.uvTransform)), O.alphaMap && (N.alphaMap.value = O.alphaMap, t(O.alphaMap, N.alphaMapTransform)), O.alphaTest > 0 && (N.alphaTest.value = O.alphaTest);
  }
  function y(N, O) {
    N.diffuse.value.copy(O.color), N.opacity.value = O.opacity, N.rotation.value = O.rotation, O.map && (N.map.value = O.map, t(O.map, N.mapTransform)), O.alphaMap && (N.alphaMap.value = O.alphaMap, t(O.alphaMap, N.alphaMapTransform)), O.alphaTest > 0 && (N.alphaTest.value = O.alphaTest);
  }
  function _(N, O) {
    N.specular.value.copy(O.specular), N.shininess.value = Math.max(O.shininess, 1e-4);
  }
  function b(N, O) {
    O.gradientMap && (N.gradientMap.value = O.gradientMap);
  }
  function M(N, O) {
    N.metalness.value = O.metalness, O.metalnessMap && (N.metalnessMap.value = O.metalnessMap, t(O.metalnessMap, N.metalnessMapTransform)), N.roughness.value = O.roughness, O.roughnessMap && (N.roughnessMap.value = O.roughnessMap, t(O.roughnessMap, N.roughnessMapTransform)), e.get(O).envMap && (N.envMapIntensity.value = O.envMapIntensity);
  }
  function C(N, O, I) {
    N.ior.value = O.ior, O.sheen > 0 && (N.sheenColor.value.copy(O.sheenColor).multiplyScalar(O.sheen), N.sheenRoughness.value = O.sheenRoughness, O.sheenColorMap && (N.sheenColorMap.value = O.sheenColorMap, t(O.sheenColorMap, N.sheenColorMapTransform)), O.sheenRoughnessMap && (N.sheenRoughnessMap.value = O.sheenRoughnessMap, t(O.sheenRoughnessMap, N.sheenRoughnessMapTransform))), O.clearcoat > 0 && (N.clearcoat.value = O.clearcoat, N.clearcoatRoughness.value = O.clearcoatRoughness, O.clearcoatMap && (N.clearcoatMap.value = O.clearcoatMap, t(O.clearcoatMap, N.clearcoatMapTransform)), O.clearcoatRoughnessMap && (N.clearcoatRoughnessMap.value = O.clearcoatRoughnessMap, t(O.clearcoatRoughnessMap, N.clearcoatRoughnessMapTransform)), O.clearcoatNormalMap && (N.clearcoatNormalMap.value = O.clearcoatNormalMap, t(O.clearcoatNormalMap, N.clearcoatNormalMapTransform), N.clearcoatNormalScale.value.copy(O.clearcoatNormalScale), O.side === bf && N.clearcoatNormalScale.value.negate())), O.iridescence > 0 && (N.iridescence.value = O.iridescence, N.iridescenceIOR.value = O.iridescenceIOR, N.iridescenceThicknessMinimum.value = O.iridescenceThicknessRange[0], N.iridescenceThicknessMaximum.value = O.iridescenceThicknessRange[1], O.iridescenceMap && (N.iridescenceMap.value = O.iridescenceMap, t(O.iridescenceMap, N.iridescenceMapTransform)), O.iridescenceThicknessMap && (N.iridescenceThicknessMap.value = O.iridescenceThicknessMap, t(O.iridescenceThicknessMap, N.iridescenceThicknessMapTransform))), O.transmission > 0 && (N.transmission.value = O.transmission, N.transmissionSamplerMap.value = I.texture, N.transmissionSamplerSize.value.set(I.width, I.height), O.transmissionMap && (N.transmissionMap.value = O.transmissionMap, t(O.transmissionMap, N.transmissionMapTransform)), N.thickness.value = O.thickness, O.thicknessMap && (N.thicknessMap.value = O.thicknessMap, t(O.thicknessMap, N.thicknessMapTransform)), N.attenuationDistance.value = O.attenuationDistance, N.attenuationColor.value.copy(O.attenuationColor)), O.anisotropy > 0 && (N.anisotropyVector.value.set(O.anisotropy * Math.cos(O.anisotropyRotation), O.anisotropy * Math.sin(O.anisotropyRotation)), O.anisotropyMap && (N.anisotropyMap.value = O.anisotropyMap, t(O.anisotropyMap, N.anisotropyMapTransform))), N.specularIntensity.value = O.specularIntensity, N.specularColor.value.copy(O.specularColor), O.specularColorMap && (N.specularColorMap.value = O.specularColorMap, t(O.specularColorMap, N.specularColorMapTransform)), O.specularIntensityMap && (N.specularIntensityMap.value = O.specularIntensityMap, t(O.specularIntensityMap, N.specularIntensityMapTransform));
  }
  function D(N, O) {
    O.matcap && (N.matcap.value = O.matcap);
  }
  function U(N, O) {
    const I = e.get(O).light;
    N.referencePosition.value.setFromMatrixPosition(I.matrixWorld), N.nearDistance.value = I.shadow.camera.near, N.farDistance.value = I.shadow.camera.far;
  }
  return {
    refreshFogUniforms: r,
    refreshMaterialUniforms: a
  };
}
function i$(n, e, t, r) {
  let a = {}, s = {}, u = [];
  const h = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function v(I, k) {
    const G = k.program;
    r.uniformBlockBinding(I, G);
  }
  function y(I, k) {
    let G = a[I.id];
    G === void 0 && (D(I), G = _(I), a[I.id] = G, I.addEventListener("dispose", N));
    const j = k.program;
    r.updateUBOMapping(I, j);
    const Y = e.render.frame;
    s[I.id] !== Y && (M(I), s[I.id] = Y);
  }
  function _(I) {
    const k = b();
    I.__bindingPointIndex = k;
    const G = n.createBuffer(), j = I.__size, Y = I.usage;
    return n.bindBuffer(n.UNIFORM_BUFFER, G), n.bufferData(n.UNIFORM_BUFFER, j, Y), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, k, G), G;
  }
  function b() {
    for (let I = 0; I < h; I++)
      if (u.indexOf(I) === -1)
        return u.push(I), I;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function M(I) {
    const k = a[I.id], G = I.uniforms, j = I.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, k);
    for (let Y = 0, Z = G.length; Y < Z; Y++) {
      const te = G[Y];
      if (C(te, Y, j) === !0) {
        const J = te.__offset, q = Array.isArray(te.value) ? te.value : [te.value];
        let oe = 0;
        for (let ye = 0; ye < q.length; ye++) {
          const de = q[ye], xe = U(de);
          typeof de == "number" ? (te.__data[0] = de, n.bufferSubData(n.UNIFORM_BUFFER, J + oe, te.__data)) : de.isMatrix3 ? (te.__data[0] = de.elements[0], te.__data[1] = de.elements[1], te.__data[2] = de.elements[2], te.__data[3] = de.elements[0], te.__data[4] = de.elements[3], te.__data[5] = de.elements[4], te.__data[6] = de.elements[5], te.__data[7] = de.elements[0], te.__data[8] = de.elements[6], te.__data[9] = de.elements[7], te.__data[10] = de.elements[8], te.__data[11] = de.elements[0]) : (de.toArray(te.__data, oe), oe += xe.storage / Float32Array.BYTES_PER_ELEMENT);
        }
        n.bufferSubData(n.UNIFORM_BUFFER, J, te.__data);
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function C(I, k, G) {
    const j = I.value;
    if (G[k] === void 0) {
      if (typeof j == "number")
        G[k] = j;
      else {
        const Y = Array.isArray(j) ? j : [j], Z = [];
        for (let te = 0; te < Y.length; te++)
          Z.push(Y[te].clone());
        G[k] = Z;
      }
      return !0;
    } else if (typeof j == "number") {
      if (G[k] !== j)
        return G[k] = j, !0;
    } else {
      const Y = Array.isArray(G[k]) ? G[k] : [G[k]], Z = Array.isArray(j) ? j : [j];
      for (let te = 0; te < Y.length; te++) {
        const J = Y[te];
        if (J.equals(Z[te]) === !1)
          return J.copy(Z[te]), !0;
      }
    }
    return !1;
  }
  function D(I) {
    const k = I.uniforms;
    let G = 0;
    const j = 16;
    let Y = 0;
    for (let Z = 0, te = k.length; Z < te; Z++) {
      const J = k[Z], q = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      }, oe = Array.isArray(J.value) ? J.value : [J.value];
      for (let ye = 0, de = oe.length; ye < de; ye++) {
        const xe = oe[ye], Re = U(xe);
        q.boundary += Re.boundary, q.storage += Re.storage;
      }
      if (J.__data = new Float32Array(q.storage / Float32Array.BYTES_PER_ELEMENT), J.__offset = G, Z > 0) {
        Y = G % j;
        const ye = j - Y;
        Y !== 0 && ye - q.boundary < 0 && (G += j - Y, J.__offset = G);
      }
      G += q.storage;
    }
    return Y = G % j, Y > 0 && (G += j - Y), I.__size = G, I.__cache = {}, this;
  }
  function U(I) {
    const k = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof I == "number" ? (k.boundary = 4, k.storage = 4) : I.isVector2 ? (k.boundary = 8, k.storage = 8) : I.isVector3 || I.isColor ? (k.boundary = 16, k.storage = 12) : I.isVector4 ? (k.boundary = 16, k.storage = 16) : I.isMatrix3 ? (k.boundary = 48, k.storage = 48) : I.isMatrix4 ? (k.boundary = 64, k.storage = 64) : I.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", I), k;
  }
  function N(I) {
    const k = I.target;
    k.removeEventListener("dispose", N);
    const G = u.indexOf(k.__bindingPointIndex);
    u.splice(G, 1), n.deleteBuffer(a[k.id]), delete a[k.id], delete s[k.id];
  }
  function O() {
    for (const I in a)
      n.deleteBuffer(a[I]);
    u = [], a = {}, s = {};
  }
  return {
    bind: v,
    update: y,
    dispose: O
  };
}
function a$() {
  const n = OT("canvas");
  return n.style.display = "block", n;
}
class rP {
  constructor(e = {}) {
    const {
      canvas: t = a$(),
      context: r = null,
      depth: a = !0,
      stencil: s = !0,
      alpha: u = !1,
      antialias: h = !1,
      premultipliedAlpha: v = !0,
      preserveDrawingBuffer: y = !1,
      powerPreference: _ = "default",
      failIfMajorPerformanceCaveat: b = !1
    } = e;
    this.isWebGLRenderer = !0;
    let M;
    r !== null ? M = r.getContextAttributes().alpha : M = u;
    const C = new Uint32Array(4), D = new Int32Array(4);
    let U = null, N = null;
    const O = [], I = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputColorSpace = ai, this.useLegacyLights = !0, this.toneMapping = em, this.toneMappingExposure = 1;
    const k = this;
    let G = !1, j = 0, Y = 0, Z = null, te = -1, J = null;
    const q = new Ua(), oe = new Ua();
    let ye = null;
    const de = new Un(0);
    let xe = 0, Re = t.width, Pe = t.height, Te = 1, ue = null, we = null;
    const X = new Ua(0, 0, Re, Pe), me = new Ua(0, 0, Re, Pe);
    let ce = !1;
    const Ue = new GR();
    let Oe = !1, Ze = !1, je = null;
    const Je = new ei(), at = new It(), xt = new be(), $t = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function Ht() {
      return Z === null ? Te : 1;
    }
    let he = r;
    function nt(ve, $e) {
      for (let qe = 0; qe < ve.length; qe++) {
        const ze = ve[qe], dt = t.getContext(ze, $e);
        if (dt !== null)
          return dt;
      }
      return null;
    }
    try {
      const ve = {
        alpha: !0,
        depth: a,
        stencil: s,
        antialias: h,
        premultipliedAlpha: v,
        preserveDrawingBuffer: y,
        powerPreference: _,
        failIfMajorPerformanceCaveat: b
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${kR}`), t.addEventListener("webglcontextlost", zt, !1), t.addEventListener("webglcontextrestored", Fe, !1), t.addEventListener("webglcontextcreationerror", ft, !1), he === null) {
        const $e = ["webgl2", "webgl", "experimental-webgl"];
        if (k.isWebGL1Renderer === !0 && $e.shift(), he = nt($e, ve), he === null)
          throw nt($e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      he instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), he.getShaderPrecisionFormat === void 0 && (he.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (ve) {
      throw console.error("THREE.WebGLRenderer: " + ve.message), ve;
    }
    let et, Rt, gt, Jt, Kt, qt, hn, Rn, Yn, se, ae, Ke, wt, _t, Vt, fn, Wt, Ee, Xe, St, Ut, Se, Ye, bt;
    function Tt() {
      et = new _9(he), Rt = new m9(he, et, e), et.init(Rt), Se = new BF(he, et, Rt), gt = new J7(he, et, Rt), Jt = new T9(he), Kt = new H7(), qt = new e$(he, et, gt, Kt, Rt, Se, Jt), hn = new g9(k), Rn = new x9(k), Yn = new z8(he, Rt), Ye = new h9(he, et, Yn, Rt), se = new E9(he, Yn, Jt, Ye), ae = new R9(he, se, Yn, Jt), Xe = new C9(he, Rt, qt), fn = new v9(Kt), Ke = new B7(k, hn, Rn, et, Rt, Ye, fn), wt = new r$(k, Kt), _t = new G7(), Vt = new q7(et, Rt), Ee = new d9(k, hn, Rn, gt, ae, M, v), Wt = new Z7(k, ae, Rt), bt = new i$(he, Jt, Rt, gt), St = new p9(he, et, Jt, Rt), Ut = new b9(he, et, Jt, Rt), Jt.programs = Ke.programs, k.capabilities = Rt, k.extensions = et, k.properties = Kt, k.renderLists = _t, k.shadowMap = Wt, k.state = gt, k.info = Jt;
    }
    Tt();
    const ge = new n$(k, he);
    this.xr = ge, this.getContext = function() {
      return he;
    }, this.getContextAttributes = function() {
      return he.getContextAttributes();
    }, this.forceContextLoss = function() {
      const ve = et.get("WEBGL_lose_context");
      ve && ve.loseContext();
    }, this.forceContextRestore = function() {
      const ve = et.get("WEBGL_lose_context");
      ve && ve.restoreContext();
    }, this.getPixelRatio = function() {
      return Te;
    }, this.setPixelRatio = function(ve) {
      ve !== void 0 && (Te = ve, this.setSize(Re, Pe, !1));
    }, this.getSize = function(ve) {
      return ve.set(Re, Pe);
    }, this.setSize = function(ve, $e, qe = !0) {
      if (ge.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      Re = ve, Pe = $e, t.width = Math.floor(ve * Te), t.height = Math.floor($e * Te), qe === !0 && (t.style.width = ve + "px", t.style.height = $e + "px"), this.setViewport(0, 0, ve, $e);
    }, this.getDrawingBufferSize = function(ve) {
      return ve.set(Re * Te, Pe * Te).floor();
    }, this.setDrawingBufferSize = function(ve, $e, qe) {
      Re = ve, Pe = $e, Te = qe, t.width = Math.floor(ve * qe), t.height = Math.floor($e * qe), this.setViewport(0, 0, ve, $e);
    }, this.getCurrentViewport = function(ve) {
      return ve.copy(q);
    }, this.getViewport = function(ve) {
      return ve.copy(X);
    }, this.setViewport = function(ve, $e, qe, ze) {
      ve.isVector4 ? X.set(ve.x, ve.y, ve.z, ve.w) : X.set(ve, $e, qe, ze), gt.viewport(q.copy(X).multiplyScalar(Te).floor());
    }, this.getScissor = function(ve) {
      return ve.copy(me);
    }, this.setScissor = function(ve, $e, qe, ze) {
      ve.isVector4 ? me.set(ve.x, ve.y, ve.z, ve.w) : me.set(ve, $e, qe, ze), gt.scissor(oe.copy(me).multiplyScalar(Te).floor());
    }, this.getScissorTest = function() {
      return ce;
    }, this.setScissorTest = function(ve) {
      gt.setScissorTest(ce = ve);
    }, this.setOpaqueSort = function(ve) {
      ue = ve;
    }, this.setTransparentSort = function(ve) {
      we = ve;
    }, this.getClearColor = function(ve) {
      return ve.copy(Ee.getClearColor());
    }, this.setClearColor = function() {
      Ee.setClearColor.apply(Ee, arguments);
    }, this.getClearAlpha = function() {
      return Ee.getClearAlpha();
    }, this.setClearAlpha = function() {
      Ee.setClearAlpha.apply(Ee, arguments);
    }, this.clear = function(ve = !0, $e = !0, qe = !0) {
      let ze = 0;
      if (ve) {
        let dt = !1;
        if (Z !== null) {
          const tn = Z.texture.format;
          dt = tn === jO || tn === WO || tn === GO;
        }
        if (dt) {
          const tn = Z.texture.type, pn = tn === Sv || tn === Ug || tn === BR || tn === s0 || tn === HO || tn === VO, An = Ee.getClearColor(), Gn = Ee.getClearAlpha(), cr = An.r, sn = An.g, pr = An.b, Pr = Kt.get(Z).__webglFramebuffer;
          pn ? (C[0] = cr, C[1] = sn, C[2] = pr, C[3] = Gn, he.clearBufferuiv(he.COLOR, Pr, C)) : (D[0] = cr, D[1] = sn, D[2] = pr, D[3] = Gn, he.clearBufferiv(he.COLOR, Pr, D));
        } else
          ze |= he.COLOR_BUFFER_BIT;
      }
      $e && (ze |= he.DEPTH_BUFFER_BIT), qe && (ze |= he.STENCIL_BUFFER_BIT), he.clear(ze);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", zt, !1), t.removeEventListener("webglcontextrestored", Fe, !1), t.removeEventListener("webglcontextcreationerror", ft, !1), _t.dispose(), Vt.dispose(), Kt.dispose(), hn.dispose(), Rn.dispose(), ae.dispose(), Ye.dispose(), bt.dispose(), Ke.dispose(), ge.dispose(), ge.removeEventListener("sessionstart", vr), ge.removeEventListener("sessionend", Ai), je && (je.dispose(), je = null), oi.stop();
    };
    function zt(ve) {
      ve.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), G = !0;
    }
    function Fe() {
      console.log("THREE.WebGLRenderer: Context Restored."), G = !1;
      const ve = Jt.autoReset, $e = Wt.enabled, qe = Wt.autoUpdate, ze = Wt.needsUpdate, dt = Wt.type;
      Tt(), Jt.autoReset = ve, Wt.enabled = $e, Wt.autoUpdate = qe, Wt.needsUpdate = ze, Wt.type = dt;
    }
    function ft(ve) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", ve.statusMessage);
    }
    function ln(ve) {
      const $e = ve.target;
      $e.removeEventListener("dispose", ln), zn($e);
    }
    function zn(ve) {
      yr(ve), Kt.remove(ve);
    }
    function yr(ve) {
      const $e = Kt.get(ve).programs;
      $e !== void 0 && ($e.forEach(function(qe) {
        Ke.releaseProgram(qe);
      }), ve.isShaderMaterial && Ke.releaseShaderCache(ve));
    }
    this.renderBufferDirect = function(ve, $e, qe, ze, dt, tn) {
      $e === null && ($e = $t);
      const pn = dt.isMesh && dt.matrixWorld.determinant() < 0, An = Bt(ve, $e, qe, ze, dt);
      gt.setMaterial(ze, pn);
      let Gn = qe.index, cr = 1;
      ze.wireframe === !0 && (Gn = se.getWireframeAttribute(qe), cr = 2);
      const sn = qe.drawRange, pr = qe.attributes.position;
      let Pr = sn.start * cr, kn = (sn.start + sn.count) * cr;
      tn !== null && (Pr = Math.max(Pr, tn.start * cr), kn = Math.min(kn, (tn.start + tn.count) * cr)), Gn !== null ? (Pr = Math.max(Pr, 0), kn = Math.min(kn, Gn.count)) : pr != null && (Pr = Math.max(Pr, 0), kn = Math.min(kn, pr.count));
      const za = kn - Pr;
      if (za < 0 || za === 1 / 0)
        return;
      Ye.setup(dt, ze, An, qe, Gn);
      let Ja, Si = St;
      if (Gn !== null && (Ja = Yn.get(Gn), Si = Ut, Si.setIndex(Ja)), dt.isMesh)
        ze.wireframe === !0 ? (gt.setLineWidth(ze.wireframeLinewidth * Ht()), Si.setMode(he.LINES)) : Si.setMode(he.TRIANGLES);
      else if (dt.isLine) {
        let ir = ze.linewidth;
        ir === void 0 && (ir = 1), gt.setLineWidth(ir * Ht()), dt.isLineSegments ? Si.setMode(he.LINES) : dt.isLineLoop ? Si.setMode(he.LINE_LOOP) : Si.setMode(he.LINE_STRIP);
      } else
        dt.isPoints ? Si.setMode(he.POINTS) : dt.isSprite && Si.setMode(he.TRIANGLES);
      if (dt.isInstancedMesh)
        Si.renderInstances(Pr, za, dt.count);
      else if (qe.isInstancedBufferGeometry) {
        const ir = qe._maxInstanceCount !== void 0 ? qe._maxInstanceCount : 1 / 0, Cr = Math.min(qe.instanceCount, ir);
        Si.renderInstances(Pr, za, Cr);
      } else
        Si.render(Pr, za);
    }, this.compile = function(ve, $e) {
      function qe(ze, dt, tn) {
        ze.transparent === !0 && ze.side === mv && ze.forceSinglePass === !1 ? (ze.side = bf, ze.needsUpdate = !0, Eo(ze, dt, tn), ze.side = Fg, ze.needsUpdate = !0, Eo(ze, dt, tn), ze.side = mv) : Eo(ze, dt, tn);
      }
      N = Vt.get(ve), N.init(), I.push(N), ve.traverseVisible(function(ze) {
        ze.isLight && ze.layers.test($e.layers) && (N.pushLight(ze), ze.castShadow && N.pushShadow(ze));
      }), N.setupLights(k.useLegacyLights), ve.traverse(function(ze) {
        const dt = ze.material;
        if (dt)
          if (Array.isArray(dt))
            for (let tn = 0; tn < dt.length; tn++) {
              const pn = dt[tn];
              qe(pn, ve, ze);
            }
          else
            qe(dt, ve, ze);
      }), I.pop(), N = null;
    };
    let ti = null;
    function rr(ve) {
      ti && ti(ve);
    }
    function vr() {
      oi.stop();
    }
    function Ai() {
      oi.start();
    }
    const oi = new UF();
    oi.setAnimationLoop(rr), typeof self < "u" && oi.setContext(self), this.setAnimationLoop = function(ve) {
      ti = ve, ge.setAnimationLoop(ve), ve === null ? oi.stop() : oi.start();
    }, ge.addEventListener("sessionstart", vr), ge.addEventListener("sessionend", Ai), this.render = function(ve, $e) {
      if ($e !== void 0 && $e.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (G === !0)
        return;
      ve.matrixWorldAutoUpdate === !0 && ve.updateMatrixWorld(), $e.parent === null && $e.matrixWorldAutoUpdate === !0 && $e.updateMatrixWorld(), ge.enabled === !0 && ge.isPresenting === !0 && ($e = ge.updateCameraXR($e)), ve.isScene === !0 && ve.onBeforeRender(k, ve, $e, Z), N = Vt.get(ve, I.length), N.init(), I.push(N), Je.multiplyMatrices($e.projectionMatrix, $e.matrixWorldInverse), Ue.setFromProjectionMatrix(Je), Ze = this.localClippingEnabled, Oe = fn.init(this.clippingPlanes, Ze), U = _t.get(ve, O.length), U.init(), O.push(U), Ma(ve, $e, 0, k.sortObjects), U.finish(), k.sortObjects === !0 && U.sort(ue, we), Oe === !0 && fn.beginShadows();
      const qe = N.state.shadowsArray;
      if (Wt.render(qe, ve, $e), Oe === !0 && fn.endShadows(), this.info.autoReset === !0 && this.info.reset(), this.info.render.frame++, Ee.render(U, ve), N.setupLights(k.useLegacyLights), $e.isArrayCamera) {
        const ze = $e.cameras;
        for (let dt = 0, tn = ze.length; dt < tn; dt++) {
          const pn = ze[dt];
          Ji(U, ve, pn, pn.viewport);
        }
      } else
        Ji(U, ve, $e);
      Z !== null && (qt.updateMultisampleRenderTarget(Z), qt.updateRenderTargetMipmap(Z)), ve.isScene === !0 && ve.onAfterRender(k, ve, $e), Ye.resetDefaultState(), te = -1, J = null, I.pop(), I.length > 0 ? N = I[I.length - 1] : N = null, O.pop(), O.length > 0 ? U = O[O.length - 1] : U = null;
    };
    function Ma(ve, $e, qe, ze) {
      if (ve.visible === !1)
        return;
      if (ve.layers.test($e.layers)) {
        if (ve.isGroup)
          qe = ve.renderOrder;
        else if (ve.isLOD)
          ve.autoUpdate === !0 && ve.update($e);
        else if (ve.isLight)
          N.pushLight(ve), ve.castShadow && N.pushShadow(ve);
        else if (ve.isSprite) {
          if (!ve.frustumCulled || Ue.intersectsSprite(ve)) {
            ze && xt.setFromMatrixPosition(ve.matrixWorld).applyMatrix4(Je);
            const pn = ae.update(ve), An = ve.material;
            An.visible && U.push(ve, pn, An, qe, xt.z, null);
          }
        } else if ((ve.isMesh || ve.isLine || ve.isPoints) && (!ve.frustumCulled || Ue.intersectsObject(ve))) {
          ve.isSkinnedMesh && ve.skeleton.frame !== Jt.render.frame && (ve.skeleton.update(), ve.skeleton.frame = Jt.render.frame);
          const pn = ae.update(ve), An = ve.material;
          if (ze && (ve.boundingSphere !== void 0 ? (ve.boundingSphere === null && ve.computeBoundingSphere(), xt.copy(ve.boundingSphere.center)) : (pn.boundingSphere === null && pn.computeBoundingSphere(), xt.copy(pn.boundingSphere.center)), xt.applyMatrix4(ve.matrixWorld).applyMatrix4(Je)), Array.isArray(An)) {
            const Gn = pn.groups;
            for (let cr = 0, sn = Gn.length; cr < sn; cr++) {
              const pr = Gn[cr], Pr = An[pr.materialIndex];
              Pr && Pr.visible && U.push(ve, pn, Pr, qe, xt.z, pr);
            }
          } else
            An.visible && U.push(ve, pn, An, qe, xt.z, null);
        }
      }
      const tn = ve.children;
      for (let pn = 0, An = tn.length; pn < An; pn++)
        Ma(tn[pn], $e, qe, ze);
    }
    function Ji(ve, $e, qe, ze) {
      const dt = ve.opaque, tn = ve.transmissive, pn = ve.transparent;
      N.setupLightsView(qe), Oe === !0 && fn.setGlobalState(k.clippingPlanes, qe), tn.length > 0 && _l(dt, tn, $e, qe), ze && gt.viewport(q.copy(ze)), dt.length > 0 && ea(dt, $e, qe), tn.length > 0 && ea(tn, $e, qe), pn.length > 0 && ea(pn, $e, qe), gt.buffers.depth.setTest(!0), gt.buffers.depth.setMask(!0), gt.buffers.color.setMask(!0), gt.setPolygonOffset(!1);
    }
    function _l(ve, $e, qe, ze) {
      const dt = Rt.isWebGL2;
      je === null && (je = new rm(1, 1, {
        generateMipmaps: !0,
        type: et.has("EXT_color_buffer_half_float") ? UE : Sv,
        minFilter: h0,
        samples: dt && h === !0 ? 4 : 0
      })), k.getDrawingBufferSize(at), dt ? je.setSize(at.x, at.y) : je.setSize(yR(at.x), yR(at.y));
      const tn = k.getRenderTarget();
      k.setRenderTarget(je), k.getClearColor(de), xe = k.getClearAlpha(), xe < 1 && k.setClearColor(16777215, 0.5), k.clear();
      const pn = k.toneMapping;
      k.toneMapping = em, ea(ve, qe, ze), qt.updateMultisampleRenderTarget(je), qt.updateRenderTargetMipmap(je);
      let An = !1;
      for (let Gn = 0, cr = $e.length; Gn < cr; Gn++) {
        const sn = $e[Gn], pr = sn.object, Pr = sn.geometry, kn = sn.material, za = sn.group;
        if (kn.side === mv && pr.layers.test(ze.layers)) {
          const Ja = kn.side;
          kn.side = bf, kn.needsUpdate = !0, _o(pr, qe, ze, Pr, kn, za), kn.side = Ja, kn.needsUpdate = !0, An = !0;
        }
      }
      An === !0 && (qt.updateMultisampleRenderTarget(je), qt.updateRenderTargetMipmap(je)), k.setRenderTarget(tn), k.setClearColor(de, xe), k.toneMapping = pn;
    }
    function ea(ve, $e, qe) {
      const ze = $e.isScene === !0 ? $e.overrideMaterial : null;
      for (let dt = 0, tn = ve.length; dt < tn; dt++) {
        const pn = ve[dt], An = pn.object, Gn = pn.geometry, cr = ze === null ? pn.material : ze, sn = pn.group;
        An.layers.test(qe.layers) && _o(An, $e, qe, Gn, cr, sn);
      }
    }
    function _o(ve, $e, qe, ze, dt, tn) {
      ve.onBeforeRender(k, $e, qe, ze, dt, tn), ve.modelViewMatrix.multiplyMatrices(qe.matrixWorldInverse, ve.matrixWorld), ve.normalMatrix.getNormalMatrix(ve.modelViewMatrix), dt.onBeforeRender(k, $e, qe, ze, ve, tn), dt.transparent === !0 && dt.side === mv && dt.forceSinglePass === !1 ? (dt.side = bf, dt.needsUpdate = !0, k.renderBufferDirect(qe, $e, ze, dt, ve, tn), dt.side = Fg, dt.needsUpdate = !0, k.renderBufferDirect(qe, $e, ze, dt, ve, tn), dt.side = mv) : k.renderBufferDirect(qe, $e, ze, dt, ve, tn), ve.onAfterRender(k, $e, qe, ze, dt, tn);
    }
    function Eo(ve, $e, qe) {
      $e.isScene !== !0 && ($e = $t);
      const ze = Kt.get(ve), dt = N.state.lights, tn = N.state.shadowsArray, pn = dt.state.version, An = Ke.getParameters(ve, dt.state, tn, $e, qe), Gn = Ke.getProgramCacheKey(An);
      let cr = ze.programs;
      ze.environment = ve.isMeshStandardMaterial ? $e.environment : null, ze.fog = $e.fog, ze.envMap = (ve.isMeshStandardMaterial ? Rn : hn).get(ve.envMap || ze.environment), cr === void 0 && (ve.addEventListener("dispose", ln), cr = /* @__PURE__ */ new Map(), ze.programs = cr);
      let sn = cr.get(Gn);
      if (sn !== void 0) {
        if (ze.currentProgram === sn && ze.lightsStateVersion === pn)
          return Le(ve, An), sn;
      } else
        An.uniforms = Ke.getUniforms(ve), ve.onBuild(qe, An, k), ve.onBeforeCompile(An, k), sn = Ke.acquireProgram(An, Gn), cr.set(Gn, sn), ze.uniforms = An.uniforms;
      const pr = ze.uniforms;
      (!ve.isShaderMaterial && !ve.isRawShaderMaterial || ve.clipping === !0) && (pr.clippingPlanes = fn.uniform), Le(ve, An), ze.needsLights = _n(ve), ze.lightsStateVersion = pn, ze.needsLights && (pr.ambientLightColor.value = dt.state.ambient, pr.lightProbe.value = dt.state.probe, pr.directionalLights.value = dt.state.directional, pr.directionalLightShadows.value = dt.state.directionalShadow, pr.spotLights.value = dt.state.spot, pr.spotLightShadows.value = dt.state.spotShadow, pr.rectAreaLights.value = dt.state.rectArea, pr.ltc_1.value = dt.state.rectAreaLTC1, pr.ltc_2.value = dt.state.rectAreaLTC2, pr.pointLights.value = dt.state.point, pr.pointLightShadows.value = dt.state.pointShadow, pr.hemisphereLights.value = dt.state.hemi, pr.directionalShadowMap.value = dt.state.directionalShadowMap, pr.directionalShadowMatrix.value = dt.state.directionalShadowMatrix, pr.spotShadowMap.value = dt.state.spotShadowMap, pr.spotLightMatrix.value = dt.state.spotLightMatrix, pr.spotLightMap.value = dt.state.spotLightMap, pr.pointShadowMap.value = dt.state.pointShadowMap, pr.pointShadowMatrix.value = dt.state.pointShadowMatrix);
      const Pr = sn.getUniforms(), kn = dR.seqWithValue(Pr.seq, pr);
      return ze.currentProgram = sn, ze.uniformsList = kn, sn;
    }
    function Le(ve, $e) {
      const qe = Kt.get(ve);
      qe.outputColorSpace = $e.outputColorSpace, qe.instancing = $e.instancing, qe.skinning = $e.skinning, qe.morphTargets = $e.morphTargets, qe.morphNormals = $e.morphNormals, qe.morphColors = $e.morphColors, qe.morphTargetsCount = $e.morphTargetsCount, qe.numClippingPlanes = $e.numClippingPlanes, qe.numIntersection = $e.numClipIntersection, qe.vertexAlphas = $e.vertexAlphas, qe.vertexTangents = $e.vertexTangents, qe.toneMapping = $e.toneMapping;
    }
    function Bt(ve, $e, qe, ze, dt) {
      $e.isScene !== !0 && ($e = $t), qt.resetTextureUnits();
      const tn = $e.fog, pn = ze.isMeshStandardMaterial ? $e.environment : null, An = Z === null ? k.outputColorSpace : Z.isXRRenderTarget === !0 ? Z.texture.colorSpace : nm, Gn = (ze.isMeshStandardMaterial ? Rn : hn).get(ze.envMap || pn), cr = ze.vertexColors === !0 && !!qe.attributes.color && qe.attributes.color.itemSize === 4, sn = !!qe.attributes.tangent && (!!ze.normalMap || ze.anisotropy > 0), pr = !!qe.morphAttributes.position, Pr = !!qe.morphAttributes.normal, kn = !!qe.morphAttributes.color, za = ze.toneMapped ? k.toneMapping : em, Ja = qe.morphAttributes.position || qe.morphAttributes.normal || qe.morphAttributes.color, Si = Ja !== void 0 ? Ja.length : 0, ir = Kt.get(ze), Cr = N.state.lights;
      if (Oe === !0 && (Ze === !0 || ve !== J)) {
        const Ui = ve === J && ze.id === te;
        fn.setState(ze, ve, Ui);
      }
      let fr = !1;
      ze.version === ir.__version ? (ir.needsLights && ir.lightsStateVersion !== Cr.state.version || ir.outputColorSpace !== An || dt.isInstancedMesh && ir.instancing === !1 || !dt.isInstancedMesh && ir.instancing === !0 || dt.isSkinnedMesh && ir.skinning === !1 || !dt.isSkinnedMesh && ir.skinning === !0 || ir.envMap !== Gn || ze.fog === !0 && ir.fog !== tn || ir.numClippingPlanes !== void 0 && (ir.numClippingPlanes !== fn.numPlanes || ir.numIntersection !== fn.numIntersection) || ir.vertexAlphas !== cr || ir.vertexTangents !== sn || ir.morphTargets !== pr || ir.morphNormals !== Pr || ir.morphColors !== kn || ir.toneMapping !== za || Rt.isWebGL2 === !0 && ir.morphTargetsCount !== Si) && (fr = !0) : (fr = !0, ir.__version = ze.version);
      let Di = ir.currentProgram;
      fr === !0 && (Di = Eo(ze, $e, dt));
      let wa = !1, ni = !1, ss = !1;
      const ta = Di.getUniforms(), Vi = ir.uniforms;
      if (gt.useProgram(Di.program) && (wa = !0, ni = !0, ss = !0), ze.id !== te && (te = ze.id, ni = !0), wa || J !== ve) {
        if (ta.setValue(he, "projectionMatrix", ve.projectionMatrix), Rt.logarithmicDepthBuffer && ta.setValue(
          he,
          "logDepthBufFC",
          2 / (Math.log(ve.far + 1) / Math.LN2)
        ), J !== ve && (J = ve, ni = !0, ss = !0), ze.isShaderMaterial || ze.isMeshPhongMaterial || ze.isMeshToonMaterial || ze.isMeshStandardMaterial || ze.envMap) {
          const Ui = ta.map.cameraPosition;
          Ui !== void 0 && Ui.setValue(
            he,
            xt.setFromMatrixPosition(ve.matrixWorld)
          );
        }
        (ze.isMeshPhongMaterial || ze.isMeshToonMaterial || ze.isMeshLambertMaterial || ze.isMeshBasicMaterial || ze.isMeshStandardMaterial || ze.isShaderMaterial) && ta.setValue(he, "isOrthographic", ve.isOrthographicCamera === !0), (ze.isMeshPhongMaterial || ze.isMeshToonMaterial || ze.isMeshLambertMaterial || ze.isMeshBasicMaterial || ze.isMeshStandardMaterial || ze.isShaderMaterial || ze.isShadowMaterial || dt.isSkinnedMesh) && ta.setValue(he, "viewMatrix", ve.matrixWorldInverse);
      }
      if (dt.isSkinnedMesh) {
        ta.setOptional(he, dt, "bindMatrix"), ta.setOptional(he, dt, "bindMatrixInverse");
        const Ui = dt.skeleton;
        Ui && (Rt.floatVertexTextures ? (Ui.boneTexture === null && Ui.computeBoneTexture(), ta.setValue(he, "boneTexture", Ui.boneTexture, qt), ta.setValue(he, "boneTextureSize", Ui.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      const Po = qe.morphAttributes;
      if ((Po.position !== void 0 || Po.normal !== void 0 || Po.color !== void 0 && Rt.isWebGL2 === !0) && Xe.update(dt, qe, Di), (ni || ir.receiveShadow !== dt.receiveShadow) && (ir.receiveShadow = dt.receiveShadow, ta.setValue(he, "receiveShadow", dt.receiveShadow)), ze.isMeshGouraudMaterial && ze.envMap !== null && (Vi.envMap.value = Gn, Vi.flipEnvMap.value = Gn.isCubeTexture && Gn.isRenderTargetTexture === !1 ? -1 : 1), ni && (ta.setValue(he, "toneMappingExposure", k.toneMappingExposure), ir.needsLights && en(Vi, ss), tn && ze.fog === !0 && wt.refreshFogUniforms(Vi, tn), wt.refreshMaterialUniforms(Vi, ze, Te, Pe, je), dR.upload(he, ir.uniformsList, Vi, qt)), ze.isShaderMaterial && ze.uniformsNeedUpdate === !0 && (dR.upload(he, ir.uniformsList, Vi, qt), ze.uniformsNeedUpdate = !1), ze.isSpriteMaterial && ta.setValue(he, "center", dt.center), ta.setValue(he, "modelViewMatrix", dt.modelViewMatrix), ta.setValue(he, "normalMatrix", dt.normalMatrix), ta.setValue(he, "modelMatrix", dt.matrixWorld), ze.isShaderMaterial || ze.isRawShaderMaterial) {
        const Ui = ze.uniformsGroups;
        for (let El = 0, Ds = Ui.length; El < Ds; El++)
          if (Rt.isWebGL2) {
            const bl = Ui[El];
            bt.update(bl, Di), bt.bind(bl, Di);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return Di;
    }
    function en(ve, $e) {
      ve.ambientLightColor.needsUpdate = $e, ve.lightProbe.needsUpdate = $e, ve.directionalLights.needsUpdate = $e, ve.directionalLightShadows.needsUpdate = $e, ve.pointLights.needsUpdate = $e, ve.pointLightShadows.needsUpdate = $e, ve.spotLights.needsUpdate = $e, ve.spotLightShadows.needsUpdate = $e, ve.rectAreaLights.needsUpdate = $e, ve.hemisphereLights.needsUpdate = $e;
    }
    function _n(ve) {
      return ve.isMeshLambertMaterial || ve.isMeshToonMaterial || ve.isMeshPhongMaterial || ve.isMeshStandardMaterial || ve.isShadowMaterial || ve.isShaderMaterial && ve.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return j;
    }, this.getActiveMipmapLevel = function() {
      return Y;
    }, this.getRenderTarget = function() {
      return Z;
    }, this.setRenderTargetTextures = function(ve, $e, qe) {
      Kt.get(ve.texture).__webglTexture = $e, Kt.get(ve.depthTexture).__webglTexture = qe;
      const ze = Kt.get(ve);
      ze.__hasExternalTextures = !0, ze.__hasExternalTextures && (ze.__autoAllocateDepthBuffer = qe === void 0, ze.__autoAllocateDepthBuffer || et.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ze.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(ve, $e) {
      const qe = Kt.get(ve);
      qe.__webglFramebuffer = $e, qe.__useDefaultFramebuffer = $e === void 0;
    }, this.setRenderTarget = function(ve, $e = 0, qe = 0) {
      Z = ve, j = $e, Y = qe;
      let ze = !0, dt = null, tn = !1, pn = !1;
      if (ve) {
        const Gn = Kt.get(ve);
        Gn.__useDefaultFramebuffer !== void 0 ? (gt.bindFramebuffer(he.FRAMEBUFFER, null), ze = !1) : Gn.__webglFramebuffer === void 0 ? qt.setupRenderTarget(ve) : Gn.__hasExternalTextures && qt.rebindTextures(ve, Kt.get(ve.texture).__webglTexture, Kt.get(ve.depthTexture).__webglTexture);
        const cr = ve.texture;
        (cr.isData3DTexture || cr.isDataArrayTexture || cr.isCompressedArrayTexture) && (pn = !0);
        const sn = Kt.get(ve).__webglFramebuffer;
        ve.isWebGLCubeRenderTarget ? (dt = sn[$e], tn = !0) : Rt.isWebGL2 && ve.samples > 0 && qt.useMultisampledRTT(ve) === !1 ? dt = Kt.get(ve).__webglMultisampledFramebuffer : dt = sn, q.copy(ve.viewport), oe.copy(ve.scissor), ye = ve.scissorTest;
      } else
        q.copy(X).multiplyScalar(Te).floor(), oe.copy(me).multiplyScalar(Te).floor(), ye = ce;
      if (gt.bindFramebuffer(he.FRAMEBUFFER, dt) && Rt.drawBuffers && ze && gt.drawBuffers(ve, dt), gt.viewport(q), gt.scissor(oe), gt.setScissorTest(ye), tn) {
        const Gn = Kt.get(ve.texture);
        he.framebufferTexture2D(he.FRAMEBUFFER, he.COLOR_ATTACHMENT0, he.TEXTURE_CUBE_MAP_POSITIVE_X + $e, Gn.__webglTexture, qe);
      } else if (pn) {
        const Gn = Kt.get(ve.texture), cr = $e || 0;
        he.framebufferTextureLayer(he.FRAMEBUFFER, he.COLOR_ATTACHMENT0, Gn.__webglTexture, qe || 0, cr);
      }
      te = -1;
    }, this.readRenderTargetPixels = function(ve, $e, qe, ze, dt, tn, pn) {
      if (!(ve && ve.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let An = Kt.get(ve).__webglFramebuffer;
      if (ve.isWebGLCubeRenderTarget && pn !== void 0 && (An = An[pn]), An) {
        gt.bindFramebuffer(he.FRAMEBUFFER, An);
        try {
          const Gn = ve.texture, cr = Gn.format, sn = Gn.type;
          if (cr !== dd && Se.convert(cr) !== he.getParameter(he.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const pr = sn === UE && (et.has("EXT_color_buffer_half_float") || Rt.isWebGL2 && et.has("EXT_color_buffer_float"));
          if (sn !== Sv && Se.convert(sn) !== he.getParameter(he.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(sn === vv && (Rt.isWebGL2 || et.has("OES_texture_float") || et.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !pr) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          $e >= 0 && $e <= ve.width - ze && qe >= 0 && qe <= ve.height - dt && he.readPixels($e, qe, ze, dt, Se.convert(cr), Se.convert(sn), tn);
        } finally {
          const Gn = Z !== null ? Kt.get(Z).__webglFramebuffer : null;
          gt.bindFramebuffer(he.FRAMEBUFFER, Gn);
        }
      }
    }, this.copyFramebufferToTexture = function(ve, $e, qe = 0) {
      const ze = Math.pow(2, -qe), dt = Math.floor($e.image.width * ze), tn = Math.floor($e.image.height * ze);
      qt.setTexture2D($e, 0), he.copyTexSubImage2D(he.TEXTURE_2D, qe, 0, 0, ve.x, ve.y, dt, tn), gt.unbindTexture();
    }, this.copyTextureToTexture = function(ve, $e, qe, ze = 0) {
      const dt = $e.image.width, tn = $e.image.height, pn = Se.convert(qe.format), An = Se.convert(qe.type);
      qt.setTexture2D(qe, 0), he.pixelStorei(he.UNPACK_FLIP_Y_WEBGL, qe.flipY), he.pixelStorei(he.UNPACK_PREMULTIPLY_ALPHA_WEBGL, qe.premultiplyAlpha), he.pixelStorei(he.UNPACK_ALIGNMENT, qe.unpackAlignment), $e.isDataTexture ? he.texSubImage2D(he.TEXTURE_2D, ze, ve.x, ve.y, dt, tn, pn, An, $e.image.data) : $e.isCompressedTexture ? he.compressedTexSubImage2D(he.TEXTURE_2D, ze, ve.x, ve.y, $e.mipmaps[0].width, $e.mipmaps[0].height, pn, $e.mipmaps[0].data) : he.texSubImage2D(he.TEXTURE_2D, ze, ve.x, ve.y, pn, An, $e.image), ze === 0 && qe.generateMipmaps && he.generateMipmap(he.TEXTURE_2D), gt.unbindTexture();
    }, this.copyTextureToTexture3D = function(ve, $e, qe, ze, dt = 0) {
      if (k.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const tn = ve.max.x - ve.min.x + 1, pn = ve.max.y - ve.min.y + 1, An = ve.max.z - ve.min.z + 1, Gn = Se.convert(ze.format), cr = Se.convert(ze.type);
      let sn;
      if (ze.isData3DTexture)
        qt.setTexture3D(ze, 0), sn = he.TEXTURE_3D;
      else if (ze.isDataArrayTexture)
        qt.setTexture2DArray(ze, 0), sn = he.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      he.pixelStorei(he.UNPACK_FLIP_Y_WEBGL, ze.flipY), he.pixelStorei(he.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ze.premultiplyAlpha), he.pixelStorei(he.UNPACK_ALIGNMENT, ze.unpackAlignment);
      const pr = he.getParameter(he.UNPACK_ROW_LENGTH), Pr = he.getParameter(he.UNPACK_IMAGE_HEIGHT), kn = he.getParameter(he.UNPACK_SKIP_PIXELS), za = he.getParameter(he.UNPACK_SKIP_ROWS), Ja = he.getParameter(he.UNPACK_SKIP_IMAGES), Si = qe.isCompressedTexture ? qe.mipmaps[0] : qe.image;
      he.pixelStorei(he.UNPACK_ROW_LENGTH, Si.width), he.pixelStorei(he.UNPACK_IMAGE_HEIGHT, Si.height), he.pixelStorei(he.UNPACK_SKIP_PIXELS, ve.min.x), he.pixelStorei(he.UNPACK_SKIP_ROWS, ve.min.y), he.pixelStorei(he.UNPACK_SKIP_IMAGES, ve.min.z), qe.isDataTexture || qe.isData3DTexture ? he.texSubImage3D(sn, dt, $e.x, $e.y, $e.z, tn, pn, An, Gn, cr, Si.data) : qe.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), he.compressedTexSubImage3D(sn, dt, $e.x, $e.y, $e.z, tn, pn, An, Gn, Si.data)) : he.texSubImage3D(sn, dt, $e.x, $e.y, $e.z, tn, pn, An, Gn, cr, Si), he.pixelStorei(he.UNPACK_ROW_LENGTH, pr), he.pixelStorei(he.UNPACK_IMAGE_HEIGHT, Pr), he.pixelStorei(he.UNPACK_SKIP_PIXELS, kn), he.pixelStorei(he.UNPACK_SKIP_ROWS, za), he.pixelStorei(he.UNPACK_SKIP_IMAGES, Ja), dt === 0 && ze.generateMipmaps && he.generateMipmap(sn), gt.unbindTexture();
    }, this.initTexture = function(ve) {
      ve.isCubeTexture ? qt.setTextureCube(ve, 0) : ve.isData3DTexture ? qt.setTexture3D(ve, 0) : ve.isDataArrayTexture || ve.isCompressedArrayTexture ? qt.setTexture2DArray(ve, 0) : qt.setTexture2D(ve, 0), gt.unbindTexture();
    }, this.resetState = function() {
      j = 0, Y = 0, Z = null, gt.reset(), Ye.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return gv;
  }
  get physicallyCorrectLights() {
    return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights;
  }
  set physicallyCorrectLights(e) {
    console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e;
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === ai ? u0 : YO;
  }
  set outputEncoding(e) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === u0 ? ai : nm;
  }
}
class GF extends rP {
}
GF.prototype.isWebGL1Renderer = !0;
class jR {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Un(e), this.density = t;
  }
  clone() {
    return new jR(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class $R {
  constructor(e, t = 1, r = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Un(e), this.near = t, this.far = r;
  }
  clone() {
    return new $R(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class SR extends ha {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
  get autoUpdate() {
    return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate;
  }
  set autoUpdate(e) {
    console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e;
  }
}
class YR {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = DT, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = sh();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, r) {
    e *= this.stride, r *= t.stride;
    for (let a = 0, s = this.stride; a < s; a++)
      this.array[e + a] = t.array[r + a];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = sh()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = sh()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const yf = /* @__PURE__ */ new be();
class lx {
  constructor(e, t, r, a = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = r, this.normalized = a;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      yf.fromBufferAttribute(this, t), yf.applyMatrix4(e), this.setXYZ(t, yf.x, yf.y, yf.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      yf.fromBufferAttribute(this, t), yf.applyNormalMatrix(e), this.setXYZ(t, yf.x, yf.y, yf.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      yf.fromBufferAttribute(this, t), yf.transformDirection(e), this.setXYZ(t, yf.x, yf.y, yf.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = gi(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = oh(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = oh(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = oh(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = oh(t, this.array)), t;
  }
  setXY(e, t, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = gi(t, this.array), r = gi(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = gi(t, this.array), r = gi(r, this.array), a = gi(a, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = a, this;
  }
  setXYZW(e, t, r, a, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = gi(t, this.array), r = gi(r, this.array), a = gi(a, this.array), s = gi(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = a, this.data.array[e + 3] = s, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const a = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[a + s]);
      }
      return new so(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new lx(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const a = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[a + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class iP extends Ku {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Un(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let dE;
const Z1 = /* @__PURE__ */ new be(), hE = /* @__PURE__ */ new be(), pE = /* @__PURE__ */ new be(), mE = /* @__PURE__ */ new It(), J1 = /* @__PURE__ */ new It(), WF = /* @__PURE__ */ new ei(), CC = /* @__PURE__ */ new be(), eT = /* @__PURE__ */ new be(), RC = /* @__PURE__ */ new be(), F3 = /* @__PURE__ */ new It(), w2 = /* @__PURE__ */ new It(), B3 = /* @__PURE__ */ new It();
class jF extends ha {
  constructor(e) {
    if (super(), this.isSprite = !0, this.type = "Sprite", dE === void 0) {
      dE = new yi();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), r = new YR(t, 5);
      dE.setIndex([0, 1, 2, 0, 2, 3]), dE.setAttribute("position", new lx(r, 3, 0, !1)), dE.setAttribute("uv", new lx(r, 2, 3, !1));
    }
    this.geometry = dE, this.material = e !== void 0 ? e : new iP(), this.center = new It(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), hE.setFromMatrixScale(this.matrixWorld), WF.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), pE.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && hE.multiplyScalar(-pE.z);
    const r = this.material.rotation;
    let a, s;
    r !== 0 && (s = Math.cos(r), a = Math.sin(r));
    const u = this.center;
    AC(CC.set(-0.5, -0.5, 0), pE, u, hE, a, s), AC(eT.set(0.5, -0.5, 0), pE, u, hE, a, s), AC(RC.set(0.5, 0.5, 0), pE, u, hE, a, s), F3.set(0, 0), w2.set(1, 0), B3.set(1, 1);
    let h = e.ray.intersectTriangle(CC, eT, RC, !1, Z1);
    if (h === null && (AC(eT.set(-0.5, 0.5, 0), pE, u, hE, a, s), w2.set(0, 1), h = e.ray.intersectTriangle(CC, RC, eT, !1, Z1), h === null))
      return;
    const v = e.ray.origin.distanceTo(Z1);
    v < e.near || v > e.far || t.push({
      distance: v,
      point: Z1.clone(),
      uv: fd.getInterpolation(Z1, CC, eT, RC, F3, w2, B3, new It()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function AC(n, e, t, r, a, s) {
  mE.subVectors(n, t).addScalar(0.5).multiply(r), a !== void 0 ? (J1.x = s * mE.x - a * mE.y, J1.y = a * mE.x + s * mE.y) : J1.copy(mE), n.copy(e), n.x += J1.x, n.y += J1.y, n.applyMatrix4(WF);
}
const DC = /* @__PURE__ */ new be(), H3 = /* @__PURE__ */ new be();
class $F extends ha {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, a = t.length; r < a; r++) {
      const s = t[r];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, r = 0) {
    t = Math.abs(t);
    const a = this.levels;
    let s;
    for (s = 0; s < a.length && !(t < a[s].distance); s++)
      ;
    return a.splice(s, 0, { distance: t, hysteresis: r, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, a;
      for (r = 1, a = t.length; r < a; r++) {
        let s = t[r].distance;
        if (t[r].object.visible && (s -= s * t[r].hysteresis), e < s)
          break;
      }
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      DC.setFromMatrixPosition(this.matrixWorld);
      const a = e.ray.origin.distanceTo(DC);
      this.getObjectForDistance(a).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      DC.setFromMatrixPosition(e.matrixWorld), H3.setFromMatrixPosition(this.matrixWorld);
      const r = DC.distanceTo(H3) / e.zoom;
      t[0].object.visible = !0;
      let a, s;
      for (a = 1, s = t.length; a < s; a++) {
        let u = t[a].distance;
        if (t[a].object.visible && (u -= u * t[a].hysteresis), r >= u)
          t[a - 1].object.visible = !1, t[a].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = a - 1; a < s; a++)
        t[a].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const r = this.levels;
    for (let a = 0, s = r.length; a < s; a++) {
      const u = r[a];
      t.object.levels.push({
        object: u.object.uuid,
        distance: u.distance,
        hysteresis: u.hysteresis
      });
    }
    return t;
  }
}
const V3 = /* @__PURE__ */ new be(), G3 = /* @__PURE__ */ new Ua(), W3 = /* @__PURE__ */ new Ua(), o$ = /* @__PURE__ */ new be(), j3 = /* @__PURE__ */ new ei(), vE = /* @__PURE__ */ new be(), C2 = /* @__PURE__ */ new sm(), $3 = /* @__PURE__ */ new ei(), R2 = /* @__PURE__ */ new mx();
class YF extends qu {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new ei(), this.bindMatrixInverse = new ei(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Mv()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      vE.fromBufferAttribute(t, r), this.applyBoneTransform(r, vE), this.boundingBox.expandByPoint(vE);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new sm()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      vE.fromBufferAttribute(t, r), this.applyBoneTransform(r, vE), this.boundingSphere.expandByPoint(vE);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const r = this.material, a = this.matrixWorld;
    r !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), C2.copy(this.boundingSphere), C2.applyMatrix4(a), e.ray.intersectsSphere(C2) !== !1 && ($3.copy(a).invert(), R2.copy(e.ray).applyMatrix4($3), !(this.boundingBox !== null && R2.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, R2)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Ua(), t = this.geometry.attributes.skinWeight;
    for (let r = 0, a = t.count; r < a; r++) {
      e.fromBufferAttribute(t, r);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const r = this.skeleton, a = this.geometry;
    G3.fromBufferAttribute(a.attributes.skinIndex, e), W3.fromBufferAttribute(a.attributes.skinWeight, e), V3.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const u = W3.getComponent(s);
      if (u !== 0) {
        const h = G3.getComponent(s);
        j3.multiplyMatrices(r.bones[h].matrixWorld, r.boneInverses[h]), t.addScaledVector(o$.copy(V3).applyMatrix4(j3), u);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t);
  }
}
class aP extends ha {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class OE extends Rs {
  constructor(e = null, t = 1, r = 1, a, s, u, h, v, y = el, _ = el, b, M) {
    super(null, u, h, v, y, _, a, s, b, M), this.isDataTexture = !0, this.image = { data: e, width: t, height: r }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const Y3 = /* @__PURE__ */ new ei(), s$ = /* @__PURE__ */ new ei();
class XR {
  constructor(e = [], t = []) {
    this.uuid = sh(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let r = 0, a = this.bones.length; r < a; r++)
        this.boneInverses.push(new ei());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new ei();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, r = this.boneMatrices, a = this.boneTexture;
    for (let s = 0, u = e.length; s < u; s++) {
      const h = e[s] ? e[s].matrixWorld : s$;
      Y3.multiplyMatrices(h, t[s]), Y3.toArray(r, s * 16);
    }
    a !== null && (a.needsUpdate = !0);
  }
  clone() {
    return new XR(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = RF(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new OE(t, e, e, dd, vv);
    return r.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = r, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const a = this.bones[t];
      if (a.name === e)
        return a;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, a = e.bones.length; r < a; r++) {
      const s = e.bones[r];
      let u = t[s];
      u === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), u = new aP()), this.bones.push(u), this.boneInverses.push(new ei().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, r = this.boneInverses;
    for (let a = 0, s = t.length; a < s; a++) {
      const u = t[a];
      e.bones.push(u.uuid);
      const h = r[a];
      e.boneInverses.push(h.toArray());
    }
    return e;
  }
}
class IE extends so {
  constructor(e, t, r, a = 1) {
    super(e, t, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = a;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const gE = /* @__PURE__ */ new ei(), X3 = /* @__PURE__ */ new ei(), LC = [], q3 = /* @__PURE__ */ new Mv(), l$ = /* @__PURE__ */ new ei(), tT = /* @__PURE__ */ new qu(), nT = /* @__PURE__ */ new sm();
class XF extends qu {
  constructor(e, t, r) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new IE(new Float32Array(r * 16), 16), this.instanceColor = null, this.count = r, this.boundingBox = null, this.boundingSphere = null;
    for (let a = 0; a < r; a++)
      this.setMatrixAt(a, l$);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new Mv()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, gE), q3.copy(e.boundingBox).applyMatrix4(gE), this.boundingBox.union(q3);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new sm()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, gE), nT.copy(e.boundingSphere).applyMatrix4(gE), this.boundingSphere.union(nT);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const r = this.matrixWorld, a = this.count;
    if (tT.geometry = this.geometry, tT.material = this.material, tT.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), nT.copy(this.boundingSphere), nT.applyMatrix4(r), e.ray.intersectsSphere(nT) !== !1))
      for (let s = 0; s < a; s++) {
        this.getMatrixAt(s, gE), X3.multiplyMatrices(r, gE), tT.matrixWorld = X3, tT.raycast(e, LC);
        for (let u = 0, h = LC.length; u < h; u++) {
          const v = LC[u];
          v.instanceId = s, v.object = this, t.push(v);
        }
        LC.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new IE(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Tf extends Ku {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Un(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const K3 = /* @__PURE__ */ new be(), Q3 = /* @__PURE__ */ new be(), Z3 = /* @__PURE__ */ new ei(), A2 = /* @__PURE__ */ new mx(), OC = /* @__PURE__ */ new sm();
class p0 extends ha {
  constructor(e = new yi(), t = new Tf()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, r = [0];
      for (let a = 1, s = t.count; a < s; a++)
        K3.fromBufferAttribute(t, a - 1), Q3.fromBufferAttribute(t, a), r[a] = r[a - 1], r[a] += K3.distanceTo(Q3);
      e.setAttribute("lineDistance", new nr(r, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const r = this.geometry, a = this.matrixWorld, s = e.params.Line.threshold, u = r.drawRange;
    if (r.boundingSphere === null && r.computeBoundingSphere(), OC.copy(r.boundingSphere), OC.applyMatrix4(a), OC.radius += s, e.ray.intersectsSphere(OC) === !1)
      return;
    Z3.copy(a).invert(), A2.copy(e.ray).applyMatrix4(Z3);
    const h = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), v = h * h, y = new be(), _ = new be(), b = new be(), M = new be(), C = this.isLineSegments ? 2 : 1, D = r.index, N = r.attributes.position;
    if (D !== null) {
      const O = Math.max(0, u.start), I = Math.min(D.count, u.start + u.count);
      for (let k = O, G = I - 1; k < G; k += C) {
        const j = D.getX(k), Y = D.getX(k + 1);
        if (y.fromBufferAttribute(N, j), _.fromBufferAttribute(N, Y), A2.distanceSqToSegment(y, _, M, b) > v)
          continue;
        M.applyMatrix4(this.matrixWorld);
        const te = e.ray.origin.distanceTo(M);
        te < e.near || te > e.far || t.push({
          distance: te,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: b.clone().applyMatrix4(this.matrixWorld),
          index: k,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const O = Math.max(0, u.start), I = Math.min(N.count, u.start + u.count);
      for (let k = O, G = I - 1; k < G; k += C) {
        if (y.fromBufferAttribute(N, k), _.fromBufferAttribute(N, k + 1), A2.distanceSqToSegment(y, _, M, b) > v)
          continue;
        M.applyMatrix4(this.matrixWorld);
        const Y = e.ray.origin.distanceTo(M);
        Y < e.near || Y > e.far || t.push({
          distance: Y,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: b.clone().applyMatrix4(this.matrixWorld),
          index: k,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const a = t[r[0]];
      if (a !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, u = a.length; s < u; s++) {
          const h = a[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[h] = s;
        }
      }
    }
  }
}
const J3 = /* @__PURE__ */ new be(), ez = /* @__PURE__ */ new be();
class wv extends p0 {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, r = [];
      for (let a = 0, s = t.count; a < s; a += 2)
        J3.fromBufferAttribute(t, a), ez.fromBufferAttribute(t, a + 1), r[a] = a === 0 ? 0 : r[a - 1], r[a + 1] = r[a] + J3.distanceTo(ez);
      e.setAttribute("lineDistance", new nr(r, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class qF extends p0 {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class oP extends Ku {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Un(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const tz = /* @__PURE__ */ new ei(), KL = /* @__PURE__ */ new mx(), PC = /* @__PURE__ */ new sm(), NC = /* @__PURE__ */ new be();
class KF extends ha {
  constructor(e = new yi(), t = new oP()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const r = this.geometry, a = this.matrixWorld, s = e.params.Points.threshold, u = r.drawRange;
    if (r.boundingSphere === null && r.computeBoundingSphere(), PC.copy(r.boundingSphere), PC.applyMatrix4(a), PC.radius += s, e.ray.intersectsSphere(PC) === !1)
      return;
    tz.copy(a).invert(), KL.copy(e.ray).applyMatrix4(tz);
    const h = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), v = h * h, y = r.index, b = r.attributes.position;
    if (y !== null) {
      const M = Math.max(0, u.start), C = Math.min(y.count, u.start + u.count);
      for (let D = M, U = C; D < U; D++) {
        const N = y.getX(D);
        NC.fromBufferAttribute(b, N), nz(NC, N, v, a, e, t, this);
      }
    } else {
      const M = Math.max(0, u.start), C = Math.min(b.count, u.start + u.count);
      for (let D = M, U = C; D < U; D++)
        NC.fromBufferAttribute(b, D), nz(NC, D, v, a, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const a = t[r[0]];
      if (a !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, u = a.length; s < u; s++) {
          const h = a[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[h] = s;
        }
      }
    }
  }
}
function nz(n, e, t, r, a, s, u) {
  const h = KL.distanceSqToPoint(n);
  if (h < t) {
    const v = new be();
    KL.closestPointToPoint(n, v), v.applyMatrix4(r);
    const y = a.ray.origin.distanceTo(v);
    if (y < a.near || y > a.far)
      return;
    s.push({
      distance: y,
      distanceToRay: Math.sqrt(h),
      point: v,
      index: e,
      face: null,
      object: u
    });
  }
}
class u$ extends Rs {
  constructor(e, t, r, a, s, u, h, v, y) {
    super(e, t, r, a, s, u, h, v, y), this.isVideoTexture = !0, this.minFilter = u !== void 0 ? u : tl, this.magFilter = s !== void 0 ? s : tl, this.generateMipmaps = !1;
    const _ = this;
    function b() {
      _.needsUpdate = !0, e.requestVideoFrameCallback(b);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(b);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class c$ extends Rs {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = el, this.minFilter = el, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class sP extends Rs {
  constructor(e, t, r, a, s, u, h, v, y, _, b, M) {
    super(null, u, h, v, y, _, a, s, b, M), this.isCompressedTexture = !0, this.image = { width: t, height: r }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class f$ extends sP {
  constructor(e, t, r, a, s, u) {
    super(e, t, r, s, u), this.isCompressedArrayTexture = !0, this.image.depth = a, this.wrapR = Dc;
  }
}
class QF extends Rs {
  constructor(e, t, r, a, s, u, h, v, y) {
    super(e, t, r, a, s, u, h, v, y), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class lm {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPointAt(r / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r, a = this.getPoint(0), s = 0;
    t.push(0);
    for (let u = 1; u <= e; u++)
      r = this.getPoint(u / e), s += r.distanceTo(a), t.push(s), a = r;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let a = 0;
    const s = r.length;
    let u;
    t ? u = t : u = e * r[s - 1];
    let h = 0, v = s - 1, y;
    for (; h <= v; )
      if (a = Math.floor(h + (v - h) / 2), y = r[a] - u, y < 0)
        h = a + 1;
      else if (y > 0)
        v = a - 1;
      else {
        v = a;
        break;
      }
    if (a = v, r[a] === u)
      return a / (s - 1);
    const _ = r[a], M = r[a + 1] - _, C = (u - _) / M;
    return (a + C) / (s - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let a = e - 1e-4, s = e + 1e-4;
    a < 0 && (a = 0), s > 1 && (s = 1);
    const u = this.getPoint(a), h = this.getPoint(s), v = t || (u.isVector2 ? new It() : new be());
    return v.copy(h).sub(u).normalize(), v;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new be(), a = [], s = [], u = [], h = new be(), v = new ei();
    for (let C = 0; C <= e; C++) {
      const D = C / e;
      a[C] = this.getTangentAt(D, new be());
    }
    s[0] = new be(), u[0] = new be();
    let y = Number.MAX_VALUE;
    const _ = Math.abs(a[0].x), b = Math.abs(a[0].y), M = Math.abs(a[0].z);
    _ <= y && (y = _, r.set(1, 0, 0)), b <= y && (y = b, r.set(0, 1, 0)), M <= y && r.set(0, 0, 1), h.crossVectors(a[0], r).normalize(), s[0].crossVectors(a[0], h), u[0].crossVectors(a[0], s[0]);
    for (let C = 1; C <= e; C++) {
      if (s[C] = s[C - 1].clone(), u[C] = u[C - 1].clone(), h.crossVectors(a[C - 1], a[C]), h.length() > Number.EPSILON) {
        h.normalize();
        const D = Math.acos(ws(a[C - 1].dot(a[C]), -1, 1));
        s[C].applyMatrix4(v.makeRotationAxis(h, D));
      }
      u[C].crossVectors(a[C], s[C]);
    }
    if (t === !0) {
      let C = Math.acos(ws(s[0].dot(s[e]), -1, 1));
      C /= e, a[0].dot(h.crossVectors(s[0], s[e])) > 0 && (C = -C);
      for (let D = 1; D <= e; D++)
        s[D].applyMatrix4(v.makeRotationAxis(a[D], C * D)), u[D].crossVectors(a[D], s[D]);
    }
    return {
      tangents: a,
      normals: s,
      binormals: u
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class qR extends lm {
  constructor(e = 0, t = 0, r = 1, a = 1, s = 0, u = Math.PI * 2, h = !1, v = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = a, this.aStartAngle = s, this.aEndAngle = u, this.aClockwise = h, this.aRotation = v;
  }
  getPoint(e, t) {
    const r = t || new It(), a = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const u = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += a;
    for (; s > a; )
      s -= a;
    s < Number.EPSILON && (u ? s = 0 : s = a), this.aClockwise === !0 && !u && (s === a ? s = -a : s = s - a);
    const h = this.aStartAngle + e * s;
    let v = this.aX + this.xRadius * Math.cos(h), y = this.aY + this.yRadius * Math.sin(h);
    if (this.aRotation !== 0) {
      const _ = Math.cos(this.aRotation), b = Math.sin(this.aRotation), M = v - this.aX, C = y - this.aY;
      v = M * _ - C * b + this.aX, y = M * b + C * _ + this.aY;
    }
    return r.set(v, y);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class ZF extends qR {
  constructor(e, t, r, a, s, u) {
    super(e, t, r, r, a, s, u), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function lP() {
  let n = 0, e = 0, t = 0, r = 0;
  function a(s, u, h, v) {
    n = s, e = h, t = -3 * s + 3 * u - 2 * h - v, r = 2 * s - 2 * u + h + v;
  }
  return {
    initCatmullRom: function(s, u, h, v, y) {
      a(u, h, y * (h - s), y * (v - u));
    },
    initNonuniformCatmullRom: function(s, u, h, v, y, _, b) {
      let M = (u - s) / y - (h - s) / (y + _) + (h - u) / _, C = (h - u) / _ - (v - u) / (_ + b) + (v - h) / b;
      M *= _, C *= _, a(u, h, M, C);
    },
    calc: function(s) {
      const u = s * s, h = u * s;
      return n + e * s + t * u + r * h;
    }
  };
}
const UC = /* @__PURE__ */ new be(), D2 = /* @__PURE__ */ new lP(), L2 = /* @__PURE__ */ new lP(), O2 = /* @__PURE__ */ new lP();
class JF extends lm {
  constructor(e = [], t = !1, r = "centripetal", a = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = a;
  }
  getPoint(e, t = new be()) {
    const r = t, a = this.points, s = a.length, u = (s - (this.closed ? 0 : 1)) * e;
    let h = Math.floor(u), v = u - h;
    this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / s) + 1) * s : v === 0 && h === s - 1 && (h = s - 2, v = 1);
    let y, _;
    this.closed || h > 0 ? y = a[(h - 1) % s] : (UC.subVectors(a[0], a[1]).add(a[0]), y = UC);
    const b = a[h % s], M = a[(h + 1) % s];
    if (this.closed || h + 2 < s ? _ = a[(h + 2) % s] : (UC.subVectors(a[s - 1], a[s - 2]).add(a[s - 1]), _ = UC), this.curveType === "centripetal" || this.curveType === "chordal") {
      const C = this.curveType === "chordal" ? 0.5 : 0.25;
      let D = Math.pow(y.distanceToSquared(b), C), U = Math.pow(b.distanceToSquared(M), C), N = Math.pow(M.distanceToSquared(_), C);
      U < 1e-4 && (U = 1), D < 1e-4 && (D = U), N < 1e-4 && (N = U), D2.initNonuniformCatmullRom(y.x, b.x, M.x, _.x, D, U, N), L2.initNonuniformCatmullRom(y.y, b.y, M.y, _.y, D, U, N), O2.initNonuniformCatmullRom(y.z, b.z, M.z, _.z, D, U, N);
    } else
      this.curveType === "catmullrom" && (D2.initCatmullRom(y.x, b.x, M.x, _.x, this.tension), L2.initCatmullRom(y.y, b.y, M.y, _.y, this.tension), O2.initCatmullRom(y.z, b.z, M.z, _.z, this.tension));
    return r.set(
      D2.calc(v),
      L2.calc(v),
      O2.calc(v)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const a = e.points[t];
      this.points.push(a.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const a = this.points[t];
      e.points.push(a.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const a = e.points[t];
      this.points.push(new be().fromArray(a));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function rz(n, e, t, r, a) {
  const s = (r - e) * 0.5, u = (a - t) * 0.5, h = n * n, v = n * h;
  return (2 * t - 2 * r + s + u) * v + (-3 * t + 3 * r - 2 * s - u) * h + s * n + t;
}
function d$(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function h$(n, e) {
  return 2 * (1 - n) * n * e;
}
function p$(n, e) {
  return n * n * e;
}
function yT(n, e, t, r) {
  return d$(n, e) + h$(n, t) + p$(n, r);
}
function m$(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function v$(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function g$(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function y$(n, e) {
  return n * n * n * e;
}
function ST(n, e, t, r, a) {
  return m$(n, e) + v$(n, t) + g$(n, r) + y$(n, a);
}
class uP extends lm {
  constructor(e = new It(), t = new It(), r = new It(), a = new It()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = a;
  }
  getPoint(e, t = new It()) {
    const r = t, a = this.v0, s = this.v1, u = this.v2, h = this.v3;
    return r.set(
      ST(e, a.x, s.x, u.x, h.x),
      ST(e, a.y, s.y, u.y, h.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class eB extends lm {
  constructor(e = new be(), t = new be(), r = new be(), a = new be()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = a;
  }
  getPoint(e, t = new be()) {
    const r = t, a = this.v0, s = this.v1, u = this.v2, h = this.v3;
    return r.set(
      ST(e, a.x, s.x, u.x, h.x),
      ST(e, a.y, s.y, u.y, h.y),
      ST(e, a.z, s.z, u.z, h.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class KR extends lm {
  constructor(e = new It(), t = new It()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new It()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new It()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class tB extends lm {
  constructor(e = new be(), t = new be()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new be()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new be()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class cP extends lm {
  constructor(e = new It(), t = new It(), r = new It()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new It()) {
    const r = t, a = this.v0, s = this.v1, u = this.v2;
    return r.set(
      yT(e, a.x, s.x, u.x),
      yT(e, a.y, s.y, u.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class fP extends lm {
  constructor(e = new be(), t = new be(), r = new be()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new be()) {
    const r = t, a = this.v0, s = this.v1, u = this.v2;
    return r.set(
      yT(e, a.x, s.x, u.x),
      yT(e, a.y, s.y, u.y),
      yT(e, a.z, s.z, u.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class dP extends lm {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new It()) {
    const r = t, a = this.points, s = (a.length - 1) * e, u = Math.floor(s), h = s - u, v = a[u === 0 ? u : u - 1], y = a[u], _ = a[u > a.length - 2 ? a.length - 1 : u + 1], b = a[u > a.length - 3 ? a.length - 1 : u + 2];
    return r.set(
      rz(h, v.x, y.x, _.x, b.x),
      rz(h, v.y, y.y, _.y, b.y)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const a = e.points[t];
      this.points.push(a.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const a = this.points[t];
      e.points.push(a.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const a = e.points[t];
      this.points.push(new It().fromArray(a));
    }
    return this;
  }
}
var hP = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: ZF,
  CatmullRomCurve3: JF,
  CubicBezierCurve: uP,
  CubicBezierCurve3: eB,
  EllipseCurve: qR,
  LineCurve: KR,
  LineCurve3: tB,
  QuadraticBezierCurve: cP,
  QuadraticBezierCurve3: fP,
  SplineCurve: dP
});
class nB extends lm {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new KR(t, e));
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const r = e * this.getLength(), a = this.getCurveLengths();
    let s = 0;
    for (; s < a.length; ) {
      if (a[s] >= r) {
        const u = a[s] - r, h = this.curves[s], v = h.getLength(), y = v === 0 ? 0 : 1 - u / v;
        return h.getPointAt(y, t);
      }
      s++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, a = this.curves.length; r < a; r++)
      t += this.curves[r].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let a = 0, s = this.curves; a < s.length; a++) {
      const u = s[a], h = u.isEllipseCurve ? e * 2 : u.isLineCurve || u.isLineCurve3 ? 1 : u.isSplineCurve ? e * u.points.length : e, v = u.getPoints(h);
      for (let y = 0; y < v.length; y++) {
        const _ = v[y];
        r && r.equals(_) || (t.push(_), r = _);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const a = e.curves[t];
      this.curves.push(a.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const a = this.curves[t];
      e.curves.push(a.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const a = e.curves[t];
      this.curves.push(new hP[a.type]().fromJSON(a));
    }
    return this;
  }
}
class PT extends nB {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new It(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new KR(this.currentPoint.clone(), new It(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, a) {
    const s = new cP(
      this.currentPoint.clone(),
      new It(e, t),
      new It(r, a)
    );
    return this.curves.push(s), this.currentPoint.set(r, a), this;
  }
  bezierCurveTo(e, t, r, a, s, u) {
    const h = new uP(
      this.currentPoint.clone(),
      new It(e, t),
      new It(r, a),
      new It(s, u)
    );
    return this.curves.push(h), this.currentPoint.set(s, u), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), r = new dP(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, a, s, u) {
    const h = this.currentPoint.x, v = this.currentPoint.y;
    return this.absarc(
      e + h,
      t + v,
      r,
      a,
      s,
      u
    ), this;
  }
  absarc(e, t, r, a, s, u) {
    return this.absellipse(e, t, r, r, a, s, u), this;
  }
  ellipse(e, t, r, a, s, u, h, v) {
    const y = this.currentPoint.x, _ = this.currentPoint.y;
    return this.absellipse(e + y, t + _, r, a, s, u, h, v), this;
  }
  absellipse(e, t, r, a, s, u, h, v) {
    const y = new qR(e, t, r, a, s, u, h, v);
    if (this.curves.length > 0) {
      const b = y.getPoint(0);
      b.equals(this.currentPoint) || this.lineTo(b.x, b.y);
    }
    this.curves.push(y);
    const _ = y.getPoint(1);
    return this.currentPoint.copy(_), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class YE extends yi {
  constructor(e = [new It(0, -0.5), new It(0.5, 0), new It(0, 0.5)], t = 12, r = 0, a = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: r,
      phiLength: a
    }, t = Math.floor(t), a = ws(a, 0, Math.PI * 2);
    const s = [], u = [], h = [], v = [], y = [], _ = 1 / t, b = new be(), M = new It(), C = new be(), D = new be(), U = new be();
    let N = 0, O = 0;
    for (let I = 0; I <= e.length - 1; I++)
      switch (I) {
        case 0:
          N = e[I + 1].x - e[I].x, O = e[I + 1].y - e[I].y, C.x = O * 1, C.y = -N, C.z = O * 0, U.copy(C), C.normalize(), v.push(C.x, C.y, C.z);
          break;
        case e.length - 1:
          v.push(U.x, U.y, U.z);
          break;
        default:
          N = e[I + 1].x - e[I].x, O = e[I + 1].y - e[I].y, C.x = O * 1, C.y = -N, C.z = O * 0, D.copy(C), C.x += U.x, C.y += U.y, C.z += U.z, C.normalize(), v.push(C.x, C.y, C.z), U.copy(D);
      }
    for (let I = 0; I <= t; I++) {
      const k = r + I * _ * a, G = Math.sin(k), j = Math.cos(k);
      for (let Y = 0; Y <= e.length - 1; Y++) {
        b.x = e[Y].x * G, b.y = e[Y].y, b.z = e[Y].x * j, u.push(b.x, b.y, b.z), M.x = I / t, M.y = Y / (e.length - 1), h.push(M.x, M.y);
        const Z = v[3 * Y + 0] * G, te = v[3 * Y + 1], J = v[3 * Y + 0] * j;
        y.push(Z, te, J);
      }
    }
    for (let I = 0; I < t; I++)
      for (let k = 0; k < e.length - 1; k++) {
        const G = k + I * e.length, j = G, Y = G + e.length, Z = G + e.length + 1, te = G + 1;
        s.push(j, Y, te), s.push(Z, te, Y);
      }
    this.setIndex(s), this.setAttribute("position", new nr(u, 3)), this.setAttribute("uv", new nr(h, 2)), this.setAttribute("normal", new nr(y, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new YE(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class QT extends YE {
  constructor(e = 1, t = 1, r = 4, a = 8) {
    const s = new PT();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(r), a), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      height: t,
      capSegments: r,
      radialSegments: a
    };
  }
  static fromJSON(e) {
    return new QT(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class ZT extends yi {
  constructor(e = 1, t = 32, r = 0, a = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: r,
      thetaLength: a
    }, t = Math.max(3, t);
    const s = [], u = [], h = [], v = [], y = new be(), _ = new It();
    u.push(0, 0, 0), h.push(0, 0, 1), v.push(0.5, 0.5);
    for (let b = 0, M = 3; b <= t; b++, M += 3) {
      const C = r + b / t * a;
      y.x = e * Math.cos(C), y.y = e * Math.sin(C), u.push(y.x, y.y, y.z), h.push(0, 0, 1), _.x = (u[M] / e + 1) / 2, _.y = (u[M + 1] / e + 1) / 2, v.push(_.x, _.y);
    }
    for (let b = 1; b <= t; b++)
      s.push(b, b + 1, 0);
    this.setIndex(s), this.setAttribute("position", new nr(u, 3)), this.setAttribute("normal", new nr(h, 3)), this.setAttribute("uv", new nr(v, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ZT(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class vx extends yi {
  constructor(e = 1, t = 1, r = 1, a = 32, s = 1, u = !1, h = 0, v = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: r,
      radialSegments: a,
      heightSegments: s,
      openEnded: u,
      thetaStart: h,
      thetaLength: v
    };
    const y = this;
    a = Math.floor(a), s = Math.floor(s);
    const _ = [], b = [], M = [], C = [];
    let D = 0;
    const U = [], N = r / 2;
    let O = 0;
    I(), u === !1 && (e > 0 && k(!0), t > 0 && k(!1)), this.setIndex(_), this.setAttribute("position", new nr(b, 3)), this.setAttribute("normal", new nr(M, 3)), this.setAttribute("uv", new nr(C, 2));
    function I() {
      const G = new be(), j = new be();
      let Y = 0;
      const Z = (t - e) / r;
      for (let te = 0; te <= s; te++) {
        const J = [], q = te / s, oe = q * (t - e) + e;
        for (let ye = 0; ye <= a; ye++) {
          const de = ye / a, xe = de * v + h, Re = Math.sin(xe), Pe = Math.cos(xe);
          j.x = oe * Re, j.y = -q * r + N, j.z = oe * Pe, b.push(j.x, j.y, j.z), G.set(Re, Z, Pe).normalize(), M.push(G.x, G.y, G.z), C.push(de, 1 - q), J.push(D++);
        }
        U.push(J);
      }
      for (let te = 0; te < a; te++)
        for (let J = 0; J < s; J++) {
          const q = U[J][te], oe = U[J + 1][te], ye = U[J + 1][te + 1], de = U[J][te + 1];
          _.push(q, oe, de), _.push(oe, ye, de), Y += 6;
        }
      y.addGroup(O, Y, 0), O += Y;
    }
    function k(G) {
      const j = D, Y = new It(), Z = new be();
      let te = 0;
      const J = G === !0 ? e : t, q = G === !0 ? 1 : -1;
      for (let ye = 1; ye <= a; ye++)
        b.push(0, N * q, 0), M.push(0, q, 0), C.push(0.5, 0.5), D++;
      const oe = D;
      for (let ye = 0; ye <= a; ye++) {
        const xe = ye / a * v + h, Re = Math.cos(xe), Pe = Math.sin(xe);
        Z.x = J * Pe, Z.y = N * q, Z.z = J * Re, b.push(Z.x, Z.y, Z.z), M.push(0, q, 0), Y.x = Re * 0.5 + 0.5, Y.y = Pe * 0.5 * q + 0.5, C.push(Y.x, Y.y), D++;
      }
      for (let ye = 0; ye < a; ye++) {
        const de = j + ye, xe = oe + ye;
        G === !0 ? _.push(xe, xe + 1, de) : _.push(xe + 1, xe, de), te += 3;
      }
      y.addGroup(O, te, G === !0 ? 1 : 2), O += te;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new vx(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class JT extends vx {
  constructor(e = 1, t = 1, r = 32, a = 1, s = !1, u = 0, h = Math.PI * 2) {
    super(0, e, t, r, a, s, u, h), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: r,
      heightSegments: a,
      openEnded: s,
      thetaStart: u,
      thetaLength: h
    };
  }
  static fromJSON(e) {
    return new JT(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Wg extends yi {
  constructor(e = [], t = [], r = 1, a = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: r,
      detail: a
    };
    const s = [], u = [];
    h(a), y(r), _(), this.setAttribute("position", new nr(s, 3)), this.setAttribute("normal", new nr(s.slice(), 3)), this.setAttribute("uv", new nr(u, 2)), a === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function h(I) {
      const k = new be(), G = new be(), j = new be();
      for (let Y = 0; Y < t.length; Y += 3)
        C(t[Y + 0], k), C(t[Y + 1], G), C(t[Y + 2], j), v(k, G, j, I);
    }
    function v(I, k, G, j) {
      const Y = j + 1, Z = [];
      for (let te = 0; te <= Y; te++) {
        Z[te] = [];
        const J = I.clone().lerp(G, te / Y), q = k.clone().lerp(G, te / Y), oe = Y - te;
        for (let ye = 0; ye <= oe; ye++)
          ye === 0 && te === Y ? Z[te][ye] = J : Z[te][ye] = J.clone().lerp(q, ye / oe);
      }
      for (let te = 0; te < Y; te++)
        for (let J = 0; J < 2 * (Y - te) - 1; J++) {
          const q = Math.floor(J / 2);
          J % 2 === 0 ? (M(Z[te][q + 1]), M(Z[te + 1][q]), M(Z[te][q])) : (M(Z[te][q + 1]), M(Z[te + 1][q + 1]), M(Z[te + 1][q]));
        }
    }
    function y(I) {
      const k = new be();
      for (let G = 0; G < s.length; G += 3)
        k.x = s[G + 0], k.y = s[G + 1], k.z = s[G + 2], k.normalize().multiplyScalar(I), s[G + 0] = k.x, s[G + 1] = k.y, s[G + 2] = k.z;
    }
    function _() {
      const I = new be();
      for (let k = 0; k < s.length; k += 3) {
        I.x = s[k + 0], I.y = s[k + 1], I.z = s[k + 2];
        const G = N(I) / 2 / Math.PI + 0.5, j = O(I) / Math.PI + 0.5;
        u.push(G, 1 - j);
      }
      D(), b();
    }
    function b() {
      for (let I = 0; I < u.length; I += 6) {
        const k = u[I + 0], G = u[I + 2], j = u[I + 4], Y = Math.max(k, G, j), Z = Math.min(k, G, j);
        Y > 0.9 && Z < 0.1 && (k < 0.2 && (u[I + 0] += 1), G < 0.2 && (u[I + 2] += 1), j < 0.2 && (u[I + 4] += 1));
      }
    }
    function M(I) {
      s.push(I.x, I.y, I.z);
    }
    function C(I, k) {
      const G = I * 3;
      k.x = e[G + 0], k.y = e[G + 1], k.z = e[G + 2];
    }
    function D() {
      const I = new be(), k = new be(), G = new be(), j = new be(), Y = new It(), Z = new It(), te = new It();
      for (let J = 0, q = 0; J < s.length; J += 9, q += 6) {
        I.set(s[J + 0], s[J + 1], s[J + 2]), k.set(s[J + 3], s[J + 4], s[J + 5]), G.set(s[J + 6], s[J + 7], s[J + 8]), Y.set(u[q + 0], u[q + 1]), Z.set(u[q + 2], u[q + 3]), te.set(u[q + 4], u[q + 5]), j.copy(I).add(k).add(G).divideScalar(3);
        const oe = N(j);
        U(Y, q + 0, I, oe), U(Z, q + 2, k, oe), U(te, q + 4, G, oe);
      }
    }
    function U(I, k, G, j) {
      j < 0 && I.x === 1 && (u[k] = I.x - 1), G.x === 0 && G.z === 0 && (u[k] = j / 2 / Math.PI + 0.5);
    }
    function N(I) {
      return Math.atan2(I.z, -I.x);
    }
    function O(I) {
      return Math.atan2(-I.y, Math.sqrt(I.x * I.x + I.z * I.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Wg(e.vertices, e.indices, e.radius, e.details);
  }
}
class eM extends Wg {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, a = 1 / r, s = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -a,
      -r,
      0,
      -a,
      r,
      0,
      a,
      -r,
      0,
      a,
      r,
      // (1/, , 0)
      -a,
      -r,
      0,
      -a,
      r,
      0,
      a,
      -r,
      0,
      a,
      r,
      0,
      // (, 0, 1/)
      -r,
      0,
      -a,
      r,
      0,
      -a,
      -r,
      0,
      a,
      r,
      0,
      a
    ], u = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(s, u, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new eM(e.radius, e.detail);
  }
}
const zC = /* @__PURE__ */ new be(), kC = /* @__PURE__ */ new be(), P2 = /* @__PURE__ */ new be(), IC = /* @__PURE__ */ new fd();
class rB extends yi {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const a = Math.pow(10, 4), s = Math.cos(nx * t), u = e.getIndex(), h = e.getAttribute("position"), v = u ? u.count : h.count, y = [0, 0, 0], _ = ["a", "b", "c"], b = new Array(3), M = {}, C = [];
      for (let D = 0; D < v; D += 3) {
        u ? (y[0] = u.getX(D), y[1] = u.getX(D + 1), y[2] = u.getX(D + 2)) : (y[0] = D, y[1] = D + 1, y[2] = D + 2);
        const { a: U, b: N, c: O } = IC;
        if (U.fromBufferAttribute(h, y[0]), N.fromBufferAttribute(h, y[1]), O.fromBufferAttribute(h, y[2]), IC.getNormal(P2), b[0] = `${Math.round(U.x * a)},${Math.round(U.y * a)},${Math.round(U.z * a)}`, b[1] = `${Math.round(N.x * a)},${Math.round(N.y * a)},${Math.round(N.z * a)}`, b[2] = `${Math.round(O.x * a)},${Math.round(O.y * a)},${Math.round(O.z * a)}`, !(b[0] === b[1] || b[1] === b[2] || b[2] === b[0]))
          for (let I = 0; I < 3; I++) {
            const k = (I + 1) % 3, G = b[I], j = b[k], Y = IC[_[I]], Z = IC[_[k]], te = `${G}_${j}`, J = `${j}_${G}`;
            J in M && M[J] ? (P2.dot(M[J].normal) <= s && (C.push(Y.x, Y.y, Y.z), C.push(Z.x, Z.y, Z.z)), M[J] = null) : te in M || (M[te] = {
              index0: y[I],
              index1: y[k],
              normal: P2.clone()
            });
          }
      }
      for (const D in M)
        if (M[D]) {
          const { index0: U, index1: N } = M[D];
          zC.fromBufferAttribute(h, U), kC.fromBufferAttribute(h, N), C.push(zC.x, zC.y, zC.z), C.push(kC.x, kC.y, kC.z);
        }
      this.setAttribute("position", new nr(C, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class ix extends PT {
  constructor(e) {
    super(e), this.uuid = sh(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, a = this.holes.length; r < a; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const a = e.holes[t];
      this.holes.push(a.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const a = this.holes[t];
      e.holes.push(a.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const a = e.holes[t];
      this.holes.push(new PT().fromJSON(a));
    }
    return this;
  }
}
const S$ = {
  triangulate: function(n, e, t = 2) {
    const r = e && e.length, a = r ? e[0] * t : n.length;
    let s = iB(n, 0, a, t, !0);
    const u = [];
    if (!s || s.next === s.prev)
      return u;
    let h, v, y, _, b, M, C;
    if (r && (s = T$(n, e, s, t)), n.length > 80 * t) {
      h = y = n[0], v = _ = n[1];
      for (let D = t; D < a; D += t)
        b = n[D], M = n[D + 1], b < h && (h = b), M < v && (v = M), b > y && (y = b), M > _ && (_ = M);
      C = Math.max(y - h, _ - v), C = C !== 0 ? 32767 / C : 0;
    }
    return NT(s, u, t, h, v, C, 0), u;
  }
};
function iB(n, e, t, r, a) {
  let s, u;
  if (a === U$(n, e, t, r) > 0)
    for (s = e; s < t; s += r)
      u = iz(s, n[s], n[s + 1], u);
  else
    for (s = t - r; s >= e; s -= r)
      u = iz(s, n[s], n[s + 1], u);
  return u && QR(u, u.next) && (zT(u), u = u.next), u;
}
function ux(n, e) {
  if (!n)
    return n;
  e || (e = n);
  let t = n, r;
  do
    if (r = !1, !t.steiner && (QR(t, t.next) || as(t.prev, t, t.next) === 0)) {
      if (zT(t), t = e = t.prev, t === t.next)
        break;
      r = !0;
    } else
      t = t.next;
  while (r || t !== e);
  return e;
}
function NT(n, e, t, r, a, s, u) {
  if (!n)
    return;
  !u && s && A$(n, r, a, s);
  let h = n, v, y;
  for (; n.prev !== n.next; ) {
    if (v = n.prev, y = n.next, s ? _$(n, r, a, s) : x$(n)) {
      e.push(v.i / t | 0), e.push(n.i / t | 0), e.push(y.i / t | 0), zT(n), n = y.next, h = y.next;
      continue;
    }
    if (n = y, n === h) {
      u ? u === 1 ? (n = E$(ux(n), e, t), NT(n, e, t, r, a, s, 2)) : u === 2 && b$(n, e, t, r, a, s) : NT(ux(n), e, t, r, a, s, 1);
      break;
    }
  }
}
function x$(n) {
  const e = n.prev, t = n, r = n.next;
  if (as(e, t, r) >= 0)
    return !1;
  const a = e.x, s = t.x, u = r.x, h = e.y, v = t.y, y = r.y, _ = a < s ? a < u ? a : u : s < u ? s : u, b = h < v ? h < y ? h : y : v < y ? v : y, M = a > s ? a > u ? a : u : s > u ? s : u, C = h > v ? h > y ? h : y : v > y ? v : y;
  let D = r.next;
  for (; D !== e; ) {
    if (D.x >= _ && D.x <= M && D.y >= b && D.y <= C && RE(a, h, s, v, u, y, D.x, D.y) && as(D.prev, D, D.next) >= 0)
      return !1;
    D = D.next;
  }
  return !0;
}
function _$(n, e, t, r) {
  const a = n.prev, s = n, u = n.next;
  if (as(a, s, u) >= 0)
    return !1;
  const h = a.x, v = s.x, y = u.x, _ = a.y, b = s.y, M = u.y, C = h < v ? h < y ? h : y : v < y ? v : y, D = _ < b ? _ < M ? _ : M : b < M ? b : M, U = h > v ? h > y ? h : y : v > y ? v : y, N = _ > b ? _ > M ? _ : M : b > M ? b : M, O = QL(C, D, e, t, r), I = QL(U, N, e, t, r);
  let k = n.prevZ, G = n.nextZ;
  for (; k && k.z >= O && G && G.z <= I; ) {
    if (k.x >= C && k.x <= U && k.y >= D && k.y <= N && k !== a && k !== u && RE(h, _, v, b, y, M, k.x, k.y) && as(k.prev, k, k.next) >= 0 || (k = k.prevZ, G.x >= C && G.x <= U && G.y >= D && G.y <= N && G !== a && G !== u && RE(h, _, v, b, y, M, G.x, G.y) && as(G.prev, G, G.next) >= 0))
      return !1;
    G = G.nextZ;
  }
  for (; k && k.z >= O; ) {
    if (k.x >= C && k.x <= U && k.y >= D && k.y <= N && k !== a && k !== u && RE(h, _, v, b, y, M, k.x, k.y) && as(k.prev, k, k.next) >= 0)
      return !1;
    k = k.prevZ;
  }
  for (; G && G.z <= I; ) {
    if (G.x >= C && G.x <= U && G.y >= D && G.y <= N && G !== a && G !== u && RE(h, _, v, b, y, M, G.x, G.y) && as(G.prev, G, G.next) >= 0)
      return !1;
    G = G.nextZ;
  }
  return !0;
}
function E$(n, e, t) {
  let r = n;
  do {
    const a = r.prev, s = r.next.next;
    !QR(a, s) && aB(a, r, r.next, s) && UT(a, s) && UT(s, a) && (e.push(a.i / t | 0), e.push(r.i / t | 0), e.push(s.i / t | 0), zT(r), zT(r.next), r = n = s), r = r.next;
  } while (r !== n);
  return ux(r);
}
function b$(n, e, t, r, a, s) {
  let u = n;
  do {
    let h = u.next.next;
    for (; h !== u.prev; ) {
      if (u.i !== h.i && O$(u, h)) {
        let v = oB(u, h);
        u = ux(u, u.next), v = ux(v, v.next), NT(u, e, t, r, a, s, 0), NT(v, e, t, r, a, s, 0);
        return;
      }
      h = h.next;
    }
    u = u.next;
  } while (u !== n);
}
function T$(n, e, t, r) {
  const a = [];
  let s, u, h, v, y;
  for (s = 0, u = e.length; s < u; s++)
    h = e[s] * r, v = s < u - 1 ? e[s + 1] * r : n.length, y = iB(n, h, v, r, !1), y === y.next && (y.steiner = !0), a.push(L$(y));
  for (a.sort(M$), s = 0; s < a.length; s++)
    t = w$(a[s], t);
  return t;
}
function M$(n, e) {
  return n.x - e.x;
}
function w$(n, e) {
  const t = C$(n, e);
  if (!t)
    return e;
  const r = oB(t, n);
  return ux(r, r.next), ux(t, t.next);
}
function C$(n, e) {
  let t = e, r = -1 / 0, a;
  const s = n.x, u = n.y;
  do {
    if (u <= t.y && u >= t.next.y && t.next.y !== t.y) {
      const M = t.x + (u - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (M <= s && M > r && (r = M, a = t.x < t.next.x ? t : t.next, M === s))
        return a;
    }
    t = t.next;
  } while (t !== e);
  if (!a)
    return null;
  const h = a, v = a.x, y = a.y;
  let _ = 1 / 0, b;
  t = a;
  do
    s >= t.x && t.x >= v && s !== t.x && RE(u < y ? s : r, u, v, y, u < y ? r : s, u, t.x, t.y) && (b = Math.abs(u - t.y) / (s - t.x), UT(t, n) && (b < _ || b === _ && (t.x > a.x || t.x === a.x && R$(a, t))) && (a = t, _ = b)), t = t.next;
  while (t !== h);
  return a;
}
function R$(n, e) {
  return as(n.prev, n, e.prev) < 0 && as(e.next, n, n.next) < 0;
}
function A$(n, e, t, r) {
  let a = n;
  do
    a.z === 0 && (a.z = QL(a.x, a.y, e, t, r)), a.prevZ = a.prev, a.nextZ = a.next, a = a.next;
  while (a !== n);
  a.prevZ.nextZ = null, a.prevZ = null, D$(a);
}
function D$(n) {
  let e, t, r, a, s, u, h, v, y = 1;
  do {
    for (t = n, n = null, s = null, u = 0; t; ) {
      for (u++, r = t, h = 0, e = 0; e < y && (h++, r = r.nextZ, !!r); e++)
        ;
      for (v = y; h > 0 || v > 0 && r; )
        h !== 0 && (v === 0 || !r || t.z <= r.z) ? (a = t, t = t.nextZ, h--) : (a = r, r = r.nextZ, v--), s ? s.nextZ = a : n = a, a.prevZ = s, s = a;
      t = r;
    }
    s.nextZ = null, y *= 2;
  } while (u > 1);
  return n;
}
function QL(n, e, t, r, a) {
  return n = (n - t) * a | 0, e = (e - r) * a | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1;
}
function L$(n) {
  let e = n, t = n;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== n);
  return t;
}
function RE(n, e, t, r, a, s, u, h) {
  return (a - u) * (e - h) >= (n - u) * (s - h) && (n - u) * (r - h) >= (t - u) * (e - h) && (t - u) * (s - h) >= (a - u) * (r - h);
}
function O$(n, e) {
  return n.next.i !== e.i && n.prev.i !== e.i && !P$(n, e) && // dones't intersect other edges
  (UT(n, e) && UT(e, n) && N$(n, e) && // locally visible
  (as(n.prev, n, e.prev) || as(n, e.prev, e)) || // does not create opposite-facing sectors
  QR(n, e) && as(n.prev, n, n.next) > 0 && as(e.prev, e, e.next) > 0);
}
function as(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function QR(n, e) {
  return n.x === e.x && n.y === e.y;
}
function aB(n, e, t, r) {
  const a = BC(as(n, e, t)), s = BC(as(n, e, r)), u = BC(as(t, r, n)), h = BC(as(t, r, e));
  return !!(a !== s && u !== h || a === 0 && FC(n, t, e) || s === 0 && FC(n, r, e) || u === 0 && FC(t, n, r) || h === 0 && FC(t, e, r));
}
function FC(n, e, t) {
  return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y);
}
function BC(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function P$(n, e) {
  let t = n;
  do {
    if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && aB(t, t.next, n, e))
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function UT(n, e) {
  return as(n.prev, n, n.next) < 0 ? as(n, e, n.next) >= 0 && as(n, n.prev, e) >= 0 : as(n, e, n.prev) < 0 || as(n, n.next, e) < 0;
}
function N$(n, e) {
  let t = n, r = !1;
  const a = (n.x + e.x) / 2, s = (n.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && a < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next;
  while (t !== n);
  return r;
}
function oB(n, e) {
  const t = new ZL(n.i, n.x, n.y), r = new ZL(e.i, e.x, e.y), a = n.next, s = e.prev;
  return n.next = e, e.prev = n, t.next = a, a.prev = t, r.next = t, t.prev = r, s.next = r, r.prev = s, r;
}
function iz(n, e, t, r) {
  const a = new ZL(n, e, t);
  return r ? (a.next = r.next, a.prev = r, r.next.prev = a, r.next = a) : (a.prev = a, a.next = a), a;
}
function zT(n) {
  n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function ZL(n, e, t) {
  this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function U$(n, e, t, r) {
  let a = 0;
  for (let s = e, u = t - r; s < t; s += r)
    a += (n[u] - n[s]) * (n[s + 1] + n[u + 1]), u = s;
  return a;
}
class xv {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let a = t - 1, s = 0; s < t; a = s++)
      r += e[a].x * e[s].y - e[s].x * e[a].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return xv.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [], a = [], s = [];
    az(e), oz(r, e);
    let u = e.length;
    t.forEach(az);
    for (let v = 0; v < t.length; v++)
      a.push(u), u += t[v].length, oz(r, t[v]);
    const h = S$.triangulate(r, a);
    for (let v = 0; v < h.length; v += 3)
      s.push(h.slice(v, v + 3));
    return s;
  }
}
function az(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function oz(n, e) {
  for (let t = 0; t < e.length; t++)
    n.push(e[t].x), n.push(e[t].y);
}
class tM extends yi {
  constructor(e = new ix([new It(0.5, 0.5), new It(-0.5, 0.5), new It(-0.5, -0.5), new It(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const r = this, a = [], s = [];
    for (let h = 0, v = e.length; h < v; h++) {
      const y = e[h];
      u(y);
    }
    this.setAttribute("position", new nr(a, 3)), this.setAttribute("uv", new nr(s, 2)), this.computeVertexNormals();
    function u(h) {
      const v = [], y = t.curveSegments !== void 0 ? t.curveSegments : 12, _ = t.steps !== void 0 ? t.steps : 1, b = t.depth !== void 0 ? t.depth : 1;
      let M = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, C = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, D = t.bevelSize !== void 0 ? t.bevelSize : C - 0.1, U = t.bevelOffset !== void 0 ? t.bevelOffset : 0, N = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const O = t.extrudePath, I = t.UVGenerator !== void 0 ? t.UVGenerator : z$;
      let k, G = !1, j, Y, Z, te;
      O && (k = O.getSpacedPoints(_), G = !0, M = !1, j = O.computeFrenetFrames(_, !1), Y = new be(), Z = new be(), te = new be()), M || (N = 0, C = 0, D = 0, U = 0);
      const J = h.extractPoints(y);
      let q = J.shape;
      const oe = J.holes;
      if (!xv.isClockWise(q)) {
        q = q.reverse();
        for (let he = 0, nt = oe.length; he < nt; he++) {
          const et = oe[he];
          xv.isClockWise(et) && (oe[he] = et.reverse());
        }
      }
      const de = xv.triangulateShape(q, oe), xe = q;
      for (let he = 0, nt = oe.length; he < nt; he++) {
        const et = oe[he];
        q = q.concat(et);
      }
      function Re(he, nt, et) {
        return nt || console.error("THREE.ExtrudeGeometry: vec does not exist"), he.clone().addScaledVector(nt, et);
      }
      const Pe = q.length, Te = de.length;
      function ue(he, nt, et) {
        let Rt, gt, Jt;
        const Kt = he.x - nt.x, qt = he.y - nt.y, hn = et.x - he.x, Rn = et.y - he.y, Yn = Kt * Kt + qt * qt, se = Kt * Rn - qt * hn;
        if (Math.abs(se) > Number.EPSILON) {
          const ae = Math.sqrt(Yn), Ke = Math.sqrt(hn * hn + Rn * Rn), wt = nt.x - qt / ae, _t = nt.y + Kt / ae, Vt = et.x - Rn / Ke, fn = et.y + hn / Ke, Wt = ((Vt - wt) * Rn - (fn - _t) * hn) / (Kt * Rn - qt * hn);
          Rt = wt + Kt * Wt - he.x, gt = _t + qt * Wt - he.y;
          const Ee = Rt * Rt + gt * gt;
          if (Ee <= 2)
            return new It(Rt, gt);
          Jt = Math.sqrt(Ee / 2);
        } else {
          let ae = !1;
          Kt > Number.EPSILON ? hn > Number.EPSILON && (ae = !0) : Kt < -Number.EPSILON ? hn < -Number.EPSILON && (ae = !0) : Math.sign(qt) === Math.sign(Rn) && (ae = !0), ae ? (Rt = -qt, gt = Kt, Jt = Math.sqrt(Yn)) : (Rt = Kt, gt = qt, Jt = Math.sqrt(Yn / 2));
        }
        return new It(Rt / Jt, gt / Jt);
      }
      const we = [];
      for (let he = 0, nt = xe.length, et = nt - 1, Rt = he + 1; he < nt; he++, et++, Rt++)
        et === nt && (et = 0), Rt === nt && (Rt = 0), we[he] = ue(xe[he], xe[et], xe[Rt]);
      const X = [];
      let me, ce = we.concat();
      for (let he = 0, nt = oe.length; he < nt; he++) {
        const et = oe[he];
        me = [];
        for (let Rt = 0, gt = et.length, Jt = gt - 1, Kt = Rt + 1; Rt < gt; Rt++, Jt++, Kt++)
          Jt === gt && (Jt = 0), Kt === gt && (Kt = 0), me[Rt] = ue(et[Rt], et[Jt], et[Kt]);
        X.push(me), ce = ce.concat(me);
      }
      for (let he = 0; he < N; he++) {
        const nt = he / N, et = C * Math.cos(nt * Math.PI / 2), Rt = D * Math.sin(nt * Math.PI / 2) + U;
        for (let gt = 0, Jt = xe.length; gt < Jt; gt++) {
          const Kt = Re(xe[gt], we[gt], Rt);
          Je(Kt.x, Kt.y, -et);
        }
        for (let gt = 0, Jt = oe.length; gt < Jt; gt++) {
          const Kt = oe[gt];
          me = X[gt];
          for (let qt = 0, hn = Kt.length; qt < hn; qt++) {
            const Rn = Re(Kt[qt], me[qt], Rt);
            Je(Rn.x, Rn.y, -et);
          }
        }
      }
      const Ue = D + U;
      for (let he = 0; he < Pe; he++) {
        const nt = M ? Re(q[he], ce[he], Ue) : q[he];
        G ? (Z.copy(j.normals[0]).multiplyScalar(nt.x), Y.copy(j.binormals[0]).multiplyScalar(nt.y), te.copy(k[0]).add(Z).add(Y), Je(te.x, te.y, te.z)) : Je(nt.x, nt.y, 0);
      }
      for (let he = 1; he <= _; he++)
        for (let nt = 0; nt < Pe; nt++) {
          const et = M ? Re(q[nt], ce[nt], Ue) : q[nt];
          G ? (Z.copy(j.normals[he]).multiplyScalar(et.x), Y.copy(j.binormals[he]).multiplyScalar(et.y), te.copy(k[he]).add(Z).add(Y), Je(te.x, te.y, te.z)) : Je(et.x, et.y, b / _ * he);
        }
      for (let he = N - 1; he >= 0; he--) {
        const nt = he / N, et = C * Math.cos(nt * Math.PI / 2), Rt = D * Math.sin(nt * Math.PI / 2) + U;
        for (let gt = 0, Jt = xe.length; gt < Jt; gt++) {
          const Kt = Re(xe[gt], we[gt], Rt);
          Je(Kt.x, Kt.y, b + et);
        }
        for (let gt = 0, Jt = oe.length; gt < Jt; gt++) {
          const Kt = oe[gt];
          me = X[gt];
          for (let qt = 0, hn = Kt.length; qt < hn; qt++) {
            const Rn = Re(Kt[qt], me[qt], Rt);
            G ? Je(Rn.x, Rn.y + k[_ - 1].y, k[_ - 1].x + et) : Je(Rn.x, Rn.y, b + et);
          }
        }
      }
      Oe(), Ze();
      function Oe() {
        const he = a.length / 3;
        if (M) {
          let nt = 0, et = Pe * nt;
          for (let Rt = 0; Rt < Te; Rt++) {
            const gt = de[Rt];
            at(gt[2] + et, gt[1] + et, gt[0] + et);
          }
          nt = _ + N * 2, et = Pe * nt;
          for (let Rt = 0; Rt < Te; Rt++) {
            const gt = de[Rt];
            at(gt[0] + et, gt[1] + et, gt[2] + et);
          }
        } else {
          for (let nt = 0; nt < Te; nt++) {
            const et = de[nt];
            at(et[2], et[1], et[0]);
          }
          for (let nt = 0; nt < Te; nt++) {
            const et = de[nt];
            at(et[0] + Pe * _, et[1] + Pe * _, et[2] + Pe * _);
          }
        }
        r.addGroup(he, a.length / 3 - he, 0);
      }
      function Ze() {
        const he = a.length / 3;
        let nt = 0;
        je(xe, nt), nt += xe.length;
        for (let et = 0, Rt = oe.length; et < Rt; et++) {
          const gt = oe[et];
          je(gt, nt), nt += gt.length;
        }
        r.addGroup(he, a.length / 3 - he, 1);
      }
      function je(he, nt) {
        let et = he.length;
        for (; --et >= 0; ) {
          const Rt = et;
          let gt = et - 1;
          gt < 0 && (gt = he.length - 1);
          for (let Jt = 0, Kt = _ + N * 2; Jt < Kt; Jt++) {
            const qt = Pe * Jt, hn = Pe * (Jt + 1), Rn = nt + Rt + qt, Yn = nt + gt + qt, se = nt + gt + hn, ae = nt + Rt + hn;
            xt(Rn, Yn, se, ae);
          }
        }
      }
      function Je(he, nt, et) {
        v.push(he), v.push(nt), v.push(et);
      }
      function at(he, nt, et) {
        $t(he), $t(nt), $t(et);
        const Rt = a.length / 3, gt = I.generateTopUV(r, a, Rt - 3, Rt - 2, Rt - 1);
        Ht(gt[0]), Ht(gt[1]), Ht(gt[2]);
      }
      function xt(he, nt, et, Rt) {
        $t(he), $t(nt), $t(Rt), $t(nt), $t(et), $t(Rt);
        const gt = a.length / 3, Jt = I.generateSideWallUV(r, a, gt - 6, gt - 3, gt - 2, gt - 1);
        Ht(Jt[0]), Ht(Jt[1]), Ht(Jt[3]), Ht(Jt[1]), Ht(Jt[2]), Ht(Jt[3]);
      }
      function $t(he) {
        a.push(v[he * 3 + 0]), a.push(v[he * 3 + 1]), a.push(v[he * 3 + 2]);
      }
      function Ht(he) {
        s.push(he.x), s.push(he.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options;
    return k$(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let s = 0, u = e.shapes.length; s < u; s++) {
      const h = t[e.shapes[s]];
      r.push(h);
    }
    const a = e.options.extrudePath;
    return a !== void 0 && (e.options.extrudePath = new hP[a.type]().fromJSON(a)), new tM(r, e.options);
  }
}
const z$ = {
  generateTopUV: function(n, e, t, r, a) {
    const s = e[t * 3], u = e[t * 3 + 1], h = e[r * 3], v = e[r * 3 + 1], y = e[a * 3], _ = e[a * 3 + 1];
    return [
      new It(s, u),
      new It(h, v),
      new It(y, _)
    ];
  },
  generateSideWallUV: function(n, e, t, r, a, s) {
    const u = e[t * 3], h = e[t * 3 + 1], v = e[t * 3 + 2], y = e[r * 3], _ = e[r * 3 + 1], b = e[r * 3 + 2], M = e[a * 3], C = e[a * 3 + 1], D = e[a * 3 + 2], U = e[s * 3], N = e[s * 3 + 1], O = e[s * 3 + 2];
    return Math.abs(h - _) < Math.abs(u - y) ? [
      new It(u, 1 - v),
      new It(y, 1 - b),
      new It(M, 1 - D),
      new It(U, 1 - O)
    ] : [
      new It(h, 1 - v),
      new It(_, 1 - b),
      new It(C, 1 - D),
      new It(N, 1 - O)
    ];
  }
};
function k$(n, e, t) {
  if (t.shapes = [], Array.isArray(n))
    for (let r = 0, a = n.length; r < a; r++) {
      const s = n[r];
      t.shapes.push(s.uuid);
    }
  else
    t.shapes.push(n.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class nM extends Wg {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, a = [
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      0,
      0,
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      r,
      0,
      -1,
      r,
      0,
      1,
      -r,
      0,
      -1,
      -r,
      0,
      1
    ], s = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(a, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new nM(e.radius, e.detail);
  }
}
class XE extends Wg {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], a = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(r, a, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new XE(e.radius, e.detail);
  }
}
class rM extends yi {
  constructor(e = 0.5, t = 1, r = 32, a = 1, s = 0, u = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: r,
      phiSegments: a,
      thetaStart: s,
      thetaLength: u
    }, r = Math.max(3, r), a = Math.max(1, a);
    const h = [], v = [], y = [], _ = [];
    let b = e;
    const M = (t - e) / a, C = new be(), D = new It();
    for (let U = 0; U <= a; U++) {
      for (let N = 0; N <= r; N++) {
        const O = s + N / r * u;
        C.x = b * Math.cos(O), C.y = b * Math.sin(O), v.push(C.x, C.y, C.z), y.push(0, 0, 1), D.x = (C.x / t + 1) / 2, D.y = (C.y / t + 1) / 2, _.push(D.x, D.y);
      }
      b += M;
    }
    for (let U = 0; U < a; U++) {
      const N = U * (r + 1);
      for (let O = 0; O < r; O++) {
        const I = O + N, k = I, G = I + r + 1, j = I + r + 2, Y = I + 1;
        h.push(k, G, Y), h.push(G, j, Y);
      }
    }
    this.setIndex(h), this.setAttribute("position", new nr(v, 3)), this.setAttribute("normal", new nr(y, 3)), this.setAttribute("uv", new nr(_, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new rM(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class iM extends yi {
  constructor(e = new ix([new It(0, 0.5), new It(-0.5, -0.5), new It(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const r = [], a = [], s = [], u = [];
    let h = 0, v = 0;
    if (Array.isArray(e) === !1)
      y(e);
    else
      for (let _ = 0; _ < e.length; _++)
        y(e[_]), this.addGroup(h, v, _), h += v, v = 0;
    this.setIndex(r), this.setAttribute("position", new nr(a, 3)), this.setAttribute("normal", new nr(s, 3)), this.setAttribute("uv", new nr(u, 2));
    function y(_) {
      const b = a.length / 3, M = _.extractPoints(t);
      let C = M.shape;
      const D = M.holes;
      xv.isClockWise(C) === !1 && (C = C.reverse());
      for (let N = 0, O = D.length; N < O; N++) {
        const I = D[N];
        xv.isClockWise(I) === !0 && (D[N] = I.reverse());
      }
      const U = xv.triangulateShape(C, D);
      for (let N = 0, O = D.length; N < O; N++) {
        const I = D[N];
        C = C.concat(I);
      }
      for (let N = 0, O = C.length; N < O; N++) {
        const I = C[N];
        a.push(I.x, I.y, 0), s.push(0, 0, 1), u.push(I.x, I.y);
      }
      for (let N = 0, O = U.length; N < O; N++) {
        const I = U[N], k = I[0] + b, G = I[1] + b, j = I[2] + b;
        r.push(k, G, j), v += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return I$(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let a = 0, s = e.shapes.length; a < s; a++) {
      const u = t[e.shapes[a]];
      r.push(u);
    }
    return new iM(r, e.curveSegments);
  }
}
function I$(n, e) {
  if (e.shapes = [], Array.isArray(n))
    for (let t = 0, r = n.length; t < r; t++) {
      const a = n[t];
      e.shapes.push(a.uuid);
    }
  else
    e.shapes.push(n.uuid);
  return e;
}
class qE extends yi {
  constructor(e = 1, t = 32, r = 16, a = 0, s = Math.PI * 2, u = 0, h = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: r,
      phiStart: a,
      phiLength: s,
      thetaStart: u,
      thetaLength: h
    }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r));
    const v = Math.min(u + h, Math.PI);
    let y = 0;
    const _ = [], b = new be(), M = new be(), C = [], D = [], U = [], N = [];
    for (let O = 0; O <= r; O++) {
      const I = [], k = O / r;
      let G = 0;
      O === 0 && u === 0 ? G = 0.5 / t : O === r && v === Math.PI && (G = -0.5 / t);
      for (let j = 0; j <= t; j++) {
        const Y = j / t;
        b.x = -e * Math.cos(a + Y * s) * Math.sin(u + k * h), b.y = e * Math.cos(u + k * h), b.z = e * Math.sin(a + Y * s) * Math.sin(u + k * h), D.push(b.x, b.y, b.z), M.copy(b).normalize(), U.push(M.x, M.y, M.z), N.push(Y + G, 1 - k), I.push(y++);
      }
      _.push(I);
    }
    for (let O = 0; O < r; O++)
      for (let I = 0; I < t; I++) {
        const k = _[O][I + 1], G = _[O][I], j = _[O + 1][I], Y = _[O + 1][I + 1];
        (O !== 0 || u > 0) && C.push(k, G, Y), (O !== r - 1 || v < Math.PI) && C.push(G, j, Y);
      }
    this.setIndex(C), this.setAttribute("position", new nr(D, 3)), this.setAttribute("normal", new nr(U, 3)), this.setAttribute("uv", new nr(N, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new qE(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class aM extends Wg {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], a = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(r, a, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new aM(e.radius, e.detail);
  }
}
class oM extends yi {
  constructor(e = 1, t = 0.4, r = 12, a = 48, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: r,
      tubularSegments: a,
      arc: s
    }, r = Math.floor(r), a = Math.floor(a);
    const u = [], h = [], v = [], y = [], _ = new be(), b = new be(), M = new be();
    for (let C = 0; C <= r; C++)
      for (let D = 0; D <= a; D++) {
        const U = D / a * s, N = C / r * Math.PI * 2;
        b.x = (e + t * Math.cos(N)) * Math.cos(U), b.y = (e + t * Math.cos(N)) * Math.sin(U), b.z = t * Math.sin(N), h.push(b.x, b.y, b.z), _.x = e * Math.cos(U), _.y = e * Math.sin(U), M.subVectors(b, _).normalize(), v.push(M.x, M.y, M.z), y.push(D / a), y.push(C / r);
      }
    for (let C = 1; C <= r; C++)
      for (let D = 1; D <= a; D++) {
        const U = (a + 1) * C + D - 1, N = (a + 1) * (C - 1) + D - 1, O = (a + 1) * (C - 1) + D, I = (a + 1) * C + D;
        u.push(U, N, I), u.push(N, O, I);
      }
    this.setIndex(u), this.setAttribute("position", new nr(h, 3)), this.setAttribute("normal", new nr(v, 3)), this.setAttribute("uv", new nr(y, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new oM(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class sM extends yi {
  constructor(e = 1, t = 0.4, r = 64, a = 8, s = 2, u = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: r,
      radialSegments: a,
      p: s,
      q: u
    }, r = Math.floor(r), a = Math.floor(a);
    const h = [], v = [], y = [], _ = [], b = new be(), M = new be(), C = new be(), D = new be(), U = new be(), N = new be(), O = new be();
    for (let k = 0; k <= r; ++k) {
      const G = k / r * s * Math.PI * 2;
      I(G, s, u, e, C), I(G + 0.01, s, u, e, D), N.subVectors(D, C), O.addVectors(D, C), U.crossVectors(N, O), O.crossVectors(U, N), U.normalize(), O.normalize();
      for (let j = 0; j <= a; ++j) {
        const Y = j / a * Math.PI * 2, Z = -t * Math.cos(Y), te = t * Math.sin(Y);
        b.x = C.x + (Z * O.x + te * U.x), b.y = C.y + (Z * O.y + te * U.y), b.z = C.z + (Z * O.z + te * U.z), v.push(b.x, b.y, b.z), M.subVectors(b, C).normalize(), y.push(M.x, M.y, M.z), _.push(k / r), _.push(j / a);
      }
    }
    for (let k = 1; k <= r; k++)
      for (let G = 1; G <= a; G++) {
        const j = (a + 1) * (k - 1) + (G - 1), Y = (a + 1) * k + (G - 1), Z = (a + 1) * k + G, te = (a + 1) * (k - 1) + G;
        h.push(j, Y, te), h.push(Y, Z, te);
      }
    this.setIndex(h), this.setAttribute("position", new nr(v, 3)), this.setAttribute("normal", new nr(y, 3)), this.setAttribute("uv", new nr(_, 2));
    function I(k, G, j, Y, Z) {
      const te = Math.cos(k), J = Math.sin(k), q = j / G * k, oe = Math.cos(q);
      Z.x = Y * (2 + oe) * 0.5 * te, Z.y = Y * (2 + oe) * J * 0.5, Z.z = Y * Math.sin(q) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new sM(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class lM extends yi {
  constructor(e = new fP(new be(-1, -1, 0), new be(-1, 1, 0), new be(1, 1, 0)), t = 64, r = 1, a = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: r,
      radialSegments: a,
      closed: s
    };
    const u = e.computeFrenetFrames(t, s);
    this.tangents = u.tangents, this.normals = u.normals, this.binormals = u.binormals;
    const h = new be(), v = new be(), y = new It();
    let _ = new be();
    const b = [], M = [], C = [], D = [];
    U(), this.setIndex(D), this.setAttribute("position", new nr(b, 3)), this.setAttribute("normal", new nr(M, 3)), this.setAttribute("uv", new nr(C, 2));
    function U() {
      for (let k = 0; k < t; k++)
        N(k);
      N(s === !1 ? t : 0), I(), O();
    }
    function N(k) {
      _ = e.getPointAt(k / t, _);
      const G = u.normals[k], j = u.binormals[k];
      for (let Y = 0; Y <= a; Y++) {
        const Z = Y / a * Math.PI * 2, te = Math.sin(Z), J = -Math.cos(Z);
        v.x = J * G.x + te * j.x, v.y = J * G.y + te * j.y, v.z = J * G.z + te * j.z, v.normalize(), M.push(v.x, v.y, v.z), h.x = _.x + r * v.x, h.y = _.y + r * v.y, h.z = _.z + r * v.z, b.push(h.x, h.y, h.z);
      }
    }
    function O() {
      for (let k = 1; k <= t; k++)
        for (let G = 1; G <= a; G++) {
          const j = (a + 1) * (k - 1) + (G - 1), Y = (a + 1) * k + (G - 1), Z = (a + 1) * k + G, te = (a + 1) * (k - 1) + G;
          D.push(j, Y, te), D.push(Y, Z, te);
        }
    }
    function I() {
      for (let k = 0; k <= t; k++)
        for (let G = 0; G <= a; G++)
          y.x = k / t, y.y = G / a, C.push(y.x, y.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new lM(
      new hP[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class sB extends yi {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], r = /* @__PURE__ */ new Set(), a = new be(), s = new be();
      if (e.index !== null) {
        const u = e.attributes.position, h = e.index;
        let v = e.groups;
        v.length === 0 && (v = [{ start: 0, count: h.count, materialIndex: 0 }]);
        for (let y = 0, _ = v.length; y < _; ++y) {
          const b = v[y], M = b.start, C = b.count;
          for (let D = M, U = M + C; D < U; D += 3)
            for (let N = 0; N < 3; N++) {
              const O = h.getX(D + N), I = h.getX(D + (N + 1) % 3);
              a.fromBufferAttribute(u, O), s.fromBufferAttribute(u, I), sz(a, s, r) === !0 && (t.push(a.x, a.y, a.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const u = e.attributes.position;
        for (let h = 0, v = u.count / 3; h < v; h++)
          for (let y = 0; y < 3; y++) {
            const _ = 3 * h + y, b = 3 * h + (y + 1) % 3;
            a.fromBufferAttribute(u, _), s.fromBufferAttribute(u, b), sz(a, s, r) === !0 && (t.push(a.x, a.y, a.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new nr(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function sz(n, e, t) {
  const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`, a = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(r) === !0 || t.has(a) === !0 ? !1 : (t.add(r), t.add(a), !0);
}
var lz = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: _0,
  CapsuleGeometry: QT,
  CircleGeometry: ZT,
  ConeGeometry: JT,
  CylinderGeometry: vx,
  DodecahedronGeometry: eM,
  EdgesGeometry: rB,
  ExtrudeGeometry: tM,
  IcosahedronGeometry: nM,
  LatheGeometry: YE,
  OctahedronGeometry: XE,
  PlaneGeometry: jE,
  PolyhedronGeometry: Wg,
  RingGeometry: rM,
  ShapeGeometry: iM,
  SphereGeometry: qE,
  TetrahedronGeometry: aM,
  TorusGeometry: oM,
  TorusKnotGeometry: sM,
  TubeGeometry: lM,
  WireframeGeometry: sB
});
class lB extends Ku {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Un(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class uB extends _v {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class pP extends Ku {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Un(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Un(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = S0, this.normalScale = new It(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class cB extends pP {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new It(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return ws(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Un(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Un(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Un(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class fB extends Ku {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Un(16777215), this.specular = new Un(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Un(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = S0, this.normalScale = new It(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = YT, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class dB extends Ku {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Un(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Un(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = S0, this.normalScale = new It(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class hB extends Ku {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = S0, this.normalScale = new It(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class pB extends Ku {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Un(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Un(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = S0, this.normalScale = new It(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = YT, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class mB extends Ku {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Un(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = S0, this.normalScale = new It(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class vB extends Tf {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function np(n, e, t) {
  return mP(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t);
}
function JS(n, e, t) {
  return !n || // let 'undefined' and 'null' pass
  !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n);
}
function mP(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function gB(n) {
  function e(a, s) {
    return n[a] - n[s];
  }
  const t = n.length, r = new Array(t);
  for (let a = 0; a !== t; ++a)
    r[a] = a;
  return r.sort(e), r;
}
function JL(n, e, t) {
  const r = n.length, a = new n.constructor(r);
  for (let s = 0, u = 0; u !== r; ++s) {
    const h = t[s] * e;
    for (let v = 0; v !== e; ++v)
      a[u++] = n[h + v];
  }
  return a;
}
function vP(n, e, t, r) {
  let a = 1, s = n[0];
  for (; s !== void 0 && s[r] === void 0; )
    s = n[a++];
  if (s === void 0)
    return;
  let u = s[r];
  if (u !== void 0)
    if (Array.isArray(u))
      do
        u = s[r], u !== void 0 && (e.push(s.time), t.push.apply(t, u)), s = n[a++];
      while (s !== void 0);
    else if (u.toArray !== void 0)
      do
        u = s[r], u !== void 0 && (e.push(s.time), u.toArray(t, t.length)), s = n[a++];
      while (s !== void 0);
    else
      do
        u = s[r], u !== void 0 && (e.push(s.time), t.push(u)), s = n[a++];
      while (s !== void 0);
}
function F$(n, e, t, r, a = 30) {
  const s = n.clone();
  s.name = e;
  const u = [];
  for (let v = 0; v < s.tracks.length; ++v) {
    const y = s.tracks[v], _ = y.getValueSize(), b = [], M = [];
    for (let C = 0; C < y.times.length; ++C) {
      const D = y.times[C] * a;
      if (!(D < t || D >= r)) {
        b.push(y.times[C]);
        for (let U = 0; U < _; ++U)
          M.push(y.values[C * _ + U]);
      }
    }
    b.length !== 0 && (y.times = JS(b, y.times.constructor), y.values = JS(M, y.values.constructor), u.push(y));
  }
  s.tracks = u;
  let h = 1 / 0;
  for (let v = 0; v < s.tracks.length; ++v)
    h > s.tracks[v].times[0] && (h = s.tracks[v].times[0]);
  for (let v = 0; v < s.tracks.length; ++v)
    s.tracks[v].shift(-1 * h);
  return s.resetDuration(), s;
}
function B$(n, e = 0, t = n, r = 30) {
  r <= 0 && (r = 30);
  const a = t.tracks.length, s = e / r;
  for (let u = 0; u < a; ++u) {
    const h = t.tracks[u], v = h.ValueTypeName;
    if (v === "bool" || v === "string")
      continue;
    const y = n.tracks.find(function(O) {
      return O.name === h.name && O.ValueTypeName === v;
    });
    if (y === void 0)
      continue;
    let _ = 0;
    const b = h.getValueSize();
    h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (_ = b / 3);
    let M = 0;
    const C = y.getValueSize();
    y.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (M = C / 3);
    const D = h.times.length - 1;
    let U;
    if (s <= h.times[0]) {
      const O = _, I = b - _;
      U = np(h.values, O, I);
    } else if (s >= h.times[D]) {
      const O = D * b + _, I = O + b - _;
      U = np(h.values, O, I);
    } else {
      const O = h.createInterpolant(), I = _, k = b - _;
      O.evaluate(s), U = np(O.resultBuffer, I, k);
    }
    v === "quaternion" && new Oc().fromArray(U).normalize().conjugate().toArray(U);
    const N = y.times.length;
    for (let O = 0; O < N; ++O) {
      const I = O * C + M;
      if (v === "quaternion")
        Oc.multiplyQuaternionsFlat(
          y.values,
          I,
          U,
          0,
          y.values,
          I
        );
      else {
        const k = C - M * 2;
        for (let G = 0; G < k; ++G)
          y.values[I + G] -= U[G];
      }
    }
  }
  return n.blendMode = $O, n;
}
const H$ = {
  arraySlice: np,
  convertArray: JS,
  isTypedArray: mP,
  getKeyframeOrder: gB,
  sortedArray: JL,
  flattenJSON: vP,
  subclip: F$,
  makeClipAdditive: B$
};
class uM {
  constructor(e, t, r, a) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = a !== void 0 ? a : new t.constructor(r), this.sampleValues = t, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex, a = t[r], s = t[r - 1];
    e: {
      t: {
        let u;
        n: {
          r:
            if (!(e < a)) {
              for (let h = r + 2; ; ) {
                if (a === void 0) {
                  if (e < s)
                    break r;
                  return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
                }
                if (r === h)
                  break;
                if (s = a, a = t[++r], e < a)
                  break t;
              }
              u = t.length;
              break n;
            }
          if (!(e >= s)) {
            const h = t[1];
            e < h && (r = 2, s = h);
            for (let v = r - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (r === v)
                break;
              if (a = s, s = t[--r - 1], e >= s)
                break t;
            }
            u = r, r = 0;
            break n;
          }
          break e;
        }
        for (; r < u; ) {
          const h = r + u >>> 1;
          e < t[h] ? u = h : r = h + 1;
        }
        if (a = t[r], s = t[r - 1], s === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (a === void 0)
          return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
      }
      this._cachedIndex = r, this.intervalChanged_(r, s, a);
    }
    return this.interpolate_(r, s, e, a);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, r = this.sampleValues, a = this.valueSize, s = e * a;
    for (let u = 0; u !== a; ++u)
      t[u] = r[s + u];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class yB extends uM {
  constructor(e, t, r, a) {
    super(e, t, r, a), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: KS,
      endingEnd: KS
    };
  }
  intervalChanged_(e, t, r) {
    const a = this.parameterPositions;
    let s = e - 2, u = e + 1, h = a[s], v = a[u];
    if (h === void 0)
      switch (this.getSettings_().endingStart) {
        case QS:
          s = e, h = 2 * t - r;
          break;
        case AT:
          s = a.length - 2, h = t + a[s] - a[s + 1];
          break;
        default:
          s = e, h = r;
      }
    if (v === void 0)
      switch (this.getSettings_().endingEnd) {
        case QS:
          u = e, v = 2 * r - t;
          break;
        case AT:
          u = 1, v = r + a[1] - a[0];
          break;
        default:
          u = e - 1, v = t;
      }
    const y = (r - t) * 0.5, _ = this.valueSize;
    this._weightPrev = y / (t - h), this._weightNext = y / (v - r), this._offsetPrev = s * _, this._offsetNext = u * _;
  }
  interpolate_(e, t, r, a) {
    const s = this.resultBuffer, u = this.sampleValues, h = this.valueSize, v = e * h, y = v - h, _ = this._offsetPrev, b = this._offsetNext, M = this._weightPrev, C = this._weightNext, D = (r - t) / (a - t), U = D * D, N = U * D, O = -M * N + 2 * M * U - M * D, I = (1 + M) * N + (-1.5 - 2 * M) * U + (-0.5 + M) * D + 1, k = (-1 - C) * N + (1.5 + C) * U + 0.5 * D, G = C * N - C * U;
    for (let j = 0; j !== h; ++j)
      s[j] = O * u[_ + j] + I * u[y + j] + k * u[v + j] + G * u[b + j];
    return s;
  }
}
class gP extends uM {
  constructor(e, t, r, a) {
    super(e, t, r, a);
  }
  interpolate_(e, t, r, a) {
    const s = this.resultBuffer, u = this.sampleValues, h = this.valueSize, v = e * h, y = v - h, _ = (r - t) / (a - t), b = 1 - _;
    for (let M = 0; M !== h; ++M)
      s[M] = u[y + M] * b + u[v + M] * _;
    return s;
  }
}
class SB extends uM {
  constructor(e, t, r, a) {
    super(e, t, r, a);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class um {
  constructor(e, t, r, a) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = JS(t, this.TimeBufferType), this.values = JS(r, this.ValueBufferType), this.setInterpolation(a || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON)
      r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: JS(e.times, Array),
        values: JS(e.values, Array)
      };
      const a = e.getInterpolation();
      a !== e.DefaultInterpolation && (r.interpolation = a);
    }
    return r.type = e.ValueTypeName, r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new SB(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new gP(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new yB(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case CT:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case RT:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case cR:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return CT;
      case this.InterpolantFactoryMethodLinear:
        return RT;
      case this.InterpolantFactoryMethodSmooth:
        return cR;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, a = t.length; r !== a; ++r)
        t[r] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, a = t.length; r !== a; ++r)
        t[r] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const r = this.times, a = r.length;
    let s = 0, u = a - 1;
    for (; s !== a && r[s] < e; )
      ++s;
    for (; u !== -1 && r[u] > t; )
      --u;
    if (++u, s !== 0 || u !== a) {
      s >= u && (u = Math.max(u, 1), s = u - 1);
      const h = this.getValueSize();
      this.times = np(r, s, u), this.values = np(this.values, s * h, u * h);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const r = this.times, a = this.values, s = r.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let u = null;
    for (let h = 0; h !== s; h++) {
      const v = r[h];
      if (typeof v == "number" && isNaN(v)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, h, v), e = !1;
        break;
      }
      if (u !== null && u > v) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, h, v, u), e = !1;
        break;
      }
      u = v;
    }
    if (a !== void 0 && mP(a))
      for (let h = 0, v = a.length; h !== v; ++h) {
        const y = a[h];
        if (isNaN(y)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, h, y), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = np(this.times), t = np(this.values), r = this.getValueSize(), a = this.getInterpolation() === cR, s = e.length - 1;
    let u = 1;
    for (let h = 1; h < s; ++h) {
      let v = !1;
      const y = e[h], _ = e[h + 1];
      if (y !== _ && (h !== 1 || y !== e[0]))
        if (a)
          v = !0;
        else {
          const b = h * r, M = b - r, C = b + r;
          for (let D = 0; D !== r; ++D) {
            const U = t[b + D];
            if (U !== t[M + D] || U !== t[C + D]) {
              v = !0;
              break;
            }
          }
        }
      if (v) {
        if (h !== u) {
          e[u] = e[h];
          const b = h * r, M = u * r;
          for (let C = 0; C !== r; ++C)
            t[M + C] = t[b + C];
        }
        ++u;
      }
    }
    if (s > 0) {
      e[u] = e[s];
      for (let h = s * r, v = u * r, y = 0; y !== r; ++y)
        t[v + y] = t[h + y];
      ++u;
    }
    return u !== e.length ? (this.times = np(e, 0, u), this.values = np(t, 0, u * r)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = np(this.times, 0), t = np(this.values, 0), r = this.constructor, a = new r(this.name, e, t);
    return a.createInterpolant = this.createInterpolant, a;
  }
}
um.prototype.TimeBufferType = Float32Array;
um.prototype.ValueBufferType = Float32Array;
um.prototype.DefaultInterpolation = RT;
class gx extends um {
}
gx.prototype.ValueTypeName = "bool";
gx.prototype.ValueBufferType = Array;
gx.prototype.DefaultInterpolation = CT;
gx.prototype.InterpolantFactoryMethodLinear = void 0;
gx.prototype.InterpolantFactoryMethodSmooth = void 0;
class yP extends um {
}
yP.prototype.ValueTypeName = "color";
class kT extends um {
}
kT.prototype.ValueTypeName = "number";
class xB extends uM {
  constructor(e, t, r, a) {
    super(e, t, r, a);
  }
  interpolate_(e, t, r, a) {
    const s = this.resultBuffer, u = this.sampleValues, h = this.valueSize, v = (r - t) / (a - t);
    let y = e * h;
    for (let _ = y + h; y !== _; y += 4)
      Oc.slerpFlat(s, 0, u, y - h, u, y, v);
    return s;
  }
}
class KE extends um {
  InterpolantFactoryMethodLinear(e) {
    return new xB(this.times, this.values, this.getValueSize(), e);
  }
}
KE.prototype.ValueTypeName = "quaternion";
KE.prototype.DefaultInterpolation = RT;
KE.prototype.InterpolantFactoryMethodSmooth = void 0;
class yx extends um {
}
yx.prototype.ValueTypeName = "string";
yx.prototype.ValueBufferType = Array;
yx.prototype.DefaultInterpolation = CT;
yx.prototype.InterpolantFactoryMethodLinear = void 0;
yx.prototype.InterpolantFactoryMethodSmooth = void 0;
class IT extends um {
}
IT.prototype.ValueTypeName = "vector";
class FT {
  constructor(e, t = -1, r, a = HR) {
    this.name = e, this.tracks = r, this.duration = t, this.blendMode = a, this.uuid = sh(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], r = e.tracks, a = 1 / (e.fps || 1);
    for (let u = 0, h = r.length; u !== h; ++u)
      t.push(G$(r[u]).scale(a));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s;
  }
  static toJSON(e) {
    const t = [], r = e.tracks, a = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let s = 0, u = r.length; s !== u; ++s)
      t.push(um.toJSON(r[s]));
    return a;
  }
  static CreateFromMorphTargetSequence(e, t, r, a) {
    const s = t.length, u = [];
    for (let h = 0; h < s; h++) {
      let v = [], y = [];
      v.push(
        (h + s - 1) % s,
        h,
        (h + 1) % s
      ), y.push(0, 1, 0);
      const _ = gB(v);
      v = JL(v, 1, _), y = JL(y, 1, _), !a && v[0] === 0 && (v.push(s), y.push(y[0])), u.push(
        new kT(
          ".morphTargetInfluences[" + t[h].name + "]",
          v,
          y
        ).scale(1 / r)
      );
    }
    return new this(e, -1, u);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const a = e;
      r = a.geometry && a.geometry.animations || a.animations;
    }
    for (let a = 0; a < r.length; a++)
      if (r[a].name === t)
        return r[a];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const a = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let h = 0, v = e.length; h < v; h++) {
      const y = e[h], _ = y.name.match(s);
      if (_ && _.length > 1) {
        const b = _[1];
        let M = a[b];
        M || (a[b] = M = []), M.push(y);
      }
    }
    const u = [];
    for (const h in a)
      u.push(this.CreateFromMorphTargetSequence(h, a[h], t, r));
    return u;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const r = function(b, M, C, D, U) {
      if (C.length !== 0) {
        const N = [], O = [];
        vP(C, N, O, D), N.length !== 0 && U.push(new b(M, N, O));
      }
    }, a = [], s = e.name || "default", u = e.fps || 30, h = e.blendMode;
    let v = e.length || -1;
    const y = e.hierarchy || [];
    for (let b = 0; b < y.length; b++) {
      const M = y[b].keys;
      if (!(!M || M.length === 0))
        if (M[0].morphTargets) {
          const C = {};
          let D;
          for (D = 0; D < M.length; D++)
            if (M[D].morphTargets)
              for (let U = 0; U < M[D].morphTargets.length; U++)
                C[M[D].morphTargets[U]] = -1;
          for (const U in C) {
            const N = [], O = [];
            for (let I = 0; I !== M[D].morphTargets.length; ++I) {
              const k = M[D];
              N.push(k.time), O.push(k.morphTarget === U ? 1 : 0);
            }
            a.push(new kT(".morphTargetInfluence[" + U + "]", N, O));
          }
          v = C.length * u;
        } else {
          const C = ".bones[" + t[b].name + "]";
          r(
            IT,
            C + ".position",
            M,
            "pos",
            a
          ), r(
            KE,
            C + ".quaternion",
            M,
            "rot",
            a
          ), r(
            IT,
            C + ".scale",
            M,
            "scl",
            a
          );
        }
    }
    return a.length === 0 ? null : new this(s, v, a, h);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, a = e.length; r !== a; ++r) {
      const s = this.tracks[r];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function V$(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return kT;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return IT;
    case "color":
      return yP;
    case "quaternion":
      return KE;
    case "bool":
    case "boolean":
      return gx;
    case "string":
      return yx;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function G$(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = V$(n.type);
  if (n.times === void 0) {
    const t = [], r = [];
    vP(n.keys, t, r, "value"), n.times = t, n.values = r;
  }
  return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation);
}
const cx = {
  enabled: !1,
  files: {},
  add: function(n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function(n) {
    if (this.enabled !== !1)
      return this.files[n];
  },
  remove: function(n) {
    delete this.files[n];
  },
  clear: function() {
    this.files = {};
  }
};
class SP {
  constructor(e, t, r) {
    const a = this;
    let s = !1, u = 0, h = 0, v;
    const y = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = r, this.itemStart = function(_) {
      h++, s === !1 && a.onStart !== void 0 && a.onStart(_, u, h), s = !0;
    }, this.itemEnd = function(_) {
      u++, a.onProgress !== void 0 && a.onProgress(_, u, h), u === h && (s = !1, a.onLoad !== void 0 && a.onLoad());
    }, this.itemError = function(_) {
      a.onError !== void 0 && a.onError(_);
    }, this.resolveURL = function(_) {
      return v ? v(_) : _;
    }, this.setURLModifier = function(_) {
      return v = _, this;
    }, this.addHandler = function(_, b) {
      return y.push(_, b), this;
    }, this.removeHandler = function(_) {
      const b = y.indexOf(_);
      return b !== -1 && y.splice(b, 2), this;
    }, this.getHandler = function(_) {
      for (let b = 0, M = y.length; b < M; b += 2) {
        const C = y[b], D = y[b + 1];
        if (C.global && (C.lastIndex = 0), C.test(_))
          return D;
      }
      return null;
    };
  }
}
const _B = /* @__PURE__ */ new SP();
class uh {
  constructor(e) {
    this.manager = e !== void 0 ? e : _B, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const r = this;
    return new Promise(function(a, s) {
      r.load(e, a, t, s);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
const Dg = {};
class W$ extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class Bg extends uh {
  constructor(e) {
    super(e);
  }
  load(e, t, r, a) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = cx.get(e);
    if (s !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(s), this.manager.itemEnd(e);
      }, 0), s;
    if (Dg[e] !== void 0) {
      Dg[e].push({
        onLoad: t,
        onProgress: r,
        onError: a
      });
      return;
    }
    Dg[e] = [], Dg[e].push({
      onLoad: t,
      onProgress: r,
      onError: a
    });
    const u = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), h = this.mimeType, v = this.responseType;
    fetch(u).then((y) => {
      if (y.status === 200 || y.status === 0) {
        if (y.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || y.body === void 0 || y.body.getReader === void 0)
          return y;
        const _ = Dg[e], b = y.body.getReader(), M = y.headers.get("Content-Length") || y.headers.get("X-File-Size"), C = M ? parseInt(M) : 0, D = C !== 0;
        let U = 0;
        const N = new ReadableStream({
          start(O) {
            I();
            function I() {
              b.read().then(({ done: k, value: G }) => {
                if (k)
                  O.close();
                else {
                  U += G.byteLength;
                  const j = new ProgressEvent("progress", { lengthComputable: D, loaded: U, total: C });
                  for (let Y = 0, Z = _.length; Y < Z; Y++) {
                    const te = _[Y];
                    te.onProgress && te.onProgress(j);
                  }
                  O.enqueue(G), I();
                }
              });
            }
          }
        });
        return new Response(N);
      } else
        throw new W$(`fetch for "${y.url}" responded with ${y.status}: ${y.statusText}`, y);
    }).then((y) => {
      switch (v) {
        case "arraybuffer":
          return y.arrayBuffer();
        case "blob":
          return y.blob();
        case "document":
          return y.text().then((_) => new DOMParser().parseFromString(_, h));
        case "json":
          return y.json();
        default:
          if (h === void 0)
            return y.text();
          {
            const b = /charset="?([^;"\s]*)"?/i.exec(h), M = b && b[1] ? b[1].toLowerCase() : void 0, C = new TextDecoder(M);
            return y.arrayBuffer().then((D) => C.decode(D));
          }
      }
    }).then((y) => {
      cx.add(e, y);
      const _ = Dg[e];
      delete Dg[e];
      for (let b = 0, M = _.length; b < M; b++) {
        const C = _[b];
        C.onLoad && C.onLoad(y);
      }
    }).catch((y) => {
      const _ = Dg[e];
      if (_ === void 0)
        throw this.manager.itemError(e), y;
      delete Dg[e];
      for (let b = 0, M = _.length; b < M; b++) {
        const C = _[b];
        C.onError && C.onError(y);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class j$ extends uh {
  constructor(e) {
    super(e);
  }
  load(e, t, r, a) {
    const s = this, u = new Bg(this.manager);
    u.setPath(this.path), u.setRequestHeader(this.requestHeader), u.setWithCredentials(this.withCredentials), u.load(e, function(h) {
      try {
        t(s.parse(JSON.parse(h)));
      } catch (v) {
        a ? a(v) : console.error(v), s.manager.itemError(e);
      }
    }, r, a);
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const a = FT.parse(e[r]);
      t.push(a);
    }
    return t;
  }
}
class $$ extends uh {
  constructor(e) {
    super(e);
  }
  load(e, t, r, a) {
    const s = this, u = [], h = new sP(), v = new Bg(this.manager);
    v.setPath(this.path), v.setResponseType("arraybuffer"), v.setRequestHeader(this.requestHeader), v.setWithCredentials(s.withCredentials);
    let y = 0;
    function _(b) {
      v.load(e[b], function(M) {
        const C = s.parse(M, !0);
        u[b] = {
          width: C.width,
          height: C.height,
          format: C.format,
          mipmaps: C.mipmaps
        }, y += 1, y === 6 && (C.mipmapCount === 1 && (h.minFilter = tl), h.image = u, h.format = C.format, h.needsUpdate = !0, t && t(h));
      }, r, a);
    }
    if (Array.isArray(e))
      for (let b = 0, M = e.length; b < M; ++b)
        _(b);
    else
      v.load(e, function(b) {
        const M = s.parse(b, !0);
        if (M.isCubemap) {
          const C = M.mipmaps.length / M.mipmapCount;
          for (let D = 0; D < C; D++) {
            u[D] = { mipmaps: [] };
            for (let U = 0; U < M.mipmapCount; U++)
              u[D].mipmaps.push(M.mipmaps[D * M.mipmapCount + U]), u[D].format = M.format, u[D].width = M.width, u[D].height = M.height;
          }
          h.image = u;
        } else
          h.image.width = M.width, h.image.height = M.height, h.mipmaps = M.mipmaps;
        M.mipmapCount === 1 && (h.minFilter = tl), h.format = M.format, h.needsUpdate = !0, t && t(h);
      }, r, a);
    return h;
  }
}
class BT extends uh {
  constructor(e) {
    super(e);
  }
  load(e, t, r, a) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, u = cx.get(e);
    if (u !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(u), s.manager.itemEnd(e);
      }, 0), u;
    const h = OT("img");
    function v() {
      _(), cx.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function y(b) {
      _(), a && a(b), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function _() {
      h.removeEventListener("load", v, !1), h.removeEventListener("error", y, !1);
    }
    return h.addEventListener("load", v, !1), h.addEventListener("error", y, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (h.crossOrigin = this.crossOrigin), s.manager.itemStart(e), h.src = e, h;
  }
}
class Y$ extends uh {
  constructor(e) {
    super(e);
  }
  load(e, t, r, a) {
    const s = new KT();
    s.colorSpace = ai;
    const u = new BT(this.manager);
    u.setCrossOrigin(this.crossOrigin), u.setPath(this.path);
    let h = 0;
    function v(y) {
      u.load(e[y], function(_) {
        s.images[y] = _, h++, h === 6 && (s.needsUpdate = !0, t && t(s));
      }, void 0, a);
    }
    for (let y = 0; y < e.length; ++y)
      v(y);
    return s;
  }
}
class X$ extends uh {
  constructor(e) {
    super(e);
  }
  load(e, t, r, a) {
    const s = this, u = new OE(), h = new Bg(this.manager);
    return h.setResponseType("arraybuffer"), h.setRequestHeader(this.requestHeader), h.setPath(this.path), h.setWithCredentials(s.withCredentials), h.load(e, function(v) {
      const y = s.parse(v);
      y && (y.image !== void 0 ? u.image = y.image : y.data !== void 0 && (u.image.width = y.width, u.image.height = y.height, u.image.data = y.data), u.wrapS = y.wrapS !== void 0 ? y.wrapS : Dc, u.wrapT = y.wrapT !== void 0 ? y.wrapT : Dc, u.magFilter = y.magFilter !== void 0 ? y.magFilter : tl, u.minFilter = y.minFilter !== void 0 ? y.minFilter : tl, u.anisotropy = y.anisotropy !== void 0 ? y.anisotropy : 1, y.colorSpace !== void 0 ? u.colorSpace = y.colorSpace : y.encoding !== void 0 && (u.encoding = y.encoding), y.flipY !== void 0 && (u.flipY = y.flipY), y.format !== void 0 && (u.format = y.format), y.type !== void 0 && (u.type = y.type), y.mipmaps !== void 0 && (u.mipmaps = y.mipmaps, u.minFilter = h0), y.mipmapCount === 1 && (u.minFilter = tl), y.generateMipmaps !== void 0 && (u.generateMipmaps = y.generateMipmaps), u.needsUpdate = !0, t && t(u, y));
    }, r, a), u;
  }
}
class q$ extends uh {
  constructor(e) {
    super(e);
  }
  load(e, t, r, a) {
    const s = new Rs(), u = new BT(this.manager);
    return u.setCrossOrigin(this.crossOrigin), u.setPath(this.path), u.load(e, function(h) {
      s.image = h, s.needsUpdate = !0, t !== void 0 && t(s);
    }, r, a), s;
  }
}
class E0 extends ha {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Un(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class EB extends E0 {
  constructor(e, t, r) {
    super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(ha.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Un(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const N2 = /* @__PURE__ */ new ei(), uz = /* @__PURE__ */ new be(), cz = /* @__PURE__ */ new be();
class xP {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new It(512, 512), this.map = null, this.mapPass = null, this.matrix = new ei(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new GR(), this._frameExtents = new It(1, 1), this._viewportCount = 1, this._viewports = [
      new Ua(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, r = this.matrix;
    uz.setFromMatrixPosition(e.matrixWorld), t.position.copy(uz), cz.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(cz), t.updateMatrixWorld(), N2.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(N2), r.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), r.multiply(N2);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class K$ extends xP {
  constructor() {
    super(new Cs(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, r = zE * 2 * e.angle * this.focus, a = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
    (r !== t.fov || a !== t.aspect || s !== t.far) && (t.fov = r, t.aspect = a, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class bB extends E0 {
  constructor(e, t, r = 0, a = Math.PI / 3, s = 0, u = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(ha.DEFAULT_UP), this.updateMatrix(), this.target = new ha(), this.distance = r, this.angle = a, this.penumbra = s, this.decay = u, this.map = null, this.shadow = new K$();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const fz = /* @__PURE__ */ new ei(), rT = /* @__PURE__ */ new be(), U2 = /* @__PURE__ */ new be();
class Q$ extends xP {
  constructor() {
    super(new Cs(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new It(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Ua(2, 1, 1, 1),
      // negative X
      new Ua(0, 1, 1, 1),
      // positive Z
      new Ua(3, 1, 1, 1),
      // negative Z
      new Ua(1, 1, 1, 1),
      // positive Y
      new Ua(3, 0, 1, 1),
      // negative Y
      new Ua(1, 0, 1, 1)
    ], this._cubeDirections = [
      new be(1, 0, 0),
      new be(-1, 0, 0),
      new be(0, 0, 1),
      new be(0, 0, -1),
      new be(0, 1, 0),
      new be(0, -1, 0)
    ], this._cubeUps = [
      new be(0, 1, 0),
      new be(0, 1, 0),
      new be(0, 1, 0),
      new be(0, 1, 0),
      new be(0, 0, 1),
      new be(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const r = this.camera, a = this.matrix, s = e.distance || r.far;
    s !== r.far && (r.far = s, r.updateProjectionMatrix()), rT.setFromMatrixPosition(e.matrixWorld), r.position.copy(rT), U2.copy(r.position), U2.add(this._cubeDirections[t]), r.up.copy(this._cubeUps[t]), r.lookAt(U2), r.updateMatrixWorld(), a.makeTranslation(-rT.x, -rT.y, -rT.z), fz.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(fz);
  }
}
class TB extends E0 {
  constructor(e, t, r = 0, a = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = a, this.shadow = new Q$();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class Z$ extends xP {
  constructor() {
    super(new zg(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class MB extends E0 {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(ha.DEFAULT_UP), this.updateMatrix(), this.target = new ha(), this.shadow = new Z$();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class wB extends E0 {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class CB extends E0 {
  constructor(e, t, r = 10, a = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = a;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class RB {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new be());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const r = e.x, a = e.y, s = e.z, u = this.coefficients;
    return t.copy(u[0]).multiplyScalar(0.282095), t.addScaledVector(u[1], 0.488603 * a), t.addScaledVector(u[2], 0.488603 * s), t.addScaledVector(u[3], 0.488603 * r), t.addScaledVector(u[4], 1.092548 * (r * a)), t.addScaledVector(u[5], 1.092548 * (a * s)), t.addScaledVector(u[6], 0.315392 * (3 * s * s - 1)), t.addScaledVector(u[7], 1.092548 * (r * s)), t.addScaledVector(u[8], 0.546274 * (r * r - a * a)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const r = e.x, a = e.y, s = e.z, u = this.coefficients;
    return t.copy(u[0]).multiplyScalar(0.886227), t.addScaledVector(u[1], 2 * 0.511664 * a), t.addScaledVector(u[2], 2 * 0.511664 * s), t.addScaledVector(u[3], 2 * 0.511664 * r), t.addScaledVector(u[4], 2 * 0.429043 * r * a), t.addScaledVector(u[5], 2 * 0.429043 * a * s), t.addScaledVector(u[6], 0.743125 * s * s - 0.247708), t.addScaledVector(u[7], 2 * 0.429043 * r * s), t.addScaledVector(u[8], 0.429043 * (r * r - a * a)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let a = 0; a < 9; a++)
      r[a].fromArray(e, t + a * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let a = 0; a < 9; a++)
      r[a].toArray(e, t + a * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const r = e.x, a = e.y, s = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * a, t[2] = 0.488603 * s, t[3] = 0.488603 * r, t[4] = 1.092548 * r * a, t[5] = 1.092548 * a * s, t[6] = 0.315392 * (3 * s * s - 1), t[7] = 1.092548 * r * s, t[8] = 0.546274 * (r * r - a * a);
  }
}
class ZR extends E0 {
  constructor(e = new RB(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class JR extends uh {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, r, a) {
    const s = this, u = new Bg(s.manager);
    u.setPath(s.path), u.setRequestHeader(s.requestHeader), u.setWithCredentials(s.withCredentials), u.load(e, function(h) {
      try {
        t(s.parse(JSON.parse(h)));
      } catch (v) {
        a ? a(v) : console.error(v), s.manager.itemError(e);
      }
    }, r, a);
  }
  parse(e) {
    const t = this.textures;
    function r(s) {
      return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s];
    }
    const a = JR.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (a.uuid = e.uuid), e.name !== void 0 && (a.name = e.name), e.color !== void 0 && a.color !== void 0 && a.color.setHex(e.color), e.roughness !== void 0 && (a.roughness = e.roughness), e.metalness !== void 0 && (a.metalness = e.metalness), e.sheen !== void 0 && (a.sheen = e.sheen), e.sheenColor !== void 0 && (a.sheenColor = new Un().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (a.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && a.emissive !== void 0 && a.emissive.setHex(e.emissive), e.specular !== void 0 && a.specular !== void 0 && a.specular.setHex(e.specular), e.specularIntensity !== void 0 && (a.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && a.specularColor !== void 0 && a.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (a.shininess = e.shininess), e.clearcoat !== void 0 && (a.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (a.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (a.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (a.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (a.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (a.transmission = e.transmission), e.thickness !== void 0 && (a.thickness = e.thickness), e.attenuationDistance !== void 0 && (a.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && a.attenuationColor !== void 0 && a.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (a.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (a.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (a.fog = e.fog), e.flatShading !== void 0 && (a.flatShading = e.flatShading), e.blending !== void 0 && (a.blending = e.blending), e.combine !== void 0 && (a.combine = e.combine), e.side !== void 0 && (a.side = e.side), e.shadowSide !== void 0 && (a.shadowSide = e.shadowSide), e.opacity !== void 0 && (a.opacity = e.opacity), e.transparent !== void 0 && (a.transparent = e.transparent), e.alphaTest !== void 0 && (a.alphaTest = e.alphaTest), e.depthTest !== void 0 && (a.depthTest = e.depthTest), e.depthWrite !== void 0 && (a.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (a.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (a.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (a.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (a.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (a.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (a.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (a.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (a.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (a.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (a.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (a.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (a.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (a.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (a.rotation = e.rotation), e.linewidth !== 1 && (a.linewidth = e.linewidth), e.dashSize !== void 0 && (a.dashSize = e.dashSize), e.gapSize !== void 0 && (a.gapSize = e.gapSize), e.scale !== void 0 && (a.scale = e.scale), e.polygonOffset !== void 0 && (a.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (a.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (a.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (a.dithering = e.dithering), e.alphaToCoverage !== void 0 && (a.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (a.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (a.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (a.visible = e.visible), e.toneMapped !== void 0 && (a.toneMapped = e.toneMapped), e.userData !== void 0 && (a.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? a.vertexColors = e.vertexColors > 0 : a.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const s in e.uniforms) {
        const u = e.uniforms[s];
        switch (a.uniforms[s] = {}, u.type) {
          case "t":
            a.uniforms[s].value = r(u.value);
            break;
          case "c":
            a.uniforms[s].value = new Un().setHex(u.value);
            break;
          case "v2":
            a.uniforms[s].value = new It().fromArray(u.value);
            break;
          case "v3":
            a.uniforms[s].value = new be().fromArray(u.value);
            break;
          case "v4":
            a.uniforms[s].value = new Ua().fromArray(u.value);
            break;
          case "m3":
            a.uniforms[s].value = new vi().fromArray(u.value);
            break;
          case "m4":
            a.uniforms[s].value = new ei().fromArray(u.value);
            break;
          default:
            a.uniforms[s].value = u.value;
        }
      }
    if (e.defines !== void 0 && (a.defines = e.defines), e.vertexShader !== void 0 && (a.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (a.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (a.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const s in e.extensions)
        a.extensions[s] = e.extensions[s];
    if (e.lights !== void 0 && (a.lights = e.lights), e.clipping !== void 0 && (a.clipping = e.clipping), e.size !== void 0 && (a.size = e.size), e.sizeAttenuation !== void 0 && (a.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (a.map = r(e.map)), e.matcap !== void 0 && (a.matcap = r(e.matcap)), e.alphaMap !== void 0 && (a.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (a.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (a.bumpScale = e.bumpScale), e.normalMap !== void 0 && (a.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (a.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]), a.normalScale = new It().fromArray(s);
    }
    return e.displacementMap !== void 0 && (a.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (a.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (a.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (a.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (a.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (a.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (a.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (a.specularMap = r(e.specularMap)), e.specularIntensityMap !== void 0 && (a.specularIntensityMap = r(e.specularIntensityMap)), e.specularColorMap !== void 0 && (a.specularColorMap = r(e.specularColorMap)), e.envMap !== void 0 && (a.envMap = r(e.envMap)), e.envMapIntensity !== void 0 && (a.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (a.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (a.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (a.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (a.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (a.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (a.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (a.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (a.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (a.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (a.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (a.clearcoatNormalScale = new It().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (a.iridescenceMap = r(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (a.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (a.transmissionMap = r(e.transmissionMap)), e.thicknessMap !== void 0 && (a.thicknessMap = r(e.thicknessMap)), e.anisotropyMap !== void 0 && (a.anisotropyMap = r(e.anisotropyMap)), e.sheenColorMap !== void 0 && (a.sheenColorMap = r(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (a.sheenRoughnessMap = r(e.sheenRoughnessMap)), a;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: lB,
      SpriteMaterial: iP,
      RawShaderMaterial: uB,
      ShaderMaterial: _v,
      PointsMaterial: oP,
      MeshPhysicalMaterial: cB,
      MeshStandardMaterial: pP,
      MeshPhongMaterial: fB,
      MeshToonMaterial: dB,
      MeshNormalMaterial: hB,
      MeshLambertMaterial: pB,
      MeshDepthMaterial: tP,
      MeshDistanceMaterial: nP,
      MeshBasicMaterial: x0,
      MeshMatcapMaterial: mB,
      LineDashedMaterial: vB,
      LineBasicMaterial: Tf,
      Material: Ku
    };
    return new t[e]();
  }
}
class eO {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let r = 0, a = e.length; r < a; r++)
      t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class AB extends yi {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class DB extends uh {
  constructor(e) {
    super(e);
  }
  load(e, t, r, a) {
    const s = this, u = new Bg(s.manager);
    u.setPath(s.path), u.setRequestHeader(s.requestHeader), u.setWithCredentials(s.withCredentials), u.load(e, function(h) {
      try {
        t(s.parse(JSON.parse(h)));
      } catch (v) {
        a ? a(v) : console.error(v), s.manager.itemError(e);
      }
    }, r, a);
  }
  parse(e) {
    const t = {}, r = {};
    function a(C, D) {
      if (t[D] !== void 0)
        return t[D];
      const N = C.interleavedBuffers[D], O = s(C, N.buffer), I = ME(N.type, O), k = new YR(I, N.stride);
      return k.uuid = N.uuid, t[D] = k, k;
    }
    function s(C, D) {
      if (r[D] !== void 0)
        return r[D];
      const N = C.arrayBuffers[D], O = new Uint32Array(N).buffer;
      return r[D] = O, O;
    }
    const u = e.isInstancedBufferGeometry ? new AB() : new yi(), h = e.data.index;
    if (h !== void 0) {
      const C = ME(h.type, h.array);
      u.setIndex(new so(C, 1));
    }
    const v = e.data.attributes;
    for (const C in v) {
      const D = v[C];
      let U;
      if (D.isInterleavedBufferAttribute) {
        const N = a(e.data, D.data);
        U = new lx(N, D.itemSize, D.offset, D.normalized);
      } else {
        const N = ME(D.type, D.array), O = D.isInstancedBufferAttribute ? IE : so;
        U = new O(N, D.itemSize, D.normalized);
      }
      D.name !== void 0 && (U.name = D.name), D.usage !== void 0 && U.setUsage(D.usage), D.updateRange !== void 0 && (U.updateRange.offset = D.updateRange.offset, U.updateRange.count = D.updateRange.count), u.setAttribute(C, U);
    }
    const y = e.data.morphAttributes;
    if (y)
      for (const C in y) {
        const D = y[C], U = [];
        for (let N = 0, O = D.length; N < O; N++) {
          const I = D[N];
          let k;
          if (I.isInterleavedBufferAttribute) {
            const G = a(e.data, I.data);
            k = new lx(G, I.itemSize, I.offset, I.normalized);
          } else {
            const G = ME(I.type, I.array);
            k = new so(G, I.itemSize, I.normalized);
          }
          I.name !== void 0 && (k.name = I.name), U.push(k);
        }
        u.morphAttributes[C] = U;
      }
    e.data.morphTargetsRelative && (u.morphTargetsRelative = !0);
    const b = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (b !== void 0)
      for (let C = 0, D = b.length; C !== D; ++C) {
        const U = b[C];
        u.addGroup(U.start, U.count, U.materialIndex);
      }
    const M = e.data.boundingSphere;
    if (M !== void 0) {
      const C = new be();
      M.center !== void 0 && C.fromArray(M.center), u.boundingSphere = new sm(C, M.radius);
    }
    return e.name && (u.name = e.name), e.userData && (u.userData = e.userData), u;
  }
}
class J$ extends uh {
  constructor(e) {
    super(e);
  }
  load(e, t, r, a) {
    const s = this, u = this.path === "" ? eO.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || u;
    const h = new Bg(this.manager);
    h.setPath(this.path), h.setRequestHeader(this.requestHeader), h.setWithCredentials(this.withCredentials), h.load(e, function(v) {
      let y = null;
      try {
        y = JSON.parse(v);
      } catch (b) {
        a !== void 0 && a(b), console.error("THREE:ObjectLoader: Can't parse " + e + ".", b.message);
        return;
      }
      const _ = y.metadata;
      if (_ === void 0 || _.type === void 0 || _.type.toLowerCase() === "geometry") {
        a !== void 0 && a(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      s.parse(y, t);
    }, r, a);
  }
  async loadAsync(e, t) {
    const r = this, a = this.path === "" ? eO.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || a;
    const s = new Bg(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
    const u = await s.loadAsync(e, t), h = JSON.parse(u), v = h.metadata;
    if (v === void 0 || v.type === void 0 || v.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(h);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations), a = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, a), u = this.parseImages(e.images, function() {
      t !== void 0 && t(y);
    }), h = this.parseTextures(e.textures, u), v = this.parseMaterials(e.materials, h), y = this.parseObject(e.object, s, v, h, r), _ = this.parseSkeletons(e.skeletons, y);
    if (this.bindSkeletons(y, _), t !== void 0) {
      let b = !1;
      for (const M in u)
        if (u[M].data instanceof HTMLImageElement) {
          b = !0;
          break;
        }
      b === !1 && t(y);
    }
    return y;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), a = this.parseGeometries(e.geometries, r), s = await this.parseImagesAsync(e.images), u = this.parseTextures(e.textures, s), h = this.parseMaterials(e.materials, u), v = this.parseObject(e.object, a, h, u, t), y = this.parseSkeletons(e.skeletons, v);
    return this.bindSkeletons(v, y), v;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, a = e.length; r < a; r++) {
        const s = new ix().fromJSON(e[r]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {}, a = {};
    if (t.traverse(function(s) {
      s.isBone && (a[s.uuid] = s);
    }), e !== void 0)
      for (let s = 0, u = e.length; s < u; s++) {
        const h = new XR().fromJSON(e[s], a);
        r[h.uuid] = h;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const a = new DB();
      for (let s = 0, u = e.length; s < u; s++) {
        let h;
        const v = e[s];
        switch (v.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            h = a.parse(v);
            break;
          default:
            v.type in lz ? h = lz[v.type].fromJSON(v, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${v.type}"`);
        }
        h.uuid = v.uuid, v.name !== void 0 && (h.name = v.name), v.userData !== void 0 && (h.userData = v.userData), r[v.uuid] = h;
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {}, a = {};
    if (e !== void 0) {
      const s = new JR();
      s.setTextures(t);
      for (let u = 0, h = e.length; u < h; u++) {
        const v = e[u];
        r[v.uuid] === void 0 && (r[v.uuid] = s.parse(v)), a[v.uuid] = r[v.uuid];
      }
    }
    return a;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const a = e[r], s = FT.parse(a);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this, a = {};
    let s;
    function u(v) {
      return r.manager.itemStart(v), s.load(v, function() {
        r.manager.itemEnd(v);
      }, void 0, function() {
        r.manager.itemError(v), r.manager.itemEnd(v);
      });
    }
    function h(v) {
      if (typeof v == "string") {
        const y = v, _ = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(y) ? y : r.resourcePath + y;
        return u(_);
      } else
        return v.data ? {
          data: ME(v.type, v.data),
          width: v.width,
          height: v.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const v = new SP(t);
      s = new BT(v), s.setCrossOrigin(this.crossOrigin);
      for (let y = 0, _ = e.length; y < _; y++) {
        const b = e[y], M = b.url;
        if (Array.isArray(M)) {
          const C = [];
          for (let D = 0, U = M.length; D < U; D++) {
            const N = M[D], O = h(N);
            O !== null && (O instanceof HTMLImageElement ? C.push(O) : C.push(new OE(O.data, O.width, O.height)));
          }
          a[b.uuid] = new ZS(C);
        } else {
          const C = h(b.url);
          a[b.uuid] = new ZS(C);
        }
      }
    }
    return a;
  }
  async parseImagesAsync(e) {
    const t = this, r = {};
    let a;
    async function s(u) {
      if (typeof u == "string") {
        const h = u, v = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h) ? h : t.resourcePath + h;
        return await a.loadAsync(v);
      } else
        return u.data ? {
          data: ME(u.type, u.data),
          width: u.width,
          height: u.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      a = new BT(this.manager), a.setCrossOrigin(this.crossOrigin);
      for (let u = 0, h = e.length; u < h; u++) {
        const v = e[u], y = v.url;
        if (Array.isArray(y)) {
          const _ = [];
          for (let b = 0, M = y.length; b < M; b++) {
            const C = y[b], D = await s(C);
            D !== null && (D instanceof HTMLImageElement ? _.push(D) : _.push(new OE(D.data, D.width, D.height)));
          }
          r[v.uuid] = new ZS(_);
        } else {
          const _ = await s(v.url);
          r[v.uuid] = new ZS(_);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(s, u) {
      return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), u[s]);
    }
    const a = {};
    if (e !== void 0)
      for (let s = 0, u = e.length; s < u; s++) {
        const h = e[s];
        h.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', h.uuid), t[h.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", h.image);
        const v = t[h.image], y = v.data;
        let _;
        Array.isArray(y) ? (_ = new KT(), y.length === 6 && (_.needsUpdate = !0)) : (y && y.data ? _ = new OE() : _ = new Rs(), y && (_.needsUpdate = !0)), _.source = v, _.uuid = h.uuid, h.name !== void 0 && (_.name = h.name), h.mapping !== void 0 && (_.mapping = r(h.mapping, eY)), h.channel !== void 0 && (_.channel = h.channel), h.offset !== void 0 && _.offset.fromArray(h.offset), h.repeat !== void 0 && _.repeat.fromArray(h.repeat), h.center !== void 0 && _.center.fromArray(h.center), h.rotation !== void 0 && (_.rotation = h.rotation), h.wrap !== void 0 && (_.wrapS = r(h.wrap[0], dz), _.wrapT = r(h.wrap[1], dz)), h.format !== void 0 && (_.format = h.format), h.internalFormat !== void 0 && (_.internalFormat = h.internalFormat), h.type !== void 0 && (_.type = h.type), h.colorSpace !== void 0 && (_.colorSpace = h.colorSpace), h.encoding !== void 0 && (_.encoding = h.encoding), h.minFilter !== void 0 && (_.minFilter = r(h.minFilter, hz)), h.magFilter !== void 0 && (_.magFilter = r(h.magFilter, hz)), h.anisotropy !== void 0 && (_.anisotropy = h.anisotropy), h.flipY !== void 0 && (_.flipY = h.flipY), h.generateMipmaps !== void 0 && (_.generateMipmaps = h.generateMipmaps), h.premultiplyAlpha !== void 0 && (_.premultiplyAlpha = h.premultiplyAlpha), h.unpackAlignment !== void 0 && (_.unpackAlignment = h.unpackAlignment), h.compareFunction !== void 0 && (_.compareFunction = h.compareFunction), h.userData !== void 0 && (_.userData = h.userData), a[h.uuid] = _;
      }
    return a;
  }
  parseObject(e, t, r, a, s) {
    let u;
    function h(M) {
      return t[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", M), t[M];
    }
    function v(M) {
      if (M !== void 0) {
        if (Array.isArray(M)) {
          const C = [];
          for (let D = 0, U = M.length; D < U; D++) {
            const N = M[D];
            r[N] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", N), C.push(r[N]);
          }
          return C;
        }
        return r[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", M), r[M];
      }
    }
    function y(M) {
      return a[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", M), a[M];
    }
    let _, b;
    switch (e.type) {
      case "Scene":
        u = new SR(), e.background !== void 0 && (Number.isInteger(e.background) ? u.background = new Un(e.background) : u.background = y(e.background)), e.environment !== void 0 && (u.environment = y(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? u.fog = new $R(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (u.fog = new jR(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (u.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (u.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        u = new Cs(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (u.focus = e.focus), e.zoom !== void 0 && (u.zoom = e.zoom), e.filmGauge !== void 0 && (u.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (u.filmOffset = e.filmOffset), e.view !== void 0 && (u.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        u = new zg(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (u.zoom = e.zoom), e.view !== void 0 && (u.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        u = new wB(e.color, e.intensity);
        break;
      case "DirectionalLight":
        u = new MB(e.color, e.intensity);
        break;
      case "PointLight":
        u = new TB(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        u = new CB(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        u = new bB(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        u = new EB(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        u = new ZR().fromJSON(e);
        break;
      case "SkinnedMesh":
        _ = h(e.geometry), b = v(e.material), u = new YF(_, b), e.bindMode !== void 0 && (u.bindMode = e.bindMode), e.bindMatrix !== void 0 && u.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (u.skeleton = e.skeleton);
        break;
      case "Mesh":
        _ = h(e.geometry), b = v(e.material), u = new qu(_, b);
        break;
      case "InstancedMesh":
        _ = h(e.geometry), b = v(e.material);
        const M = e.count, C = e.instanceMatrix, D = e.instanceColor;
        u = new XF(_, b, M), u.instanceMatrix = new IE(new Float32Array(C.array), 16), D !== void 0 && (u.instanceColor = new IE(new Float32Array(D.array), D.itemSize));
        break;
      case "LOD":
        u = new $F();
        break;
      case "Line":
        u = new p0(h(e.geometry), v(e.material));
        break;
      case "LineLoop":
        u = new qF(h(e.geometry), v(e.material));
        break;
      case "LineSegments":
        u = new wv(h(e.geometry), v(e.material));
        break;
      case "PointCloud":
      case "Points":
        u = new KF(h(e.geometry), v(e.material));
        break;
      case "Sprite":
        u = new jF(v(e.material));
        break;
      case "Group":
        u = new CE();
        break;
      case "Bone":
        u = new aP();
        break;
      default:
        u = new ha();
    }
    if (u.uuid = e.uuid, e.name !== void 0 && (u.name = e.name), e.matrix !== void 0 ? (u.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (u.matrixAutoUpdate = e.matrixAutoUpdate), u.matrixAutoUpdate && u.matrix.decompose(u.position, u.quaternion, u.scale)) : (e.position !== void 0 && u.position.fromArray(e.position), e.rotation !== void 0 && u.rotation.fromArray(e.rotation), e.quaternion !== void 0 && u.quaternion.fromArray(e.quaternion), e.scale !== void 0 && u.scale.fromArray(e.scale)), e.up !== void 0 && u.up.fromArray(e.up), e.castShadow !== void 0 && (u.castShadow = e.castShadow), e.receiveShadow !== void 0 && (u.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (u.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (u.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (u.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && u.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (u.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (u.visible = e.visible), e.frustumCulled !== void 0 && (u.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (u.renderOrder = e.renderOrder), e.userData !== void 0 && (u.userData = e.userData), e.layers !== void 0 && (u.layers.mask = e.layers), e.children !== void 0) {
      const M = e.children;
      for (let C = 0; C < M.length; C++)
        u.add(this.parseObject(M[C], t, r, a, s));
    }
    if (e.animations !== void 0) {
      const M = e.animations;
      for (let C = 0; C < M.length; C++) {
        const D = M[C];
        u.animations.push(s[D]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (u.autoUpdate = e.autoUpdate);
      const M = e.levels;
      for (let C = 0; C < M.length; C++) {
        const D = M[C], U = u.getObjectByProperty("uuid", D.object);
        U !== void 0 && u.addLevel(U, D.distance, D.hysteresis);
      }
    }
    return u;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(r) {
      if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
        const a = t[r.skeleton];
        a === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(a, r.bindMatrix);
      }
    });
  }
}
const eY = {
  UVMapping: FR,
  CubeReflectionMapping: f0,
  CubeRefractionMapping: d0,
  EquirectangularReflectionMapping: bT,
  EquirectangularRefractionMapping: TT,
  CubeUVReflectionMapping: WE
}, dz = {
  RepeatWrapping: MT,
  ClampToEdgeWrapping: Dc,
  MirroredRepeatWrapping: wT
}, hz = {
  NearestFilter: el,
  NearestMipmapNearestFilter: vR,
  NearestMipmapLinearFilter: mT,
  LinearFilter: tl,
  LinearMipmapNearestFilter: FO,
  LinearMipmapLinearFilter: h0
};
class tY extends uh {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, r, a) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, u = cx.get(e);
    if (u !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(u), s.manager.itemEnd(e);
      }, 0), u;
    const h = {};
    h.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", h.headers = this.requestHeader, fetch(e, h).then(function(v) {
      return v.blob();
    }).then(function(v) {
      return createImageBitmap(v, Object.assign(s.options, { colorSpaceConversion: "none" }));
    }).then(function(v) {
      cx.add(e, v), t && t(v), s.manager.itemEnd(e);
    }).catch(function(v) {
      a && a(v), s.manager.itemError(e), s.manager.itemEnd(e);
    }), s.manager.itemStart(e);
  }
}
let HC;
class _P {
  static getContext() {
    return HC === void 0 && (HC = new (window.AudioContext || window.webkitAudioContext)()), HC;
  }
  static setContext(e) {
    HC = e;
  }
}
class nY extends uh {
  constructor(e) {
    super(e);
  }
  load(e, t, r, a) {
    const s = this, u = new Bg(this.manager);
    u.setResponseType("arraybuffer"), u.setPath(this.path), u.setRequestHeader(this.requestHeader), u.setWithCredentials(this.withCredentials), u.load(e, function(v) {
      try {
        const y = v.slice(0);
        _P.getContext().decodeAudioData(y, function(b) {
          t(b);
        }, h);
      } catch (y) {
        h(y);
      }
    }, r, a);
    function h(v) {
      a ? a(v) : console.error(v), s.manager.itemError(e);
    }
  }
}
class rY extends ZR {
  constructor(e, t, r = 1) {
    super(void 0, r), this.isHemisphereLightProbe = !0;
    const a = new Un().set(e), s = new Un().set(t), u = new be(a.r, a.g, a.b), h = new be(s.r, s.g, s.b), v = Math.sqrt(Math.PI), y = v * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(u).add(h).multiplyScalar(v), this.sh.coefficients[1].copy(u).sub(h).multiplyScalar(y);
  }
}
class iY extends ZR {
  constructor(e, t = 1) {
    super(void 0, t), this.isAmbientLightProbe = !0;
    const r = new Un().set(e);
    this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const pz = /* @__PURE__ */ new ei(), mz = /* @__PURE__ */ new ei(), BS = /* @__PURE__ */ new ei();
class aY {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Cs(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Cs(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, BS.copy(e.projectionMatrix);
      const a = t.eyeSep / 2, s = a * t.near / t.focus, u = t.near * Math.tan(nx * t.fov * 0.5) / t.zoom;
      let h, v;
      mz.elements[12] = -a, pz.elements[12] = a, h = -u * t.aspect + s, v = u * t.aspect + s, BS.elements[0] = 2 * t.near / (v - h), BS.elements[8] = (v + h) / (v - h), this.cameraL.projectionMatrix.copy(BS), h = -u * t.aspect - s, v = u * t.aspect - s, BS.elements[0] = 2 * t.near / (v - h), BS.elements[8] = (v + h) / (v - h), this.cameraR.projectionMatrix.copy(BS);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(mz), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(pz);
  }
}
class EP {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = vz(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = vz();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function vz() {
  return (typeof performance > "u" ? Date : performance).now();
}
const HS = /* @__PURE__ */ new be(), gz = /* @__PURE__ */ new Oc(), oY = /* @__PURE__ */ new be(), VS = /* @__PURE__ */ new be();
class sY extends ha {
  constructor() {
    super(), this.type = "AudioListener", this.context = _P.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new EP();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, r = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(HS, gz, oY), VS.set(0, 0, -1).applyQuaternion(gz), t.positionX) {
      const a = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(HS.x, a), t.positionY.linearRampToValueAtTime(HS.y, a), t.positionZ.linearRampToValueAtTime(HS.z, a), t.forwardX.linearRampToValueAtTime(VS.x, a), t.forwardY.linearRampToValueAtTime(VS.y, a), t.forwardZ.linearRampToValueAtTime(VS.z, a), t.upX.linearRampToValueAtTime(r.x, a), t.upY.linearRampToValueAtTime(r.y, a), t.upZ.linearRampToValueAtTime(r.z, a);
    } else
      t.setPosition(HS.x, HS.y, HS.z), t.setOrientation(VS.x, VS.y, VS.z, r.x, r.y, r.z);
  }
}
class LB extends ha {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this._connected = !1, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const GS = /* @__PURE__ */ new be(), yz = /* @__PURE__ */ new Oc(), lY = /* @__PURE__ */ new be(), WS = /* @__PURE__ */ new be();
class uY extends LB {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, r) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = r, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(GS, yz, lY), WS.set(0, 0, 1).applyQuaternion(yz);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(GS.x, r), t.positionY.linearRampToValueAtTime(GS.y, r), t.positionZ.linearRampToValueAtTime(GS.z, r), t.orientationX.linearRampToValueAtTime(WS.x, r), t.orientationY.linearRampToValueAtTime(WS.y, r), t.orientationZ.linearRampToValueAtTime(WS.z, r);
    } else
      t.setPosition(GS.x, GS.y, GS.z), t.setOrientation(WS.x, WS.y, WS.z);
  }
}
class cY {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++)
      e += t[r];
    return e / t.length;
  }
}
class OB {
  constructor(e, t, r) {
    this.binding = e, this.valueSize = r;
    let a, s, u;
    switch (t) {
      case "quaternion":
        a = this._slerp, s = this._slerpAdditive, u = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        a = this._select, s = this._select, u = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5);
        break;
      default:
        a = this._lerp, s = this._lerpAdditive, u = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5);
    }
    this._mixBufferRegion = a, this._mixBufferRegionAdditive = s, this._setIdentity = u, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const r = this.buffer, a = this.valueSize, s = e * a + a;
    let u = this.cumulativeWeight;
    if (u === 0) {
      for (let h = 0; h !== a; ++h)
        r[s + h] = r[h];
      u = t;
    } else {
      u += t;
      const h = t / u;
      this._mixBufferRegion(r, s, 0, h, a);
    }
    this.cumulativeWeight = u;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, r = this.valueSize, a = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, a, 0, e, r), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, r = this.buffer, a = e * t + t, s = this.cumulativeWeight, u = this.cumulativeWeightAdditive, h = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const v = t * this._origIndex;
      this._mixBufferRegion(
        r,
        a,
        v,
        1 - s,
        t
      );
    }
    u > 0 && this._mixBufferRegionAdditive(r, a, this._addIndex * t, 1, t);
    for (let v = t, y = t + t; v !== y; ++v)
      if (r[v] !== r[v + t]) {
        h.setValue(r, a);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, r = this.valueSize, a = r * this._origIndex;
    e.getValue(t, a);
    for (let s = r, u = a; s !== u; ++s)
      t[s] = t[a + s % r];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let r = e; r < t; r++)
      this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  // mix functions
  _select(e, t, r, a, s) {
    if (a >= 0.5)
      for (let u = 0; u !== s; ++u)
        e[t + u] = e[r + u];
  }
  _slerp(e, t, r, a) {
    Oc.slerpFlat(e, t, e, t, e, r, a);
  }
  _slerpAdditive(e, t, r, a, s) {
    const u = this._workIndex * s;
    Oc.multiplyQuaternionsFlat(e, u, e, t, e, r), Oc.slerpFlat(e, t, e, t, e, u, a);
  }
  _lerp(e, t, r, a, s) {
    const u = 1 - a;
    for (let h = 0; h !== s; ++h) {
      const v = t + h;
      e[v] = e[v] * u + e[r + h] * a;
    }
  }
  _lerpAdditive(e, t, r, a, s) {
    for (let u = 0; u !== s; ++u) {
      const h = t + u;
      e[h] = e[h] + e[r + u] * a;
    }
  }
}
const bP = "\\[\\]\\.:\\/", fY = new RegExp("[" + bP + "]", "g"), TP = "[^" + bP + "]", dY = "[^" + bP.replace("\\.", "") + "]", hY = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", TP), pY = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", dY), mY = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", TP), vY = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", TP), gY = new RegExp(
  "^" + hY + pY + mY + vY + "$"
), yY = ["material", "materials", "bones", "map"];
class SY {
  constructor(e, t, r) {
    const a = r || sa.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, a);
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_, a = this._bindings[r];
    a !== void 0 && a.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let a = this._targetGroup.nCachedObjects_, s = r.length; a !== s; ++a)
      r[a].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class sa {
  constructor(e, t, r) {
    this.path = t, this.parsedPath = r || sa.parseTrackName(t), this.node = sa.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup ? new sa.Composite(e, t, r) : new sa(e, t, r);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(fY, "");
  }
  static parseTrackName(e) {
    const t = gY.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, a = r.nodeName && r.nodeName.lastIndexOf(".");
    if (a !== void 0 && a !== -1) {
      const s = r.nodeName.substring(a + 1);
      yY.indexOf(s) !== -1 && (r.nodeName = r.nodeName.substring(0, a), r.objectName = s);
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return r;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0)
        return r;
    }
    if (e.children) {
      const r = function(s) {
        for (let u = 0; u < s.length; u++) {
          const h = s[u];
          if (h.name === t || h.uuid === t)
            return h;
          const v = r(h.children);
          if (v)
            return v;
        }
        return null;
      }, a = r(e.children);
      if (a)
        return a;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let a = 0, s = r.length; a !== s; ++a)
      e[t++] = r[a];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let a = 0, s = r.length; a !== s; ++a)
      r[a] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let a = 0, s = r.length; a !== s; ++a)
      r[a] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let a = 0, s = r.length; a !== s; ++a)
      r[a] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, r = t.objectName, a = t.propertyName;
    let s = t.propertyIndex;
    if (e || (e = sa.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (r) {
      let y = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let _ = 0; _ < e.length; _++)
            if (e[_].name === y) {
              y = _;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[r];
      }
      if (y !== void 0) {
        if (e[y] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[y];
      }
    }
    const u = e[a];
    if (u === void 0) {
      const y = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + y + "." + a + " but it wasn't found.", e);
      return;
    }
    let h = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? h = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (h = this.Versioning.MatrixWorldNeedsUpdate);
    let v = this.BindingType.Direct;
    if (s !== void 0) {
      if (a === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
      }
      v = this.BindingType.ArrayElement, this.resolvedProperty = u, this.propertyIndex = s;
    } else
      u.fromArray !== void 0 && u.toArray !== void 0 ? (v = this.BindingType.HasFromToArray, this.resolvedProperty = u) : Array.isArray(u) ? (v = this.BindingType.EntireArray, this.resolvedProperty = u) : this.propertyName = a;
    this.getValue = this.GetterByBindingType[v], this.setValue = this.SetterByBindingTypeAndVersioning[v][h];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
sa.Composite = SY;
sa.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
sa.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
sa.prototype.GetterByBindingType = [
  sa.prototype._getValue_direct,
  sa.prototype._getValue_array,
  sa.prototype._getValue_arrayElement,
  sa.prototype._getValue_toArray
];
sa.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    sa.prototype._setValue_direct,
    sa.prototype._setValue_direct_setNeedsUpdate,
    sa.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    sa.prototype._setValue_array,
    sa.prototype._setValue_array_setNeedsUpdate,
    sa.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    sa.prototype._setValue_arrayElement,
    sa.prototype._setValue_arrayElement_setNeedsUpdate,
    sa.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    sa.prototype._setValue_fromArray,
    sa.prototype._setValue_fromArray_setNeedsUpdate,
    sa.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class xY {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = sh(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, a = arguments.length; r !== a; ++r)
      e[arguments[r].uuid] = r;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, r = this._paths, a = this._parsedPaths, s = this._bindings, u = s.length;
    let h, v = e.length, y = this.nCachedObjects_;
    for (let _ = 0, b = arguments.length; _ !== b; ++_) {
      const M = arguments[_], C = M.uuid;
      let D = t[C];
      if (D === void 0) {
        D = v++, t[C] = D, e.push(M);
        for (let U = 0, N = u; U !== N; ++U)
          s[U].push(new sa(M, r[U], a[U]));
      } else if (D < y) {
        h = e[D];
        const U = --y, N = e[U];
        t[N.uuid] = D, e[D] = N, t[C] = U, e[U] = M;
        for (let O = 0, I = u; O !== I; ++O) {
          const k = s[O], G = k[U];
          let j = k[D];
          k[D] = G, j === void 0 && (j = new sa(M, r[O], a[O])), k[U] = j;
        }
      } else
        e[D] !== h && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = y;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, r = this._bindings, a = r.length;
    let s = this.nCachedObjects_;
    for (let u = 0, h = arguments.length; u !== h; ++u) {
      const v = arguments[u], y = v.uuid, _ = t[y];
      if (_ !== void 0 && _ >= s) {
        const b = s++, M = e[b];
        t[M.uuid] = _, e[_] = M, t[y] = b, e[b] = v;
        for (let C = 0, D = a; C !== D; ++C) {
          const U = r[C], N = U[b], O = U[_];
          U[_] = N, U[b] = O;
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, r = this._bindings, a = r.length;
    let s = this.nCachedObjects_, u = e.length;
    for (let h = 0, v = arguments.length; h !== v; ++h) {
      const y = arguments[h], _ = y.uuid, b = t[_];
      if (b !== void 0)
        if (delete t[_], b < s) {
          const M = --s, C = e[M], D = --u, U = e[D];
          t[C.uuid] = b, e[b] = C, t[U.uuid] = M, e[M] = U, e.pop();
          for (let N = 0, O = a; N !== O; ++N) {
            const I = r[N], k = I[M], G = I[D];
            I[b] = k, I[M] = G, I.pop();
          }
        } else {
          const M = --u, C = e[M];
          M > 0 && (t[C.uuid] = b), e[b] = C, e.pop();
          for (let D = 0, U = a; D !== U; ++D) {
            const N = r[D];
            N[b] = N[M], N.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let a = r[e];
    const s = this._bindings;
    if (a !== void 0)
      return s[a];
    const u = this._paths, h = this._parsedPaths, v = this._objects, y = v.length, _ = this.nCachedObjects_, b = new Array(y);
    a = s.length, r[e] = a, u.push(e), h.push(t), s.push(b);
    for (let M = _, C = v.length; M !== C; ++M) {
      const D = v[M];
      b[M] = new sa(D, e, t);
    }
    return b;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, r = t[e];
    if (r !== void 0) {
      const a = this._paths, s = this._parsedPaths, u = this._bindings, h = u.length - 1, v = u[h], y = e[h];
      t[y] = r, u[r] = v, u.pop(), s[r] = s[h], s.pop(), a[r] = a[h], a.pop();
    }
  }
}
class PB {
  constructor(e, t, r = null, a = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = r, this.blendMode = a;
    const s = t.tracks, u = s.length, h = new Array(u), v = {
      endingStart: KS,
      endingEnd: KS
    };
    for (let y = 0; y !== u; ++y) {
      const _ = s[y].createInterpolant(null);
      h[y] = _, _.settings = v;
    }
    this._interpolantSettings = v, this._interpolants = h, this._propertyBindings = new Array(u), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = pF, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r) {
    if (e.fadeOut(t), this.fadeIn(t), r) {
      const a = this._clip.duration, s = e._clip.duration, u = s / a, h = a / s;
      e.warp(1, u, t), this.warp(h, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const a = this._mixer, s = a.time, u = this.timeScale;
    let h = this._timeScaleInterpolant;
    h === null && (h = a._lendControlInterpolant(), this._timeScaleInterpolant = h);
    const v = h.parameterPositions, y = h.sampleValues;
    return v[0] = s, v[1] = s + r, y[0] = e / u, y[1] = t / u, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, r, a) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const v = (e - s) * r;
      v < 0 || r === 0 ? t = 0 : (this._startTime = null, t = r * v);
    }
    t *= this._updateTimeScale(e);
    const u = this._updateTime(t), h = this._updateWeight(e);
    if (h > 0) {
      const v = this._interpolants, y = this._propertyBindings;
      switch (this.blendMode) {
        case $O:
          for (let _ = 0, b = v.length; _ !== b; ++_)
            v[_].evaluate(u), y[_].accumulateAdditive(h);
          break;
        case HR:
        default:
          for (let _ = 0, b = v.length; _ !== b; ++_)
            v[_].evaluate(u), y[_].accumulate(a, h);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const a = r.evaluate(e)[0];
        t *= a, e > r.parameterPositions[1] && (this.stopFading(), a === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const a = r.evaluate(e)[0];
        t *= a, e > r.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, r = this.loop;
    let a = this.time + e, s = this._loopCount;
    const u = r === mF;
    if (e === 0)
      return s === -1 ? a : u && (s & 1) === 1 ? t - a : a;
    if (r === hF) {
      s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (a >= t)
          a = t;
        else if (a < 0)
          a = 0;
        else {
          this.time = a;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = a, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, u)) : this._setEndings(this.repetitions === 0, !0, u)), a >= t || a < 0) {
        const h = Math.floor(a / t);
        a -= t * h, s += Math.abs(h);
        const v = this.repetitions - s;
        if (v <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, a = e > 0 ? t : 0, this.time = a, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (v === 1) {
            const y = e < 0;
            this._setEndings(y, !y, u);
          } else
            this._setEndings(!1, !1, u);
          this._loopCount = s, this.time = a, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: h
          });
        }
      } else
        this.time = a;
      if (u && (s & 1) === 1)
        return t - a;
    }
    return a;
  }
  _setEndings(e, t, r) {
    const a = this._interpolantSettings;
    r ? (a.endingStart = QS, a.endingEnd = QS) : (e ? a.endingStart = this.zeroSlopeAtStart ? QS : KS : a.endingStart = AT, t ? a.endingEnd = this.zeroSlopeAtEnd ? QS : KS : a.endingEnd = AT);
  }
  _scheduleFading(e, t, r) {
    const a = this._mixer, s = a.time;
    let u = this._weightInterpolant;
    u === null && (u = a._lendControlInterpolant(), this._weightInterpolant = u);
    const h = u.parameterPositions, v = u.sampleValues;
    return h[0] = s, v[0] = t, h[1] = s + e, v[1] = r, this;
  }
}
const _Y = new Float32Array(1);
class EY extends Tv {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root, a = e._clip.tracks, s = a.length, u = e._propertyBindings, h = e._interpolants, v = r.uuid, y = this._bindingsByRootAndName;
    let _ = y[v];
    _ === void 0 && (_ = {}, y[v] = _);
    for (let b = 0; b !== s; ++b) {
      const M = a[b], C = M.name;
      let D = _[C];
      if (D !== void 0)
        ++D.referenceCount, u[b] = D;
      else {
        if (D = u[b], D !== void 0) {
          D._cacheIndex === null && (++D.referenceCount, this._addInactiveBinding(D, v, C));
          continue;
        }
        const U = t && t._propertyBindings[b].binding.parsedPath;
        D = new OB(
          sa.create(r, C, U),
          M.ValueTypeName,
          M.getValueSize()
        ), ++D.referenceCount, this._addInactiveBinding(D, v, C), u[b] = D;
      }
      h[b].resultBuffer = D.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid, a = e._clip.uuid, s = this._actionsByClip[a];
        this._bindAction(
          e,
          s && s.knownActions[0]
        ), this._addInactiveAction(e, a, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, a = t.length; r !== a; ++r) {
        const s = t[r];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, a = t.length; r !== a; ++r) {
        const s = t[r];
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const a = this._actions, s = this._actionsByClip;
    let u = s[t];
    if (u === void 0)
      u = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, s[t] = u;
    else {
      const h = u.knownActions;
      e._byClipCacheIndex = h.length, h.push(e);
    }
    e._cacheIndex = a.length, a.push(e), u.actionByRoot[r] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, r = t[t.length - 1], a = e._cacheIndex;
    r._cacheIndex = a, t[a] = r, t.pop(), e._cacheIndex = null;
    const s = e._clip.uuid, u = this._actionsByClip, h = u[s], v = h.knownActions, y = v[v.length - 1], _ = e._byClipCacheIndex;
    y._byClipCacheIndex = _, v[_] = y, v.pop(), e._byClipCacheIndex = null;
    const b = h.actionByRoot, M = (e._localRoot || this._root).uuid;
    delete b[M], v.length === 0 && delete u[s], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, a = t.length; r !== a; ++r) {
      const s = t[r];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions, r = e._cacheIndex, a = this._nActiveActions++, s = t[a];
    e._cacheIndex = a, t[a] = e, s._cacheIndex = r, t[r] = s;
  }
  _takeBackAction(e) {
    const t = this._actions, r = e._cacheIndex, a = --this._nActiveActions, s = t[a];
    e._cacheIndex = a, t[a] = e, s._cacheIndex = r, t[r] = s;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, r) {
    const a = this._bindingsByRootAndName, s = this._bindings;
    let u = a[t];
    u === void 0 && (u = {}, a[t] = u), u[r] = e, e._cacheIndex = s.length, s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, r = e.binding, a = r.rootNode.uuid, s = r.path, u = this._bindingsByRootAndName, h = u[a], v = t[t.length - 1], y = e._cacheIndex;
    v._cacheIndex = y, t[y] = v, t.pop(), delete h[s], Object.keys(h).length === 0 && delete u[a];
  }
  _lendBinding(e) {
    const t = this._bindings, r = e._cacheIndex, a = this._nActiveBindings++, s = t[a];
    e._cacheIndex = a, t[a] = e, s._cacheIndex = r, t[r] = s;
  }
  _takeBackBinding(e) {
    const t = this._bindings, r = e._cacheIndex, a = --this._nActiveBindings, s = t[a];
    e._cacheIndex = a, t[a] = e, s._cacheIndex = r, t[r] = s;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let r = e[t];
    return r === void 0 && (r = new gP(
      new Float32Array(2),
      new Float32Array(2),
      1,
      _Y
    ), r.__cacheIndex = t, e[t] = r), r;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, r = e.__cacheIndex, a = --this._nActiveControlInterpolants, s = t[a];
    e.__cacheIndex = a, t[a] = e, s.__cacheIndex = r, t[r] = s;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, r) {
    const a = t || this._root, s = a.uuid;
    let u = typeof e == "string" ? FT.findByName(a, e) : e;
    const h = u !== null ? u.uuid : e, v = this._actionsByClip[h];
    let y = null;
    if (r === void 0 && (u !== null ? r = u.blendMode : r = HR), v !== void 0) {
      const b = v.actionByRoot[s];
      if (b !== void 0 && b.blendMode === r)
        return b;
      y = v.knownActions[0], u === null && (u = y._clip);
    }
    if (u === null)
      return null;
    const _ = new PB(this, u, t, r);
    return this._bindAction(_, y), this._addInactiveAction(_, h, s), _;
  }
  // get an existing action
  existingAction(e, t) {
    const r = t || this._root, a = r.uuid, s = typeof e == "string" ? FT.findByName(r, e) : e, u = s ? s.uuid : e, h = this._actionsByClip[u];
    return h !== void 0 && h.actionByRoot[a] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r)
      e[r].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, r = this._nActiveActions, a = this.time += e, s = Math.sign(e), u = this._accuIndex ^= 1;
    for (let y = 0; y !== r; ++y)
      t[y]._update(a, e, s, u);
    const h = this._bindings, v = this._nActiveBindings;
    for (let y = 0; y !== v; ++y)
      h[y].apply(u);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, r = e.uuid, a = this._actionsByClip, s = a[r];
    if (s !== void 0) {
      const u = s.knownActions;
      for (let h = 0, v = u.length; h !== v; ++h) {
        const y = u[h];
        this._deactivateAction(y);
        const _ = y._cacheIndex, b = t[t.length - 1];
        y._cacheIndex = null, y._byClipCacheIndex = null, b._cacheIndex = _, t[_] = b, t.pop(), this._removeInactiveBindingsForAction(y);
      }
      delete a[r];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, r = this._actionsByClip;
    for (const u in r) {
      const h = r[u].actionByRoot, v = h[t];
      v !== void 0 && (this._deactivateAction(v), this._removeInactiveAction(v));
    }
    const a = this._bindingsByRootAndName, s = a[t];
    if (s !== void 0)
      for (const u in s) {
        const h = s[u];
        h.restoreOriginalState(), this._removeInactiveBinding(h);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class MP {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new MP(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let bY = 0;
class TY extends Tv {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: bY++ }), this.name = "", this.usage = DT, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, a = t.length; r < a; r++)
      this.uniforms.push(t[r].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class MY extends YR {
  constructor(e, t, r = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class wY {
  constructor(e, t, r, a, s) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = r, this.elementSize = a, this.count = s, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class wP {
  constructor(e, t, r = 0, a = 1 / 0) {
    this.ray = new mx(e, t), this.near = r, this.far = a, this.camera = null, this.layers = new rx(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, r = []) {
    return tO(e, this, r, t), r.sort(Sz), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let a = 0, s = e.length; a < s; a++)
      tO(e[a], this, r, t);
    return r.sort(Sz), r;
  }
}
function Sz(n, e) {
  return n.distance - e.distance;
}
function tO(n, e, t, r) {
  if (n.layers.test(e.layers) && n.raycast(e, t), r === !0) {
    const a = n.children;
    for (let s = 0, u = a.length; s < u; s++)
      tO(a[s], e, t, !0);
  }
}
class nO {
  constructor(e = 1, t = 0, r = 0) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  }
  set(e, t, r) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return this.radius = Math.sqrt(e * e + t * t + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(ws(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class CY {
  constructor(e = 1, t = 0, r = 0) {
    return this.radius = e, this.theta = t, this.y = r, this;
  }
  set(e, t, r) {
    return this.radius = e, this.theta = t, this.y = r, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const xz = /* @__PURE__ */ new It();
class RY {
  constructor(e = new It(1 / 0, 1 / 0), t = new It(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = xz.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, xz).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const _z = /* @__PURE__ */ new be(), VC = /* @__PURE__ */ new be();
class AY {
  constructor(e = new be(), t = new be()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    _z.subVectors(e, this.start), VC.subVectors(this.end, this.start);
    const r = VC.dot(VC);
    let s = VC.dot(_z) / r;
    return t && (s = ws(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, r) {
    const a = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(a).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ez = /* @__PURE__ */ new be();
class DY extends ha {
  constructor(e, t) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const r = new yi(), a = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let u = 0, h = 1, v = 32; u < v; u++, h++) {
      const y = u / v * Math.PI * 2, _ = h / v * Math.PI * 2;
      a.push(
        Math.cos(y),
        Math.sin(y),
        1,
        Math.cos(_),
        Math.sin(_),
        1
      );
    }
    r.setAttribute("position", new nr(a, 3));
    const s = new Tf({ fog: !1, toneMapped: !1 });
    this.cone = new wv(r, s), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), Ez.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Ez), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const r0 = /* @__PURE__ */ new be(), GC = /* @__PURE__ */ new ei(), z2 = /* @__PURE__ */ new ei();
class LY extends wv {
  constructor(e) {
    const t = NB(e), r = new yi(), a = [], s = [], u = new Un(0, 0, 1), h = new Un(0, 1, 0);
    for (let y = 0; y < t.length; y++) {
      const _ = t[y];
      _.parent && _.parent.isBone && (a.push(0, 0, 0), a.push(0, 0, 0), s.push(u.r, u.g, u.b), s.push(h.r, h.g, h.b));
    }
    r.setAttribute("position", new nr(a, 3)), r.setAttribute("color", new nr(s, 3));
    const v = new Tf({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(r, v), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, r = this.geometry, a = r.getAttribute("position");
    z2.copy(this.root.matrixWorld).invert();
    for (let s = 0, u = 0; s < t.length; s++) {
      const h = t[s];
      h.parent && h.parent.isBone && (GC.multiplyMatrices(z2, h.matrixWorld), r0.setFromMatrixPosition(GC), a.setXYZ(u, r0.x, r0.y, r0.z), GC.multiplyMatrices(z2, h.parent.matrixWorld), r0.setFromMatrixPosition(GC), a.setXYZ(u + 1, r0.x, r0.y, r0.z), u += 2);
    }
    r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function NB(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, NB(n.children[t]));
  return e;
}
class OY extends qu {
  constructor(e, t, r) {
    const a = new qE(t, 4, 2), s = new x0({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(a, s), this.light = e, this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const PY = /* @__PURE__ */ new be(), bz = /* @__PURE__ */ new Un(), Tz = /* @__PURE__ */ new Un();
class NY extends ha {
  constructor(e, t, r) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "HemisphereLightHelper";
    const a = new XE(t);
    a.rotateY(Math.PI * 0.5), this.material = new x0({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const s = a.getAttribute("position"), u = new Float32Array(s.count * 3);
    a.setAttribute("color", new so(u, 3)), this.add(new qu(a, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      bz.copy(this.light.color), Tz.copy(this.light.groundColor);
      for (let r = 0, a = t.count; r < a; r++) {
        const s = r < a / 2 ? bz : Tz;
        t.setXYZ(r, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(PY.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class UY extends wv {
  constructor(e = 10, t = 10, r = 4473924, a = 8947848) {
    r = new Un(r), a = new Un(a);
    const s = t / 2, u = e / t, h = e / 2, v = [], y = [];
    for (let M = 0, C = 0, D = -h; M <= t; M++, D += u) {
      v.push(-h, 0, D, h, 0, D), v.push(D, 0, -h, D, 0, h);
      const U = M === s ? r : a;
      U.toArray(y, C), C += 3, U.toArray(y, C), C += 3, U.toArray(y, C), C += 3, U.toArray(y, C), C += 3;
    }
    const _ = new yi();
    _.setAttribute("position", new nr(v, 3)), _.setAttribute("color", new nr(y, 3));
    const b = new Tf({ vertexColors: !0, toneMapped: !1 });
    super(_, b), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class zY extends wv {
  constructor(e = 10, t = 16, r = 8, a = 64, s = 4473924, u = 8947848) {
    s = new Un(s), u = new Un(u);
    const h = [], v = [];
    if (t > 1)
      for (let b = 0; b < t; b++) {
        const M = b / t * (Math.PI * 2), C = Math.sin(M) * e, D = Math.cos(M) * e;
        h.push(0, 0, 0), h.push(C, 0, D);
        const U = b & 1 ? s : u;
        v.push(U.r, U.g, U.b), v.push(U.r, U.g, U.b);
      }
    for (let b = 0; b < r; b++) {
      const M = b & 1 ? s : u, C = e - e / r * b;
      for (let D = 0; D < a; D++) {
        let U = D / a * (Math.PI * 2), N = Math.sin(U) * C, O = Math.cos(U) * C;
        h.push(N, 0, O), v.push(M.r, M.g, M.b), U = (D + 1) / a * (Math.PI * 2), N = Math.sin(U) * C, O = Math.cos(U) * C, h.push(N, 0, O), v.push(M.r, M.g, M.b);
      }
    }
    const y = new yi();
    y.setAttribute("position", new nr(h, 3)), y.setAttribute("color", new nr(v, 3));
    const _ = new Tf({ vertexColors: !0, toneMapped: !1 });
    super(y, _), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const Mz = /* @__PURE__ */ new be(), WC = /* @__PURE__ */ new be(), wz = /* @__PURE__ */ new be();
class kY extends ha {
  constructor(e, t, r) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let a = new yi();
    a.setAttribute("position", new nr([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const s = new Tf({ fog: !1, toneMapped: !1 });
    this.lightPlane = new p0(a, s), this.add(this.lightPlane), a = new yi(), a.setAttribute("position", new nr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new p0(a, s), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Mz.setFromMatrixPosition(this.light.matrixWorld), WC.setFromMatrixPosition(this.light.target.matrixWorld), wz.subVectors(WC, Mz), this.lightPlane.lookAt(WC), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(WC), this.targetLine.scale.z = wz.length();
  }
}
const jC = /* @__PURE__ */ new be(), Ms = /* @__PURE__ */ new qT();
class IY extends wv {
  constructor(e) {
    const t = new yi(), r = new Tf({ color: 16777215, vertexColors: !0, toneMapped: !1 }), a = [], s = [], u = {};
    h("n1", "n2"), h("n2", "n4"), h("n4", "n3"), h("n3", "n1"), h("f1", "f2"), h("f2", "f4"), h("f4", "f3"), h("f3", "f1"), h("n1", "f1"), h("n2", "f2"), h("n3", "f3"), h("n4", "f4"), h("p", "n1"), h("p", "n2"), h("p", "n3"), h("p", "n4"), h("u1", "u2"), h("u2", "u3"), h("u3", "u1"), h("c", "t"), h("p", "c"), h("cn1", "cn2"), h("cn3", "cn4"), h("cf1", "cf2"), h("cf3", "cf4");
    function h(D, U) {
      v(D), v(U);
    }
    function v(D) {
      a.push(0, 0, 0), s.push(0, 0, 0), u[D] === void 0 && (u[D] = []), u[D].push(a.length / 3 - 1);
    }
    t.setAttribute("position", new nr(a, 3)), t.setAttribute("color", new nr(s, 3)), super(t, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = u, this.update();
    const y = new Un(16755200), _ = new Un(16711680), b = new Un(43775), M = new Un(16777215), C = new Un(3355443);
    this.setColors(y, _, b, M, C);
  }
  setColors(e, t, r, a, s) {
    const h = this.geometry.getAttribute("color");
    h.setXYZ(0, e.r, e.g, e.b), h.setXYZ(1, e.r, e.g, e.b), h.setXYZ(2, e.r, e.g, e.b), h.setXYZ(3, e.r, e.g, e.b), h.setXYZ(4, e.r, e.g, e.b), h.setXYZ(5, e.r, e.g, e.b), h.setXYZ(6, e.r, e.g, e.b), h.setXYZ(7, e.r, e.g, e.b), h.setXYZ(8, e.r, e.g, e.b), h.setXYZ(9, e.r, e.g, e.b), h.setXYZ(10, e.r, e.g, e.b), h.setXYZ(11, e.r, e.g, e.b), h.setXYZ(12, e.r, e.g, e.b), h.setXYZ(13, e.r, e.g, e.b), h.setXYZ(14, e.r, e.g, e.b), h.setXYZ(15, e.r, e.g, e.b), h.setXYZ(16, e.r, e.g, e.b), h.setXYZ(17, e.r, e.g, e.b), h.setXYZ(18, e.r, e.g, e.b), h.setXYZ(19, e.r, e.g, e.b), h.setXYZ(20, e.r, e.g, e.b), h.setXYZ(21, e.r, e.g, e.b), h.setXYZ(22, e.r, e.g, e.b), h.setXYZ(23, e.r, e.g, e.b), h.setXYZ(24, t.r, t.g, t.b), h.setXYZ(25, t.r, t.g, t.b), h.setXYZ(26, t.r, t.g, t.b), h.setXYZ(27, t.r, t.g, t.b), h.setXYZ(28, t.r, t.g, t.b), h.setXYZ(29, t.r, t.g, t.b), h.setXYZ(30, t.r, t.g, t.b), h.setXYZ(31, t.r, t.g, t.b), h.setXYZ(32, r.r, r.g, r.b), h.setXYZ(33, r.r, r.g, r.b), h.setXYZ(34, r.r, r.g, r.b), h.setXYZ(35, r.r, r.g, r.b), h.setXYZ(36, r.r, r.g, r.b), h.setXYZ(37, r.r, r.g, r.b), h.setXYZ(38, a.r, a.g, a.b), h.setXYZ(39, a.r, a.g, a.b), h.setXYZ(40, s.r, s.g, s.b), h.setXYZ(41, s.r, s.g, s.b), h.setXYZ(42, s.r, s.g, s.b), h.setXYZ(43, s.r, s.g, s.b), h.setXYZ(44, s.r, s.g, s.b), h.setXYZ(45, s.r, s.g, s.b), h.setXYZ(46, s.r, s.g, s.b), h.setXYZ(47, s.r, s.g, s.b), h.setXYZ(48, s.r, s.g, s.b), h.setXYZ(49, s.r, s.g, s.b), h.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, r = 1, a = 1;
    Ms.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Js("c", t, e, Ms, 0, 0, -1), Js("t", t, e, Ms, 0, 0, 1), Js("n1", t, e, Ms, -r, -a, -1), Js("n2", t, e, Ms, r, -a, -1), Js("n3", t, e, Ms, -r, a, -1), Js("n4", t, e, Ms, r, a, -1), Js("f1", t, e, Ms, -r, -a, 1), Js("f2", t, e, Ms, r, -a, 1), Js("f3", t, e, Ms, -r, a, 1), Js("f4", t, e, Ms, r, a, 1), Js("u1", t, e, Ms, r * 0.7, a * 1.1, -1), Js("u2", t, e, Ms, -r * 0.7, a * 1.1, -1), Js("u3", t, e, Ms, 0, a * 2, -1), Js("cf1", t, e, Ms, -r, 0, 1), Js("cf2", t, e, Ms, r, 0, 1), Js("cf3", t, e, Ms, 0, -a, 1), Js("cf4", t, e, Ms, 0, a, 1), Js("cn1", t, e, Ms, -r, 0, -1), Js("cn2", t, e, Ms, r, 0, -1), Js("cn3", t, e, Ms, 0, -a, -1), Js("cn4", t, e, Ms, 0, a, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Js(n, e, t, r, a, s, u) {
  jC.set(a, s, u).unproject(r);
  const h = e[n];
  if (h !== void 0) {
    const v = t.getAttribute("position");
    for (let y = 0, _ = h.length; y < _; y++)
      v.setXYZ(h[y], jC.x, jC.y, jC.z);
  }
}
const $C = /* @__PURE__ */ new Mv();
class FY extends wv {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), a = new Float32Array(8 * 3), s = new yi();
    s.setIndex(new so(r, 1)), s.setAttribute("position", new so(a, 3)), super(s, new Tf({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && $C.setFromObject(this.object), $C.isEmpty())
      return;
    const t = $C.min, r = $C.max, a = this.geometry.attributes.position, s = a.array;
    s[0] = r.x, s[1] = r.y, s[2] = r.z, s[3] = t.x, s[4] = r.y, s[5] = r.z, s[6] = t.x, s[7] = t.y, s[8] = r.z, s[9] = r.x, s[10] = t.y, s[11] = r.z, s[12] = r.x, s[13] = r.y, s[14] = t.z, s[15] = t.x, s[16] = r.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = r.x, s[22] = t.y, s[23] = t.z, a.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class BY extends wv {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new yi();
    s.setIndex(new so(r, 1)), s.setAttribute("position", new nr(a, 3)), super(s, new Tf({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class HY extends p0 {
  constructor(e, t = 1, r = 16776960) {
    const a = r, s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], u = new yi();
    u.setAttribute("position", new nr(s, 3)), u.computeBoundingSphere(), super(u, new Tf({ color: a, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const h = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], v = new yi();
    v.setAttribute("position", new nr(h, 3)), v.computeBoundingSphere(), this.add(new qu(v, new x0({ color: a, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const Cz = /* @__PURE__ */ new be();
let YC, k2;
class VY extends ha {
  // dir is assumed to be normalized
  constructor(e = new be(0, 0, 1), t = new be(0, 0, 0), r = 1, a = 16776960, s = r * 0.2, u = s * 0.2) {
    super(), this.type = "ArrowHelper", YC === void 0 && (YC = new yi(), YC.setAttribute("position", new nr([0, 0, 0, 0, 1, 0], 3)), k2 = new vx(0, 0.5, 1, 5, 1), k2.translate(0, -0.5, 0)), this.position.copy(t), this.line = new p0(YC, new Tf({ color: a, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new qu(k2, new x0({ color: a, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, s, u);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      Cz.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(Cz, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(r, t, r), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class GY extends wv {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], r = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], a = new yi();
    a.setAttribute("position", new nr(t, 3)), a.setAttribute("color", new nr(r, 3));
    const s = new Tf({ vertexColors: !0, toneMapped: !1 });
    super(a, s), this.type = "AxesHelper";
  }
  setColors(e, t, r) {
    const a = new Un(), s = this.geometry.attributes.color.array;
    return a.set(e), a.toArray(s, 0), a.toArray(s, 3), a.set(t), a.toArray(s, 6), a.toArray(s, 9), a.set(r), a.toArray(s, 12), a.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class WY {
  constructor() {
    this.type = "ShapePath", this.color = new Un(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new PT(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, a) {
    return this.currentPath.quadraticCurveTo(e, t, r, a), this;
  }
  bezierCurveTo(e, t, r, a, s, u) {
    return this.currentPath.bezierCurveTo(e, t, r, a, s, u), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(O) {
      const I = [];
      for (let k = 0, G = O.length; k < G; k++) {
        const j = O[k], Y = new ix();
        Y.curves = j.curves, I.push(Y);
      }
      return I;
    }
    function r(O, I) {
      const k = I.length;
      let G = !1;
      for (let j = k - 1, Y = 0; Y < k; j = Y++) {
        let Z = I[j], te = I[Y], J = te.x - Z.x, q = te.y - Z.y;
        if (Math.abs(q) > Number.EPSILON) {
          if (q < 0 && (Z = I[Y], J = -J, te = I[j], q = -q), O.y < Z.y || O.y > te.y)
            continue;
          if (O.y === Z.y) {
            if (O.x === Z.x)
              return !0;
          } else {
            const oe = q * (O.x - Z.x) - J * (O.y - Z.y);
            if (oe === 0)
              return !0;
            if (oe < 0)
              continue;
            G = !G;
          }
        } else {
          if (O.y !== Z.y)
            continue;
          if (te.x <= O.x && O.x <= Z.x || Z.x <= O.x && O.x <= te.x)
            return !0;
        }
      }
      return G;
    }
    const a = xv.isClockWise, s = this.subPaths;
    if (s.length === 0)
      return [];
    let u, h, v;
    const y = [];
    if (s.length === 1)
      return h = s[0], v = new ix(), v.curves = h.curves, y.push(v), y;
    let _ = !a(s[0].getPoints());
    _ = e ? !_ : _;
    const b = [], M = [];
    let C = [], D = 0, U;
    M[D] = void 0, C[D] = [];
    for (let O = 0, I = s.length; O < I; O++)
      h = s[O], U = h.getPoints(), u = a(U), u = e ? !u : u, u ? (!_ && M[D] && D++, M[D] = { s: new ix(), p: U }, M[D].s.curves = h.curves, _ && D++, C[D] = []) : C[D].push({ h, p: U[0] });
    if (!M[0])
      return t(s);
    if (M.length > 1) {
      let O = !1, I = 0;
      for (let k = 0, G = M.length; k < G; k++)
        b[k] = [];
      for (let k = 0, G = M.length; k < G; k++) {
        const j = C[k];
        for (let Y = 0; Y < j.length; Y++) {
          const Z = j[Y];
          let te = !0;
          for (let J = 0; J < M.length; J++)
            r(Z.p, M[J].p) && (k !== J && I++, te ? (te = !1, b[J].push(Z)) : O = !0);
          te && b[k].push(Z);
        }
      }
      I > 0 && O === !1 && (C = b);
    }
    let N;
    for (let O = 0, I = M.length; O < I; O++) {
      v = M[O].s, y.push(v), N = C[O];
      for (let k = 0, G = N.length; k < G; k++)
        v.holes.push(N[k].h);
    }
    return y;
  }
}
class jY extends _0 {
  // @deprecated, r144
  constructor(e, t, r, a, s, u) {
    console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e, t, r, a, s, u);
  }
}
class $Y extends QT {
  // @deprecated, r144
  constructor(e, t, r, a) {
    console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e, t, r, a);
  }
}
class YY extends ZT {
  // @deprecated, r144
  constructor(e, t, r, a) {
    console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e, t, r, a);
  }
}
class XY extends JT {
  // @deprecated, r144
  constructor(e, t, r, a, s, u, h) {
    console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e, t, r, a, s, u, h);
  }
}
class qY extends vx {
  // @deprecated, r144
  constructor(e, t, r, a, s, u, h, v) {
    console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e, t, r, a, s, u, h, v);
  }
}
class KY extends eM {
  // @deprecated, r144
  constructor(e, t) {
    console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e, t);
  }
}
class QY extends tM {
  // @deprecated, r144
  constructor(e, t) {
    console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e, t);
  }
}
class ZY extends nM {
  // @deprecated, r144
  constructor(e, t) {
    console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e, t);
  }
}
class JY extends YE {
  // @deprecated, r144
  constructor(e, t, r, a) {
    console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e, t, r, a);
  }
}
class eX extends XE {
  // @deprecated, r144
  constructor(e, t) {
    console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e, t);
  }
}
class tX extends jE {
  // @deprecated, r144
  constructor(e, t, r, a) {
    console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e, t, r, a);
  }
}
class nX extends Wg {
  // @deprecated, r144
  constructor(e, t, r, a) {
    console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e, t, r, a);
  }
}
class rX extends rM {
  // @deprecated, r144
  constructor(e, t, r, a, s, u) {
    console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e, t, r, a, s, u);
  }
}
class iX extends iM {
  // @deprecated, r144
  constructor(e, t) {
    console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e, t);
  }
}
class aX extends qE {
  // @deprecated, r144
  constructor(e, t, r, a, s, u, h) {
    console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e, t, r, a, s, u, h);
  }
}
class oX extends aM {
  // @deprecated, r144
  constructor(e, t) {
    console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e, t);
  }
}
class sX extends oM {
  // @deprecated, r144
  constructor(e, t, r, a, s) {
    console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e, t, r, a, s);
  }
}
class lX extends sM {
  // @deprecated, r144
  constructor(e, t, r, a, s, u) {
    console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e, t, r, a, s, u);
  }
}
class uX extends lM {
  // @deprecated, r144
  constructor(e, t, r, a, s) {
    console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e, t, r, a, s);
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: kR
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = kR);
const cX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: IO,
  AddEquation: XS,
  AddOperation: JI,
  AdditiveAnimationBlendMode: $O,
  AdditiveBlending: yL,
  AlphaFormat: oF,
  AlwaysCompare: CF,
  AlwaysDepth: $I,
  AlwaysStencilFunc: SF,
  AmbientLight: wB,
  AmbientLightProbe: iY,
  AnimationAction: PB,
  AnimationClip: FT,
  AnimationLoader: j$,
  AnimationMixer: EY,
  AnimationObjectGroup: xY,
  AnimationUtils: H$,
  ArcCurve: ZF,
  ArrayCamera: HF,
  ArrowHelper: VY,
  Audio: LB,
  AudioAnalyser: cY,
  AudioContext: _P,
  AudioListener: sY,
  AudioLoader: nY,
  AxesHelper: GY,
  BackSide: bf,
  BasicDepthPacking: vF,
  BasicShadowMap: OI,
  Bone: aP,
  BooleanKeyframeTrack: gx,
  Box2: RY,
  Box3: Mv,
  Box3Helper: BY,
  BoxBufferGeometry: jY,
  BoxGeometry: _0,
  BoxHelper: FY,
  BufferAttribute: so,
  BufferGeometry: yi,
  BufferGeometryLoader: DB,
  ByteType: iF,
  Cache: cx,
  Camera: qT,
  CameraHelper: IY,
  CanvasTexture: QF,
  CapsuleBufferGeometry: $Y,
  CapsuleGeometry: QT,
  CatmullRomCurve3: JF,
  CineonToneMapping: nF,
  CircleBufferGeometry: YY,
  CircleGeometry: ZT,
  ClampToEdgeWrapping: Dc,
  Clock: EP,
  Color: Un,
  ColorKeyframeTrack: yP,
  ColorManagement: tp,
  CompressedArrayTexture: f$,
  CompressedTexture: sP,
  CompressedTextureLoader: $$,
  ConeBufferGeometry: XY,
  ConeGeometry: JT,
  CubeCamera: PF,
  CubeReflectionMapping: f0,
  CubeRefractionMapping: d0,
  CubeTexture: KT,
  CubeTextureLoader: Y$,
  CubeUVReflectionMapping: WE,
  CubicBezierCurve: uP,
  CubicBezierCurve3: eB,
  CubicInterpolant: yB,
  CullFaceBack: gL,
  CullFaceFront: LI,
  CullFaceFrontBack: l6,
  CullFaceNone: DI,
  Curve: lm,
  CurvePath: nB,
  CustomBlending: PI,
  CustomToneMapping: rF,
  CylinderBufferGeometry: qY,
  CylinderGeometry: vx,
  Cylindrical: CY,
  Data3DTexture: QO,
  DataArrayTexture: VR,
  DataTexture: OE,
  DataTextureLoader: X$,
  DataUtils: _8,
  DecrementStencilOp: x6,
  DecrementWrapStencilOp: E6,
  DefaultLoadingManager: _B,
  DepthFormat: l0,
  DepthStencilFormat: sx,
  DepthTexture: VF,
  DirectionalLight: MB,
  DirectionalLightHelper: kY,
  DiscreteInterpolant: SB,
  DisplayP3ColorSpace: XO,
  DodecahedronBufferGeometry: KY,
  DodecahedronGeometry: eM,
  DoubleSide: mv,
  DstAlphaFactor: BI,
  DstColorFactor: VI,
  DynamicCopyUsage: k6,
  DynamicDrawUsage: L6,
  DynamicReadUsage: N6,
  EdgesGeometry: rB,
  EllipseCurve: qR,
  EqualCompare: EF,
  EqualDepth: XI,
  EqualStencilFunc: w6,
  EquirectangularReflectionMapping: bT,
  EquirectangularRefractionMapping: TT,
  Euler: XT,
  EventDispatcher: Tv,
  ExtrudeBufferGeometry: QY,
  ExtrudeGeometry: tM,
  FileLoader: Bg,
  Float16BufferAttribute: C8,
  Float32BufferAttribute: nr,
  Float64BufferAttribute: R8,
  FloatType: vv,
  Fog: $R,
  FogExp2: jR,
  FramebufferTexture: c$,
  FrontSide: Fg,
  Frustum: GR,
  GLBufferAttribute: wY,
  GLSL1: F6,
  GLSL3: $L,
  GreaterCompare: TF,
  GreaterDepth: KI,
  GreaterEqualCompare: wF,
  GreaterEqualDepth: qI,
  GreaterEqualStencilFunc: D6,
  GreaterStencilFunc: R6,
  GridHelper: UY,
  Group: CE,
  HalfFloatType: UE,
  HemisphereLight: EB,
  HemisphereLightHelper: NY,
  HemisphereLightProbe: rY,
  IcosahedronBufferGeometry: ZY,
  IcosahedronGeometry: nM,
  ImageBitmapLoader: tY,
  ImageLoader: BT,
  ImageUtils: KO,
  IncrementStencilOp: S6,
  IncrementWrapStencilOp: _6,
  InstancedBufferAttribute: IE,
  InstancedBufferGeometry: AB,
  InstancedInterleavedBuffer: MY,
  InstancedMesh: XF,
  Int16BufferAttribute: M8,
  Int32BufferAttribute: w8,
  Int8BufferAttribute: E8,
  IntType: BO,
  InterleavedBuffer: YR,
  InterleavedBufferAttribute: lx,
  Interpolant: uM,
  InterpolateDiscrete: CT,
  InterpolateLinear: RT,
  InterpolateSmooth: cR,
  InvertStencilOp: b6,
  KeepStencilOp: fR,
  KeyframeTrack: um,
  LOD: $F,
  LatheBufferGeometry: JY,
  LatheGeometry: YE,
  Layers: rx,
  LessCompare: _F,
  LessDepth: YI,
  LessEqualCompare: bF,
  LessEqualDepth: mR,
  LessEqualStencilFunc: C6,
  LessStencilFunc: M6,
  Light: E0,
  LightProbe: ZR,
  Line: p0,
  Line3: AY,
  LineBasicMaterial: Tf,
  LineCurve: KR,
  LineCurve3: tB,
  LineDashedMaterial: vB,
  LineLoop: qF,
  LineSegments: wv,
  LinearEncoding: YO,
  LinearFilter: tl,
  LinearInterpolant: gP,
  LinearMipMapLinearFilter: h6,
  LinearMipMapNearestFilter: d6,
  LinearMipmapLinearFilter: h0,
  LinearMipmapNearestFilter: FO,
  LinearSRGBColorSpace: nm,
  LinearToneMapping: eF,
  Loader: uh,
  LoaderUtils: eO,
  LoadingManager: SP,
  LoopOnce: hF,
  LoopPingPong: mF,
  LoopRepeat: pF,
  LuminanceAlphaFormat: lF,
  LuminanceFormat: sF,
  MOUSE: jS,
  Material: Ku,
  MaterialLoader: JR,
  MathUtils: J6,
  Matrix3: vi,
  Matrix4: ei,
  MaxEquation: EL,
  Mesh: qu,
  MeshBasicMaterial: x0,
  MeshDepthMaterial: tP,
  MeshDistanceMaterial: nP,
  MeshLambertMaterial: pB,
  MeshMatcapMaterial: mB,
  MeshNormalMaterial: hB,
  MeshPhongMaterial: fB,
  MeshPhysicalMaterial: cB,
  MeshStandardMaterial: pP,
  MeshToonMaterial: dB,
  MinEquation: _L,
  MirroredRepeatWrapping: wT,
  MixOperation: ZI,
  MultiplyBlending: xL,
  MultiplyOperation: YT,
  NearestFilter: el,
  NearestMipMapLinearFilter: f6,
  NearestMipMapNearestFilter: c6,
  NearestMipmapLinearFilter: mT,
  NearestMipmapNearestFilter: vR,
  NeverCompare: xF,
  NeverDepth: jI,
  NeverStencilFunc: T6,
  NoBlending: kg,
  NoColorSpace: c0,
  NoToneMapping: em,
  NormalAnimationBlendMode: HR,
  NormalBlending: tx,
  NotEqualCompare: MF,
  NotEqualDepth: QI,
  NotEqualStencilFunc: A6,
  NumberKeyframeTrack: kT,
  Object3D: ha,
  ObjectLoader: J$,
  ObjectSpaceNormalMap: yF,
  OctahedronBufferGeometry: eX,
  OctahedronGeometry: XE,
  OneFactor: kI,
  OneMinusDstAlphaFactor: HI,
  OneMinusDstColorFactor: GI,
  OneMinusSrcAlphaFactor: kO,
  OneMinusSrcColorFactor: FI,
  OrthographicCamera: zg,
  PCFShadowMap: IR,
  PCFSoftShadowMap: pT,
  PMREMGenerator: XL,
  Path: PT,
  PerspectiveCamera: Cs,
  Plane: pv,
  PlaneBufferGeometry: tX,
  PlaneGeometry: jE,
  PlaneHelper: HY,
  PointLight: TB,
  PointLightHelper: OY,
  Points: KF,
  PointsMaterial: oP,
  PolarGridHelper: zY,
  PolyhedronBufferGeometry: nX,
  PolyhedronGeometry: Wg,
  PositionalAudio: uY,
  PropertyBinding: sa,
  PropertyMixer: OB,
  QuadraticBezierCurve: cP,
  QuadraticBezierCurve3: fP,
  Quaternion: Oc,
  QuaternionKeyframeTrack: KE,
  QuaternionLinearInterpolant: xB,
  RED_GREEN_RGTC2_Format: WL,
  RED_RGTC1_Format: dF,
  REVISION: kR,
  RGBADepthPacking: gF,
  RGBAFormat: dd,
  RGBAIntegerFormat: jO,
  RGBA_ASTC_10x10_Format: BL,
  RGBA_ASTC_10x5_Format: kL,
  RGBA_ASTC_10x6_Format: IL,
  RGBA_ASTC_10x8_Format: FL,
  RGBA_ASTC_12x10_Format: HL,
  RGBA_ASTC_12x12_Format: VL,
  RGBA_ASTC_4x4_Format: AL,
  RGBA_ASTC_5x4_Format: DL,
  RGBA_ASTC_5x5_Format: LL,
  RGBA_ASTC_6x5_Format: OL,
  RGBA_ASTC_6x6_Format: PL,
  RGBA_ASTC_8x5_Format: NL,
  RGBA_ASTC_8x6_Format: UL,
  RGBA_ASTC_8x8_Format: zL,
  RGBA_BPTC_Format: uR,
  RGBA_ETC2_EAC_Format: RL,
  RGBA_PVRTC_2BPPV1_Format: wL,
  RGBA_PVRTC_4BPPV1_Format: ML,
  RGBA_S3TC_DXT1_Format: oR,
  RGBA_S3TC_DXT3_Format: sR,
  RGBA_S3TC_DXT5_Format: lR,
  RGB_ETC1_Format: fF,
  RGB_ETC2_Format: CL,
  RGB_PVRTC_2BPPV1_Format: TL,
  RGB_PVRTC_4BPPV1_Format: bL,
  RGB_S3TC_DXT1_Format: aR,
  RGFormat: cF,
  RGIntegerFormat: WO,
  RawShaderMaterial: uB,
  Ray: mx,
  Raycaster: wP,
  RectAreaLight: CB,
  RedFormat: uF,
  RedIntegerFormat: GO,
  ReinhardToneMapping: tF,
  RepeatWrapping: MT,
  ReplaceStencilOp: y6,
  ReverseSubtractEquation: UI,
  RingBufferGeometry: rX,
  RingGeometry: rM,
  SIGNED_RED_GREEN_RGTC2_Format: jL,
  SIGNED_RED_RGTC1_Format: GL,
  SRGBColorSpace: ai,
  Scene: SR,
  ShaderChunk: mi,
  ShaderLib: Jp,
  ShaderMaterial: _v,
  ShadowMaterial: lB,
  Shape: ix,
  ShapeBufferGeometry: iX,
  ShapeGeometry: iM,
  ShapePath: WY,
  ShapeUtils: xv,
  ShortType: aF,
  Skeleton: XR,
  SkeletonHelper: LY,
  SkinnedMesh: YF,
  Source: ZS,
  Sphere: sm,
  SphereBufferGeometry: aX,
  SphereGeometry: qE,
  Spherical: nO,
  SphericalHarmonics3: RB,
  SplineCurve: dP,
  SpotLight: bB,
  SpotLightHelper: DY,
  Sprite: jF,
  SpriteMaterial: iP,
  SrcAlphaFactor: zO,
  SrcAlphaSaturateFactor: WI,
  SrcColorFactor: II,
  StaticCopyUsage: z6,
  StaticDrawUsage: DT,
  StaticReadUsage: P6,
  StereoCamera: aY,
  StreamCopyUsage: I6,
  StreamDrawUsage: O6,
  StreamReadUsage: U6,
  StringKeyframeTrack: yx,
  SubtractEquation: NI,
  SubtractiveBlending: SL,
  TOUCH: $S,
  TangentSpaceNormalMap: S0,
  TetrahedronBufferGeometry: oX,
  TetrahedronGeometry: aM,
  Texture: Rs,
  TextureLoader: q$,
  TorusBufferGeometry: sX,
  TorusGeometry: oM,
  TorusKnotBufferGeometry: lX,
  TorusKnotGeometry: sM,
  Triangle: fd,
  TriangleFanDrawMode: v6,
  TriangleStripDrawMode: m6,
  TrianglesDrawMode: p6,
  TubeBufferGeometry: uX,
  TubeGeometry: lM,
  TwoPassDoubleSide: u6,
  UVMapping: FR,
  Uint16BufferAttribute: ZO,
  Uint32BufferAttribute: JO,
  Uint8BufferAttribute: b8,
  Uint8ClampedBufferAttribute: T8,
  Uniform: MP,
  UniformsGroup: TY,
  UniformsLib: bn,
  UniformsUtils: OF,
  UnsignedByteType: Sv,
  UnsignedInt248Type: s0,
  UnsignedIntType: Ug,
  UnsignedShort4444Type: HO,
  UnsignedShort5551Type: VO,
  UnsignedShortType: BR,
  VSMShadowMap: Zp,
  Vector2: It,
  Vector3: be,
  Vector4: Ua,
  VectorKeyframeTrack: IT,
  VideoTexture: u$,
  WebGL1Renderer: GF,
  WebGL3DRenderTarget: c8,
  WebGLArrayRenderTarget: u8,
  WebGLCoordinateSystem: gv,
  WebGLCubeRenderTarget: NF,
  WebGLMultipleRenderTargets: f8,
  WebGLRenderTarget: rm,
  WebGLRenderer: rP,
  WebGLUtils: BF,
  WebGPUCoordinateSystem: LT,
  WireframeGeometry: sB,
  WrapAroundEnding: AT,
  ZeroCurvatureEnding: KS,
  ZeroFactor: zI,
  ZeroSlopeEnding: QS,
  ZeroStencilOp: g6,
  _SRGBAFormat: gR,
  sRGBEncoding: u0
}, Symbol.toStringTag, { value: "Module" }));
var rO = { exports: {} }, i0 = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rz;
function fX() {
  return Rz || (Rz = 1, i0.ConcurrentRoot = 1, i0.ContinuousEventPriority = 4, i0.DefaultEventPriority = 16, i0.DiscreteEventPriority = 1, i0.IdleEventPriority = 536870912, i0.LegacyRoot = 0), i0;
}
var a0 = {};
/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Az;
function dX() {
  return Az || (Az = 1, process.env.NODE_ENV !== "production" && function() {
    var n = (
      /*                        */
      1
    ), e = (
      /*            */
      4
    ), t = (
      /*                    */
      16
    ), r = (
      /*                       */
      536870912
    ), a = n, s = e, u = t, h = r, v = 0, y = 1;
    a0.ConcurrentRoot = y, a0.ContinuousEventPriority = s, a0.DefaultEventPriority = u, a0.DiscreteEventPriority = a, a0.IdleEventPriority = h, a0.LegacyRoot = v;
  }()), a0;
}
process.env.NODE_ENV === "production" ? rO.exports = fX() : rO.exports = dX();
var AE = rO.exports;
function hX(n) {
  let e;
  const t = /* @__PURE__ */ new Set(), r = (y, _) => {
    const b = typeof y == "function" ? y(e) : y;
    if (b !== e) {
      const M = e;
      e = _ ? b : Object.assign({}, e, b), t.forEach((C) => C(e, M));
    }
  }, a = () => e, s = (y, _ = a, b = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let M = _(e);
    function C() {
      const D = _(e);
      if (!b(M, D)) {
        const U = M;
        y(M = D, U);
      }
    }
    return t.add(C), () => t.delete(C);
  }, v = { setState: r, getState: a, subscribe: (y, _, b) => _ || b ? s(y, _, b) : (t.add(y), () => t.delete(y)), destroy: () => t.clear() };
  return e = n(r, a, v), v;
}
const pX = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), Dz = pX ? le.useEffect : le.useLayoutEffect;
function UB(n) {
  const e = typeof n == "function" ? hX(n) : n, t = (r = e.getState, a = Object.is) => {
    const [, s] = le.useReducer((N) => N + 1, 0), u = e.getState(), h = le.useRef(u), v = le.useRef(r), y = le.useRef(a), _ = le.useRef(!1), b = le.useRef();
    b.current === void 0 && (b.current = r(u));
    let M, C = !1;
    (h.current !== u || v.current !== r || y.current !== a || _.current) && (M = r(u), C = !a(b.current, M)), Dz(() => {
      C && (b.current = M), h.current = u, v.current = r, y.current = a, _.current = !1;
    });
    const D = le.useRef(u);
    Dz(() => {
      const N = () => {
        try {
          const I = e.getState(), k = v.current(I);
          y.current(b.current, k) || (h.current = I, b.current = k, s());
        } catch {
          _.current = !0, s();
        }
      }, O = e.subscribe(N);
      return e.getState() !== D.current && N(), O;
    }, []);
    const U = C ? M : b.current;
    return le.useDebugValue(U), U;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const r = [t, e];
    return {
      next() {
        const a = r.length <= 0;
        return { value: r.shift(), done: a };
      }
    };
  }, t;
}
var iO = { exports: {} }, aO = { exports: {} }, I2 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lz;
function mX() {
  return Lz || (Lz = 1, function(n) {
    function e(ue, we) {
      var X = ue.length;
      ue.push(we);
      e:
        for (; 0 < X; ) {
          var me = X - 1 >>> 1, ce = ue[me];
          if (0 < a(ce, we))
            ue[me] = we, ue[X] = ce, X = me;
          else
            break e;
        }
    }
    function t(ue) {
      return ue.length === 0 ? null : ue[0];
    }
    function r(ue) {
      if (ue.length === 0)
        return null;
      var we = ue[0], X = ue.pop();
      if (X !== we) {
        ue[0] = X;
        e:
          for (var me = 0, ce = ue.length, Ue = ce >>> 1; me < Ue; ) {
            var Oe = 2 * (me + 1) - 1, Ze = ue[Oe], je = Oe + 1, Je = ue[je];
            if (0 > a(Ze, X))
              je < ce && 0 > a(Je, Ze) ? (ue[me] = Je, ue[je] = X, me = je) : (ue[me] = Ze, ue[Oe] = X, me = Oe);
            else if (je < ce && 0 > a(Je, X))
              ue[me] = Je, ue[je] = X, me = je;
            else
              break e;
          }
      }
      return we;
    }
    function a(ue, we) {
      var X = ue.sortIndex - we.sortIndex;
      return X !== 0 ? X : ue.id - we.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      n.unstable_now = function() {
        return s.now();
      };
    } else {
      var u = Date, h = u.now();
      n.unstable_now = function() {
        return u.now() - h;
      };
    }
    var v = [], y = [], _ = 1, b = null, M = 3, C = !1, D = !1, U = !1, N = typeof setTimeout == "function" ? setTimeout : null, O = typeof clearTimeout == "function" ? clearTimeout : null, I = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function k(ue) {
      for (var we = t(y); we !== null; ) {
        if (we.callback === null)
          r(y);
        else if (we.startTime <= ue)
          r(y), we.sortIndex = we.expirationTime, e(v, we);
        else
          break;
        we = t(y);
      }
    }
    function G(ue) {
      if (U = !1, k(ue), !D)
        if (t(v) !== null)
          D = !0, Pe(j);
        else {
          var we = t(y);
          we !== null && Te(G, we.startTime - ue);
        }
    }
    function j(ue, we) {
      D = !1, U && (U = !1, O(te), te = -1), C = !0;
      var X = M;
      try {
        for (k(we), b = t(v); b !== null && (!(b.expirationTime > we) || ue && !oe()); ) {
          var me = b.callback;
          if (typeof me == "function") {
            b.callback = null, M = b.priorityLevel;
            var ce = me(b.expirationTime <= we);
            we = n.unstable_now(), typeof ce == "function" ? b.callback = ce : b === t(v) && r(v), k(we);
          } else
            r(v);
          b = t(v);
        }
        if (b !== null)
          var Ue = !0;
        else {
          var Oe = t(y);
          Oe !== null && Te(G, Oe.startTime - we), Ue = !1;
        }
        return Ue;
      } finally {
        b = null, M = X, C = !1;
      }
    }
    var Y = !1, Z = null, te = -1, J = 5, q = -1;
    function oe() {
      return !(n.unstable_now() - q < J);
    }
    function ye() {
      if (Z !== null) {
        var ue = n.unstable_now();
        q = ue;
        var we = !0;
        try {
          we = Z(!0, ue);
        } finally {
          we ? de() : (Y = !1, Z = null);
        }
      } else
        Y = !1;
    }
    var de;
    if (typeof I == "function")
      de = function() {
        I(ye);
      };
    else if (typeof MessageChannel < "u") {
      var xe = new MessageChannel(), Re = xe.port2;
      xe.port1.onmessage = ye, de = function() {
        Re.postMessage(null);
      };
    } else
      de = function() {
        N(ye, 0);
      };
    function Pe(ue) {
      Z = ue, Y || (Y = !0, de());
    }
    function Te(ue, we) {
      te = N(function() {
        ue(n.unstable_now());
      }, we);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(ue) {
      ue.callback = null;
    }, n.unstable_continueExecution = function() {
      D || C || (D = !0, Pe(j));
    }, n.unstable_forceFrameRate = function(ue) {
      0 > ue || 125 < ue ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : J = 0 < ue ? Math.floor(1e3 / ue) : 5;
    }, n.unstable_getCurrentPriorityLevel = function() {
      return M;
    }, n.unstable_getFirstCallbackNode = function() {
      return t(v);
    }, n.unstable_next = function(ue) {
      switch (M) {
        case 1:
        case 2:
        case 3:
          var we = 3;
          break;
        default:
          we = M;
      }
      var X = M;
      M = we;
      try {
        return ue();
      } finally {
        M = X;
      }
    }, n.unstable_pauseExecution = function() {
    }, n.unstable_requestPaint = function() {
    }, n.unstable_runWithPriority = function(ue, we) {
      switch (ue) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ue = 3;
      }
      var X = M;
      M = ue;
      try {
        return we();
      } finally {
        M = X;
      }
    }, n.unstable_scheduleCallback = function(ue, we, X) {
      var me = n.unstable_now();
      switch (typeof X == "object" && X !== null ? (X = X.delay, X = typeof X == "number" && 0 < X ? me + X : me) : X = me, ue) {
        case 1:
          var ce = -1;
          break;
        case 2:
          ce = 250;
          break;
        case 5:
          ce = 1073741823;
          break;
        case 4:
          ce = 1e4;
          break;
        default:
          ce = 5e3;
      }
      return ce = X + ce, ue = { id: _++, callback: we, priorityLevel: ue, startTime: X, expirationTime: ce, sortIndex: -1 }, X > me ? (ue.sortIndex = X, e(y, ue), t(v) === null && ue === t(y) && (U ? (O(te), te = -1) : U = !0, Te(G, X - me))) : (ue.sortIndex = ce, e(v, ue), D || C || (D = !0, Pe(j))), ue;
    }, n.unstable_shouldYield = oe, n.unstable_wrapCallback = function(ue) {
      var we = M;
      return function() {
        var X = M;
        M = we;
        try {
          return ue.apply(this, arguments);
        } finally {
          M = X;
        }
      };
    };
  }(I2)), I2;
}
var F2 = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Oz;
function vX() {
  return Oz || (Oz = 1, function(n) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, r = 5;
      function a(Ee, Xe) {
        var St = Ee.length;
        Ee.push(Xe), h(Ee, Xe, St);
      }
      function s(Ee) {
        return Ee.length === 0 ? null : Ee[0];
      }
      function u(Ee) {
        if (Ee.length === 0)
          return null;
        var Xe = Ee[0], St = Ee.pop();
        return St !== Xe && (Ee[0] = St, v(Ee, St, 0)), Xe;
      }
      function h(Ee, Xe, St) {
        for (var Ut = St; Ut > 0; ) {
          var Se = Ut - 1 >>> 1, Ye = Ee[Se];
          if (y(Ye, Xe) > 0)
            Ee[Se] = Xe, Ee[Ut] = Ye, Ut = Se;
          else
            return;
        }
      }
      function v(Ee, Xe, St) {
        for (var Ut = St, Se = Ee.length, Ye = Se >>> 1; Ut < Ye; ) {
          var bt = (Ut + 1) * 2 - 1, Tt = Ee[bt], ge = bt + 1, zt = Ee[ge];
          if (y(Tt, Xe) < 0)
            ge < Se && y(zt, Tt) < 0 ? (Ee[Ut] = zt, Ee[ge] = Xe, Ut = ge) : (Ee[Ut] = Tt, Ee[bt] = Xe, Ut = bt);
          else if (ge < Se && y(zt, Xe) < 0)
            Ee[Ut] = zt, Ee[ge] = Xe, Ut = ge;
          else
            return;
        }
      }
      function y(Ee, Xe) {
        var St = Ee.sortIndex - Xe.sortIndex;
        return St !== 0 ? St : Ee.id - Xe.id;
      }
      var _ = 1, b = 2, M = 3, C = 4, D = 5;
      function U(Ee, Xe) {
      }
      var N = typeof performance == "object" && typeof performance.now == "function";
      if (N) {
        var O = performance;
        n.unstable_now = function() {
          return O.now();
        };
      } else {
        var I = Date, k = I.now();
        n.unstable_now = function() {
          return I.now() - k;
        };
      }
      var G = 1073741823, j = -1, Y = 250, Z = 5e3, te = 1e4, J = G, q = [], oe = [], ye = 1, de = null, xe = M, Re = !1, Pe = !1, Te = !1, ue = typeof setTimeout == "function" ? setTimeout : null, we = typeof clearTimeout == "function" ? clearTimeout : null, X = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function me(Ee) {
        for (var Xe = s(oe); Xe !== null; ) {
          if (Xe.callback === null)
            u(oe);
          else if (Xe.startTime <= Ee)
            u(oe), Xe.sortIndex = Xe.expirationTime, a(q, Xe);
          else
            return;
          Xe = s(oe);
        }
      }
      function ce(Ee) {
        if (Te = !1, me(Ee), !Pe)
          if (s(q) !== null)
            Pe = !0, wt(Ue);
          else {
            var Xe = s(oe);
            Xe !== null && _t(ce, Xe.startTime - Ee);
          }
      }
      function Ue(Ee, Xe) {
        Pe = !1, Te && (Te = !1, Vt()), Re = !0;
        var St = xe;
        try {
          var Ut;
          if (!t)
            return Oe(Ee, Xe);
        } finally {
          de = null, xe = St, Re = !1;
        }
      }
      function Oe(Ee, Xe) {
        var St = Xe;
        for (me(St), de = s(q); de !== null && !e && !(de.expirationTime > St && (!Ee || qt())); ) {
          var Ut = de.callback;
          if (typeof Ut == "function") {
            de.callback = null, xe = de.priorityLevel;
            var Se = de.expirationTime <= St, Ye = Ut(Se);
            St = n.unstable_now(), typeof Ye == "function" ? de.callback = Ye : de === s(q) && u(q), me(St);
          } else
            u(q);
          de = s(q);
        }
        if (de !== null)
          return !0;
        var bt = s(oe);
        return bt !== null && _t(ce, bt.startTime - St), !1;
      }
      function Ze(Ee, Xe) {
        switch (Ee) {
          case _:
          case b:
          case M:
          case C:
          case D:
            break;
          default:
            Ee = M;
        }
        var St = xe;
        xe = Ee;
        try {
          return Xe();
        } finally {
          xe = St;
        }
      }
      function je(Ee) {
        var Xe;
        switch (xe) {
          case _:
          case b:
          case M:
            Xe = M;
            break;
          default:
            Xe = xe;
            break;
        }
        var St = xe;
        xe = Xe;
        try {
          return Ee();
        } finally {
          xe = St;
        }
      }
      function Je(Ee) {
        var Xe = xe;
        return function() {
          var St = xe;
          xe = Xe;
          try {
            return Ee.apply(this, arguments);
          } finally {
            xe = St;
          }
        };
      }
      function at(Ee, Xe, St) {
        var Ut = n.unstable_now(), Se;
        if (typeof St == "object" && St !== null) {
          var Ye = St.delay;
          typeof Ye == "number" && Ye > 0 ? Se = Ut + Ye : Se = Ut;
        } else
          Se = Ut;
        var bt;
        switch (Ee) {
          case _:
            bt = j;
            break;
          case b:
            bt = Y;
            break;
          case D:
            bt = J;
            break;
          case C:
            bt = te;
            break;
          case M:
          default:
            bt = Z;
            break;
        }
        var Tt = Se + bt, ge = {
          id: ye++,
          callback: Xe,
          priorityLevel: Ee,
          startTime: Se,
          expirationTime: Tt,
          sortIndex: -1
        };
        return Se > Ut ? (ge.sortIndex = Se, a(oe, ge), s(q) === null && ge === s(oe) && (Te ? Vt() : Te = !0, _t(ce, Se - Ut))) : (ge.sortIndex = Tt, a(q, ge), !Pe && !Re && (Pe = !0, wt(Ue))), ge;
      }
      function xt() {
      }
      function $t() {
        !Pe && !Re && (Pe = !0, wt(Ue));
      }
      function Ht() {
        return s(q);
      }
      function he(Ee) {
        Ee.callback = null;
      }
      function nt() {
        return xe;
      }
      var et = !1, Rt = null, gt = -1, Jt = r, Kt = -1;
      function qt() {
        var Ee = n.unstable_now() - Kt;
        return !(Ee < Jt);
      }
      function hn() {
      }
      function Rn(Ee) {
        if (Ee < 0 || Ee > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Ee > 0 ? Jt = Math.floor(1e3 / Ee) : Jt = r;
      }
      var Yn = function() {
        if (Rt !== null) {
          var Ee = n.unstable_now();
          Kt = Ee;
          var Xe = !0, St = !0;
          try {
            St = Rt(Xe, Ee);
          } finally {
            St ? se() : (et = !1, Rt = null);
          }
        } else
          et = !1;
      }, se;
      if (typeof X == "function")
        se = function() {
          X(Yn);
        };
      else if (typeof MessageChannel < "u") {
        var ae = new MessageChannel(), Ke = ae.port2;
        ae.port1.onmessage = Yn, se = function() {
          Ke.postMessage(null);
        };
      } else
        se = function() {
          ue(Yn, 0);
        };
      function wt(Ee) {
        Rt = Ee, et || (et = !0, se());
      }
      function _t(Ee, Xe) {
        gt = ue(function() {
          Ee(n.unstable_now());
        }, Xe);
      }
      function Vt() {
        we(gt), gt = -1;
      }
      var fn = hn, Wt = null;
      n.unstable_IdlePriority = D, n.unstable_ImmediatePriority = _, n.unstable_LowPriority = C, n.unstable_NormalPriority = M, n.unstable_Profiling = Wt, n.unstable_UserBlockingPriority = b, n.unstable_cancelCallback = he, n.unstable_continueExecution = $t, n.unstable_forceFrameRate = Rn, n.unstable_getCurrentPriorityLevel = nt, n.unstable_getFirstCallbackNode = Ht, n.unstable_next = je, n.unstable_pauseExecution = xt, n.unstable_requestPaint = fn, n.unstable_runWithPriority = Ze, n.unstable_scheduleCallback = at, n.unstable_shouldYield = qt, n.unstable_wrapCallback = Je, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(F2)), F2;
}
process.env.NODE_ENV === "production" ? aO.exports = mX() : aO.exports = vX();
var xR = aO.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var B2, Pz;
function gX() {
  return Pz || (Pz = 1, B2 = function(e) {
    var t = {}, r = px(), a = xR, s = Object.assign;
    function u(m) {
      for (var g = "https://reactjs.org/docs/error-decoder.html?invariant=" + m, R = 1; R < arguments.length; R++)
        g += "&args[]=" + encodeURIComponent(arguments[R]);
      return "Minified React error #" + m + "; visit " + g + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var h = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, v = Symbol.for("react.element"), y = Symbol.for("react.portal"), _ = Symbol.for("react.fragment"), b = Symbol.for("react.strict_mode"), M = Symbol.for("react.profiler"), C = Symbol.for("react.provider"), D = Symbol.for("react.context"), U = Symbol.for("react.forward_ref"), N = Symbol.for("react.suspense"), O = Symbol.for("react.suspense_list"), I = Symbol.for("react.memo"), k = Symbol.for("react.lazy"), G = Symbol.for("react.offscreen"), j = Symbol.iterator;
    function Y(m) {
      return m === null || typeof m != "object" ? null : (m = j && m[j] || m["@@iterator"], typeof m == "function" ? m : null);
    }
    function Z(m) {
      if (m == null)
        return null;
      if (typeof m == "function")
        return m.displayName || m.name || null;
      if (typeof m == "string")
        return m;
      switch (m) {
        case _:
          return "Fragment";
        case y:
          return "Portal";
        case M:
          return "Profiler";
        case b:
          return "StrictMode";
        case N:
          return "Suspense";
        case O:
          return "SuspenseList";
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case D:
            return (m.displayName || "Context") + ".Consumer";
          case C:
            return (m._context.displayName || "Context") + ".Provider";
          case U:
            var g = m.render;
            return m = m.displayName, m || (m = g.displayName || g.name || "", m = m !== "" ? "ForwardRef(" + m + ")" : "ForwardRef"), m;
          case I:
            return g = m.displayName || null, g !== null ? g : Z(m.type) || "Memo";
          case k:
            g = m._payload, m = m._init;
            try {
              return Z(m(g));
            } catch {
            }
        }
      return null;
    }
    function te(m) {
      var g = m.type;
      switch (m.tag) {
        case 24:
          return "Cache";
        case 9:
          return (g.displayName || "Context") + ".Consumer";
        case 10:
          return (g._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return m = g.render, m = m.displayName || m.name || "", g.displayName || (m !== "" ? "ForwardRef(" + m + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return g;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Z(g);
        case 8:
          return g === b ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof g == "function")
            return g.displayName || g.name || null;
          if (typeof g == "string")
            return g;
      }
      return null;
    }
    function J(m) {
      var g = m, R = m;
      if (m.alternate)
        for (; g.return; )
          g = g.return;
      else {
        m = g;
        do
          g = m, g.flags & 4098 && (R = g.return), m = g.return;
        while (m);
      }
      return g.tag === 3 ? R : null;
    }
    function q(m) {
      if (J(m) !== m)
        throw Error(u(188));
    }
    function oe(m) {
      var g = m.alternate;
      if (!g) {
        if (g = J(m), g === null)
          throw Error(u(188));
        return g !== m ? null : m;
      }
      for (var R = m, z = g; ; ) {
        var V = R.return;
        if (V === null)
          break;
        var Q = V.alternate;
        if (Q === null) {
          if (z = V.return, z !== null) {
            R = z;
            continue;
          }
          break;
        }
        if (V.child === Q.child) {
          for (Q = V.child; Q; ) {
            if (Q === R)
              return q(V), m;
            if (Q === z)
              return q(V), g;
            Q = Q.sibling;
          }
          throw Error(u(188));
        }
        if (R.return !== z.return)
          R = V, z = Q;
        else {
          for (var Me = !1, We = V.child; We; ) {
            if (We === R) {
              Me = !0, R = V, z = Q;
              break;
            }
            if (We === z) {
              Me = !0, z = V, R = Q;
              break;
            }
            We = We.sibling;
          }
          if (!Me) {
            for (We = Q.child; We; ) {
              if (We === R) {
                Me = !0, R = Q, z = V;
                break;
              }
              if (We === z) {
                Me = !0, z = Q, R = V;
                break;
              }
              We = We.sibling;
            }
            if (!Me)
              throw Error(u(189));
          }
        }
        if (R.alternate !== z)
          throw Error(u(190));
      }
      if (R.tag !== 3)
        throw Error(u(188));
      return R.stateNode.current === R ? m : g;
    }
    function ye(m) {
      return m = oe(m), m !== null ? de(m) : null;
    }
    function de(m) {
      if (m.tag === 5 || m.tag === 6)
        return m;
      for (m = m.child; m !== null; ) {
        var g = de(m);
        if (g !== null)
          return g;
        m = m.sibling;
      }
      return null;
    }
    function xe(m) {
      if (m.tag === 5 || m.tag === 6)
        return m;
      for (m = m.child; m !== null; ) {
        if (m.tag !== 4) {
          var g = xe(m);
          if (g !== null)
            return g;
        }
        m = m.sibling;
      }
      return null;
    }
    var Re = Array.isArray, Pe = e.getPublicInstance, Te = e.getRootHostContext, ue = e.getChildHostContext, we = e.prepareForCommit, X = e.resetAfterCommit, me = e.createInstance, ce = e.appendInitialChild, Ue = e.finalizeInitialChildren, Oe = e.prepareUpdate, Ze = e.shouldSetTextContent, je = e.createTextInstance, Je = e.scheduleTimeout, at = e.cancelTimeout, xt = e.noTimeout, $t = e.isPrimaryRenderer, Ht = e.supportsMutation, he = e.supportsPersistence, nt = e.supportsHydration, et = e.getInstanceFromNode, Rt = e.preparePortalMount, gt = e.getCurrentEventPriority, Jt = e.detachDeletedInstance, Kt = e.supportsMicrotasks, qt = e.scheduleMicrotask, hn = e.supportsTestSelectors, Rn = e.findFiberRoot, Yn = e.getBoundingRect, se = e.getTextContent, ae = e.isHiddenSubtree, Ke = e.matchAccessibilityRole, wt = e.setFocusIfFocusable, _t = e.setupIntersectionObserver, Vt = e.appendChild, fn = e.appendChildToContainer, Wt = e.commitTextUpdate, Ee = e.commitMount, Xe = e.commitUpdate, St = e.insertBefore, Ut = e.insertInContainerBefore, Se = e.removeChild, Ye = e.removeChildFromContainer, bt = e.resetTextContent, Tt = e.hideInstance, ge = e.hideTextInstance, zt = e.unhideInstance, Fe = e.unhideTextInstance, ft = e.clearContainer, ln = e.cloneInstance, zn = e.createContainerChildSet, yr = e.appendChildToContainerChildSet, ti = e.finalizeContainerChildren, rr = e.replaceContainerChildren, vr = e.cloneHiddenInstance, Ai = e.cloneHiddenTextInstance, oi = e.canHydrateInstance, Ma = e.canHydrateTextInstance, Ji = e.canHydrateSuspenseInstance, _l = e.isSuspenseInstancePending, ea = e.isSuspenseInstanceFallback, _o = e.registerSuspenseInstanceRetry, Eo = e.getNextHydratableSibling, Le = e.getFirstHydratableChild, Bt = e.getFirstHydratableChildWithinContainer, en = e.getFirstHydratableChildWithinSuspenseInstance, _n = e.hydrateInstance, ve = e.hydrateTextInstance, $e = e.hydrateSuspenseInstance, qe = e.getNextHydratableInstanceAfterSuspenseInstance, ze = e.commitHydratedContainer, dt = e.commitHydratedSuspenseInstance, tn = e.clearSuspenseBoundary, pn = e.clearSuspenseBoundaryFromContainer, An = e.shouldDeleteUnhydratedTailInstances, Gn = e.didNotMatchHydratedContainerTextInstance, cr = e.didNotMatchHydratedTextInstance, sn;
    function pr(m) {
      if (sn === void 0)
        try {
          throw Error();
        } catch (R) {
          var g = R.stack.trim().match(/\n( *(at )?)/);
          sn = g && g[1] || "";
        }
      return `
` + sn + m;
    }
    var Pr = !1;
    function kn(m, g) {
      if (!m || Pr)
        return "";
      Pr = !0;
      var R = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (g)
          if (g = function() {
            throw Error();
          }, Object.defineProperty(g.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(g, []);
            } catch (Qt) {
              var z = Qt;
            }
            Reflect.construct(m, [], g);
          } else {
            try {
              g.call();
            } catch (Qt) {
              z = Qt;
            }
            m.call(g.prototype);
          }
        else {
          try {
            throw Error();
          } catch (Qt) {
            z = Qt;
          }
          m();
        }
      } catch (Qt) {
        if (Qt && z && typeof Qt.stack == "string") {
          for (var V = Qt.stack.split(`
`), Q = z.stack.split(`
`), Me = V.length - 1, We = Q.length - 1; 1 <= Me && 0 <= We && V[Me] !== Q[We]; )
            We--;
          for (; 1 <= Me && 0 <= We; Me--, We--)
            if (V[Me] !== Q[We]) {
              if (Me !== 1 || We !== 1)
                do
                  if (Me--, We--, 0 > We || V[Me] !== Q[We]) {
                    var Mt = `
` + V[Me].replace(" at new ", " at ");
                    return m.displayName && Mt.includes("<anonymous>") && (Mt = Mt.replace("<anonymous>", m.displayName)), Mt;
                  }
                while (1 <= Me && 0 <= We);
              break;
            }
        }
      } finally {
        Pr = !1, Error.prepareStackTrace = R;
      }
      return (m = m ? m.displayName || m.name : "") ? pr(m) : "";
    }
    var za = Object.prototype.hasOwnProperty, Ja = [], Si = -1;
    function ir(m) {
      return { current: m };
    }
    function Cr(m) {
      0 > Si || (m.current = Ja[Si], Ja[Si] = null, Si--);
    }
    function fr(m, g) {
      Si++, Ja[Si] = m.current, m.current = g;
    }
    var Di = {}, wa = ir(Di), ni = ir(!1), ss = Di;
    function ta(m, g) {
      var R = m.type.contextTypes;
      if (!R)
        return Di;
      var z = m.stateNode;
      if (z && z.__reactInternalMemoizedUnmaskedChildContext === g)
        return z.__reactInternalMemoizedMaskedChildContext;
      var V = {}, Q;
      for (Q in R)
        V[Q] = g[Q];
      return z && (m = m.stateNode, m.__reactInternalMemoizedUnmaskedChildContext = g, m.__reactInternalMemoizedMaskedChildContext = V), V;
    }
    function Vi(m) {
      return m = m.childContextTypes, m != null;
    }
    function Po() {
      Cr(ni), Cr(wa);
    }
    function Ui(m, g, R) {
      if (wa.current !== Di)
        throw Error(u(168));
      fr(wa, g), fr(ni, R);
    }
    function El(m, g, R) {
      var z = m.stateNode;
      if (g = g.childContextTypes, typeof z.getChildContext != "function")
        return R;
      z = z.getChildContext();
      for (var V in z)
        if (!(V in g))
          throw Error(u(108, te(m) || "Unknown", V));
      return s({}, R, z);
    }
    function Ds(m) {
      return m = (m = m.stateNode) && m.__reactInternalMemoizedMergedChildContext || Di, ss = wa.current, fr(wa, m), fr(ni, ni.current), !0;
    }
    function bl(m, g, R) {
      var z = m.stateNode;
      if (!z)
        throw Error(u(169));
      R ? (m = El(m, g, ss), z.__reactInternalMemoizedMergedChildContext = m, Cr(ni), Cr(wa), fr(wa, m)) : Cr(ni), fr(ni, R);
    }
    var Go = Math.clz32 ? Math.clz32 : fm, Mf = Math.log, Qu = Math.LN2;
    function fm(m) {
      return m >>>= 0, m === 0 ? 32 : 31 - (Mf(m) / Qu | 0) | 0;
    }
    var Tl = 64, Kr = 4194304;
    function Ml(m) {
      switch (m & -m) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return m & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return m & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return m;
      }
    }
    function Zu(m, g) {
      var R = m.pendingLanes;
      if (R === 0)
        return 0;
      var z = 0, V = m.suspendedLanes, Q = m.pingedLanes, Me = R & 268435455;
      if (Me !== 0) {
        var We = Me & ~V;
        We !== 0 ? z = Ml(We) : (Q &= Me, Q !== 0 && (z = Ml(Q)));
      } else
        Me = R & ~V, Me !== 0 ? z = Ml(Me) : Q !== 0 && (z = Ml(Q));
      if (z === 0)
        return 0;
      if (g !== 0 && g !== z && !(g & V) && (V = z & -z, Q = g & -g, V >= Q || V === 16 && (Q & 4194240) !== 0))
        return g;
      if (z & 4 && (z |= R & 16), g = m.entangledLanes, g !== 0)
        for (m = m.entanglements, g &= z; 0 < g; )
          R = 31 - Go(g), V = 1 << R, z |= m[R], g &= ~V;
      return z;
    }
    function ls(m, g) {
      switch (m) {
        case 1:
        case 2:
        case 4:
          return g + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return g + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function jr(m, g) {
      for (var R = m.suspendedLanes, z = m.pingedLanes, V = m.expirationTimes, Q = m.pendingLanes; 0 < Q; ) {
        var Me = 31 - Go(Q), We = 1 << Me, Mt = V[Me];
        Mt === -1 ? (!(We & R) || We & z) && (V[Me] = ls(We, g)) : Mt <= g && (m.expiredLanes |= We), Q &= ~We;
      }
    }
    function lo(m) {
      return m = m.pendingLanes & -1073741825, m !== 0 ? m : m & 1073741824 ? 1073741824 : 0;
    }
    function wf(m) {
      for (var g = [], R = 0; 31 > R; R++)
        g.push(m);
      return g;
    }
    function lr(m, g, R) {
      m.pendingLanes |= g, g !== 536870912 && (m.suspendedLanes = 0, m.pingedLanes = 0), m = m.eventTimes, g = 31 - Go(g), m[g] = R;
    }
    function pd(m, g) {
      var R = m.pendingLanes & ~g;
      m.pendingLanes = g, m.suspendedLanes = 0, m.pingedLanes = 0, m.expiredLanes &= g, m.mutableReadLanes &= g, m.entangledLanes &= g, g = m.entanglements;
      var z = m.eventTimes;
      for (m = m.expirationTimes; 0 < R; ) {
        var V = 31 - Go(R), Q = 1 << V;
        g[V] = 0, z[V] = -1, m[V] = -1, R &= ~Q;
      }
    }
    function pa(m, g) {
      var R = m.entangledLanes |= g;
      for (m = m.entanglements; R; ) {
        var z = 31 - Go(R), V = 1 << z;
        V & g | m[z] & g && (m[z] |= g), R &= ~V;
      }
    }
    var br = 0;
    function us(m) {
      return m &= -m, 1 < m ? 4 < m ? m & 268435455 ? 16 : 536870912 : 4 : 1;
    }
    var Ls = a.unstable_scheduleCallback, Ca = a.unstable_cancelCallback, zi = a.unstable_shouldYield, dm = a.unstable_requestPaint, si = a.unstable_now, uo = a.unstable_ImmediatePriority, Ju = a.unstable_UserBlockingPriority, ch = a.unstable_NormalPriority, Nc = a.unstable_IdlePriority, Eu = null, wl = null;
    function Jl(m) {
      if (wl && typeof wl.onCommitFiberRoot == "function")
        try {
          wl.onCommitFiberRoot(Eu, m, void 0, (m.current.flags & 128) === 128);
        } catch {
        }
    }
    function Cf(m, g) {
      return m === g && (m !== 0 || 1 / m === 1 / g) || m !== m && g !== g;
    }
    var Wo = typeof Object.is == "function" ? Object.is : Cf, co = null, Uc = !1, ec = !1;
    function tc(m) {
      co === null ? co = [m] : co.push(m);
    }
    function md(m) {
      Uc = !0, tc(m);
    }
    function Os() {
      if (!ec && co !== null) {
        ec = !0;
        var m = 0, g = br;
        try {
          var R = co;
          for (br = 1; m < R.length; m++) {
            var z = R[m];
            do
              z = z(!0);
            while (z !== null);
          }
          co = null, Uc = !1;
        } catch (V) {
          throw co !== null && (co = co.slice(m + 1)), Ls(uo, Os), V;
        } finally {
          br = g, ec = !1;
        }
      }
      return null;
    }
    var op = h.ReactCurrentBatchConfig;
    function nl(m, g) {
      if (Wo(m, g))
        return !0;
      if (typeof m != "object" || m === null || typeof g != "object" || g === null)
        return !1;
      var R = Object.keys(m), z = Object.keys(g);
      if (R.length !== z.length)
        return !1;
      for (z = 0; z < R.length; z++) {
        var V = R[z];
        if (!za.call(g, V) || !Wo(m[V], g[V]))
          return !1;
      }
      return !0;
    }
    function ne(m) {
      switch (m.tag) {
        case 5:
          return pr(m.type);
        case 16:
          return pr("Lazy");
        case 13:
          return pr("Suspense");
        case 19:
          return pr("SuspenseList");
        case 0:
        case 2:
        case 15:
          return m = kn(m.type, !1), m;
        case 11:
          return m = kn(m.type.render, !1), m;
        case 1:
          return m = kn(m.type, !0), m;
        default:
          return "";
      }
    }
    function De(m, g) {
      if (m && m.defaultProps) {
        g = s({}, g), m = m.defaultProps;
        for (var R in m)
          g[R] === void 0 && (g[R] = m[R]);
        return g;
      }
      return g;
    }
    var st = ir(null), yt = null, Zt = null, Xn = null;
    function mn() {
      Xn = Zt = yt = null;
    }
    function qn(m, g, R) {
      $t ? (fr(st, g._currentValue), g._currentValue = R) : (fr(st, g._currentValue2), g._currentValue2 = R);
    }
    function Nr(m) {
      var g = st.current;
      Cr(st), $t ? m._currentValue = g : m._currentValue2 = g;
    }
    function ri(m, g, R) {
      for (; m !== null; ) {
        var z = m.alternate;
        if ((m.childLanes & g) !== g ? (m.childLanes |= g, z !== null && (z.childLanes |= g)) : z !== null && (z.childLanes & g) !== g && (z.childLanes |= g), m === R)
          break;
        m = m.return;
      }
    }
    function Ti(m, g) {
      yt = m, Xn = Zt = null, m = m.dependencies, m !== null && m.firstContext !== null && (m.lanes & g && (Hr = !0), m.firstContext = null);
    }
    function Br(m) {
      var g = $t ? m._currentValue : m._currentValue2;
      if (Xn !== m)
        if (m = { context: m, memoizedValue: g, next: null }, Zt === null) {
          if (yt === null)
            throw Error(u(308));
          Zt = m, yt.dependencies = { lanes: 0, firstContext: m };
        } else
          Zt = Zt.next = m;
      return g;
    }
    var Qr = null, li = !1;
    function $r(m) {
      m.updateQueue = { baseState: m.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function Cl(m, g) {
      m = m.updateQueue, g.updateQueue === m && (g.updateQueue = { baseState: m.baseState, firstBaseUpdate: m.firstBaseUpdate, lastBaseUpdate: m.lastBaseUpdate, shared: m.shared, effects: m.effects });
    }
    function rl(m, g) {
      return { eventTime: m, lane: g, tag: 0, payload: null, callback: null, next: null };
    }
    function eu(m, g) {
      var R = m.updateQueue;
      R !== null && (R = R.shared, ia !== null && m.mode & 1 && !(zr & 2) ? (m = R.interleaved, m === null ? (g.next = g, Qr === null ? Qr = [R] : Qr.push(R)) : (g.next = m.next, m.next = g), R.interleaved = g) : (m = R.pending, m === null ? g.next = g : (g.next = m.next, m.next = g), R.pending = g));
    }
    function fh(m, g, R) {
      if (g = g.updateQueue, g !== null && (g = g.shared, (R & 4194240) !== 0)) {
        var z = g.lanes;
        z &= m.pendingLanes, R |= z, g.lanes = R, pa(m, R);
      }
    }
    function tu(m, g) {
      var R = m.updateQueue, z = m.alternate;
      if (z !== null && (z = z.updateQueue, R === z)) {
        var V = null, Q = null;
        if (R = R.firstBaseUpdate, R !== null) {
          do {
            var Me = { eventTime: R.eventTime, lane: R.lane, tag: R.tag, payload: R.payload, callback: R.callback, next: null };
            Q === null ? V = Q = Me : Q = Q.next = Me, R = R.next;
          } while (R !== null);
          Q === null ? V = Q = g : Q = Q.next = g;
        } else
          V = Q = g;
        R = { baseState: z.baseState, firstBaseUpdate: V, lastBaseUpdate: Q, shared: z.shared, effects: z.effects }, m.updateQueue = R;
        return;
      }
      m = R.lastBaseUpdate, m === null ? R.firstBaseUpdate = g : m.next = g, R.lastBaseUpdate = g;
    }
    function Rf(m, g, R, z) {
      var V = m.updateQueue;
      li = !1;
      var Q = V.firstBaseUpdate, Me = V.lastBaseUpdate, We = V.shared.pending;
      if (We !== null) {
        V.shared.pending = null;
        var Mt = We, Qt = Mt.next;
        Mt.next = null, Me === null ? Q = Qt : Me.next = Qt, Me = Mt;
        var cn = m.alternate;
        cn !== null && (cn = cn.updateQueue, We = cn.lastBaseUpdate, We !== Me && (We === null ? cn.firstBaseUpdate = Qt : We.next = Qt, cn.lastBaseUpdate = Mt));
      }
      if (Q !== null) {
        var sr = V.baseState;
        Me = 0, cn = Qt = Mt = null, We = Q;
        do {
          var Jn = We.lane, aa = We.eventTime;
          if ((z & Jn) === Jn) {
            cn !== null && (cn = cn.next = {
              eventTime: aa,
              lane: 0,
              tag: We.tag,
              payload: We.payload,
              callback: We.callback,
              next: null
            });
            e: {
              var yn = m, fi = We;
              switch (Jn = g, aa = R, fi.tag) {
                case 1:
                  if (yn = fi.payload, typeof yn == "function") {
                    sr = yn.call(aa, sr, Jn);
                    break e;
                  }
                  sr = yn;
                  break e;
                case 3:
                  yn.flags = yn.flags & -65537 | 128;
                case 0:
                  if (yn = fi.payload, Jn = typeof yn == "function" ? yn.call(aa, sr, Jn) : yn, Jn == null)
                    break e;
                  sr = s({}, sr, Jn);
                  break e;
                case 2:
                  li = !0;
              }
            }
            We.callback !== null && We.lane !== 0 && (m.flags |= 64, Jn = V.effects, Jn === null ? V.effects = [We] : Jn.push(We));
          } else
            aa = { eventTime: aa, lane: Jn, tag: We.tag, payload: We.payload, callback: We.callback, next: null }, cn === null ? (Qt = cn = aa, Mt = sr) : cn = cn.next = aa, Me |= Jn;
          if (We = We.next, We === null) {
            if (We = V.shared.pending, We === null)
              break;
            Jn = We, We = Jn.next, Jn.next = null, V.lastBaseUpdate = Jn, V.shared.pending = null;
          }
        } while (!0);
        if (cn === null && (Mt = sr), V.baseState = Mt, V.firstBaseUpdate = Qt, V.lastBaseUpdate = cn, g = V.shared.interleaved, g !== null) {
          V = g;
          do
            Me |= V.lane, V = V.next;
          while (V !== g);
        } else
          Q === null && (V.shared.lanes = 0);
        Ou |= Me, m.lanes = Me, m.memoizedState = sr;
      }
    }
    function dh(m, g, R) {
      if (m = g.effects, g.effects = null, m !== null)
        for (g = 0; g < m.length; g++) {
          var z = m[g], V = z.callback;
          if (V !== null) {
            if (z.callback = null, z = R, typeof V != "function")
              throw Error(u(191, V));
            V.call(z);
          }
        }
    }
    var hm = new r.Component().refs;
    function pm(m, g, R, z) {
      g = m.memoizedState, R = R(z, g), R = R == null ? g : s({}, g, R), m.memoizedState = R, m.lanes === 0 && (m.updateQueue.baseState = R);
    }
    var mm = { isMounted: function(m) {
      return (m = m._reactInternals) ? J(m) === m : !1;
    }, enqueueSetState: function(m, g, R) {
      m = m._reactInternals;
      var z = Yr(), V = wo(m), Q = rl(z, V);
      Q.payload = g, R != null && (Q.callback = R), eu(m, Q), g = Ws(m, V, z), g !== null && fh(g, m, V);
    }, enqueueReplaceState: function(m, g, R) {
      m = m._reactInternals;
      var z = Yr(), V = wo(m), Q = rl(z, V);
      Q.tag = 1, Q.payload = g, R != null && (Q.callback = R), eu(m, Q), g = Ws(m, V, z), g !== null && fh(g, m, V);
    }, enqueueForceUpdate: function(m, g) {
      m = m._reactInternals;
      var R = Yr(), z = wo(m), V = rl(
        R,
        z
      );
      V.tag = 2, g != null && (V.callback = g), eu(m, V), g = Ws(m, z, R), g !== null && fh(g, m, z);
    } };
    function vm(m, g, R, z, V, Q, Me) {
      return m = m.stateNode, typeof m.shouldComponentUpdate == "function" ? m.shouldComponentUpdate(z, Q, Me) : g.prototype && g.prototype.isPureReactComponent ? !nl(R, z) || !nl(V, Q) : !0;
    }
    function gm(m, g, R) {
      var z = !1, V = Di, Q = g.contextType;
      return typeof Q == "object" && Q !== null ? Q = Br(Q) : (V = Vi(g) ? ss : wa.current, z = g.contextTypes, Q = (z = z != null) ? ta(m, V) : Di), g = new g(R, Q), m.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null, g.updater = mm, m.stateNode = g, g._reactInternals = m, z && (m = m.stateNode, m.__reactInternalMemoizedUnmaskedChildContext = V, m.__reactInternalMemoizedMaskedChildContext = Q), g;
    }
    function Cv(m, g, R, z) {
      m = g.state, typeof g.componentWillReceiveProps == "function" && g.componentWillReceiveProps(R, z), typeof g.UNSAFE_componentWillReceiveProps == "function" && g.UNSAFE_componentWillReceiveProps(R, z), g.state !== m && mm.enqueueReplaceState(g, g.state, null);
    }
    function ym(m, g, R, z) {
      var V = m.stateNode;
      V.props = R, V.state = m.memoizedState, V.refs = hm, $r(m);
      var Q = g.contextType;
      typeof Q == "object" && Q !== null ? V.context = Br(Q) : (Q = Vi(g) ? ss : wa.current, V.context = ta(m, Q)), V.state = m.memoizedState, Q = g.getDerivedStateFromProps, typeof Q == "function" && (pm(m, g, Q, R), V.state = m.memoizedState), typeof g.getDerivedStateFromProps == "function" || typeof V.getSnapshotBeforeUpdate == "function" || typeof V.UNSAFE_componentWillMount != "function" && typeof V.componentWillMount != "function" || (g = V.state, typeof V.componentWillMount == "function" && V.componentWillMount(), typeof V.UNSAFE_componentWillMount == "function" && V.UNSAFE_componentWillMount(), g !== V.state && mm.enqueueReplaceState(V, V.state, null), Rf(m, R, V, z), V.state = m.memoizedState), typeof V.componentDidMount == "function" && (m.flags |= 4194308);
    }
    var vd = [], Af = 0, nu = null, Sm = 0, il = [], Ps = 0, zc = null, kc = 1, ru = "";
    function Df(m, g) {
      vd[Af++] = Sm, vd[Af++] = nu, nu = m, Sm = g;
    }
    function Ns(m, g, R) {
      il[Ps++] = kc, il[Ps++] = ru, il[Ps++] = zc, zc = m;
      var z = kc;
      m = ru;
      var V = 32 - Go(z) - 1;
      z &= ~(1 << V), R += 1;
      var Q = 32 - Go(g) + V;
      if (30 < Q) {
        var Me = V - V % 5;
        Q = (z & (1 << Me) - 1).toString(32), z >>= Me, V -= Me, kc = 1 << 32 - Go(g) + V | R << V | z, ru = Q + m;
      } else
        kc = 1 << Q | R << V | z, ru = m;
    }
    function bu(m) {
      m.return !== null && (Df(m, 1), Ns(m, 1, 0));
    }
    function ka(m) {
      for (; m === nu; )
        nu = vd[--Af], vd[Af] = null, Sm = vd[--Af], vd[Af] = null;
      for (; m === zc; )
        zc = il[--Ps], il[Ps] = null, ru = il[--Ps], il[Ps] = null, kc = il[--Ps], il[Ps] = null;
    }
    var Ra = null, Aa = null, Yi = !1, gd = !1, jo = null;
    function xm(m, g) {
      var R = Ro(5, null, null, 0);
      R.elementType = "DELETED", R.stateNode = g, R.return = m, g = m.deletions, g === null ? (m.deletions = [R], m.flags |= 16) : g.push(R);
    }
    function _m(m, g) {
      switch (m.tag) {
        case 5:
          return g = oi(g, m.type, m.pendingProps), g !== null ? (m.stateNode = g, Ra = m, Aa = Le(g), !0) : !1;
        case 6:
          return g = Ma(g, m.pendingProps), g !== null ? (m.stateNode = g, Ra = m, Aa = null, !0) : !1;
        case 13:
          if (g = Ji(g), g !== null) {
            var R = zc !== null ? { id: kc, overflow: ru } : null;
            return m.memoizedState = { dehydrated: g, treeContext: R, retryLane: 1073741824 }, R = Ro(18, null, null, 0), R.stateNode = g, R.return = m, m.child = R, Ra = m, Aa = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function yd(m) {
      return (m.mode & 1) !== 0 && (m.flags & 128) === 0;
    }
    function Ic(m) {
      if (Yi) {
        var g = Aa;
        if (g) {
          var R = g;
          if (!_m(m, g)) {
            if (yd(m))
              throw Error(u(418));
            g = Eo(R);
            var z = Ra;
            g && _m(m, g) ? xm(z, R) : (m.flags = m.flags & -4097 | 2, Yi = !1, Ra = m);
          }
        } else {
          if (yd(m))
            throw Error(u(418));
          m.flags = m.flags & -4097 | 2, Yi = !1, Ra = m;
        }
      }
    }
    function Rv(m) {
      for (m = m.return; m !== null && m.tag !== 5 && m.tag !== 3 && m.tag !== 13; )
        m = m.return;
      Ra = m;
    }
    function sp(m) {
      if (!nt || m !== Ra)
        return !1;
      if (!Yi)
        return Rv(m), Yi = !0, !1;
      if (m.tag !== 3 && (m.tag !== 5 || An(m.type) && !Ze(m.type, m.memoizedProps))) {
        var g = Aa;
        if (g) {
          if (yd(m)) {
            for (m = Aa; m; )
              m = Eo(m);
            throw Error(u(418));
          }
          for (; g; )
            xm(m, g), g = Eo(g);
        }
      }
      if (Rv(m), m.tag === 13) {
        if (!nt)
          throw Error(u(316));
        if (m = m.memoizedState, m = m !== null ? m.dehydrated : null, !m)
          throw Error(u(317));
        Aa = qe(m);
      } else
        Aa = Ra ? Eo(m.stateNode) : null;
      return !0;
    }
    function Sd() {
      nt && (Aa = Ra = null, gd = Yi = !1);
    }
    function hh(m) {
      jo === null ? jo = [m] : jo.push(m);
    }
    function Lf(m, g, R) {
      if (m = R.ref, m !== null && typeof m != "function" && typeof m != "object") {
        if (R._owner) {
          if (R = R._owner, R) {
            if (R.tag !== 1)
              throw Error(u(309));
            var z = R.stateNode;
          }
          if (!z)
            throw Error(u(147, m));
          var V = z, Q = "" + m;
          return g !== null && g.ref !== null && typeof g.ref == "function" && g.ref._stringRef === Q ? g.ref : (g = function(Me) {
            var We = V.refs;
            We === hm && (We = V.refs = {}), Me === null ? delete We[Q] : We[Q] = Me;
          }, g._stringRef = Q, g);
        }
        if (typeof m != "string")
          throw Error(u(284));
        if (!R._owner)
          throw Error(u(290, m));
      }
      return m;
    }
    function Us(m, g) {
      throw m = Object.prototype.toString.call(g), Error(u(31, m === "[object Object]" ? "object with keys {" + Object.keys(g).join(", ") + "}" : m));
    }
    function Fc(m) {
      var g = m._init;
      return g(m._payload);
    }
    function nc(m) {
      function g(ot, Be) {
        if (m) {
          var vt = ot.deletions;
          vt === null ? (ot.deletions = [Be], ot.flags |= 16) : vt.push(Be);
        }
      }
      function R(ot, Be) {
        if (!m)
          return null;
        for (; Be !== null; )
          g(ot, Be), Be = Be.sibling;
        return null;
      }
      function z(ot, Be) {
        for (ot = /* @__PURE__ */ new Map(); Be !== null; )
          Be.key !== null ? ot.set(Be.key, Be) : ot.set(Be.index, Be), Be = Be.sibling;
        return ot;
      }
      function V(ot, Be) {
        return ot = Xo(ot, Be), ot.index = 0, ot.sibling = null, ot;
      }
      function Q(ot, Be, vt) {
        return ot.index = vt, m ? (vt = ot.alternate, vt !== null ? (vt = vt.index, vt < Be ? (ot.flags |= 2, Be) : vt) : (ot.flags |= 2, Be)) : (ot.flags |= 1048576, Be);
      }
      function Me(ot) {
        return m && ot.alternate === null && (ot.flags |= 2), ot;
      }
      function We(ot, Be, vt, Pt) {
        return Be === null || Be.tag !== 6 ? (Be = nf(vt, ot.mode, Pt), Be.return = ot, Be) : (Be = V(Be, vt), Be.return = ot, Be);
      }
      function Mt(ot, Be, vt, Pt) {
        var Dn = vt.type;
        return Dn === _ ? cn(ot, Be, vt.props.children, Pt, vt.key) : Be !== null && (Be.elementType === Dn || typeof Dn == "object" && Dn !== null && Dn.$$typeof === k && Fc(Dn) === Be.type) ? (Pt = V(Be, vt.props), Pt.ref = Lf(ot, Be, vt), Pt.return = ot, Pt) : (Pt = tf(vt.type, vt.key, vt.props, null, ot.mode, Pt), Pt.ref = Lf(ot, Be, vt), Pt.return = ot, Pt);
      }
      function Qt(ot, Be, vt, Pt) {
        return Be === null || Be.tag !== 4 || Be.stateNode.containerInfo !== vt.containerInfo || Be.stateNode.implementation !== vt.implementation ? (Be = pu(vt, ot.mode, Pt), Be.return = ot, Be) : (Be = V(Be, vt.children || []), Be.return = ot, Be);
      }
      function cn(ot, Be, vt, Pt, Dn) {
        return Be === null || Be.tag !== 7 ? (Be = zl(vt, ot.mode, Pt, Dn), Be.return = ot, Be) : (Be = V(Be, vt), Be.return = ot, Be);
      }
      function sr(ot, Be, vt) {
        if (typeof Be == "string" && Be !== "" || typeof Be == "number")
          return Be = nf("" + Be, ot.mode, vt), Be.return = ot, Be;
        if (typeof Be == "object" && Be !== null) {
          switch (Be.$$typeof) {
            case v:
              return vt = tf(Be.type, Be.key, Be.props, null, ot.mode, vt), vt.ref = Lf(ot, null, Be), vt.return = ot, vt;
            case y:
              return Be = pu(Be, ot.mode, vt), Be.return = ot, Be;
            case k:
              var Pt = Be._init;
              return sr(ot, Pt(Be._payload), vt);
          }
          if (Re(Be) || Y(Be))
            return Be = zl(Be, ot.mode, vt, null), Be.return = ot, Be;
          Us(ot, Be);
        }
        return null;
      }
      function Jn(ot, Be, vt, Pt) {
        var Dn = Be !== null ? Be.key : null;
        if (typeof vt == "string" && vt !== "" || typeof vt == "number")
          return Dn !== null ? null : We(ot, Be, "" + vt, Pt);
        if (typeof vt == "object" && vt !== null) {
          switch (vt.$$typeof) {
            case v:
              return vt.key === Dn ? Mt(ot, Be, vt, Pt) : null;
            case y:
              return vt.key === Dn ? Qt(ot, Be, vt, Pt) : null;
            case k:
              return Dn = vt._init, Jn(
                ot,
                Be,
                Dn(vt._payload),
                Pt
              );
          }
          if (Re(vt) || Y(vt))
            return Dn !== null ? null : cn(ot, Be, vt, Pt, null);
          Us(ot, vt);
        }
        return null;
      }
      function aa(ot, Be, vt, Pt, Dn) {
        if (typeof Pt == "string" && Pt !== "" || typeof Pt == "number")
          return ot = ot.get(vt) || null, We(Be, ot, "" + Pt, Dn);
        if (typeof Pt == "object" && Pt !== null) {
          switch (Pt.$$typeof) {
            case v:
              return ot = ot.get(Pt.key === null ? vt : Pt.key) || null, Mt(Be, ot, Pt, Dn);
            case y:
              return ot = ot.get(Pt.key === null ? vt : Pt.key) || null, Qt(Be, ot, Pt, Dn);
            case k:
              var Ar = Pt._init;
              return aa(ot, Be, vt, Ar(Pt._payload), Dn);
          }
          if (Re(Pt) || Y(Pt))
            return ot = ot.get(vt) || null, cn(Be, ot, Pt, Dn, null);
          Us(Be, Pt);
        }
        return null;
      }
      function yn(ot, Be, vt, Pt) {
        for (var Dn = null, Ar = null, ar = Be, Vr = Be = 0, _a = null; ar !== null && Vr < vt.length; Vr++) {
          ar.index > Vr ? (_a = ar, ar = null) : _a = ar.sibling;
          var Gr = Jn(ot, ar, vt[Vr], Pt);
          if (Gr === null) {
            ar === null && (ar = _a);
            break;
          }
          m && ar && Gr.alternate === null && g(ot, ar), Be = Q(Gr, Be, Vr), Ar === null ? Dn = Gr : Ar.sibling = Gr, Ar = Gr, ar = _a;
        }
        if (Vr === vt.length)
          return R(ot, ar), Yi && Df(ot, Vr), Dn;
        if (ar === null) {
          for (; Vr < vt.length; Vr++)
            ar = sr(ot, vt[Vr], Pt), ar !== null && (Be = Q(ar, Be, Vr), Ar === null ? Dn = ar : Ar.sibling = ar, Ar = ar);
          return Yi && Df(ot, Vr), Dn;
        }
        for (ar = z(ot, ar); Vr < vt.length; Vr++)
          _a = aa(ar, ot, Vr, vt[Vr], Pt), _a !== null && (m && _a.alternate !== null && ar.delete(_a.key === null ? Vr : _a.key), Be = Q(_a, Be, Vr), Ar === null ? Dn = _a : Ar.sibling = _a, Ar = _a);
        return m && ar.forEach(function(hc) {
          return g(ot, hc);
        }), Yi && Df(ot, Vr), Dn;
      }
      function fi(ot, Be, vt, Pt) {
        var Dn = Y(vt);
        if (typeof Dn != "function")
          throw Error(u(150));
        if (vt = Dn.call(vt), vt == null)
          throw Error(u(151));
        for (var Ar = Dn = null, ar = Be, Vr = Be = 0, _a = null, Gr = vt.next(); ar !== null && !Gr.done; Vr++, Gr = vt.next()) {
          ar.index > Vr ? (_a = ar, ar = null) : _a = ar.sibling;
          var hc = Jn(ot, ar, Gr.value, Pt);
          if (hc === null) {
            ar === null && (ar = _a);
            break;
          }
          m && ar && hc.alternate === null && g(ot, ar), Be = Q(hc, Be, Vr), Ar === null ? Dn = hc : Ar.sibling = hc, Ar = hc, ar = _a;
        }
        if (Gr.done)
          return R(
            ot,
            ar
          ), Yi && Df(ot, Vr), Dn;
        if (ar === null) {
          for (; !Gr.done; Vr++, Gr = vt.next())
            Gr = sr(ot, Gr.value, Pt), Gr !== null && (Be = Q(Gr, Be, Vr), Ar === null ? Dn = Gr : Ar.sibling = Gr, Ar = Gr);
          return Yi && Df(ot, Vr), Dn;
        }
        for (ar = z(ot, ar); !Gr.done; Vr++, Gr = vt.next())
          Gr = aa(ar, ot, Vr, Gr.value, Pt), Gr !== null && (m && Gr.alternate !== null && ar.delete(Gr.key === null ? Vr : Gr.key), Be = Q(Gr, Be, Vr), Ar === null ? Dn = Gr : Ar.sibling = Gr, Ar = Gr);
        return m && ar.forEach(function(Th) {
          return g(ot, Th);
        }), Yi && Df(ot, Vr), Dn;
      }
      function Va(ot, Be, vt, Pt) {
        if (typeof vt == "object" && vt !== null && vt.type === _ && vt.key === null && (vt = vt.props.children), typeof vt == "object" && vt !== null) {
          switch (vt.$$typeof) {
            case v:
              e: {
                for (var Dn = vt.key, Ar = Be; Ar !== null; ) {
                  if (Ar.key === Dn) {
                    if (Dn = vt.type, Dn === _) {
                      if (Ar.tag === 7) {
                        R(ot, Ar.sibling), Be = V(Ar, vt.props.children), Be.return = ot, ot = Be;
                        break e;
                      }
                    } else if (Ar.elementType === Dn || typeof Dn == "object" && Dn !== null && Dn.$$typeof === k && Fc(Dn) === Ar.type) {
                      R(ot, Ar.sibling), Be = V(Ar, vt.props), Be.ref = Lf(ot, Ar, vt), Be.return = ot, ot = Be;
                      break e;
                    }
                    R(ot, Ar);
                    break;
                  } else
                    g(ot, Ar);
                  Ar = Ar.sibling;
                }
                vt.type === _ ? (Be = zl(vt.props.children, ot.mode, Pt, vt.key), Be.return = ot, ot = Be) : (Pt = tf(vt.type, vt.key, vt.props, null, ot.mode, Pt), Pt.ref = Lf(ot, Be, vt), Pt.return = ot, ot = Pt);
              }
              return Me(ot);
            case y:
              e: {
                for (Ar = vt.key; Be !== null; ) {
                  if (Be.key === Ar)
                    if (Be.tag === 4 && Be.stateNode.containerInfo === vt.containerInfo && Be.stateNode.implementation === vt.implementation) {
                      R(ot, Be.sibling), Be = V(Be, vt.children || []), Be.return = ot, ot = Be;
                      break e;
                    } else {
                      R(ot, Be);
                      break;
                    }
                  else
                    g(ot, Be);
                  Be = Be.sibling;
                }
                Be = pu(vt, ot.mode, Pt), Be.return = ot, ot = Be;
              }
              return Me(ot);
            case k:
              return Ar = vt._init, Va(ot, Be, Ar(vt._payload), Pt);
          }
          if (Re(vt))
            return yn(ot, Be, vt, Pt);
          if (Y(vt))
            return fi(ot, Be, vt, Pt);
          Us(ot, vt);
        }
        return typeof vt == "string" && vt !== "" || typeof vt == "number" ? (vt = "" + vt, Be !== null && Be.tag === 6 ? (R(ot, Be.sibling), Be = V(Be, vt), Be.return = ot, ot = Be) : (R(ot, Be), Be = nf(vt, ot.mode, Pt), Be.return = ot, ot = Be), Me(ot)) : R(ot, Be);
      }
      return Va;
    }
    var Tu = nc(!0), lp = nc(!1), xd = {}, cs = ir(xd), _d = ir(xd), Bc = ir(xd);
    function iu(m) {
      if (m === xd)
        throw Error(u(174));
      return m;
    }
    function up(m, g) {
      fr(Bc, g), fr(_d, m), fr(cs, xd), m = Te(g), Cr(cs), fr(cs, m);
    }
    function Ed() {
      Cr(cs), Cr(_d), Cr(Bc);
    }
    function cp(m) {
      var g = iu(Bc.current), R = iu(cs.current);
      g = ue(R, m.type, g), R !== g && (fr(_d, m), fr(cs, g));
    }
    function Rl(m) {
      _d.current === m && (Cr(cs), Cr(_d));
    }
    var la = ir(0);
    function bd(m) {
      for (var g = m; g !== null; ) {
        if (g.tag === 13) {
          var R = g.memoizedState;
          if (R !== null && (R = R.dehydrated, R === null || _l(R) || ea(R)))
            return g;
        } else if (g.tag === 19 && g.memoizedProps.revealOrder !== void 0) {
          if (g.flags & 128)
            return g;
        } else if (g.child !== null) {
          g.child.return = g, g = g.child;
          continue;
        }
        if (g === m)
          break;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === m)
            return null;
          g = g.return;
        }
        g.sibling.return = g.return, g = g.sibling;
      }
      return null;
    }
    var Ia = [];
    function al() {
      for (var m = 0; m < Ia.length; m++) {
        var g = Ia[m];
        $t ? g._workInProgressVersionPrimary = null : g._workInProgressVersionSecondary = null;
      }
      Ia.length = 0;
    }
    var fo = h.ReactCurrentDispatcher, Gi = h.ReactCurrentBatchConfig, Hc = 0, Zr = null, Mi = null, ki = null, Td = !1, ho = !1, Of = 0, rc = 0;
    function eo() {
      throw Error(u(321));
    }
    function Al(m, g) {
      if (g === null)
        return !1;
      for (var R = 0; R < g.length && R < m.length; R++)
        if (!Wo(m[R], g[R]))
          return !1;
      return !0;
    }
    function Vc(m, g, R, z, V, Q) {
      if (Hc = Q, Zr = g, g.memoizedState = null, g.updateQueue = null, g.lanes = 0, fo.current = m === null || m.memoizedState === null ? Gc : Rd, m = R(z, V), ho) {
        Q = 0;
        do {
          if (ho = !1, Of = 0, 25 <= Q)
            throw Error(u(301));
          Q += 1, ki = Mi = null, g.updateQueue = null, fo.current = Wc, m = R(z, V);
        } while (ho);
      }
      if (fo.current = Uf, g = Mi !== null && Mi.next !== null, Hc = 0, ki = Mi = Zr = null, Td = !1, g)
        throw Error(u(300));
      return m;
    }
    function Mu() {
      var m = Of !== 0;
      return Of = 0, m;
    }
    function au() {
      var m = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return ki === null ? Zr.memoizedState = ki = m : ki = ki.next = m, ki;
    }
    function Dl() {
      if (Mi === null) {
        var m = Zr.alternate;
        m = m !== null ? m.memoizedState : null;
      } else
        m = Mi.next;
      var g = ki === null ? Zr.memoizedState : ki.next;
      if (g !== null)
        ki = g, Mi = m;
      else {
        if (m === null)
          throw Error(u(310));
        Mi = m, m = { memoizedState: Mi.memoizedState, baseState: Mi.baseState, baseQueue: Mi.baseQueue, queue: Mi.queue, next: null }, ki === null ? Zr.memoizedState = ki = m : ki = ki.next = m;
      }
      return ki;
    }
    function na(m, g) {
      return typeof g == "function" ? g(m) : g;
    }
    function Md(m) {
      var g = Dl(), R = g.queue;
      if (R === null)
        throw Error(u(311));
      R.lastRenderedReducer = m;
      var z = Mi, V = z.baseQueue, Q = R.pending;
      if (Q !== null) {
        if (V !== null) {
          var Me = V.next;
          V.next = Q.next, Q.next = Me;
        }
        z.baseQueue = V = Q, R.pending = null;
      }
      if (V !== null) {
        Q = V.next, z = z.baseState;
        var We = Me = null, Mt = null, Qt = Q;
        do {
          var cn = Qt.lane;
          if ((Hc & cn) === cn)
            Mt !== null && (Mt = Mt.next = { lane: 0, action: Qt.action, hasEagerState: Qt.hasEagerState, eagerState: Qt.eagerState, next: null }), z = Qt.hasEagerState ? Qt.eagerState : m(z, Qt.action);
          else {
            var sr = {
              lane: cn,
              action: Qt.action,
              hasEagerState: Qt.hasEagerState,
              eagerState: Qt.eagerState,
              next: null
            };
            Mt === null ? (We = Mt = sr, Me = z) : Mt = Mt.next = sr, Zr.lanes |= cn, Ou |= cn;
          }
          Qt = Qt.next;
        } while (Qt !== null && Qt !== Q);
        Mt === null ? Me = z : Mt.next = We, Wo(z, g.memoizedState) || (Hr = !0), g.memoizedState = z, g.baseState = Me, g.baseQueue = Mt, R.lastRenderedState = z;
      }
      if (m = R.interleaved, m !== null) {
        V = m;
        do
          Q = V.lane, Zr.lanes |= Q, Ou |= Q, V = V.next;
        while (V !== m);
      } else
        V === null && (R.lanes = 0);
      return [g.memoizedState, R.dispatch];
    }
    function fp(m) {
      var g = Dl(), R = g.queue;
      if (R === null)
        throw Error(u(311));
      R.lastRenderedReducer = m;
      var z = R.dispatch, V = R.pending, Q = g.memoizedState;
      if (V !== null) {
        R.pending = null;
        var Me = V = V.next;
        do
          Q = m(Q, Me.action), Me = Me.next;
        while (Me !== V);
        Wo(Q, g.memoizedState) || (Hr = !0), g.memoizedState = Q, g.baseQueue === null && (g.baseState = Q), R.lastRenderedState = Q;
      }
      return [Q, z];
    }
    function Pf() {
    }
    function Em(m, g) {
      var R = Zr, z = Dl(), V = g(), Q = !Wo(z.memoizedState, V);
      if (Q && (z.memoizedState = V, Hr = !0), z = z.queue, Gt(Ur.bind(null, R, z, m), [m]), z.getSnapshot !== g || Q || ki !== null && ki.memoizedState.tag & 1) {
        if (R.flags |= 2048, ph(9, Ii.bind(null, R, z, V, g), void 0, null), ia === null)
          throw Error(u(349));
        Hc & 30 || mr(R, g, V);
      }
      return V;
    }
    function mr(m, g, R) {
      m.flags |= 16384, m = { getSnapshot: g, value: R }, g = Zr.updateQueue, g === null ? (g = { lastEffect: null, stores: null }, Zr.updateQueue = g, g.stores = [m]) : (R = g.stores, R === null ? g.stores = [m] : R.push(m));
    }
    function Ii(m, g, R, z) {
      g.value = R, g.getSnapshot = z, ma(g) && Ws(m, 1, -1);
    }
    function Ur(m, g, R) {
      return R(function() {
        ma(g) && Ws(m, 1, -1);
      });
    }
    function ma(m) {
      var g = m.getSnapshot;
      m = m.value;
      try {
        var R = g();
        return !Wo(m, R);
      } catch {
        return !0;
      }
    }
    function No(m) {
      var g = au();
      return typeof m == "function" && (m = m()), g.memoizedState = g.baseState = m, m = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: na, lastRenderedState: m }, g.queue = m, m = m.dispatch = hp.bind(null, Zr, m), [g.memoizedState, m];
    }
    function ph(m, g, R, z) {
      return m = { tag: m, create: g, destroy: R, deps: z, next: null }, g = Zr.updateQueue, g === null ? (g = { lastEffect: null, stores: null }, Zr.updateQueue = g, g.lastEffect = m.next = m) : (R = g.lastEffect, R === null ? g.lastEffect = m.next = m : (z = R.next, R.next = m, m.next = z, g.lastEffect = m)), m;
    }
    function mh() {
      return Dl().memoizedState;
    }
    function Nf(m, g, R, z) {
      var V = au();
      Zr.flags |= m, V.memoizedState = ph(1 | g, R, void 0, z === void 0 ? null : z);
    }
    function bm(m, g, R, z) {
      var V = Dl();
      z = z === void 0 ? null : z;
      var Q = void 0;
      if (Mi !== null) {
        var Me = Mi.memoizedState;
        if (Q = Me.destroy, z !== null && Al(z, Me.deps)) {
          V.memoizedState = ph(g, R, Q, z);
          return;
        }
      }
      Zr.flags |= m, V.memoizedState = ph(1 | g, R, Q, z);
    }
    function vh(m, g) {
      return Nf(8390656, 8, m, g);
    }
    function Gt(m, g) {
      return bm(2048, 8, m, g);
    }
    function Tr(m, g) {
      return bm(4, 2, m, g);
    }
    function wr(m, g) {
      return bm(4, 4, m, g);
    }
    function zs(m, g) {
      if (typeof g == "function")
        return m = m(), g(m), function() {
          g(null);
        };
      if (g != null)
        return m = m(), g.current = m, function() {
          g.current = null;
        };
    }
    function ol(m, g, R) {
      return R = R != null ? R.concat([m]) : null, bm(4, 4, zs.bind(null, g, m), R);
    }
    function ic() {
    }
    function Ll(m, g) {
      var R = Dl();
      g = g === void 0 ? null : g;
      var z = R.memoizedState;
      return z !== null && g !== null && Al(g, z[1]) ? z[0] : (R.memoizedState = [m, g], m);
    }
    function ac(m, g) {
      var R = Dl();
      g = g === void 0 ? null : g;
      var z = R.memoizedState;
      return z !== null && g !== null && Al(g, z[1]) ? z[0] : (m = m(), R.memoizedState = [m, g], m);
    }
    function oc(m, g) {
      var R = br;
      br = R !== 0 && 4 > R ? R : 4, m(!0);
      var z = Gi.transition;
      Gi.transition = {};
      try {
        m(!1), g();
      } finally {
        br = R, Gi.transition = z;
      }
    }
    function ou() {
      return Dl().memoizedState;
    }
    function dp(m, g, R) {
      var z = wo(m);
      R = { lane: z, action: R, hasEagerState: !1, eagerState: null, next: null }, Tm(m) ? gh(g, R) : (wd(m, g, R), R = Yr(), m = Ws(m, z, R), m !== null && Cd(m, g, z));
    }
    function hp(m, g, R) {
      var z = wo(m), V = { lane: z, action: R, hasEagerState: !1, eagerState: null, next: null };
      if (Tm(m))
        gh(g, V);
      else {
        wd(m, g, V);
        var Q = m.alternate;
        if (m.lanes === 0 && (Q === null || Q.lanes === 0) && (Q = g.lastRenderedReducer, Q !== null))
          try {
            var Me = g.lastRenderedState, We = Q(Me, R);
            if (V.hasEagerState = !0, V.eagerState = We, Wo(We, Me))
              return;
          } catch {
          } finally {
          }
        R = Yr(), m = Ws(m, z, R), m !== null && Cd(m, g, z);
      }
    }
    function Tm(m) {
      var g = m.alternate;
      return m === Zr || g !== null && g === Zr;
    }
    function gh(m, g) {
      ho = Td = !0;
      var R = m.pending;
      R === null ? g.next = g : (g.next = R.next, R.next = g), m.pending = g;
    }
    function wd(m, g, R) {
      ia !== null && m.mode & 1 && !(zr & 2) ? (m = g.interleaved, m === null ? (R.next = R, Qr === null ? Qr = [g] : Qr.push(g)) : (R.next = m.next, m.next = R), g.interleaved = R) : (m = g.pending, m === null ? R.next = R : (R.next = m.next, m.next = R), g.pending = R);
    }
    function Cd(m, g, R) {
      if (R & 4194240) {
        var z = g.lanes;
        z &= m.pendingLanes, R |= z, g.lanes = R, pa(m, R);
      }
    }
    var Uf = { readContext: Br, useCallback: eo, useContext: eo, useEffect: eo, useImperativeHandle: eo, useInsertionEffect: eo, useLayoutEffect: eo, useMemo: eo, useReducer: eo, useRef: eo, useState: eo, useDebugValue: eo, useDeferredValue: eo, useTransition: eo, useMutableSource: eo, useSyncExternalStore: eo, useId: eo, unstable_isNewReconciler: !1 }, Gc = { readContext: Br, useCallback: function(m, g) {
      return au().memoizedState = [m, g === void 0 ? null : g], m;
    }, useContext: Br, useEffect: vh, useImperativeHandle: function(m, g, R) {
      return R = R != null ? R.concat([m]) : null, Nf(
        4194308,
        4,
        zs.bind(null, g, m),
        R
      );
    }, useLayoutEffect: function(m, g) {
      return Nf(4194308, 4, m, g);
    }, useInsertionEffect: function(m, g) {
      return Nf(4, 2, m, g);
    }, useMemo: function(m, g) {
      var R = au();
      return g = g === void 0 ? null : g, m = m(), R.memoizedState = [m, g], m;
    }, useReducer: function(m, g, R) {
      var z = au();
      return g = R !== void 0 ? R(g) : g, z.memoizedState = z.baseState = g, m = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: m, lastRenderedState: g }, z.queue = m, m = m.dispatch = dp.bind(null, Zr, m), [z.memoizedState, m];
    }, useRef: function(m) {
      var g = au();
      return m = { current: m }, g.memoizedState = m;
    }, useState: No, useDebugValue: ic, useDeferredValue: function(m) {
      var g = No(m), R = g[0], z = g[1];
      return vh(function() {
        var V = Gi.transition;
        Gi.transition = {};
        try {
          z(m);
        } finally {
          Gi.transition = V;
        }
      }, [m]), R;
    }, useTransition: function() {
      var m = No(!1), g = m[0];
      return m = oc.bind(null, m[1]), au().memoizedState = m, [g, m];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(m, g, R) {
      var z = Zr, V = au();
      if (Yi) {
        if (R === void 0)
          throw Error(u(407));
        R = R();
      } else {
        if (R = g(), ia === null)
          throw Error(u(349));
        Hc & 30 || mr(z, g, R);
      }
      V.memoizedState = R;
      var Q = { value: R, getSnapshot: g };
      return V.queue = Q, vh(Ur.bind(null, z, Q, m), [m]), z.flags |= 2048, ph(9, Ii.bind(null, z, Q, R, g), void 0, null), R;
    }, useId: function() {
      var m = au(), g = ia.identifierPrefix;
      if (Yi) {
        var R = ru, z = kc;
        R = (z & ~(1 << 32 - Go(z) - 1)).toString(32) + R, g = ":" + g + "R" + R, R = Of++, 0 < R && (g += "H" + R.toString(32)), g += ":";
      } else
        R = rc++, g = ":" + g + "r" + R.toString(32) + ":";
      return m.memoizedState = g;
    }, unstable_isNewReconciler: !1 }, Rd = {
      readContext: Br,
      useCallback: Ll,
      useContext: Br,
      useEffect: Gt,
      useImperativeHandle: ol,
      useInsertionEffect: Tr,
      useLayoutEffect: wr,
      useMemo: ac,
      useReducer: Md,
      useRef: mh,
      useState: function() {
        return Md(na);
      },
      useDebugValue: ic,
      useDeferredValue: function(m) {
        var g = Md(na), R = g[0], z = g[1];
        return Gt(function() {
          var V = Gi.transition;
          Gi.transition = {};
          try {
            z(m);
          } finally {
            Gi.transition = V;
          }
        }, [m]), R;
      },
      useTransition: function() {
        var m = Md(na)[0], g = Dl().memoizedState;
        return [m, g];
      },
      useMutableSource: Pf,
      useSyncExternalStore: Em,
      useId: ou,
      unstable_isNewReconciler: !1
    }, Wc = {
      readContext: Br,
      useCallback: Ll,
      useContext: Br,
      useEffect: Gt,
      useImperativeHandle: ol,
      useInsertionEffect: Tr,
      useLayoutEffect: wr,
      useMemo: ac,
      useReducer: fp,
      useRef: mh,
      useState: function() {
        return fp(na);
      },
      useDebugValue: ic,
      useDeferredValue: function(m) {
        var g = fp(na), R = g[0], z = g[1];
        return Gt(function() {
          var V = Gi.transition;
          Gi.transition = {};
          try {
            z(m);
          } finally {
            Gi.transition = V;
          }
        }, [m]), R;
      },
      useTransition: function() {
        var m = fp(na)[0], g = Dl().memoizedState;
        return [m, g];
      },
      useMutableSource: Pf,
      useSyncExternalStore: Em,
      useId: ou,
      unstable_isNewReconciler: !1
    };
    function yh(m, g) {
      try {
        var R = "", z = g;
        do
          R += ne(z), z = z.return;
        while (z);
        var V = R;
      } catch (Q) {
        V = `
Error generating stack: ` + Q.message + `
` + Q.stack;
      }
      return { value: m, source: g, stack: V };
    }
    function Ad(m, g) {
      try {
        console.error(g.value);
      } catch (R) {
        setTimeout(function() {
          throw R;
        });
      }
    }
    var pp = typeof WeakMap == "function" ? WeakMap : Map;
    function Mm(m, g, R) {
      R = rl(-1, R), R.tag = 3, R.payload = { element: null };
      var z = g.value;
      return R.callback = function() {
        qc || (qc = !0, cl = z), Ad(m, g);
      }, R;
    }
    function wu(m, g, R) {
      R = rl(-1, R), R.tag = 3;
      var z = m.type.getDerivedStateFromError;
      if (typeof z == "function") {
        var V = g.value;
        R.payload = function() {
          return z(V);
        }, R.callback = function() {
          Ad(m, g);
        };
      }
      var Q = m.stateNode;
      return Q !== null && typeof Q.componentDidCatch == "function" && (R.callback = function() {
        Ad(m, g), typeof z != "function" && (fu === null ? fu = /* @__PURE__ */ new Set([this]) : fu.add(this));
        var Me = g.stack;
        this.componentDidCatch(g.value, { componentStack: Me !== null ? Me : "" });
      }), R;
    }
    function ks(m, g, R) {
      var z = m.pingCache;
      if (z === null) {
        z = m.pingCache = new pp();
        var V = /* @__PURE__ */ new Set();
        z.set(g, V);
      } else
        V = z.get(g), V === void 0 && (V = /* @__PURE__ */ new Set(), z.set(g, V));
      V.has(R) || (V.add(R), m = Pl.bind(null, m, g, R), g.then(m, m));
    }
    function Cu(m) {
      do {
        var g;
        if ((g = m.tag === 13) && (g = m.memoizedState, g = g !== null ? g.dehydrated !== null : !0), g)
          return m;
        m = m.return;
      } while (m !== null);
      return null;
    }
    function Ru(m, g, R, z, V) {
      return m.mode & 1 ? (m.flags |= 65536, m.lanes = V, m) : (m === g ? m.flags |= 65536 : (m.flags |= 128, R.flags |= 131072, R.flags &= -52805, R.tag === 1 && (R.alternate === null ? R.tag = 17 : (g = rl(-1, 1), g.tag = 2, eu(R, g))), R.lanes |= 1), m);
    }
    function to(m) {
      m.flags |= 4;
    }
    function sc(m, g) {
      if (m !== null && m.child === g.child)
        return !0;
      if (g.flags & 16)
        return !1;
      for (m = g.child; m !== null; ) {
        if (m.flags & 12854 || m.subtreeFlags & 12854)
          return !1;
        m = m.sibling;
      }
      return !0;
    }
    var Is, zf, kf, Dd;
    if (Ht)
      Is = function(m, g) {
        for (var R = g.child; R !== null; ) {
          if (R.tag === 5 || R.tag === 6)
            ce(m, R.stateNode);
          else if (R.tag !== 4 && R.child !== null) {
            R.child.return = R, R = R.child;
            continue;
          }
          if (R === g)
            break;
          for (; R.sibling === null; ) {
            if (R.return === null || R.return === g)
              return;
            R = R.return;
          }
          R.sibling.return = R.return, R = R.sibling;
        }
      }, zf = function() {
      }, kf = function(m, g, R, z, V) {
        if (m = m.memoizedProps, m !== z) {
          var Q = g.stateNode, Me = iu(cs.current);
          R = Oe(Q, R, m, z, V, Me), (g.updateQueue = R) && to(g);
        }
      }, Dd = function(m, g, R, z) {
        R !== z && to(g);
      };
    else if (he) {
      Is = function(m, g, R, z) {
        for (var V = g.child; V !== null; ) {
          if (V.tag === 5) {
            var Q = V.stateNode;
            R && z && (Q = vr(Q, V.type, V.memoizedProps, V)), ce(m, Q);
          } else if (V.tag === 6)
            Q = V.stateNode, R && z && (Q = Ai(Q, V.memoizedProps, V)), ce(m, Q);
          else if (V.tag !== 4) {
            if (V.tag === 22 && V.memoizedState !== null)
              Q = V.child, Q !== null && (Q.return = V), Is(m, V, !0, !0);
            else if (V.child !== null) {
              V.child.return = V, V = V.child;
              continue;
            }
          }
          if (V === g)
            break;
          for (; V.sibling === null; ) {
            if (V.return === null || V.return === g)
              return;
            V = V.return;
          }
          V.sibling.return = V.return, V = V.sibling;
        }
      };
      var $o = function(m, g, R, z) {
        for (var V = g.child; V !== null; ) {
          if (V.tag === 5) {
            var Q = V.stateNode;
            R && z && (Q = vr(Q, V.type, V.memoizedProps, V)), yr(m, Q);
          } else if (V.tag === 6)
            Q = V.stateNode, R && z && (Q = Ai(Q, V.memoizedProps, V)), yr(m, Q);
          else if (V.tag !== 4) {
            if (V.tag === 22 && V.memoizedState !== null)
              Q = V.child, Q !== null && (Q.return = V), $o(m, V, !0, !0);
            else if (V.child !== null) {
              V.child.return = V, V = V.child;
              continue;
            }
          }
          if (V === g)
            break;
          for (; V.sibling === null; ) {
            if (V.return === null || V.return === g)
              return;
            V = V.return;
          }
          V.sibling.return = V.return, V = V.sibling;
        }
      };
      zf = function(m, g) {
        var R = g.stateNode;
        if (!sc(m, g)) {
          m = R.containerInfo;
          var z = zn(m);
          $o(z, g, !1, !1), R.pendingChildren = z, to(g), ti(m, z);
        }
      }, kf = function(m, g, R, z, V) {
        var Q = m.stateNode, Me = m.memoizedProps;
        if ((m = sc(m, g)) && Me === z)
          g.stateNode = Q;
        else {
          var We = g.stateNode, Mt = iu(cs.current), Qt = null;
          Me !== z && (Qt = Oe(We, R, Me, z, V, Mt)), m && Qt === null ? g.stateNode = Q : (Q = ln(Q, Qt, R, Me, z, g, m, We), Ue(Q, R, z, V, Mt) && to(g), g.stateNode = Q, m ? to(g) : Is(Q, g, !1, !1));
        }
      }, Dd = function(m, g, R, z) {
        R !== z ? (m = iu(Bc.current), R = iu(cs.current), g.stateNode = je(z, m, R, g), to(g)) : g.stateNode = m.stateNode;
      };
    } else
      zf = function() {
      }, kf = function() {
      }, Dd = function() {
      };
    function Fs(m, g) {
      if (!Yi)
        switch (m.tailMode) {
          case "hidden":
            g = m.tail;
            for (var R = null; g !== null; )
              g.alternate !== null && (R = g), g = g.sibling;
            R === null ? m.tail = null : R.sibling = null;
            break;
          case "collapsed":
            R = m.tail;
            for (var z = null; R !== null; )
              R.alternate !== null && (z = R), R = R.sibling;
            z === null ? g || m.tail === null ? m.tail = null : m.tail.sibling = null : z.sibling = null;
        }
    }
    function xi(m) {
      var g = m.alternate !== null && m.alternate.child === m.child, R = 0, z = 0;
      if (g)
        for (var V = m.child; V !== null; )
          R |= V.lanes | V.childLanes, z |= V.subtreeFlags & 14680064, z |= V.flags & 14680064, V.return = m, V = V.sibling;
      else
        for (V = m.child; V !== null; )
          R |= V.lanes | V.childLanes, z |= V.subtreeFlags, z |= V.flags, V.return = m, V = V.sibling;
      return m.subtreeFlags |= z, m.childLanes = R, g;
    }
    function Kn(m, g, R) {
      var z = g.pendingProps;
      switch (ka(g), g.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return xi(g), null;
        case 1:
          return Vi(g.type) && Po(), xi(g), null;
        case 3:
          return z = g.stateNode, Ed(), Cr(ni), Cr(wa), al(), z.pendingContext && (z.context = z.pendingContext, z.pendingContext = null), (m === null || m.child === null) && (sp(g) ? to(g) : m === null || m.memoizedState.isDehydrated && !(g.flags & 256) || (g.flags |= 1024, jo !== null && (Ct(jo), jo = null))), zf(m, g), xi(g), null;
        case 5:
          Rl(g), R = iu(Bc.current);
          var V = g.type;
          if (m !== null && g.stateNode != null)
            kf(m, g, V, z, R), m.ref !== g.ref && (g.flags |= 512, g.flags |= 2097152);
          else {
            if (!z) {
              if (g.stateNode === null)
                throw Error(u(166));
              return xi(g), null;
            }
            if (m = iu(cs.current), sp(g)) {
              if (!nt)
                throw Error(u(175));
              m = _n(g.stateNode, g.type, g.memoizedProps, R, m, g, !gd), g.updateQueue = m, m !== null && to(g);
            } else {
              var Q = me(V, z, R, m, g);
              Is(Q, g, !1, !1), g.stateNode = Q, Ue(Q, V, z, R, m) && to(g);
            }
            g.ref !== null && (g.flags |= 512, g.flags |= 2097152);
          }
          return xi(g), null;
        case 6:
          if (m && g.stateNode != null)
            Dd(m, g, m.memoizedProps, z);
          else {
            if (typeof z != "string" && g.stateNode === null)
              throw Error(u(166));
            if (m = iu(Bc.current), R = iu(cs.current), sp(g)) {
              if (!nt)
                throw Error(u(176));
              if (m = g.stateNode, z = g.memoizedProps, (R = ve(m, z, g, !gd)) && (V = Ra, V !== null))
                switch (Q = (V.mode & 1) !== 0, V.tag) {
                  case 3:
                    Gn(V.stateNode.containerInfo, m, z, Q);
                    break;
                  case 5:
                    cr(V.type, V.memoizedProps, V.stateNode, m, z, Q);
                }
              R && to(g);
            } else
              g.stateNode = je(z, m, R, g);
          }
          return xi(g), null;
        case 13:
          if (Cr(la), z = g.memoizedState, Yi && Aa !== null && g.mode & 1 && !(g.flags & 128)) {
            for (m = Aa; m; )
              m = Eo(m);
            return Sd(), g.flags |= 98560, g;
          }
          if (z !== null && z.dehydrated !== null) {
            if (z = sp(g), m === null) {
              if (!z)
                throw Error(u(318));
              if (!nt)
                throw Error(u(344));
              if (m = g.memoizedState, m = m !== null ? m.dehydrated : null, !m)
                throw Error(u(317));
              $e(m, g);
            } else
              Sd(), !(g.flags & 128) && (g.memoizedState = null), g.flags |= 4;
            return xi(g), null;
          }
          return jo !== null && (Ct(jo), jo = null), g.flags & 128 ? (g.lanes = R, g) : (z = z !== null, R = !1, m === null ? sp(g) : R = m.memoizedState !== null, z && !R && (g.child.flags |= 8192, g.mode & 1 && (m === null || la.current & 1 ? vo === 0 && (vo = 3) : Jc())), g.updateQueue !== null && (g.flags |= 4), xi(g), null);
        case 4:
          return Ed(), zf(m, g), m === null && Rt(g.stateNode.containerInfo), xi(g), null;
        case 10:
          return Nr(g.type._context), xi(g), null;
        case 17:
          return Vi(g.type) && Po(), xi(g), null;
        case 19:
          if (Cr(la), V = g.memoizedState, V === null)
            return xi(g), null;
          if (z = (g.flags & 128) !== 0, Q = V.rendering, Q === null)
            if (z)
              Fs(V, !1);
            else {
              if (vo !== 0 || m !== null && m.flags & 128)
                for (m = g.child; m !== null; ) {
                  if (Q = bd(m), Q !== null) {
                    for (g.flags |= 128, Fs(V, !1), m = Q.updateQueue, m !== null && (g.updateQueue = m, g.flags |= 4), g.subtreeFlags = 0, m = R, z = g.child; z !== null; )
                      R = z, V = m, R.flags &= 14680066, Q = R.alternate, Q === null ? (R.childLanes = 0, R.lanes = V, R.child = null, R.subtreeFlags = 0, R.memoizedProps = null, R.memoizedState = null, R.updateQueue = null, R.dependencies = null, R.stateNode = null) : (R.childLanes = Q.childLanes, R.lanes = Q.lanes, R.child = Q.child, R.subtreeFlags = 0, R.deletions = null, R.memoizedProps = Q.memoizedProps, R.memoizedState = Q.memoizedState, R.updateQueue = Q.updateQueue, R.type = Q.type, V = Q.dependencies, R.dependencies = V === null ? null : { lanes: V.lanes, firstContext: V.firstContext }), z = z.sibling;
                    return fr(la, la.current & 1 | 2), g.child;
                  }
                  m = m.sibling;
                }
              V.tail !== null && si() > Gf && (g.flags |= 128, z = !0, Fs(V, !1), g.lanes = 4194304);
            }
          else {
            if (!z)
              if (m = bd(Q), m !== null) {
                if (g.flags |= 128, z = !0, m = m.updateQueue, m !== null && (g.updateQueue = m, g.flags |= 4), Fs(V, !0), V.tail === null && V.tailMode === "hidden" && !Q.alternate && !Yi)
                  return xi(g), null;
              } else
                2 * si() - V.renderingStartTime > Gf && R !== 1073741824 && (g.flags |= 128, z = !0, Fs(V, !1), g.lanes = 4194304);
            V.isBackwards ? (Q.sibling = g.child, g.child = Q) : (m = V.last, m !== null ? m.sibling = Q : g.child = Q, V.last = Q);
          }
          return V.tail !== null ? (g = V.tail, V.rendering = g, V.tail = g.sibling, V.renderingStartTime = si(), g.sibling = null, m = la.current, fr(la, z ? m & 1 | 2 : m & 1), g) : (xi(g), null);
        case 22:
        case 23:
          return Uo(), z = g.memoizedState !== null, m !== null && m.memoizedState !== null !== z && (g.flags |= 8192), z && g.mode & 1 ? Vs & 1073741824 && (xi(g), Ht && g.subtreeFlags & 6 && (g.flags |= 8192)) : xi(g), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(u(156, g.tag));
    }
    var _i = h.ReactCurrentOwner, Hr = !1;
    function Hn(m, g, R, z) {
      g.child = m === null ? lp(g, null, R, z) : Tu(g, m.child, R, z);
    }
    function ii(m, g, R, z, V) {
      R = R.render;
      var Q = g.ref;
      return Ti(g, V), z = Vc(m, g, R, z, Q, V), R = Mu(), m !== null && !Hr ? (g.updateQueue = m.updateQueue, g.flags &= -2053, m.lanes &= ~V, hi(m, g, V)) : (Yi && R && bu(g), g.flags |= 1, Hn(m, g, z, V), g.child);
    }
    function di(m, g, R, z, V) {
      if (m === null) {
        var Q = R.type;
        return typeof Q == "function" && !Nu(Q) && Q.defaultProps === void 0 && R.compare === null && R.defaultProps === void 0 ? (g.tag = 15, g.type = Q, Au(m, g, Q, z, V)) : (m = tf(R.type, null, z, g, g.mode, V), m.ref = g.ref, m.return = g, g.child = m);
      }
      if (Q = m.child, !(m.lanes & V)) {
        var Me = Q.memoizedProps;
        if (R = R.compare, R = R !== null ? R : nl, R(Me, z) && m.ref === g.ref)
          return hi(m, g, V);
      }
      return g.flags |= 1, m = Xo(Q, z), m.ref = g.ref, m.return = g, g.child = m;
    }
    function Au(m, g, R, z, V) {
      if (m !== null && nl(m.memoizedProps, z) && m.ref === g.ref)
        if (Hr = !1, (m.lanes & V) !== 0)
          m.flags & 131072 && (Hr = !0);
        else
          return g.lanes = m.lanes, hi(m, g, V);
      return fs(m, g, R, z, V);
    }
    function dr(m, g, R) {
      var z = g.pendingProps, V = z.children, Q = m !== null ? m.memoizedState : null;
      if (z.mode === "hidden")
        if (!(g.mode & 1))
          g.memoizedState = { baseLanes: 0, cachePool: null }, fr(Xc, Vs), Vs |= R;
        else if (R & 1073741824)
          g.memoizedState = { baseLanes: 0, cachePool: null }, z = Q !== null ? Q.baseLanes : R, fr(Xc, Vs), Vs |= z;
        else
          return m = Q !== null ? Q.baseLanes | R : R, g.lanes = g.childLanes = 1073741824, g.memoizedState = { baseLanes: m, cachePool: null }, g.updateQueue = null, fr(Xc, Vs), Vs |= m, null;
      else
        Q !== null ? (z = Q.baseLanes | R, g.memoizedState = null) : z = R, fr(Xc, Vs), Vs |= z;
      return Hn(m, g, V, R), g.child;
    }
    function Da(m, g) {
      var R = g.ref;
      (m === null && R !== null || m !== null && m.ref !== R) && (g.flags |= 512, g.flags |= 2097152);
    }
    function fs(m, g, R, z, V) {
      var Q = Vi(R) ? ss : wa.current;
      return Q = ta(g, Q), Ti(g, V), R = Vc(m, g, R, z, Q, V), z = Mu(), m !== null && !Hr ? (g.updateQueue = m.updateQueue, g.flags &= -2053, m.lanes &= ~V, hi(m, g, V)) : (Yi && z && bu(g), g.flags |= 1, Hn(m, g, R, V), g.child);
    }
    function Bs(m, g, R, z, V) {
      if (Vi(R)) {
        var Q = !0;
        Ds(g);
      } else
        Q = !1;
      if (Ti(g, V), g.stateNode === null)
        m !== null && (m.alternate = null, g.alternate = null, g.flags |= 2), gm(g, R, z), ym(g, R, z, V), z = !0;
      else if (m === null) {
        var Me = g.stateNode, We = g.memoizedProps;
        Me.props = We;
        var Mt = Me.context, Qt = R.contextType;
        typeof Qt == "object" && Qt !== null ? Qt = Br(Qt) : (Qt = Vi(R) ? ss : wa.current, Qt = ta(g, Qt));
        var cn = R.getDerivedStateFromProps, sr = typeof cn == "function" || typeof Me.getSnapshotBeforeUpdate == "function";
        sr || typeof Me.UNSAFE_componentWillReceiveProps != "function" && typeof Me.componentWillReceiveProps != "function" || (We !== z || Mt !== Qt) && Cv(g, Me, z, Qt), li = !1;
        var Jn = g.memoizedState;
        Me.state = Jn, Rf(g, z, Me, V), Mt = g.memoizedState, We !== z || Jn !== Mt || ni.current || li ? (typeof cn == "function" && (pm(g, R, cn, z), Mt = g.memoizedState), (We = li || vm(g, R, We, z, Jn, Mt, Qt)) ? (sr || typeof Me.UNSAFE_componentWillMount != "function" && typeof Me.componentWillMount != "function" || (typeof Me.componentWillMount == "function" && Me.componentWillMount(), typeof Me.UNSAFE_componentWillMount == "function" && Me.UNSAFE_componentWillMount()), typeof Me.componentDidMount == "function" && (g.flags |= 4194308)) : (typeof Me.componentDidMount == "function" && (g.flags |= 4194308), g.memoizedProps = z, g.memoizedState = Mt), Me.props = z, Me.state = Mt, Me.context = Qt, z = We) : (typeof Me.componentDidMount == "function" && (g.flags |= 4194308), z = !1);
      } else {
        Me = g.stateNode, Cl(m, g), We = g.memoizedProps, Qt = g.type === g.elementType ? We : De(g.type, We), Me.props = Qt, sr = g.pendingProps, Jn = Me.context, Mt = R.contextType, typeof Mt == "object" && Mt !== null ? Mt = Br(Mt) : (Mt = Vi(R) ? ss : wa.current, Mt = ta(g, Mt));
        var aa = R.getDerivedStateFromProps;
        (cn = typeof aa == "function" || typeof Me.getSnapshotBeforeUpdate == "function") || typeof Me.UNSAFE_componentWillReceiveProps != "function" && typeof Me.componentWillReceiveProps != "function" || (We !== sr || Jn !== Mt) && Cv(g, Me, z, Mt), li = !1, Jn = g.memoizedState, Me.state = Jn, Rf(g, z, Me, V);
        var yn = g.memoizedState;
        We !== sr || Jn !== yn || ni.current || li ? (typeof aa == "function" && (pm(g, R, aa, z), yn = g.memoizedState), (Qt = li || vm(g, R, Qt, z, Jn, yn, Mt) || !1) ? (cn || typeof Me.UNSAFE_componentWillUpdate != "function" && typeof Me.componentWillUpdate != "function" || (typeof Me.componentWillUpdate == "function" && Me.componentWillUpdate(
          z,
          yn,
          Mt
        ), typeof Me.UNSAFE_componentWillUpdate == "function" && Me.UNSAFE_componentWillUpdate(z, yn, Mt)), typeof Me.componentDidUpdate == "function" && (g.flags |= 4), typeof Me.getSnapshotBeforeUpdate == "function" && (g.flags |= 1024)) : (typeof Me.componentDidUpdate != "function" || We === m.memoizedProps && Jn === m.memoizedState || (g.flags |= 4), typeof Me.getSnapshotBeforeUpdate != "function" || We === m.memoizedProps && Jn === m.memoizedState || (g.flags |= 1024), g.memoizedProps = z, g.memoizedState = yn), Me.props = z, Me.state = yn, Me.context = Mt, z = Qt) : (typeof Me.componentDidUpdate != "function" || We === m.memoizedProps && Jn === m.memoizedState || (g.flags |= 4), typeof Me.getSnapshotBeforeUpdate != "function" || We === m.memoizedProps && Jn === m.memoizedState || (g.flags |= 1024), z = !1);
      }
      return ua(m, g, R, z, Q, V);
    }
    function ua(m, g, R, z, V, Q) {
      Da(m, g);
      var Me = (g.flags & 128) !== 0;
      if (!z && !Me)
        return V && bl(g, R, !1), hi(m, g, Q);
      z = g.stateNode, _i.current = g;
      var We = Me && typeof R.getDerivedStateFromError != "function" ? null : z.render();
      return g.flags |= 1, m !== null && Me ? (g.child = Tu(g, m.child, null, Q), g.child = Tu(g, null, We, Q)) : Hn(m, g, We, Q), g.memoizedState = z.state, V && bl(g, R, !0), g.child;
    }
    function Hs(m) {
      var g = m.stateNode;
      g.pendingContext ? Ui(m, g.pendingContext, g.pendingContext !== g.context) : g.context && Ui(m, g.context, !1), up(m, g.containerInfo);
    }
    function lc(m, g, R, z, V) {
      return Sd(), hh(V), g.flags |= 256, Hn(m, g, R, z), g.child;
    }
    var If = { dehydrated: null, treeContext: null, retryLane: 0 };
    function uc(m) {
      return { baseLanes: m, cachePool: null };
    }
    function Av(m, g, R) {
      var z = g.pendingProps, V = la.current, Q = !1, Me = (g.flags & 128) !== 0, We;
      if ((We = Me) || (We = m !== null && m.memoizedState === null ? !1 : (V & 2) !== 0), We ? (Q = !0, g.flags &= -129) : (m === null || m.memoizedState !== null) && (V |= 1), fr(la, V & 1), m === null)
        return Ic(g), m = g.memoizedState, m !== null && (m = m.dehydrated, m !== null) ? (g.mode & 1 ? ea(m) ? g.lanes = 8 : g.lanes = 1073741824 : g.lanes = 1, null) : (V = z.children, m = z.fallback, Q ? (z = g.mode, Q = g.child, V = { mode: "hidden", children: V }, !(z & 1) && Q !== null ? (Q.childLanes = 0, Q.pendingProps = V) : Q = Yf(V, z, 0, null), m = zl(m, z, R, null), Q.return = g, m.return = g, Q.sibling = m, g.child = Q, g.child.memoizedState = uc(R), g.memoizedState = If, m) : ds(g, V));
      if (V = m.memoizedState, V !== null) {
        if (We = V.dehydrated, We !== null) {
          if (Me)
            return g.flags & 256 ? (g.flags &= -257, su(m, g, R, Error(u(422)))) : g.memoizedState !== null ? (g.child = m.child, g.flags |= 128, null) : (Q = z.fallback, V = g.mode, z = Yf({ mode: "visible", children: z.children }, V, 0, null), Q = zl(Q, V, R, null), Q.flags |= 2, z.return = g, Q.return = g, z.sibling = Q, g.child = z, g.mode & 1 && Tu(
              g,
              m.child,
              null,
              R
            ), g.child.memoizedState = uc(R), g.memoizedState = If, Q);
          if (!(g.mode & 1))
            g = su(m, g, R, null);
          else if (ea(We))
            g = su(m, g, R, Error(u(419)));
          else if (z = (R & m.childLanes) !== 0, Hr || z) {
            if (z = ia, z !== null) {
              switch (R & -R) {
                case 4:
                  Q = 2;
                  break;
                case 16:
                  Q = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  Q = 32;
                  break;
                case 536870912:
                  Q = 268435456;
                  break;
                default:
                  Q = 0;
              }
              z = Q & (z.suspendedLanes | R) ? 0 : Q, z !== 0 && z !== V.retryLane && (V.retryLane = z, Ws(m, z, -1));
            }
            Jc(), g = su(m, g, R, Error(u(421)));
          } else
            _l(We) ? (g.flags |= 128, g.child = m.child, g = Om.bind(null, m), _o(We, g), g = null) : (R = V.treeContext, nt && (Aa = en(We), Ra = g, Yi = !0, jo = null, gd = !1, R !== null && (il[Ps++] = kc, il[Ps++] = ru, il[Ps++] = zc, kc = R.id, ru = R.overflow, zc = g)), g = ds(g, g.pendingProps.children), g.flags |= 4096);
          return g;
        }
        return Q ? (z = Sh(m, g, z.children, z.fallback, R), Q = g.child, V = m.child.memoizedState, Q.memoizedState = V === null ? uc(R) : { baseLanes: V.baseLanes | R, cachePool: null }, Q.childLanes = m.childLanes & ~R, g.memoizedState = If, z) : (R = bo(m, g, z.children, R), g.memoizedState = null, R);
      }
      return Q ? (z = Sh(m, g, z.children, z.fallback, R), Q = g.child, V = m.child.memoizedState, Q.memoizedState = V === null ? uc(R) : { baseLanes: V.baseLanes | R, cachePool: null }, Q.childLanes = m.childLanes & ~R, g.memoizedState = If, z) : (R = bo(m, g, z.children, R), g.memoizedState = null, R);
    }
    function ds(m, g) {
      return g = Yf({ mode: "visible", children: g }, m.mode, 0, null), g.return = m, m.child = g;
    }
    function bo(m, g, R, z) {
      var V = m.child;
      return m = V.sibling, R = Xo(V, { mode: "visible", children: R }), !(g.mode & 1) && (R.lanes = z), R.return = g, R.sibling = null, m !== null && (z = g.deletions, z === null ? (g.deletions = [m], g.flags |= 16) : z.push(m)), g.child = R;
    }
    function Sh(m, g, R, z, V) {
      var Q = g.mode;
      m = m.child;
      var Me = m.sibling, We = { mode: "hidden", children: R };
      return !(Q & 1) && g.child !== m ? (R = g.child, R.childLanes = 0, R.pendingProps = We, g.deletions = null) : (R = Xo(m, We), R.subtreeFlags = m.subtreeFlags & 14680064), Me !== null ? z = Xo(Me, z) : (z = zl(z, Q, V, null), z.flags |= 2), z.return = g, R.return = g, R.sibling = z, g.child = R, z;
    }
    function su(m, g, R, z) {
      return z !== null && hh(z), Tu(g, m.child, null, R), m = ds(g, g.pendingProps.children), m.flags |= 2, g.memoizedState = null, m;
    }
    function Ff(m, g, R) {
      m.lanes |= g;
      var z = m.alternate;
      z !== null && (z.lanes |= g), ri(m.return, g, R);
    }
    function Fa(m, g, R, z, V) {
      var Q = m.memoizedState;
      Q === null ? m.memoizedState = { isBackwards: g, rendering: null, renderingStartTime: 0, last: z, tail: R, tailMode: V } : (Q.isBackwards = g, Q.rendering = null, Q.renderingStartTime = 0, Q.last = z, Q.tail = R, Q.tailMode = V);
    }
    function Du(m, g, R) {
      var z = g.pendingProps, V = z.revealOrder, Q = z.tail;
      if (Hn(m, g, z.children, R), z = la.current, z & 2)
        z = z & 1 | 2, g.flags |= 128;
      else {
        if (m !== null && m.flags & 128)
          e:
            for (m = g.child; m !== null; ) {
              if (m.tag === 13)
                m.memoizedState !== null && Ff(m, R, g);
              else if (m.tag === 19)
                Ff(m, R, g);
              else if (m.child !== null) {
                m.child.return = m, m = m.child;
                continue;
              }
              if (m === g)
                break e;
              for (; m.sibling === null; ) {
                if (m.return === null || m.return === g)
                  break e;
                m = m.return;
              }
              m.sibling.return = m.return, m = m.sibling;
            }
        z &= 1;
      }
      if (fr(la, z), !(g.mode & 1))
        g.memoizedState = null;
      else
        switch (V) {
          case "forwards":
            for (R = g.child, V = null; R !== null; )
              m = R.alternate, m !== null && bd(m) === null && (V = R), R = R.sibling;
            R = V, R === null ? (V = g.child, g.child = null) : (V = R.sibling, R.sibling = null), Fa(g, !1, V, R, Q);
            break;
          case "backwards":
            for (R = null, V = g.child, g.child = null; V !== null; ) {
              if (m = V.alternate, m !== null && bd(m) === null) {
                g.child = V;
                break;
              }
              m = V.sibling, V.sibling = R, R = V, V = m;
            }
            Fa(g, !0, R, null, Q);
            break;
          case "together":
            Fa(g, !1, null, null, void 0);
            break;
          default:
            g.memoizedState = null;
        }
      return g.child;
    }
    function hi(m, g, R) {
      if (m !== null && (g.dependencies = m.dependencies), Ou |= g.lanes, !(R & g.childLanes))
        return null;
      if (m !== null && g.child !== m.child)
        throw Error(u(153));
      if (g.child !== null) {
        for (m = g.child, R = Xo(m, m.pendingProps), g.child = R, R.return = g; m.sibling !== null; )
          m = m.sibling, R = R.sibling = Xo(m, m.pendingProps), R.return = g;
        R.sibling = null;
      }
      return g.child;
    }
    function lu(m, g, R) {
      switch (g.tag) {
        case 3:
          Hs(g), Sd();
          break;
        case 5:
          cp(g);
          break;
        case 1:
          Vi(g.type) && Ds(g);
          break;
        case 4:
          up(g, g.stateNode.containerInfo);
          break;
        case 10:
          qn(g, g.type._context, g.memoizedProps.value);
          break;
        case 13:
          var z = g.memoizedState;
          if (z !== null)
            return z.dehydrated !== null ? (fr(la, la.current & 1), g.flags |= 128, null) : R & g.child.childLanes ? Av(m, g, R) : (fr(la, la.current & 1), m = hi(m, g, R), m !== null ? m.sibling : null);
          fr(la, la.current & 1);
          break;
        case 19:
          if (z = (R & g.childLanes) !== 0, m.flags & 128) {
            if (z)
              return Du(
                m,
                g,
                R
              );
            g.flags |= 128;
          }
          var V = g.memoizedState;
          if (V !== null && (V.rendering = null, V.tail = null, V.lastEffect = null), fr(la, la.current), z)
            break;
          return null;
        case 22:
        case 23:
          return g.lanes = 0, dr(m, g, R);
      }
      return hi(m, g, R);
    }
    function Sr(m, g) {
      switch (ka(g), g.tag) {
        case 1:
          return Vi(g.type) && Po(), m = g.flags, m & 65536 ? (g.flags = m & -65537 | 128, g) : null;
        case 3:
          return Ed(), Cr(ni), Cr(wa), al(), m = g.flags, m & 65536 && !(m & 128) ? (g.flags = m & -65537 | 128, g) : null;
        case 5:
          return Rl(g), null;
        case 13:
          if (Cr(la), m = g.memoizedState, m !== null && m.dehydrated !== null) {
            if (g.alternate === null)
              throw Error(u(340));
            Sd();
          }
          return m = g.flags, m & 65536 ? (g.flags = m & -65537 | 128, g) : null;
        case 19:
          return Cr(la), null;
        case 4:
          return Ed(), null;
        case 10:
          return Nr(g.type._context), null;
        case 22:
        case 23:
          return Uo(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var po = !1, La = !1, Lu = typeof WeakSet == "function" ? WeakSet : Set, rn = null;
    function sl(m, g) {
      var R = m.ref;
      if (R !== null)
        if (typeof R == "function")
          try {
            R(null);
          } catch (z) {
            pi(m, g, z);
          }
        else
          R.current = null;
    }
    function To(m, g, R) {
      try {
        R();
      } catch (z) {
        pi(m, g, z);
      }
    }
    var wm = !1;
    function mp(m, g) {
      for (we(m.containerInfo), rn = g; rn !== null; )
        if (m = rn, g = m.child, (m.subtreeFlags & 1028) !== 0 && g !== null)
          g.return = m, rn = g;
        else
          for (; rn !== null; ) {
            m = rn;
            try {
              var R = m.alternate;
              if (m.flags & 1024)
                switch (m.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (R !== null) {
                      var z = R.memoizedProps, V = R.memoizedState, Q = m.stateNode, Me = Q.getSnapshotBeforeUpdate(m.elementType === m.type ? z : De(m.type, z), V);
                      Q.__reactInternalSnapshotBeforeUpdate = Me;
                    }
                    break;
                  case 3:
                    Ht && ft(m.stateNode.containerInfo);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(u(163));
                }
            } catch (We) {
              pi(m, m.return, We);
            }
            if (g = m.sibling, g !== null) {
              g.return = m.return, rn = g;
              break;
            }
            rn = m.return;
          }
      return R = wm, wm = !1, R;
    }
    function jc(m, g, R) {
      var z = g.updateQueue;
      if (z = z !== null ? z.lastEffect : null, z !== null) {
        var V = z = z.next;
        do {
          if ((V.tag & m) === m) {
            var Q = V.destroy;
            V.destroy = void 0, Q !== void 0 && To(g, R, Q);
          }
          V = V.next;
        } while (V !== z);
      }
    }
    function Mo(m, g) {
      if (g = g.updateQueue, g = g !== null ? g.lastEffect : null, g !== null) {
        var R = g = g.next;
        do {
          if ((R.tag & m) === m) {
            var z = R.create;
            R.destroy = z();
          }
          R = R.next;
        } while (R !== g);
      }
    }
    function hs(m) {
      var g = m.ref;
      if (g !== null) {
        var R = m.stateNode;
        switch (m.tag) {
          case 5:
            m = Pe(R);
            break;
          default:
            m = R;
        }
        typeof g == "function" ? g(m) : g.current = m;
      }
    }
    function ra(m, g, R) {
      if (wl && typeof wl.onCommitFiberUnmount == "function")
        try {
          wl.onCommitFiberUnmount(Eu, g);
        } catch {
        }
      switch (g.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (m = g.updateQueue, m !== null && (m = m.lastEffect, m !== null)) {
            var z = m = m.next;
            do {
              var V = z, Q = V.destroy;
              V = V.tag, Q !== void 0 && (V & 2 || V & 4) && To(g, R, Q), z = z.next;
            } while (z !== m);
          }
          break;
        case 1:
          if (sl(g, R), m = g.stateNode, typeof m.componentWillUnmount == "function")
            try {
              m.props = g.memoizedProps, m.state = g.memoizedState, m.componentWillUnmount();
            } catch (Me) {
              pi(
                g,
                R,
                Me
              );
            }
          break;
        case 5:
          sl(g, R);
          break;
        case 4:
          Ht ? mo(m, g, R) : he && he && (g = g.stateNode.containerInfo, R = zn(g), rr(g, R));
      }
    }
    function ll(m, g, R) {
      for (var z = g; ; )
        if (ra(m, z, R), z.child === null || Ht && z.tag === 4) {
          if (z === g)
            break;
          for (; z.sibling === null; ) {
            if (z.return === null || z.return === g)
              return;
            z = z.return;
          }
          z.sibling.return = z.return, z = z.sibling;
        } else
          z.child.return = z, z = z.child;
    }
    function Ol(m) {
      var g = m.alternate;
      g !== null && (m.alternate = null, Ol(g)), m.child = null, m.deletions = null, m.sibling = null, m.tag === 5 && (g = m.stateNode, g !== null && Jt(g)), m.stateNode = null, m.return = null, m.dependencies = null, m.memoizedProps = null, m.memoizedState = null, m.pendingProps = null, m.stateNode = null, m.updateQueue = null;
    }
    function Ld(m) {
      return m.tag === 5 || m.tag === 3 || m.tag === 4;
    }
    function $c(m) {
      e:
        for (; ; ) {
          for (; m.sibling === null; ) {
            if (m.return === null || Ld(m.return))
              return null;
            m = m.return;
          }
          for (m.sibling.return = m.return, m = m.sibling; m.tag !== 5 && m.tag !== 6 && m.tag !== 18; ) {
            if (m.flags & 2 || m.child === null || m.tag === 4)
              continue e;
            m.child.return = m, m = m.child;
          }
          if (!(m.flags & 2))
            return m.stateNode;
        }
    }
    function Od(m) {
      if (Ht) {
        e: {
          for (var g = m.return; g !== null; ) {
            if (Ld(g))
              break e;
            g = g.return;
          }
          throw Error(u(160));
        }
        var R = g;
        switch (R.tag) {
          case 5:
            g = R.stateNode, R.flags & 32 && (bt(g), R.flags &= -33), R = $c(m), ps(m, R, g);
            break;
          case 3:
          case 4:
            g = R.stateNode.containerInfo, R = $c(m), Bf(m, R, g);
            break;
          default:
            throw Error(u(161));
        }
      }
    }
    function Bf(m, g, R) {
      var z = m.tag;
      if (z === 5 || z === 6)
        m = m.stateNode, g ? Ut(R, m, g) : fn(R, m);
      else if (z !== 4 && (m = m.child, m !== null))
        for (Bf(m, g, R), m = m.sibling; m !== null; )
          Bf(m, g, R), m = m.sibling;
    }
    function ps(m, g, R) {
      var z = m.tag;
      if (z === 5 || z === 6)
        m = m.stateNode, g ? St(R, m, g) : Vt(R, m);
      else if (z !== 4 && (m = m.child, m !== null))
        for (ps(m, g, R), m = m.sibling; m !== null; )
          ps(m, g, R), m = m.sibling;
    }
    function mo(m, g, R) {
      for (var z = g, V = !1, Q, Me; ; ) {
        if (!V) {
          V = z.return;
          e:
            for (; ; ) {
              if (V === null)
                throw Error(u(160));
              switch (Q = V.stateNode, V.tag) {
                case 5:
                  Me = !1;
                  break e;
                case 3:
                  Q = Q.containerInfo, Me = !0;
                  break e;
                case 4:
                  Q = Q.containerInfo, Me = !0;
                  break e;
              }
              V = V.return;
            }
          V = !0;
        }
        if (z.tag === 5 || z.tag === 6)
          ll(m, z, R), Me ? Ye(Q, z.stateNode) : Se(Q, z.stateNode);
        else if (z.tag === 18)
          Me ? pn(Q, z.stateNode) : tn(Q, z.stateNode);
        else if (z.tag === 4) {
          if (z.child !== null) {
            Q = z.stateNode.containerInfo, Me = !0, z.child.return = z, z = z.child;
            continue;
          }
        } else if (ra(m, z, R), z.child !== null) {
          z.child.return = z, z = z.child;
          continue;
        }
        if (z === g)
          break;
        for (; z.sibling === null; ) {
          if (z.return === null || z.return === g)
            return;
          z = z.return, z.tag === 4 && (V = !1);
        }
        z.sibling.return = z.return, z = z.sibling;
      }
    }
    function va(m, g) {
      if (Ht) {
        switch (g.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            jc(3, g, g.return), Mo(3, g), jc(5, g, g.return);
            return;
          case 1:
            return;
          case 5:
            var R = g.stateNode;
            if (R != null) {
              var z = g.memoizedProps;
              m = m !== null ? m.memoizedProps : z;
              var V = g.type, Q = g.updateQueue;
              g.updateQueue = null, Q !== null && Xe(R, Q, V, m, z, g);
            }
            return;
          case 6:
            if (g.stateNode === null)
              throw Error(u(162));
            R = g.memoizedProps, Wt(g.stateNode, m !== null ? m.memoizedProps : R, R);
            return;
          case 3:
            nt && m !== null && m.memoizedState.isDehydrated && ze(g.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            xh(g);
            return;
          case 19:
            xh(g);
            return;
          case 17:
            return;
        }
        throw Error(u(163));
      }
      switch (g.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          jc(3, g, g.return), Mo(3, g), jc(5, g, g.return);
          return;
        case 12:
          return;
        case 13:
          xh(g);
          return;
        case 19:
          xh(g);
          return;
        case 3:
          nt && m !== null && m.memoizedState.isDehydrated && ze(g.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e:
        if (he) {
          switch (g.tag) {
            case 1:
            case 5:
            case 6:
              break e;
            case 3:
            case 4:
              g = g.stateNode, rr(g.containerInfo, g.pendingChildren);
              break e;
          }
          throw Error(u(163));
        }
    }
    function xh(m) {
      var g = m.updateQueue;
      if (g !== null) {
        m.updateQueue = null;
        var R = m.stateNode;
        R === null && (R = m.stateNode = new Lu()), g.forEach(function(z) {
          var V = Nl.bind(null, m, z);
          R.has(z) || (R.add(z), z.then(V, V));
        });
      }
    }
    function Cm(m, g) {
      for (rn = g; rn !== null; ) {
        g = rn;
        var R = g.deletions;
        if (R !== null)
          for (var z = 0; z < R.length; z++) {
            var V = R[z];
            try {
              var Q = m;
              Ht ? mo(Q, V, g) : ll(Q, V, g);
              var Me = V.alternate;
              Me !== null && (Me.return = null), V.return = null;
            } catch (Dn) {
              pi(V, g, Dn);
            }
          }
        if (R = g.child, g.subtreeFlags & 12854 && R !== null)
          R.return = g, rn = R;
        else
          for (; rn !== null; ) {
            g = rn;
            try {
              var We = g.flags;
              if (We & 32 && Ht && bt(g.stateNode), We & 512) {
                var Mt = g.alternate;
                if (Mt !== null) {
                  var Qt = Mt.ref;
                  Qt !== null && (typeof Qt == "function" ? Qt(null) : Qt.current = null);
                }
              }
              if (We & 8192)
                switch (g.tag) {
                  case 13:
                    if (g.memoizedState !== null) {
                      var cn = g.alternate;
                      (cn === null || cn.memoizedState === null) && (Dm = si());
                    }
                    break;
                  case 22:
                    var sr = g.memoizedState !== null, Jn = g.alternate, aa = Jn !== null && Jn.memoizedState !== null;
                    if (R = g, Ht) {
                      e:
                        if (z = R, V = sr, Q = null, Ht)
                          for (var yn = z; ; ) {
                            if (yn.tag === 5) {
                              if (Q === null) {
                                Q = yn;
                                var fi = yn.stateNode;
                                V ? Tt(fi) : zt(yn.stateNode, yn.memoizedProps);
                              }
                            } else if (yn.tag === 6) {
                              if (Q === null) {
                                var Va = yn.stateNode;
                                V ? ge(Va) : Fe(Va, yn.memoizedProps);
                              }
                            } else if ((yn.tag !== 22 && yn.tag !== 23 || yn.memoizedState === null || yn === z) && yn.child !== null) {
                              yn.child.return = yn, yn = yn.child;
                              continue;
                            }
                            if (yn === z)
                              break;
                            for (; yn.sibling === null; ) {
                              if (yn.return === null || yn.return === z)
                                break e;
                              Q === yn && (Q = null), yn = yn.return;
                            }
                            Q === yn && (Q = null), yn.sibling.return = yn.return, yn = yn.sibling;
                          }
                    }
                    if (sr && !aa && R.mode & 1) {
                      rn = R;
                      for (var ot = R.child; ot !== null; ) {
                        for (R = rn = ot; rn !== null; ) {
                          z = rn;
                          var Be = z.child;
                          switch (z.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                              jc(4, z, z.return);
                              break;
                            case 1:
                              sl(z, z.return);
                              var vt = z.stateNode;
                              if (typeof vt.componentWillUnmount == "function") {
                                var Pt = z.return;
                                try {
                                  vt.props = z.memoizedProps, vt.state = z.memoizedState, vt.componentWillUnmount();
                                } catch (Dn) {
                                  pi(
                                    z,
                                    Pt,
                                    Dn
                                  );
                                }
                              }
                              break;
                            case 5:
                              sl(z, z.return);
                              break;
                            case 22:
                              if (z.memoizedState !== null) {
                                Yc(R);
                                continue;
                              }
                          }
                          Be !== null ? (Be.return = z, rn = Be) : Yc(R);
                        }
                        ot = ot.sibling;
                      }
                    }
                }
              switch (We & 4102) {
                case 2:
                  Od(g), g.flags &= -3;
                  break;
                case 6:
                  Od(g), g.flags &= -3, va(g.alternate, g);
                  break;
                case 4096:
                  g.flags &= -4097;
                  break;
                case 4100:
                  g.flags &= -4097, va(g.alternate, g);
                  break;
                case 4:
                  va(g.alternate, g);
              }
            } catch (Dn) {
              pi(g, g.return, Dn);
            }
            if (R = g.sibling, R !== null) {
              R.return = g.return, rn = R;
              break;
            }
            rn = g.return;
          }
      }
    }
    function ul(m, g, R) {
      rn = m, uu(m);
    }
    function uu(m, g, R) {
      for (var z = (m.mode & 1) !== 0; rn !== null; ) {
        var V = rn, Q = V.child;
        if (V.tag === 22 && z) {
          var Me = V.memoizedState !== null || po;
          if (!Me) {
            var We = V.alternate, Mt = We !== null && We.memoizedState !== null || La;
            We = po;
            var Qt = La;
            if (po = Me, (La = Mt) && !Qt)
              for (rn = V; rn !== null; )
                Me = rn, Mt = Me.child, Me.tag === 22 && Me.memoizedState !== null ? Rm(V) : Mt !== null ? (Mt.return = Me, rn = Mt) : Rm(V);
            for (; Q !== null; )
              rn = Q, uu(Q), Q = Q.sibling;
            rn = V, po = We, La = Qt;
          }
          _h(m);
        } else
          V.subtreeFlags & 8772 && Q !== null ? (Q.return = V, rn = Q) : _h(m);
      }
    }
    function _h(m) {
      for (; rn !== null; ) {
        var g = rn;
        if (g.flags & 8772) {
          var R = g.alternate;
          try {
            if (g.flags & 8772)
              switch (g.tag) {
                case 0:
                case 11:
                case 15:
                  La || Mo(5, g);
                  break;
                case 1:
                  var z = g.stateNode;
                  if (g.flags & 4 && !La)
                    if (R === null)
                      z.componentDidMount();
                    else {
                      var V = g.elementType === g.type ? R.memoizedProps : De(g.type, R.memoizedProps);
                      z.componentDidUpdate(V, R.memoizedState, z.__reactInternalSnapshotBeforeUpdate);
                    }
                  var Q = g.updateQueue;
                  Q !== null && dh(g, Q, z);
                  break;
                case 3:
                  var Me = g.updateQueue;
                  if (Me !== null) {
                    if (R = null, g.child !== null)
                      switch (g.child.tag) {
                        case 5:
                          R = Pe(g.child.stateNode);
                          break;
                        case 1:
                          R = g.child.stateNode;
                      }
                    dh(g, Me, R);
                  }
                  break;
                case 5:
                  var We = g.stateNode;
                  R === null && g.flags & 4 && Ee(We, g.type, g.memoizedProps, g);
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (nt && g.memoizedState === null) {
                    var Mt = g.alternate;
                    if (Mt !== null) {
                      var Qt = Mt.memoizedState;
                      if (Qt !== null) {
                        var cn = Qt.dehydrated;
                        cn !== null && dt(cn);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                  break;
                default:
                  throw Error(u(163));
              }
            La || g.flags & 512 && hs(g);
          } catch (sr) {
            pi(g, g.return, sr);
          }
        }
        if (g === m) {
          rn = null;
          break;
        }
        if (R = g.sibling, R !== null) {
          R.return = g.return, rn = R;
          break;
        }
        rn = g.return;
      }
    }
    function Yc(m) {
      for (; rn !== null; ) {
        var g = rn;
        if (g === m) {
          rn = null;
          break;
        }
        var R = g.sibling;
        if (R !== null) {
          R.return = g.return, rn = R;
          break;
        }
        rn = g.return;
      }
    }
    function Rm(m) {
      for (; rn !== null; ) {
        var g = rn;
        try {
          switch (g.tag) {
            case 0:
            case 11:
            case 15:
              var R = g.return;
              try {
                Mo(4, g);
              } catch (Mt) {
                pi(g, R, Mt);
              }
              break;
            case 1:
              var z = g.stateNode;
              if (typeof z.componentDidMount == "function") {
                var V = g.return;
                try {
                  z.componentDidMount();
                } catch (Mt) {
                  pi(g, V, Mt);
                }
              }
              var Q = g.return;
              try {
                hs(g);
              } catch (Mt) {
                pi(g, Q, Mt);
              }
              break;
            case 5:
              var Me = g.return;
              try {
                hs(g);
              } catch (Mt) {
                pi(g, Me, Mt);
              }
          }
        } catch (Mt) {
          pi(g, g.return, Mt);
        }
        if (g === m) {
          rn = null;
          break;
        }
        var We = g.sibling;
        if (We !== null) {
          We.return = g.return, rn = We;
          break;
        }
        rn = g.return;
      }
    }
    var Eh = 0, Xi = 1, ya = 2, dn = 3, Wi = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var Ba = Symbol.for;
      Eh = Ba("selector.component"), Xi = Ba("selector.has_pseudo_class"), ya = Ba("selector.role"), dn = Ba("selector.test_id"), Wi = Ba("selector.text");
    }
    function vp(m) {
      var g = et(m);
      if (g != null) {
        if (typeof g.memoizedProps["data-testname"] != "string")
          throw Error(u(364));
        return g;
      }
      if (m = Rn(m), m === null)
        throw Error(u(362));
      return m.stateNode.current;
    }
    function Am(m, g) {
      switch (g.$$typeof) {
        case Eh:
          if (m.type === g.value)
            return !0;
          break;
        case Xi:
          e: {
            g = g.value, m = [m, 0];
            for (var R = 0; R < m.length; ) {
              var z = m[R++], V = m[R++], Q = g[V];
              if (z.tag !== 5 || !ae(z)) {
                for (; Q != null && Am(z, Q); )
                  V++, Q = g[V];
                if (V === g.length) {
                  g = !0;
                  break e;
                } else
                  for (z = z.child; z !== null; )
                    m.push(z, V), z = z.sibling;
              }
            }
            g = !1;
          }
          return g;
        case ya:
          if (m.tag === 5 && Ke(m.stateNode, g.value))
            return !0;
          break;
        case Wi:
          if ((m.tag === 5 || m.tag === 6) && (m = se(m), m !== null && 0 <= m.indexOf(g.value)))
            return !0;
          break;
        case dn:
          if (m.tag === 5 && (m = m.memoizedProps["data-testname"], typeof m == "string" && m.toLowerCase() === g.value.toLowerCase()))
            return !0;
          break;
        default:
          throw Error(u(365));
      }
      return !1;
    }
    function ms(m) {
      switch (m.$$typeof) {
        case Eh:
          return "<" + (Z(m.value) || "Unknown") + ">";
        case Xi:
          return ":has(" + (ms(m) || "") + ")";
        case ya:
          return '[role="' + m.value + '"]';
        case Wi:
          return '"' + m.value + '"';
        case dn:
          return '[data-testname="' + m.value + '"]';
        default:
          throw Error(u(365));
      }
    }
    function Sa(m, g) {
      var R = [];
      m = [m, 0];
      for (var z = 0; z < m.length; ) {
        var V = m[z++], Q = m[z++], Me = g[Q];
        if (V.tag !== 5 || !ae(V)) {
          for (; Me != null && Am(V, Me); )
            Q++, Me = g[Q];
          if (Q === g.length)
            R.push(V);
          else
            for (V = V.child; V !== null; )
              m.push(V, Q), V = V.sibling;
        }
      }
      return R;
    }
    function gn(m, g) {
      if (!hn)
        throw Error(u(363));
      m = vp(m), m = Sa(m, g), g = [], m = Array.from(m);
      for (var R = 0; R < m.length; ) {
        var z = m[R++];
        if (z.tag === 5)
          ae(z) || g.push(z.stateNode);
        else
          for (z = z.child; z !== null; )
            m.push(z), z = z.sibling;
      }
      return g;
    }
    var qi = Math.ceil, Ha = h.ReactCurrentDispatcher, cc = h.ReactCurrentOwner, xa = h.ReactCurrentBatchConfig, zr = 0, ia = null, ca = null, ui = 0, Vs = 0, Xc = ir(0), vo = 0, Pd = null, Ou = 0, cu = 0, Hf = 0, Vf = null, Gs = null, Dm = 0, Gf = 1 / 0;
    function Nd() {
      Gf = si() + 500;
    }
    var qc = !1, cl = null, fu = null, Kc = !1, fl = null, bh = 0, du = 0, Qn = null, Rr = -1, Zn = 0;
    function Yr() {
      return zr & 6 ? si() : Rr !== -1 ? Rr : Rr = si();
    }
    function wo(m) {
      return m.mode & 1 ? zr & 2 && ui !== 0 ? ui & -ui : op.transition !== null ? (Zn === 0 && (m = Tl, Tl <<= 1, !(Tl & 4194240) && (Tl = 64), Zn = m), Zn) : (m = br, m !== 0 ? m : gt()) : 1;
    }
    function Ws(m, g, R) {
      if (50 < du)
        throw du = 0, Qn = null, Error(u(185));
      var z = Qc(m, g);
      return z === null ? null : (lr(z, g, R), (!(zr & 2) || z !== ia) && (z === ia && (!(zr & 2) && (cu |= g), vo === 4 && Wn(z, ui)), vs(z, R), g === 1 && zr === 0 && !(m.mode & 1) && (Nd(), Uc && Os())), z);
    }
    function Qc(m, g) {
      m.lanes |= g;
      var R = m.alternate;
      for (R !== null && (R.lanes |= g), R = m, m = m.return; m !== null; )
        m.childLanes |= g, R = m.alternate, R !== null && (R.childLanes |= g), R = m, m = m.return;
      return R.tag === 3 ? R.stateNode : null;
    }
    function vs(m, g) {
      var R = m.callbackNode;
      jr(m, g);
      var z = Zu(m, m === ia ? ui : 0);
      if (z === 0)
        R !== null && Ca(R), m.callbackNode = null, m.callbackPriority = 0;
      else if (g = z & -z, m.callbackPriority !== g) {
        if (R != null && Ca(R), g === 1)
          m.tag === 0 ? md(Pu.bind(null, m)) : tc(Pu.bind(null, m)), Kt ? qt(function() {
            zr === 0 && Os();
          }) : Ls(uo, Os), R = null;
        else {
          switch (us(z)) {
            case 1:
              R = uo;
              break;
            case 4:
              R = Ju;
              break;
            case 16:
              R = ch;
              break;
            case 536870912:
              R = Nc;
              break;
            default:
              R = ch;
          }
          R = hu(R, Co.bind(null, m));
        }
        m.callbackPriority = g, m.callbackNode = R;
      }
    }
    function Co(m, g) {
      if (Rr = -1, Zn = 0, zr & 6)
        throw Error(u(327));
      var R = m.callbackNode;
      if (fc() && m.callbackNode !== R)
        return null;
      var z = Zu(m, m === ia ? ui : 0);
      if (z === 0)
        return null;
      if (z & 30 || z & m.expiredLanes || g)
        g = zo(m, z);
      else {
        g = z;
        var V = zr;
        zr |= 2;
        var Q = Zc();
        (ia !== m || ui !== g) && (Nd(), wi(m, g));
        do
          try {
            jf();
            break;
          } catch (We) {
            Wf(m, We);
          }
        while (!0);
        mn(), Ha.current = Q, zr = V, ca !== null ? g = 0 : (ia = null, ui = 0, g = vo);
      }
      if (g !== 0) {
        if (g === 2 && (V = lo(m), V !== 0 && (z = V, g = ci(m, V))), g === 1)
          throw R = Pd, wi(m, 0), Wn(m, z), vs(m, si()), R;
        if (g === 6)
          Wn(m, z);
        else {
          if (V = m.current.alternate, !(z & 30) && !Jr(V) && (g = zo(m, z), g === 2 && (Q = lo(m), Q !== 0 && (z = Q, g = ci(m, Q))), g === 1))
            throw R = Pd, wi(m, 0), Wn(m, z), vs(m, si()), R;
          switch (m.finishedWork = V, m.finishedLanes = z, g) {
            case 0:
            case 1:
              throw Error(u(345));
            case 2:
              hl(m, Gs);
              break;
            case 3:
              if (Wn(m, z), (z & 130023424) === z && (g = Dm + 500 - si(), 10 < g)) {
                if (Zu(m, 0) !== 0)
                  break;
                if (V = m.suspendedLanes, (V & z) !== z) {
                  Yr(), m.pingedLanes |= m.suspendedLanes & V;
                  break;
                }
                m.timeoutHandle = Je(hl.bind(null, m, Gs), g);
                break;
              }
              hl(m, Gs);
              break;
            case 4:
              if (Wn(m, z), (z & 4194240) === z)
                break;
              for (g = m.eventTimes, V = -1; 0 < z; ) {
                var Me = 31 - Go(z);
                Q = 1 << Me, Me = g[Me], Me > V && (V = Me), z &= ~Q;
              }
              if (z = V, z = si() - z, z = (120 > z ? 120 : 480 > z ? 480 : 1080 > z ? 1080 : 1920 > z ? 1920 : 3e3 > z ? 3e3 : 4320 > z ? 4320 : 1960 * qi(z / 1960)) - z, 10 < z) {
                m.timeoutHandle = Je(hl.bind(null, m, Gs), z);
                break;
              }
              hl(m, Gs);
              break;
            case 5:
              hl(m, Gs);
              break;
            default:
              throw Error(u(329));
          }
        }
      }
      return vs(m, si()), m.callbackNode === R ? Co.bind(null, m) : null;
    }
    function ci(m, g) {
      var R = Vf;
      return m.current.memoizedState.isDehydrated && (wi(m, g).flags |= 256), m = zo(m, g), m !== 2 && (g = Gs, Gs = R, g !== null && Ct(g)), m;
    }
    function Ct(m) {
      Gs === null ? Gs = m : Gs.push.apply(Gs, m);
    }
    function Jr(m) {
      for (var g = m; ; ) {
        if (g.flags & 16384) {
          var R = g.updateQueue;
          if (R !== null && (R = R.stores, R !== null))
            for (var z = 0; z < R.length; z++) {
              var V = R[z], Q = V.getSnapshot;
              V = V.value;
              try {
                if (!Wo(Q(), V))
                  return !1;
              } catch {
                return !1;
              }
            }
        }
        if (R = g.child, g.subtreeFlags & 16384 && R !== null)
          R.return = g, g = R;
        else {
          if (g === m)
            break;
          for (; g.sibling === null; ) {
            if (g.return === null || g.return === m)
              return !0;
            g = g.return;
          }
          g.sibling.return = g.return, g = g.sibling;
        }
      }
      return !0;
    }
    function Wn(m, g) {
      for (g &= ~Hf, g &= ~cu, m.suspendedLanes |= g, m.pingedLanes &= ~g, m = m.expirationTimes; 0 < g; ) {
        var R = 31 - Go(g), z = 1 << R;
        m[R] = -1, g &= ~z;
      }
    }
    function Pu(m) {
      if (zr & 6)
        throw Error(u(327));
      fc();
      var g = Zu(m, 0);
      if (!(g & 1))
        return vs(m, si()), null;
      var R = zo(m, g);
      if (m.tag !== 0 && R === 2) {
        var z = lo(m);
        z !== 0 && (g = z, R = ci(m, z));
      }
      if (R === 1)
        throw R = Pd, wi(m, 0), Wn(m, g), vs(m, si()), R;
      if (R === 6)
        throw Error(u(345));
      return m.finishedWork = m.current.alternate, m.finishedLanes = g, hl(m, Gs), vs(m, si()), null;
    }
    function js(m) {
      fl !== null && fl.tag === 0 && !(zr & 6) && fc();
      var g = zr;
      zr |= 1;
      var R = xa.transition, z = br;
      try {
        if (xa.transition = null, br = 1, m)
          return m();
      } finally {
        br = z, xa.transition = R, zr = g, !(zr & 6) && Os();
      }
    }
    function Uo() {
      Vs = Xc.current, Cr(Xc);
    }
    function wi(m, g) {
      m.finishedWork = null, m.finishedLanes = 0;
      var R = m.timeoutHandle;
      if (R !== xt && (m.timeoutHandle = xt, at(R)), ca !== null)
        for (R = ca.return; R !== null; ) {
          var z = R;
          switch (ka(z), z.tag) {
            case 1:
              z = z.type.childContextTypes, z != null && Po();
              break;
            case 3:
              Ed(), Cr(ni), Cr(wa), al();
              break;
            case 5:
              Rl(z);
              break;
            case 4:
              Ed();
              break;
            case 13:
              Cr(la);
              break;
            case 19:
              Cr(la);
              break;
            case 10:
              Nr(z.type._context);
              break;
            case 22:
            case 23:
              Uo();
          }
          R = R.return;
        }
      if (ia = m, ca = m = Xo(m.current, null), ui = Vs = g, vo = 0, Pd = null, Hf = cu = Ou = 0, Gs = Vf = null, Qr !== null) {
        for (g = 0; g < Qr.length; g++)
          if (R = Qr[g], z = R.interleaved, z !== null) {
            R.interleaved = null;
            var V = z.next, Q = R.pending;
            if (Q !== null) {
              var Me = Q.next;
              Q.next = V, z.next = Me;
            }
            R.pending = z;
          }
        Qr = null;
      }
      return m;
    }
    function Wf(m, g) {
      do {
        var R = ca;
        try {
          if (mn(), fo.current = Uf, Td) {
            for (var z = Zr.memoizedState; z !== null; ) {
              var V = z.queue;
              V !== null && (V.pending = null), z = z.next;
            }
            Td = !1;
          }
          if (Hc = 0, ki = Mi = Zr = null, ho = !1, Of = 0, cc.current = null, R === null || R.return === null) {
            vo = 1, Pd = g, ca = null;
            break;
          }
          e: {
            var Q = m, Me = R.return, We = R, Mt = g;
            if (g = ui, We.flags |= 32768, Mt !== null && typeof Mt == "object" && typeof Mt.then == "function") {
              var Qt = Mt, cn = We, sr = cn.tag;
              if (!(cn.mode & 1) && (sr === 0 || sr === 11 || sr === 15)) {
                var Jn = cn.alternate;
                Jn ? (cn.updateQueue = Jn.updateQueue, cn.memoizedState = Jn.memoizedState, cn.lanes = Jn.lanes) : (cn.updateQueue = null, cn.memoizedState = null);
              }
              var aa = Cu(Me);
              if (aa !== null) {
                aa.flags &= -257, Ru(aa, Me, We, Q, g), aa.mode & 1 && ks(Q, Qt, g), g = aa, Mt = Qt;
                var yn = g.updateQueue;
                if (yn === null) {
                  var fi = /* @__PURE__ */ new Set();
                  fi.add(Mt), g.updateQueue = fi;
                } else
                  yn.add(Mt);
                break e;
              } else {
                if (!(g & 1)) {
                  ks(Q, Qt, g), Jc();
                  break e;
                }
                Mt = Error(u(426));
              }
            } else if (Yi && We.mode & 1) {
              var Va = Cu(Me);
              if (Va !== null) {
                !(Va.flags & 65536) && (Va.flags |= 256), Ru(Va, Me, We, Q, g), hh(Mt);
                break e;
              }
            }
            Q = Mt, vo !== 4 && (vo = 2), Vf === null ? Vf = [Q] : Vf.push(Q), Mt = yh(Mt, We), We = Me;
            do {
              switch (We.tag) {
                case 3:
                  We.flags |= 65536, g &= -g, We.lanes |= g;
                  var ot = Mm(We, Mt, g);
                  tu(We, ot);
                  break e;
                case 1:
                  Q = Mt;
                  var Be = We.type, vt = We.stateNode;
                  if (!(We.flags & 128) && (typeof Be.getDerivedStateFromError == "function" || vt !== null && typeof vt.componentDidCatch == "function" && (fu === null || !fu.has(vt)))) {
                    We.flags |= 65536, g &= -g, We.lanes |= g;
                    var Pt = wu(We, Q, g);
                    tu(We, Pt);
                    break e;
                  }
              }
              We = We.return;
            } while (We !== null);
          }
          Yo(R);
        } catch (Dn) {
          g = Dn, ca === R && R !== null && (ca = R = R.return);
          continue;
        }
        break;
      } while (!0);
    }
    function Zc() {
      var m = Ha.current;
      return Ha.current = Uf, m === null ? Uf : m;
    }
    function Jc() {
      (vo === 0 || vo === 3 || vo === 2) && (vo = 4), ia === null || !(Ou & 268435455) && !(cu & 268435455) || Wn(ia, ui);
    }
    function zo(m, g) {
      var R = zr;
      zr |= 2;
      var z = Zc();
      ia === m && ui === g || wi(m, g);
      do
        try {
          dl();
          break;
        } catch (V) {
          Wf(m, V);
        }
      while (!0);
      if (mn(), zr = R, Ha.current = z, ca !== null)
        throw Error(u(261));
      return ia = null, ui = 0, vo;
    }
    function dl() {
      for (; ca !== null; )
        Ud(ca);
    }
    function jf() {
      for (; ca !== null && !zi(); )
        Ud(ca);
    }
    function Ud(m) {
      var g = ef(m.alternate, m, Vs);
      m.memoizedProps = m.pendingProps, g === null ? Yo(m) : ca = g, cc.current = null;
    }
    function Yo(m) {
      var g = m;
      do {
        var R = g.alternate;
        if (m = g.return, g.flags & 32768) {
          if (R = Sr(R, g), R !== null) {
            R.flags &= 32767, ca = R;
            return;
          }
          if (m !== null)
            m.flags |= 32768, m.subtreeFlags = 0, m.deletions = null;
          else {
            vo = 6, ca = null;
            return;
          }
        } else if (R = Kn(R, g, Vs), R !== null) {
          ca = R;
          return;
        }
        if (g = g.sibling, g !== null) {
          ca = g;
          return;
        }
        ca = g = m;
      } while (g !== null);
      vo === 0 && (vo = 5);
    }
    function hl(m, g) {
      var R = br, z = xa.transition;
      try {
        xa.transition = null, br = 1, Lm(m, g, R);
      } finally {
        xa.transition = z, br = R;
      }
      return null;
    }
    function Lm(m, g, R) {
      do
        fc();
      while (fl !== null);
      if (zr & 6)
        throw Error(u(327));
      var z = m.finishedWork, V = m.finishedLanes;
      if (z === null)
        return null;
      if (m.finishedWork = null, m.finishedLanes = 0, z === m.current)
        throw Error(u(177));
      m.callbackNode = null, m.callbackPriority = 0;
      var Q = z.lanes | z.childLanes;
      if (pd(m, Q), m === ia && (ca = ia = null, ui = 0), !(z.subtreeFlags & 2064) && !(z.flags & 2064) || Kc || (Kc = !0, hu(ch, function() {
        return fc(), null;
      })), Q = (z.flags & 15990) !== 0, z.subtreeFlags & 15990 || Q) {
        Q = xa.transition, xa.transition = null;
        var Me = br;
        br = 1;
        var We = zr;
        zr |= 4, cc.current = null, mp(m, z), Cm(m, z), X(m.containerInfo), m.current = z, ul(z), dm(), zr = We, br = Me, xa.transition = Q;
      } else
        m.current = z;
      if (Kc && (Kc = !1, fl = m, bh = V), Q = m.pendingLanes, Q === 0 && (fu = null), Jl(z.stateNode), vs(m, si()), g !== null)
        for (R = m.onRecoverableError, z = 0; z < g.length; z++)
          R(g[z]);
      if (qc)
        throw qc = !1, m = cl, cl = null, m;
      return bh & 1 && m.tag !== 0 && fc(), Q = m.pendingLanes, Q & 1 ? m === Qn ? du++ : (du = 0, Qn = m) : du = 0, Os(), null;
    }
    function fc() {
      if (fl !== null) {
        var m = us(bh), g = xa.transition, R = br;
        try {
          if (xa.transition = null, br = 16 > m ? 16 : m, fl === null)
            var z = !1;
          else {
            if (m = fl, fl = null, bh = 0, zr & 6)
              throw Error(u(331));
            var V = zr;
            for (zr |= 4, rn = m.current; rn !== null; ) {
              var Q = rn, Me = Q.child;
              if (rn.flags & 16) {
                var We = Q.deletions;
                if (We !== null) {
                  for (var Mt = 0; Mt < We.length; Mt++) {
                    var Qt = We[Mt];
                    for (rn = Qt; rn !== null; ) {
                      var cn = rn;
                      switch (cn.tag) {
                        case 0:
                        case 11:
                        case 15:
                          jc(8, cn, Q);
                      }
                      var sr = cn.child;
                      if (sr !== null)
                        sr.return = cn, rn = sr;
                      else
                        for (; rn !== null; ) {
                          cn = rn;
                          var Jn = cn.sibling, aa = cn.return;
                          if (Ol(cn), cn === Qt) {
                            rn = null;
                            break;
                          }
                          if (Jn !== null) {
                            Jn.return = aa, rn = Jn;
                            break;
                          }
                          rn = aa;
                        }
                    }
                  }
                  var yn = Q.alternate;
                  if (yn !== null) {
                    var fi = yn.child;
                    if (fi !== null) {
                      yn.child = null;
                      do {
                        var Va = fi.sibling;
                        fi.sibling = null, fi = Va;
                      } while (fi !== null);
                    }
                  }
                  rn = Q;
                }
              }
              if (Q.subtreeFlags & 2064 && Me !== null)
                Me.return = Q, rn = Me;
              else
                e:
                  for (; rn !== null; ) {
                    if (Q = rn, Q.flags & 2048)
                      switch (Q.tag) {
                        case 0:
                        case 11:
                        case 15:
                          jc(9, Q, Q.return);
                      }
                    var ot = Q.sibling;
                    if (ot !== null) {
                      ot.return = Q.return, rn = ot;
                      break e;
                    }
                    rn = Q.return;
                  }
            }
            var Be = m.current;
            for (rn = Be; rn !== null; ) {
              Me = rn;
              var vt = Me.child;
              if (Me.subtreeFlags & 2064 && vt !== null)
                vt.return = Me, rn = vt;
              else
                e:
                  for (Me = Be; rn !== null; ) {
                    if (We = rn, We.flags & 2048)
                      try {
                        switch (We.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Mo(9, We);
                        }
                      } catch (Dn) {
                        pi(We, We.return, Dn);
                      }
                    if (We === Me) {
                      rn = null;
                      break e;
                    }
                    var Pt = We.sibling;
                    if (Pt !== null) {
                      Pt.return = We.return, rn = Pt;
                      break e;
                    }
                    rn = We.return;
                  }
            }
            if (zr = V, Os(), wl && typeof wl.onPostCommitFiberRoot == "function")
              try {
                wl.onPostCommitFiberRoot(Eu, m);
              } catch {
              }
            z = !0;
          }
          return z;
        } finally {
          br = R, xa.transition = g;
        }
      }
      return !1;
    }
    function go(m, g, R) {
      g = yh(R, g), g = Mm(m, g, 1), eu(m, g), g = Yr(), m = Qc(m, 1), m !== null && (lr(m, 1, g), vs(m, g));
    }
    function pi(m, g, R) {
      if (m.tag === 3)
        go(m, m, R);
      else
        for (; g !== null; ) {
          if (g.tag === 3) {
            go(g, m, R);
            break;
          } else if (g.tag === 1) {
            var z = g.stateNode;
            if (typeof g.type.getDerivedStateFromError == "function" || typeof z.componentDidCatch == "function" && (fu === null || !fu.has(z))) {
              m = yh(R, m), m = wu(g, m, 1), eu(g, m), m = Yr(), g = Qc(g, 1), g !== null && (lr(g, 1, m), vs(g, m));
              break;
            }
          }
          g = g.return;
        }
    }
    function Pl(m, g, R) {
      var z = m.pingCache;
      z !== null && z.delete(g), g = Yr(), m.pingedLanes |= m.suspendedLanes & R, ia === m && (ui & R) === R && (vo === 4 || vo === 3 && (ui & 130023424) === ui && 500 > si() - Dm ? wi(m, 0) : Hf |= R), vs(m, g);
    }
    function $s(m, g) {
      g === 0 && (m.mode & 1 ? (g = Kr, Kr <<= 1, !(Kr & 130023424) && (Kr = 4194304)) : g = 1);
      var R = Yr();
      m = Qc(m, g), m !== null && (lr(m, g, R), vs(m, R));
    }
    function Om(m) {
      var g = m.memoizedState, R = 0;
      g !== null && (R = g.retryLane), $s(m, R);
    }
    function Nl(m, g) {
      var R = 0;
      switch (m.tag) {
        case 13:
          var z = m.stateNode, V = m.memoizedState;
          V !== null && (R = V.retryLane);
          break;
        case 19:
          z = m.stateNode;
          break;
        default:
          throw Error(u(314));
      }
      z !== null && z.delete(g), $s(m, R);
    }
    var ef;
    ef = function(m, g, R) {
      if (m !== null)
        if (m.memoizedProps !== g.pendingProps || ni.current)
          Hr = !0;
        else {
          if (!(m.lanes & R) && !(g.flags & 128))
            return Hr = !1, lu(m, g, R);
          Hr = !!(m.flags & 131072);
        }
      else
        Hr = !1, Yi && g.flags & 1048576 && Ns(g, Sm, g.index);
      switch (g.lanes = 0, g.tag) {
        case 2:
          var z = g.type;
          m !== null && (m.alternate = null, g.alternate = null, g.flags |= 2), m = g.pendingProps;
          var V = ta(g, wa.current);
          Ti(g, R), V = Vc(null, g, z, m, V, R);
          var Q = Mu();
          return g.flags |= 1, typeof V == "object" && V !== null && typeof V.render == "function" && V.$$typeof === void 0 ? (g.tag = 1, g.memoizedState = null, g.updateQueue = null, Vi(z) ? (Q = !0, Ds(g)) : Q = !1, g.memoizedState = V.state !== null && V.state !== void 0 ? V.state : null, $r(g), V.updater = mm, g.stateNode = V, V._reactInternals = g, ym(g, z, m, R), g = ua(null, g, z, !0, Q, R)) : (g.tag = 0, Yi && Q && bu(g), Hn(null, g, V, R), g = g.child), g;
        case 16:
          z = g.elementType;
          e: {
            switch (m !== null && (m.alternate = null, g.alternate = null, g.flags |= 2), m = g.pendingProps, V = z._init, z = V(z._payload), g.type = z, V = g.tag = $f(z), m = De(z, m), V) {
              case 0:
                g = fs(null, g, z, m, R);
                break e;
              case 1:
                g = Bs(
                  null,
                  g,
                  z,
                  m,
                  R
                );
                break e;
              case 11:
                g = ii(null, g, z, m, R);
                break e;
              case 14:
                g = di(null, g, z, De(z.type, m), R);
                break e;
            }
            throw Error(u(306, z, ""));
          }
          return g;
        case 0:
          return z = g.type, V = g.pendingProps, V = g.elementType === z ? V : De(z, V), fs(m, g, z, V, R);
        case 1:
          return z = g.type, V = g.pendingProps, V = g.elementType === z ? V : De(z, V), Bs(m, g, z, V, R);
        case 3:
          e: {
            if (Hs(g), m === null)
              throw Error(u(387));
            z = g.pendingProps, Q = g.memoizedState, V = Q.element, Cl(m, g), Rf(g, z, null, R);
            var Me = g.memoizedState;
            if (z = Me.element, nt && Q.isDehydrated)
              if (Q = {
                element: z,
                isDehydrated: !1,
                cache: Me.cache,
                transitions: Me.transitions
              }, g.updateQueue.baseState = Q, g.memoizedState = Q, g.flags & 256) {
                V = Error(u(423)), g = lc(m, g, z, R, V);
                break e;
              } else if (z !== V) {
                V = Error(u(424)), g = lc(m, g, z, R, V);
                break e;
              } else
                for (nt && (Aa = Bt(g.stateNode.containerInfo), Ra = g, Yi = !0, jo = null, gd = !1), R = lp(g, null, z, R), g.child = R; R; )
                  R.flags = R.flags & -3 | 4096, R = R.sibling;
            else {
              if (Sd(), z === V) {
                g = hi(m, g, R);
                break e;
              }
              Hn(m, g, z, R);
            }
            g = g.child;
          }
          return g;
        case 5:
          return cp(g), m === null && Ic(g), z = g.type, V = g.pendingProps, Q = m !== null ? m.memoizedProps : null, Me = V.children, Ze(z, V) ? Me = null : Q !== null && Ze(z, Q) && (g.flags |= 32), Da(m, g), Hn(m, g, Me, R), g.child;
        case 6:
          return m === null && Ic(g), null;
        case 13:
          return Av(m, g, R);
        case 4:
          return up(g, g.stateNode.containerInfo), z = g.pendingProps, m === null ? g.child = Tu(g, null, z, R) : Hn(m, g, z, R), g.child;
        case 11:
          return z = g.type, V = g.pendingProps, V = g.elementType === z ? V : De(z, V), ii(m, g, z, V, R);
        case 7:
          return Hn(m, g, g.pendingProps, R), g.child;
        case 8:
          return Hn(m, g, g.pendingProps.children, R), g.child;
        case 12:
          return Hn(m, g, g.pendingProps.children, R), g.child;
        case 10:
          e: {
            if (z = g.type._context, V = g.pendingProps, Q = g.memoizedProps, Me = V.value, qn(g, z, Me), Q !== null)
              if (Wo(Q.value, Me)) {
                if (Q.children === V.children && !ni.current) {
                  g = hi(m, g, R);
                  break e;
                }
              } else
                for (Q = g.child, Q !== null && (Q.return = g); Q !== null; ) {
                  var We = Q.dependencies;
                  if (We !== null) {
                    Me = Q.child;
                    for (var Mt = We.firstContext; Mt !== null; ) {
                      if (Mt.context === z) {
                        if (Q.tag === 1) {
                          Mt = rl(-1, R & -R), Mt.tag = 2;
                          var Qt = Q.updateQueue;
                          if (Qt !== null) {
                            Qt = Qt.shared;
                            var cn = Qt.pending;
                            cn === null ? Mt.next = Mt : (Mt.next = cn.next, cn.next = Mt), Qt.pending = Mt;
                          }
                        }
                        Q.lanes |= R, Mt = Q.alternate, Mt !== null && (Mt.lanes |= R), ri(Q.return, R, g), We.lanes |= R;
                        break;
                      }
                      Mt = Mt.next;
                    }
                  } else if (Q.tag === 10)
                    Me = Q.type === g.type ? null : Q.child;
                  else if (Q.tag === 18) {
                    if (Me = Q.return, Me === null)
                      throw Error(u(341));
                    Me.lanes |= R, We = Me.alternate, We !== null && (We.lanes |= R), ri(Me, R, g), Me = Q.sibling;
                  } else
                    Me = Q.child;
                  if (Me !== null)
                    Me.return = Q;
                  else
                    for (Me = Q; Me !== null; ) {
                      if (Me === g) {
                        Me = null;
                        break;
                      }
                      if (Q = Me.sibling, Q !== null) {
                        Q.return = Me.return, Me = Q;
                        break;
                      }
                      Me = Me.return;
                    }
                  Q = Me;
                }
            Hn(m, g, V.children, R), g = g.child;
          }
          return g;
        case 9:
          return V = g.type, z = g.pendingProps.children, Ti(g, R), V = Br(V), z = z(V), g.flags |= 1, Hn(m, g, z, R), g.child;
        case 14:
          return z = g.type, V = De(z, g.pendingProps), V = De(z.type, V), di(m, g, z, V, R);
        case 15:
          return Au(m, g, g.type, g.pendingProps, R);
        case 17:
          return z = g.type, V = g.pendingProps, V = g.elementType === z ? V : De(z, V), m !== null && (m.alternate = null, g.alternate = null, g.flags |= 2), g.tag = 1, Vi(z) ? (m = !0, Ds(g)) : m = !1, Ti(g, R), gm(g, z, V), ym(g, z, V, R), ua(null, g, z, !0, m, R);
        case 19:
          return Du(m, g, R);
        case 22:
          return dr(m, g, R);
      }
      throw Error(u(156, g.tag));
    };
    function hu(m, g) {
      return Ls(m, g);
    }
    function Ul(m, g, R, z) {
      this.tag = m, this.key = R, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = g, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = z, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function Ro(m, g, R, z) {
      return new Ul(m, g, R, z);
    }
    function Nu(m) {
      return m = m.prototype, !(!m || !m.isReactComponent);
    }
    function $f(m) {
      if (typeof m == "function")
        return Nu(m) ? 1 : 0;
      if (m != null) {
        if (m = m.$$typeof, m === U)
          return 11;
        if (m === I)
          return 14;
      }
      return 2;
    }
    function Xo(m, g) {
      var R = m.alternate;
      return R === null ? (R = Ro(m.tag, g, m.key, m.mode), R.elementType = m.elementType, R.type = m.type, R.stateNode = m.stateNode, R.alternate = m, m.alternate = R) : (R.pendingProps = g, R.type = m.type, R.flags = 0, R.subtreeFlags = 0, R.deletions = null), R.flags = m.flags & 14680064, R.childLanes = m.childLanes, R.lanes = m.lanes, R.child = m.child, R.memoizedProps = m.memoizedProps, R.memoizedState = m.memoizedState, R.updateQueue = m.updateQueue, g = m.dependencies, R.dependencies = g === null ? null : { lanes: g.lanes, firstContext: g.firstContext }, R.sibling = m.sibling, R.index = m.index, R.ref = m.ref, R;
    }
    function tf(m, g, R, z, V, Q) {
      var Me = 2;
      if (z = m, typeof m == "function")
        Nu(m) && (Me = 1);
      else if (typeof m == "string")
        Me = 5;
      else
        e:
          switch (m) {
            case _:
              return zl(R.children, V, Q, g);
            case b:
              Me = 8, V |= 8;
              break;
            case M:
              return m = Ro(12, R, g, V | 2), m.elementType = M, m.lanes = Q, m;
            case N:
              return m = Ro(13, R, g, V), m.elementType = N, m.lanes = Q, m;
            case O:
              return m = Ro(19, R, g, V), m.elementType = O, m.lanes = Q, m;
            case G:
              return Yf(R, V, Q, g);
            default:
              if (typeof m == "object" && m !== null)
                switch (m.$$typeof) {
                  case C:
                    Me = 10;
                    break e;
                  case D:
                    Me = 9;
                    break e;
                  case U:
                    Me = 11;
                    break e;
                  case I:
                    Me = 14;
                    break e;
                  case k:
                    Me = 16, z = null;
                    break e;
                }
              throw Error(u(130, m == null ? m : typeof m, ""));
          }
      return g = Ro(Me, R, g, V), g.elementType = m, g.type = z, g.lanes = Q, g;
    }
    function zl(m, g, R, z) {
      return m = Ro(7, m, z, g), m.lanes = R, m;
    }
    function Yf(m, g, R, z) {
      return m = Ro(22, m, z, g), m.elementType = G, m.lanes = R, m.stateNode = {}, m;
    }
    function nf(m, g, R) {
      return m = Ro(6, m, null, g), m.lanes = R, m;
    }
    function pu(m, g, R) {
      return g = Ro(4, m.children !== null ? m.children : [], m.key, g), g.lanes = R, g.stateNode = { containerInfo: m.containerInfo, pendingChildren: null, implementation: m.implementation }, g;
    }
    function pl(m, g, R, z, V) {
      this.tag = g, this.containerInfo = m, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = xt, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = wf(0), this.expirationTimes = wf(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = wf(0), this.identifierPrefix = z, this.onRecoverableError = V, nt && (this.mutableSourceEagerHydrationData = null);
    }
    function Yg(m, g, R, z, V, Q, Me, We, Mt) {
      return m = new pl(m, g, R, We, Mt), g === 1 ? (g = 1, Q === !0 && (g |= 8)) : g = 0, Q = Ro(3, null, null, g), m.current = Q, Q.stateNode = m, Q.memoizedState = { element: z, isDehydrated: R, cache: null, transitions: null }, $r(Q), m;
    }
    function Xr(m) {
      if (!m)
        return Di;
      m = m._reactInternals;
      e: {
        if (J(m) !== m || m.tag !== 1)
          throw Error(u(170));
        var g = m;
        do {
          switch (g.tag) {
            case 3:
              g = g.stateNode.context;
              break e;
            case 1:
              if (Vi(g.type)) {
                g = g.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          g = g.return;
        } while (g !== null);
        throw Error(u(171));
      }
      if (m.tag === 1) {
        var R = m.type;
        if (Vi(R))
          return El(m, R, g);
      }
      return g;
    }
    function Xf(m) {
      var g = m._reactInternals;
      if (g === void 0)
        throw typeof m.render == "function" ? Error(u(188)) : (m = Object.keys(m).join(","), Error(u(268, m)));
      return m = ye(g), m === null ? null : m.stateNode;
    }
    function rf(m, g) {
      if (m = m.memoizedState, m !== null && m.dehydrated !== null) {
        var R = m.retryLane;
        m.retryLane = R !== 0 && R < g ? R : g;
      }
    }
    function Uu(m, g) {
      rf(m, g), (m = m.alternate) && rf(m, g);
    }
    function dc(m) {
      return m = ye(m), m === null ? null : m.stateNode;
    }
    function Pm() {
      return null;
    }
    return t.attemptContinuousHydration = function(m) {
      if (m.tag === 13) {
        var g = Yr();
        Ws(m, 134217728, g), Uu(m, 134217728);
      }
    }, t.attemptHydrationAtCurrentPriority = function(m) {
      if (m.tag === 13) {
        var g = Yr(), R = wo(m);
        Ws(m, R, g), Uu(m, R);
      }
    }, t.attemptSynchronousHydration = function(m) {
      switch (m.tag) {
        case 3:
          var g = m.stateNode;
          if (g.current.memoizedState.isDehydrated) {
            var R = Ml(g.pendingLanes);
            R !== 0 && (pa(g, R | 1), vs(g, si()), !(zr & 6) && (Nd(), Os()));
          }
          break;
        case 13:
          var z = Yr();
          js(function() {
            return Ws(m, 1, z);
          }), Uu(m, 1);
      }
    }, t.batchedUpdates = function(m, g) {
      var R = zr;
      zr |= 1;
      try {
        return m(g);
      } finally {
        zr = R, zr === 0 && (Nd(), Uc && Os());
      }
    }, t.createComponentSelector = function(m) {
      return { $$typeof: Eh, value: m };
    }, t.createContainer = function(m, g, R, z, V, Q, Me) {
      return Yg(m, g, !1, null, R, z, V, Q, Me);
    }, t.createHasPseudoClassSelector = function(m) {
      return { $$typeof: Xi, value: m };
    }, t.createHydrationContainer = function(m, g, R, z, V, Q, Me, We, Mt) {
      return m = Yg(R, z, !0, m, V, Q, Me, We, Mt), m.context = Xr(null), R = m.current, z = Yr(), V = wo(R), Q = rl(z, V), Q.callback = g ?? null, eu(R, Q), m.current.lanes = V, lr(m, V, z), vs(m, z), m;
    }, t.createPortal = function(m, g, R) {
      var z = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: y, key: z == null ? null : "" + z, children: m, containerInfo: g, implementation: R };
    }, t.createRoleSelector = function(m) {
      return { $$typeof: ya, value: m };
    }, t.createTestNameSelector = function(m) {
      return { $$typeof: dn, value: m };
    }, t.createTextSelector = function(m) {
      return { $$typeof: Wi, value: m };
    }, t.deferredUpdates = function(m) {
      var g = br, R = xa.transition;
      try {
        return xa.transition = null, br = 16, m();
      } finally {
        br = g, xa.transition = R;
      }
    }, t.discreteUpdates = function(m, g, R, z, V) {
      var Q = br, Me = xa.transition;
      try {
        return xa.transition = null, br = 1, m(g, R, z, V);
      } finally {
        br = Q, xa.transition = Me, zr === 0 && Nd();
      }
    }, t.findAllNodes = gn, t.findBoundingRects = function(m, g) {
      if (!hn)
        throw Error(u(363));
      g = gn(m, g), m = [];
      for (var R = 0; R < g.length; R++)
        m.push(Yn(g[R]));
      for (g = m.length - 1; 0 < g; g--) {
        R = m[g];
        for (var z = R.x, V = z + R.width, Q = R.y, Me = Q + R.height, We = g - 1; 0 <= We; We--)
          if (g !== We) {
            var Mt = m[We], Qt = Mt.x, cn = Qt + Mt.width, sr = Mt.y, Jn = sr + Mt.height;
            if (z >= Qt && Q >= sr && V <= cn && Me <= Jn) {
              m.splice(g, 1);
              break;
            } else if (z !== Qt || R.width !== Mt.width || Jn < Q || sr > Me) {
              if (!(Q !== sr || R.height !== Mt.height || cn < z || Qt > V)) {
                Qt > z && (Mt.width += Qt - z, Mt.x = z), cn < V && (Mt.width = V - Qt), m.splice(g, 1);
                break;
              }
            } else {
              sr > Q && (Mt.height += sr - Q, Mt.y = Q), Jn < Me && (Mt.height = Me - sr), m.splice(g, 1);
              break;
            }
          }
      }
      return m;
    }, t.findHostInstance = Xf, t.findHostInstanceWithNoPortals = function(m) {
      return m = oe(m), m = m !== null ? xe(m) : null, m === null ? null : m.stateNode;
    }, t.findHostInstanceWithWarning = function(m) {
      return Xf(m);
    }, t.flushControlled = function(m) {
      var g = zr;
      zr |= 1;
      var R = xa.transition, z = br;
      try {
        xa.transition = null, br = 1, m();
      } finally {
        br = z, xa.transition = R, zr = g, zr === 0 && (Nd(), Os());
      }
    }, t.flushPassiveEffects = fc, t.flushSync = js, t.focusWithin = function(m, g) {
      if (!hn)
        throw Error(u(363));
      for (m = vp(m), g = Sa(m, g), g = Array.from(g), m = 0; m < g.length; ) {
        var R = g[m++];
        if (!ae(R)) {
          if (R.tag === 5 && wt(R.stateNode))
            return !0;
          for (R = R.child; R !== null; )
            g.push(R), R = R.sibling;
        }
      }
      return !1;
    }, t.getCurrentUpdatePriority = function() {
      return br;
    }, t.getFindAllNodesFailureDescription = function(m, g) {
      if (!hn)
        throw Error(u(363));
      var R = 0, z = [];
      m = [vp(m), 0];
      for (var V = 0; V < m.length; ) {
        var Q = m[V++], Me = m[V++], We = g[Me];
        if ((Q.tag !== 5 || !ae(Q)) && (Am(Q, We) && (z.push(ms(We)), Me++, Me > R && (R = Me)), Me < g.length))
          for (Q = Q.child; Q !== null; )
            m.push(Q, Me), Q = Q.sibling;
      }
      if (R < g.length) {
        for (m = []; R < g.length; R++)
          m.push(ms(g[R]));
        return `findAllNodes was able to match part of the selector:
  ` + (z.join(" > ") + `

No matching component was found for:
  `) + m.join(" > ");
      }
      return null;
    }, t.getPublicRootInstance = function(m) {
      if (m = m.current, !m.child)
        return null;
      switch (m.child.tag) {
        case 5:
          return Pe(m.child.stateNode);
        default:
          return m.child.stateNode;
      }
    }, t.injectIntoDevTools = function(m) {
      if (m = { bundleType: m.bundleType, version: m.version, rendererPackageName: m.rendererPackageName, rendererConfig: m.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: h.ReactCurrentDispatcher, findHostInstanceByFiber: dc, findFiberByHostInstance: m.findFiberByHostInstance || Pm, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        m = !1;
      else {
        var g = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (g.isDisabled || !g.supportsFiber)
          m = !0;
        else {
          try {
            Eu = g.inject(m), wl = g;
          } catch {
          }
          m = !!g.checkDCE;
        }
      }
      return m;
    }, t.isAlreadyRendering = function() {
      return !1;
    }, t.observeVisibleRects = function(m, g, R, z) {
      if (!hn)
        throw Error(u(363));
      m = gn(m, g);
      var V = _t(m, R, z).disconnect;
      return { disconnect: function() {
        V();
      } };
    }, t.registerMutableSourceForHydration = function(m, g) {
      var R = g._getVersion;
      R = R(g._source), m.mutableSourceEagerHydrationData == null ? m.mutableSourceEagerHydrationData = [g, R] : m.mutableSourceEagerHydrationData.push(g, R);
    }, t.runWithPriority = function(m, g) {
      var R = br;
      try {
        return br = m, g();
      } finally {
        br = R;
      }
    }, t.shouldError = function() {
      return null;
    }, t.shouldSuspend = function() {
      return !1;
    }, t.updateContainer = function(m, g, R, z) {
      var V = g.current, Q = Yr(), Me = wo(V);
      return R = Xr(R), g.context === null ? g.context = R : g.pendingContext = R, g = rl(Q, Me), g.payload = { element: m }, z = z === void 0 ? null : z, z !== null && (g.callback = z), eu(V, g), m = Ws(V, Me, Q), m !== null && fh(m, V, Me), Me;
    }, t;
  }), B2;
}
var H2 = { exports: {} };
/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Nz;
function yX() {
  return Nz || (Nz = 1, process.env.NODE_ENV !== "production" && (H2.exports = function(e) {
    var t = {}, r = px(), a = xR, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, u = !1;
    function h(l) {
      u = l;
    }
    function v(l) {
      if (!u) {
        for (var f = arguments.length, E = new Array(f > 1 ? f - 1 : 0), w = 1; w < f; w++)
          E[w - 1] = arguments[w];
        _("warn", l, E);
      }
    }
    function y(l) {
      if (!u) {
        for (var f = arguments.length, E = new Array(f > 1 ? f - 1 : 0), w = 1; w < f; w++)
          E[w - 1] = arguments[w];
        _("error", l, E);
      }
    }
    function _(l, f, E) {
      {
        var w = s.ReactDebugCurrentFrame, L = w.getStackAddendum();
        L !== "" && (f += "%s", E = E.concat([L]));
        var B = E.map(function(K) {
          return String(K);
        });
        B.unshift("Warning: " + f), Function.prototype.apply.call(console[l], console, B);
      }
    }
    var b = Object.assign;
    function M(l) {
      return l._reactInternals;
    }
    function C(l, f) {
      l._reactInternals = f;
    }
    var D = !1, U = !1, N = !1, O = !1, I = !1, k = !1, G = !0, j = !0, Y = !0, Z = 0, te = 1, J = 2, q = 3, oe = 4, ye = 5, de = 6, xe = 7, Re = 8, Pe = 9, Te = 10, ue = 11, we = 12, X = 13, me = 14, ce = 15, Ue = 16, Oe = 17, Ze = 18, je = 19, Je = 21, at = 22, xt = 23, $t = 24, Ht = 25, he = Symbol.for("react.element"), nt = Symbol.for("react.portal"), et = Symbol.for("react.fragment"), Rt = Symbol.for("react.strict_mode"), gt = Symbol.for("react.profiler"), Jt = Symbol.for("react.provider"), Kt = Symbol.for("react.context"), qt = Symbol.for("react.forward_ref"), hn = Symbol.for("react.suspense"), Rn = Symbol.for("react.suspense_list"), Yn = Symbol.for("react.memo"), se = Symbol.for("react.lazy"), ae = Symbol.for("react.scope"), Ke = Symbol.for("react.debug_trace_mode"), wt = Symbol.for("react.offscreen"), _t = Symbol.for("react.legacy_hidden"), Vt = Symbol.for("react.cache"), fn = Symbol.for("react.tracing_marker"), Wt = Symbol.iterator, Ee = "@@iterator";
    function Xe(l) {
      if (l === null || typeof l != "object")
        return null;
      var f = Wt && l[Wt] || l[Ee];
      return typeof f == "function" ? f : null;
    }
    function St(l, f, E) {
      var w = l.displayName;
      if (w)
        return w;
      var L = f.displayName || f.name || "";
      return L !== "" ? E + "(" + L + ")" : E;
    }
    function Ut(l) {
      return l.displayName || "Context";
    }
    function Se(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && y("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case et:
          return "Fragment";
        case nt:
          return "Portal";
        case gt:
          return "Profiler";
        case Rt:
          return "StrictMode";
        case hn:
          return "Suspense";
        case Rn:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case Kt:
            var f = l;
            return Ut(f) + ".Consumer";
          case Jt:
            var E = l;
            return Ut(E._context) + ".Provider";
          case qt:
            return St(l, l.render, "ForwardRef");
          case Yn:
            var w = l.displayName || null;
            return w !== null ? w : Se(l.type) || "Memo";
          case se: {
            var L = l, B = L._payload, K = L._init;
            try {
              return Se(K(B));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Ye(l, f, E) {
      var w = f.displayName || f.name || "";
      return l.displayName || (w !== "" ? E + "(" + w + ")" : E);
    }
    function bt(l) {
      return l.displayName || "Context";
    }
    function Tt(l) {
      var f = l.tag, E = l.type;
      switch (f) {
        case $t:
          return "Cache";
        case Pe:
          var w = E;
          return bt(w) + ".Consumer";
        case Te:
          var L = E;
          return bt(L._context) + ".Provider";
        case Ze:
          return "DehydratedFragment";
        case ue:
          return Ye(E, E.render, "ForwardRef");
        case xe:
          return "Fragment";
        case ye:
          return E;
        case oe:
          return "Portal";
        case q:
          return "Root";
        case de:
          return "Text";
        case Ue:
          return Se(E);
        case Re:
          return E === Rt ? "StrictMode" : "Mode";
        case at:
          return "Offscreen";
        case we:
          return "Profiler";
        case Je:
          return "Scope";
        case X:
          return "Suspense";
        case je:
          return "SuspenseList";
        case Ht:
          return "TracingMarker";
        case te:
        case Z:
        case Oe:
        case J:
        case me:
        case ce:
          if (typeof E == "function")
            return E.displayName || E.name || null;
          if (typeof E == "string")
            return E;
          break;
      }
      return null;
    }
    var ge = (
      /*                      */
      0
    ), zt = (
      /*                */
      1
    ), Fe = (
      /*                    */
      2
    ), ft = (
      /*                       */
      4
    ), ln = (
      /*           */
      Fe | ft
    ), zn = (
      /*                */
      16
    ), yr = (
      /*                 */
      32
    ), ti = (
      /*                     */
      64
    ), rr = (
      /*                   */
      128
    ), vr = (
      /*            */
      256
    ), Ai = (
      /*                          */
      512
    ), oi = (
      /*                     */
      1024
    ), Ma = (
      /*                      */
      2048
    ), Ji = (
      /*                    */
      4096
    ), _l = (
      /*           */
      Ji | ft
    ), ea = (
      /*                   */
      8192
    ), _o = (
      /*             */
      16384
    ), Eo = Ma | ft | ti | Ai | oi | _o, Le = (
      /*               */
      32767
    ), Bt = (
      /*                   */
      32768
    ), en = (
      /*                */
      65536
    ), _n = (
      /* */
      131072
    ), ve = (
      /*                       */
      1048576
    ), $e = (
      /*                    */
      2097152
    ), qe = (
      /*                 */
      4194304
    ), ze = (
      /*                */
      8388608
    ), dt = (
      /*               */
      16777216
    ), tn = (
      /*              */
      33554432
    ), pn = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      ft | oi | 0
    ), An = Fe | ft | zn | yr | Ai | Ji | ea, Gn = ft | ti | Ai | ea, cr = Ma | zn, sn = qe | ze | $e, pr = s.ReactCurrentOwner;
    function Pr(l) {
      var f = l, E = l;
      if (l.alternate)
        for (; f.return; )
          f = f.return;
      else {
        var w = f;
        do
          f = w, (f.flags & (Fe | Ji)) !== ge && (E = f.return), w = f.return;
        while (w);
      }
      return f.tag === q ? E : null;
    }
    function kn(l) {
      return Pr(l) === l;
    }
    function za(l) {
      {
        var f = pr.current;
        if (f !== null && f.tag === te) {
          var E = f, w = E.stateNode;
          w._warnedAboutRefsInRender || y("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Tt(E) || "A component"), w._warnedAboutRefsInRender = !0;
        }
      }
      var L = M(l);
      return L ? Pr(L) === L : !1;
    }
    function Ja(l) {
      if (Pr(l) !== l)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Si(l) {
      var f = l.alternate;
      if (!f) {
        var E = Pr(l);
        if (E === null)
          throw new Error("Unable to find node on an unmounted component.");
        return E !== l ? null : l;
      }
      for (var w = l, L = f; ; ) {
        var B = w.return;
        if (B === null)
          break;
        var K = B.alternate;
        if (K === null) {
          var re = B.return;
          if (re !== null) {
            w = L = re;
            continue;
          }
          break;
        }
        if (B.child === K.child) {
          for (var fe = B.child; fe; ) {
            if (fe === w)
              return Ja(B), l;
            if (fe === L)
              return Ja(B), f;
            fe = fe.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (w.return !== L.return)
          w = B, L = K;
        else {
          for (var Ce = !1, ke = B.child; ke; ) {
            if (ke === w) {
              Ce = !0, w = B, L = K;
              break;
            }
            if (ke === L) {
              Ce = !0, L = B, w = K;
              break;
            }
            ke = ke.sibling;
          }
          if (!Ce) {
            for (ke = K.child; ke; ) {
              if (ke === w) {
                Ce = !0, w = K, L = B;
                break;
              }
              if (ke === L) {
                Ce = !0, L = K, w = B;
                break;
              }
              ke = ke.sibling;
            }
            if (!Ce)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (w.alternate !== L)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (w.tag !== q)
        throw new Error("Unable to find node on an unmounted component.");
      return w.stateNode.current === w ? l : f;
    }
    function ir(l) {
      var f = Si(l);
      return f !== null ? Cr(f) : null;
    }
    function Cr(l) {
      if (l.tag === ye || l.tag === de)
        return l;
      for (var f = l.child; f !== null; ) {
        var E = Cr(f);
        if (E !== null)
          return E;
        f = f.sibling;
      }
      return null;
    }
    function fr(l) {
      var f = Si(l);
      return f !== null ? Di(f) : null;
    }
    function Di(l) {
      if (l.tag === ye || l.tag === de)
        return l;
      for (var f = l.child; f !== null; ) {
        if (f.tag !== oe) {
          var E = Di(f);
          if (E !== null)
            return E;
        }
        f = f.sibling;
      }
      return null;
    }
    var wa = Array.isArray;
    function ni(l) {
      return wa(l);
    }
    var ss = e.getPublicInstance, ta = e.getRootHostContext, Vi = e.getChildHostContext, Po = e.prepareForCommit, Ui = e.resetAfterCommit, El = e.createInstance, Ds = e.appendInitialChild, bl = e.finalizeInitialChildren, Go = e.prepareUpdate, Mf = e.shouldSetTextContent, Qu = e.createTextInstance, fm = e.scheduleTimeout, Tl = e.cancelTimeout, Kr = e.noTimeout;
    e.now;
    var Ml = e.isPrimaryRenderer, Zu = e.warnsIfNotActing, ls = e.supportsMutation, jr = e.supportsPersistence, lo = e.supportsHydration, wf = e.getInstanceFromNode;
    e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
    var lr = e.preparePortalMount;
    e.preparePortalMount, e.getInstanceFromScope;
    var pd = e.getCurrentEventPriority, pa = e.detachDeletedInstance, br = e.supportsMicrotasks, us = e.scheduleMicrotask, Ls = e.supportsTestSelectors, Ca = e.findFiberRoot, zi = e.getBoundingRect, dm = e.getTextContent, si = e.isHiddenSubtree, uo = e.matchAccessibilityRole, Ju = e.setFocusIfFocusable, ch = e.setupIntersectionObserver, Nc = e.appendChild, Eu = e.appendChildToContainer, wl = e.commitTextUpdate, Jl = e.commitMount, Cf = e.commitUpdate, Wo = e.insertBefore, co = e.insertInContainerBefore, Uc = e.removeChild, ec = e.removeChildFromContainer, tc = e.resetTextContent, md = e.hideInstance, Os = e.hideTextInstance, op = e.unhideInstance, nl = e.unhideTextInstance, ne = e.clearContainer, De = e.cloneInstance, st = e.createContainerChildSet, yt = e.appendChildToContainerChildSet, Zt = e.finalizeContainerChildren, Xn = e.replaceContainerChildren;
    e.getOffscreenContainerType;
    var mn = e.getOffscreenContainerProps, qn = e.cloneHiddenInstance, Nr = e.cloneHiddenTextInstance, ri = e.canHydrateInstance, Ti = e.canHydrateTextInstance, Br = e.canHydrateSuspenseInstance, Qr = e.isSuspenseInstancePending, li = e.isSuspenseInstanceFallback, $r = e.registerSuspenseInstanceRetry, Cl = e.getNextHydratableSibling, rl = e.getFirstHydratableChild, eu = e.getFirstHydratableChildWithinContainer, fh = e.getFirstHydratableChildWithinSuspenseInstance, tu = e.hydrateInstance, Rf = e.hydrateTextInstance, dh = e.hydrateSuspenseInstance, hm = e.getNextHydratableInstanceAfterSuspenseInstance, pm = e.commitHydratedContainer, mm = e.commitHydratedSuspenseInstance, vm = e.clearSuspenseBoundary, gm = e.clearSuspenseBoundaryFromContainer, Cv = e.shouldDeleteUnhydratedTailInstances, ym = e.didNotMatchHydratedContainerTextInstance, vd = e.didNotMatchHydratedTextInstance, Af = e.didNotHydrateInstanceWithinContainer, nu = e.didNotHydrateInstanceWithinSuspenseInstance, Sm = e.didNotHydrateInstance, il = e.didNotFindHydratableInstanceWithinContainer, Ps = e.didNotFindHydratableTextInstanceWithinContainer, zc = e.didNotFindHydratableSuspenseInstanceWithinContainer, kc = e.didNotFindHydratableInstanceWithinSuspenseInstance, ru = e.didNotFindHydratableTextInstanceWithinSuspenseInstance, Df = e.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, Ns = e.didNotFindHydratableInstance, bu = e.didNotFindHydratableTextInstance, ka = e.didNotFindHydratableSuspenseInstance, Ra = e.errorHydratingContainer, Aa = 0, Yi, gd, jo, xm, _m, yd, Ic;
    function Rv() {
    }
    Rv.__reactDisabledLog = !0;
    function sp() {
      {
        if (Aa === 0) {
          Yi = console.log, gd = console.info, jo = console.warn, xm = console.error, _m = console.group, yd = console.groupCollapsed, Ic = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: Rv,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        Aa++;
      }
    }
    function Sd() {
      {
        if (Aa--, Aa === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: b({}, l, {
              value: Yi
            }),
            info: b({}, l, {
              value: gd
            }),
            warn: b({}, l, {
              value: jo
            }),
            error: b({}, l, {
              value: xm
            }),
            group: b({}, l, {
              value: _m
            }),
            groupCollapsed: b({}, l, {
              value: yd
            }),
            groupEnd: b({}, l, {
              value: Ic
            })
          });
        }
        Aa < 0 && y("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var hh = s.ReactCurrentDispatcher, Lf;
    function Us(l, f, E) {
      {
        if (Lf === void 0)
          try {
            throw Error();
          } catch (L) {
            var w = L.stack.trim().match(/\n( *(at )?)/);
            Lf = w && w[1] || "";
          }
        return `
` + Lf + l;
      }
    }
    var Fc = !1, nc;
    {
      var Tu = typeof WeakMap == "function" ? WeakMap : Map;
      nc = new Tu();
    }
    function lp(l, f) {
      if (!l || Fc)
        return "";
      {
        var E = nc.get(l);
        if (E !== void 0)
          return E;
      }
      var w;
      Fc = !0;
      var L = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var B;
      B = hh.current, hh.current = null, sp();
      try {
        if (f) {
          var K = function() {
            throw Error();
          };
          if (Object.defineProperty(K.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(K, []);
            } catch (Xt) {
              w = Xt;
            }
            Reflect.construct(l, [], K);
          } else {
            try {
              K.call();
            } catch (Xt) {
              w = Xt;
            }
            l.call(K.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Xt) {
            w = Xt;
          }
          l();
        }
      } catch (Xt) {
        if (Xt && w && typeof Xt.stack == "string") {
          for (var re = Xt.stack.split(`
`), fe = w.stack.split(`
`), Ce = re.length - 1, ke = fe.length - 1; Ce >= 1 && ke >= 0 && re[Ce] !== fe[ke]; )
            ke--;
          for (; Ce >= 1 && ke >= 0; Ce--, ke--)
            if (re[Ce] !== fe[ke]) {
              if (Ce !== 1 || ke !== 1)
                do
                  if (Ce--, ke--, ke < 0 || re[Ce] !== fe[ke]) {
                    var tt = `
` + re[Ce].replace(" at new ", " at ");
                    return l.displayName && tt.includes("<anonymous>") && (tt = tt.replace("<anonymous>", l.displayName)), typeof l == "function" && nc.set(l, tt), tt;
                  }
                while (Ce >= 1 && ke >= 0);
              break;
            }
        }
      } finally {
        Fc = !1, hh.current = B, Sd(), Error.prepareStackTrace = L;
      }
      var Et = l ? l.displayName || l.name : "", Dt = Et ? Us(Et) : "";
      return typeof l == "function" && nc.set(l, Dt), Dt;
    }
    function xd(l, f, E) {
      return lp(l, !0);
    }
    function cs(l, f, E) {
      return lp(l, !1);
    }
    function _d(l) {
      var f = l.prototype;
      return !!(f && f.isReactComponent);
    }
    function Bc(l, f, E) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return lp(l, _d(l));
      if (typeof l == "string")
        return Us(l);
      switch (l) {
        case hn:
          return Us("Suspense");
        case Rn:
          return Us("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case qt:
            return cs(l.render);
          case Yn:
            return Bc(l.type, f, E);
          case se: {
            var w = l, L = w._payload, B = w._init;
            try {
              return Bc(B(L), f, E);
            } catch {
            }
          }
        }
      return "";
    }
    var iu = Object.prototype.hasOwnProperty, up = {}, Ed = s.ReactDebugCurrentFrame;
    function cp(l) {
      if (l) {
        var f = l._owner, E = Bc(l.type, l._source, f ? f.type : null);
        Ed.setExtraStackFrame(E);
      } else
        Ed.setExtraStackFrame(null);
    }
    function Rl(l, f, E, w, L) {
      {
        var B = Function.call.bind(iu);
        for (var K in l)
          if (B(l, K)) {
            var re = void 0;
            try {
              if (typeof l[K] != "function") {
                var fe = Error((w || "React class") + ": " + E + " type `" + K + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[K] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw fe.name = "Invariant Violation", fe;
              }
              re = l[K](f, K, w, E, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ce) {
              re = Ce;
            }
            re && !(re instanceof Error) && (cp(L), y("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", w || "React class", E, K, typeof re), cp(null)), re instanceof Error && !(re.message in up) && (up[re.message] = !0, cp(L), y("Failed %s type: %s", E, re.message), cp(null));
          }
      }
    }
    var la = [], bd;
    bd = [];
    var Ia = -1;
    function al(l) {
      return {
        current: l
      };
    }
    function fo(l, f) {
      if (Ia < 0) {
        y("Unexpected pop.");
        return;
      }
      f !== bd[Ia] && y("Unexpected Fiber popped."), l.current = la[Ia], la[Ia] = null, bd[Ia] = null, Ia--;
    }
    function Gi(l, f, E) {
      Ia++, la[Ia] = l.current, bd[Ia] = E, l.current = f;
    }
    var Hc;
    Hc = {};
    var Zr = {};
    Object.freeze(Zr);
    var Mi = al(Zr), ki = al(!1), Td = Zr;
    function ho(l, f, E) {
      return E && Al(f) ? Td : Mi.current;
    }
    function Of(l, f, E) {
      {
        var w = l.stateNode;
        w.__reactInternalMemoizedUnmaskedChildContext = f, w.__reactInternalMemoizedMaskedChildContext = E;
      }
    }
    function rc(l, f) {
      {
        var E = l.type, w = E.contextTypes;
        if (!w)
          return Zr;
        var L = l.stateNode;
        if (L && L.__reactInternalMemoizedUnmaskedChildContext === f)
          return L.__reactInternalMemoizedMaskedChildContext;
        var B = {};
        for (var K in w)
          B[K] = f[K];
        {
          var re = Tt(l) || "Unknown";
          Rl(w, B, "context", re);
        }
        return L && Of(l, f, B), B;
      }
    }
    function eo() {
      return ki.current;
    }
    function Al(l) {
      {
        var f = l.childContextTypes;
        return f != null;
      }
    }
    function Vc(l) {
      fo(ki, l), fo(Mi, l);
    }
    function Mu(l) {
      fo(ki, l), fo(Mi, l);
    }
    function au(l, f, E) {
      {
        if (Mi.current !== Zr)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Gi(Mi, f, l), Gi(ki, E, l);
      }
    }
    function Dl(l, f, E) {
      {
        var w = l.stateNode, L = f.childContextTypes;
        if (typeof w.getChildContext != "function") {
          {
            var B = Tt(l) || "Unknown";
            Hc[B] || (Hc[B] = !0, y("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", B, B));
          }
          return E;
        }
        var K = w.getChildContext();
        for (var re in K)
          if (!(re in L))
            throw new Error((Tt(l) || "Unknown") + '.getChildContext(): key "' + re + '" is not defined in childContextTypes.');
        {
          var fe = Tt(l) || "Unknown";
          Rl(L, K, "child context", fe);
        }
        return b({}, E, K);
      }
    }
    function na(l) {
      {
        var f = l.stateNode, E = f && f.__reactInternalMemoizedMergedChildContext || Zr;
        return Td = Mi.current, Gi(Mi, E, l), Gi(ki, ki.current, l), !0;
      }
    }
    function Md(l, f, E) {
      {
        var w = l.stateNode;
        if (!w)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (E) {
          var L = Dl(l, f, Td);
          w.__reactInternalMemoizedMergedChildContext = L, fo(ki, l), fo(Mi, l), Gi(Mi, L, l), Gi(ki, E, l);
        } else
          fo(ki, l), Gi(ki, E, l);
      }
    }
    function fp(l) {
      {
        if (!kn(l) || l.tag !== te)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var f = l;
        do {
          switch (f.tag) {
            case q:
              return f.stateNode.context;
            case te: {
              var E = f.type;
              if (Al(E))
                return f.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          f = f.return;
        } while (f !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Pf = 0, Em = 1, mr = (
      /*                         */
      0
    ), Ii = (
      /*                 */
      1
    ), Ur = (
      /*                    */
      2
    ), ma = (
      /*               */
      8
    ), No = (
      /*              */
      16
    ), ph = Math.clz32 ? Math.clz32 : bm, mh = Math.log, Nf = Math.LN2;
    function bm(l) {
      var f = l >>> 0;
      return f === 0 ? 32 : 31 - (mh(f) / Nf | 0) | 0;
    }
    var vh = 31, Gt = (
      /*                        */
      0
    ), Tr = (
      /*                          */
      0
    ), wr = (
      /*                        */
      1
    ), zs = (
      /*    */
      2
    ), ol = (
      /*            */
      4
    ), ic = (
      /*            */
      8
    ), Ll = (
      /*                    */
      16
    ), ac = (
      /*                */
      32
    ), oc = (
      /*                       */
      4194240
    ), ou = (
      /*                        */
      64
    ), dp = (
      /*                        */
      128
    ), hp = (
      /*                        */
      256
    ), Tm = (
      /*                        */
      512
    ), gh = (
      /*                        */
      1024
    ), wd = (
      /*                        */
      2048
    ), Cd = (
      /*                        */
      4096
    ), Uf = (
      /*                        */
      8192
    ), Gc = (
      /*                        */
      16384
    ), Rd = (
      /*                       */
      32768
    ), Wc = (
      /*                       */
      65536
    ), yh = (
      /*                       */
      131072
    ), Ad = (
      /*                       */
      262144
    ), pp = (
      /*                       */
      524288
    ), Mm = (
      /*                       */
      1048576
    ), wu = (
      /*                       */
      2097152
    ), ks = (
      /*                            */
      130023424
    ), Cu = (
      /*                             */
      4194304
    ), Ru = (
      /*                             */
      8388608
    ), to = (
      /*                             */
      16777216
    ), sc = (
      /*                             */
      33554432
    ), Is = (
      /*                             */
      67108864
    ), zf = Cu, kf = (
      /*          */
      134217728
    ), Dd = (
      /*                                 */
      268435455
    ), $o = (
      /*               */
      268435456
    ), Fs = (
      /*                       */
      536870912
    ), xi = (
      /*                   */
      1073741824
    );
    function Kn(l) {
      {
        if (l & wr)
          return "Sync";
        if (l & zs)
          return "InputContinuousHydration";
        if (l & ol)
          return "InputContinuous";
        if (l & ic)
          return "DefaultHydration";
        if (l & Ll)
          return "Default";
        if (l & ac)
          return "TransitionHydration";
        if (l & oc)
          return "Transition";
        if (l & ks)
          return "Retry";
        if (l & kf)
          return "SelectiveHydration";
        if (l & $o)
          return "IdleHydration";
        if (l & Fs)
          return "Idle";
        if (l & xi)
          return "Offscreen";
      }
    }
    var _i = -1, Hr = ou, Hn = Cu;
    function ii(l) {
      switch (su(l)) {
        case wr:
          return wr;
        case zs:
          return zs;
        case ol:
          return ol;
        case ic:
          return ic;
        case Ll:
          return Ll;
        case ac:
          return ac;
        case ou:
        case dp:
        case hp:
        case Tm:
        case gh:
        case wd:
        case Cd:
        case Uf:
        case Gc:
        case Rd:
        case Wc:
        case yh:
        case Ad:
        case pp:
        case Mm:
        case wu:
          return l & oc;
        case Cu:
        case Ru:
        case to:
        case sc:
        case Is:
          return l & ks;
        case kf:
          return kf;
        case $o:
          return $o;
        case Fs:
          return Fs;
        case xi:
          return xi;
        default:
          return y("Should have found matching lanes. This is a bug in React."), l;
      }
    }
    function di(l, f) {
      var E = l.pendingLanes;
      if (E === Gt)
        return Gt;
      var w = Gt, L = l.suspendedLanes, B = l.pingedLanes, K = E & Dd;
      if (K !== Gt) {
        var re = K & ~L;
        if (re !== Gt)
          w = ii(re);
        else {
          var fe = K & B;
          fe !== Gt && (w = ii(fe));
        }
      } else {
        var Ce = E & ~L;
        Ce !== Gt ? w = ii(Ce) : B !== Gt && (w = ii(B));
      }
      if (w === Gt)
        return Gt;
      if (f !== Gt && f !== w && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (f & L) === Gt) {
        var ke = su(w), tt = su(f);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          ke >= tt || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          ke === Ll && (tt & oc) !== Gt
        )
          return f;
      }
      (w & ol) !== Gt && (w |= E & Ll);
      var Et = l.entangledLanes;
      if (Et !== Gt)
        for (var Dt = l.entanglements, Xt = w & Et; Xt > 0; ) {
          var an = Fa(Xt), or = 1 << an;
          w |= Dt[an], Xt &= ~or;
        }
      return w;
    }
    function Au(l, f) {
      for (var E = l.eventTimes, w = _i; f > 0; ) {
        var L = Fa(f), B = 1 << L, K = E[L];
        K > w && (w = K), f &= ~B;
      }
      return w;
    }
    function dr(l, f) {
      switch (l) {
        case wr:
        case zs:
        case ol:
          return f + 250;
        case ic:
        case Ll:
        case ac:
        case ou:
        case dp:
        case hp:
        case Tm:
        case gh:
        case wd:
        case Cd:
        case Uf:
        case Gc:
        case Rd:
        case Wc:
        case yh:
        case Ad:
        case pp:
        case Mm:
        case wu:
          return f + 5e3;
        case Cu:
        case Ru:
        case to:
        case sc:
        case Is:
          return _i;
        case kf:
        case $o:
        case Fs:
        case xi:
          return _i;
        default:
          return y("Should have found matching lanes. This is a bug in React."), _i;
      }
    }
    function Da(l, f) {
      for (var E = l.pendingLanes, w = l.suspendedLanes, L = l.pingedLanes, B = l.expirationTimes, K = E; K > 0; ) {
        var re = Fa(K), fe = 1 << re, Ce = B[re];
        Ce === _i ? ((fe & w) === Gt || (fe & L) !== Gt) && (B[re] = dr(fe, f)) : Ce <= f && (l.expiredLanes |= fe), K &= ~fe;
      }
    }
    function fs(l) {
      return ii(l.pendingLanes);
    }
    function Bs(l) {
      var f = l.pendingLanes & ~xi;
      return f !== Gt ? f : f & xi ? xi : Gt;
    }
    function ua(l) {
      return (l & wr) !== Gt;
    }
    function Hs(l) {
      return (l & Dd) !== Gt;
    }
    function lc(l) {
      return (l & ks) === l;
    }
    function If(l) {
      return (l & oc) === l;
    }
    function uc(l, f) {
      var E = zs | ol | ic | Ll;
      return (f & E) !== Gt;
    }
    function Av(l, f) {
      return (f & l.expiredLanes) !== Gt;
    }
    function ds(l) {
      return (l & oc) !== 0;
    }
    function bo() {
      var l = Hr;
      return Hr <<= 1, Hr & oc || (Hr = ou), l;
    }
    function Sh() {
      var l = Hn;
      return Hn <<= 1, Hn & ks || (Hn = Cu), l;
    }
    function su(l) {
      return l & -l;
    }
    function Ff(l) {
      return su(l);
    }
    function Fa(l) {
      return 31 - ph(l);
    }
    function Du(l) {
      return Fa(l);
    }
    function hi(l, f) {
      return (l & f) !== Gt;
    }
    function lu(l, f) {
      return (l & f) === f;
    }
    function Sr(l, f) {
      return l | f;
    }
    function po(l, f) {
      return l & ~f;
    }
    function La(l, f) {
      return l & f;
    }
    function Lu(l) {
      return l;
    }
    function rn(l, f) {
      return l !== Tr && l < f ? l : f;
    }
    function sl(l) {
      for (var f = [], E = 0; E < vh; E++)
        f.push(l);
      return f;
    }
    function To(l, f, E) {
      l.pendingLanes |= f, f !== Fs && (l.suspendedLanes = Gt, l.pingedLanes = Gt);
      var w = l.eventTimes, L = Du(f);
      w[L] = E;
    }
    function wm(l, f) {
      l.suspendedLanes |= f, l.pingedLanes &= ~f;
      for (var E = l.expirationTimes, w = f; w > 0; ) {
        var L = Fa(w), B = 1 << L;
        E[L] = _i, w &= ~B;
      }
    }
    function mp(l, f, E) {
      l.pingedLanes |= l.suspendedLanes & f;
    }
    function jc(l, f) {
      var E = l.pendingLanes & ~f;
      l.pendingLanes = f, l.suspendedLanes = 0, l.pingedLanes = 0, l.expiredLanes &= f, l.mutableReadLanes &= f, l.entangledLanes &= f;
      for (var w = l.entanglements, L = l.eventTimes, B = l.expirationTimes, K = E; K > 0; ) {
        var re = Fa(K), fe = 1 << re;
        w[re] = Gt, L[re] = _i, B[re] = _i, K &= ~fe;
      }
    }
    function Mo(l, f) {
      for (var E = l.entangledLanes |= f, w = l.entanglements, L = E; L; ) {
        var B = Fa(L), K = 1 << B;
        // Is this one of the newly entangled lanes?
        K & f | // Is this lane transitively entangled with the newly entangled lanes?
        w[B] & f && (w[B] |= f), L &= ~K;
      }
    }
    function hs(l, f) {
      var E = su(f), w;
      switch (E) {
        case ol:
          w = zs;
          break;
        case Ll:
          w = ic;
          break;
        case ou:
        case dp:
        case hp:
        case Tm:
        case gh:
        case wd:
        case Cd:
        case Uf:
        case Gc:
        case Rd:
        case Wc:
        case yh:
        case Ad:
        case pp:
        case Mm:
        case wu:
        case Cu:
        case Ru:
        case to:
        case sc:
        case Is:
          w = ac;
          break;
        case Fs:
          w = $o;
          break;
        default:
          w = Tr;
          break;
      }
      return (w & (l.suspendedLanes | f)) !== Tr ? Tr : w;
    }
    function ra(l, f, E) {
      if (Ha)
        for (var w = l.pendingUpdatersLaneMap; E > 0; ) {
          var L = Du(E), B = 1 << L, K = w[L];
          K.add(f), E &= ~B;
        }
    }
    function ll(l, f) {
      if (Ha)
        for (var E = l.pendingUpdatersLaneMap, w = l.memoizedUpdaters; f > 0; ) {
          var L = Du(f), B = 1 << L, K = E[L];
          K.size > 0 && (K.forEach(function(re) {
            var fe = re.alternate;
            (fe === null || !w.has(fe)) && w.add(re);
          }), K.clear()), f &= ~B;
        }
    }
    var Ol = wr, Ld = ol, $c = Ll, Od = Fs, Bf = Tr;
    function ps() {
      return Bf;
    }
    function mo(l) {
      Bf = l;
    }
    function va(l, f) {
      var E = Bf;
      try {
        return Bf = l, f();
      } finally {
        Bf = E;
      }
    }
    function xh(l, f) {
      return l !== 0 && l < f ? l : f;
    }
    function Cm(l, f) {
      return l === 0 || l > f ? l : f;
    }
    function ul(l, f) {
      return l !== 0 && l < f;
    }
    function uu(l) {
      var f = su(l);
      return ul(Ol, f) ? ul(Ld, f) ? Hs(f) ? $c : Od : Ld : Ol;
    }
    var _h = a.unstable_scheduleCallback, Yc = a.unstable_cancelCallback, Rm = a.unstable_shouldYield, Eh = a.unstable_requestPaint, Xi = a.unstable_now, ya = a.unstable_ImmediatePriority, dn = a.unstable_UserBlockingPriority, Wi = a.unstable_NormalPriority, Ba = a.unstable_IdlePriority, vp = a.unstable_yieldValue, Am = a.unstable_setDisableYieldValue, ms = null, Sa = null, gn = null, qi = !1, Ha = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function cc(l) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (f.isDisabled)
        return !0;
      if (!f.supportsFiber)
        return y("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        G && (l = b({}, l, {
          getLaneLabelMap: Xc,
          injectProfilingHooks: Vs
        })), ms = f.inject(l), Sa = f;
      } catch (E) {
        y("React instrumentation encountered an error: %s.", E);
      }
      return !!f.checkDCE;
    }
    function xa(l, f) {
      if (Sa && typeof Sa.onScheduleFiberRoot == "function")
        try {
          Sa.onScheduleFiberRoot(ms, l, f);
        } catch (E) {
          qi || (qi = !0, y("React instrumentation encountered an error: %s", E));
        }
    }
    function zr(l, f) {
      if (Sa && typeof Sa.onCommitFiberRoot == "function")
        try {
          var E = (l.current.flags & rr) === rr;
          if (j) {
            var w;
            switch (f) {
              case Ol:
                w = ya;
                break;
              case Ld:
                w = dn;
                break;
              case $c:
                w = Wi;
                break;
              case Od:
                w = Ba;
                break;
              default:
                w = Wi;
                break;
            }
            Sa.onCommitFiberRoot(ms, l, w, E);
          }
        } catch (L) {
          qi || (qi = !0, y("React instrumentation encountered an error: %s", L));
        }
    }
    function ia(l) {
      if (Sa && typeof Sa.onPostCommitFiberRoot == "function")
        try {
          Sa.onPostCommitFiberRoot(ms, l);
        } catch (f) {
          qi || (qi = !0, y("React instrumentation encountered an error: %s", f));
        }
    }
    function ca(l) {
      if (Sa && typeof Sa.onCommitFiberUnmount == "function")
        try {
          Sa.onCommitFiberUnmount(ms, l);
        } catch (f) {
          qi || (qi = !0, y("React instrumentation encountered an error: %s", f));
        }
    }
    function ui(l) {
      if (typeof vp == "function" && (Am(l), h(l)), Sa && typeof Sa.setStrictMode == "function")
        try {
          Sa.setStrictMode(ms, l);
        } catch (f) {
          qi || (qi = !0, y("React instrumentation encountered an error: %s", f));
        }
    }
    function Vs(l) {
      gn = l;
    }
    function Xc() {
      {
        for (var l = /* @__PURE__ */ new Map(), f = 1, E = 0; E < vh; E++) {
          var w = Kn(f);
          l.set(f, w), f *= 2;
        }
        return l;
      }
    }
    function vo(l) {
      gn !== null && typeof gn.markCommitStarted == "function" && gn.markCommitStarted(l);
    }
    function Pd() {
      gn !== null && typeof gn.markCommitStopped == "function" && gn.markCommitStopped();
    }
    function Ou(l) {
      gn !== null && typeof gn.markComponentRenderStarted == "function" && gn.markComponentRenderStarted(l);
    }
    function cu() {
      gn !== null && typeof gn.markComponentRenderStopped == "function" && gn.markComponentRenderStopped();
    }
    function Hf(l) {
      gn !== null && typeof gn.markComponentPassiveEffectMountStarted == "function" && gn.markComponentPassiveEffectMountStarted(l);
    }
    function Vf() {
      gn !== null && typeof gn.markComponentPassiveEffectMountStopped == "function" && gn.markComponentPassiveEffectMountStopped();
    }
    function Gs(l) {
      gn !== null && typeof gn.markComponentPassiveEffectUnmountStarted == "function" && gn.markComponentPassiveEffectUnmountStarted(l);
    }
    function Dm() {
      gn !== null && typeof gn.markComponentPassiveEffectUnmountStopped == "function" && gn.markComponentPassiveEffectUnmountStopped();
    }
    function Gf(l) {
      gn !== null && typeof gn.markComponentLayoutEffectMountStarted == "function" && gn.markComponentLayoutEffectMountStarted(l);
    }
    function Nd() {
      gn !== null && typeof gn.markComponentLayoutEffectMountStopped == "function" && gn.markComponentLayoutEffectMountStopped();
    }
    function qc(l) {
      gn !== null && typeof gn.markComponentLayoutEffectUnmountStarted == "function" && gn.markComponentLayoutEffectUnmountStarted(l);
    }
    function cl() {
      gn !== null && typeof gn.markComponentLayoutEffectUnmountStopped == "function" && gn.markComponentLayoutEffectUnmountStopped();
    }
    function fu(l, f, E) {
      gn !== null && typeof gn.markComponentErrored == "function" && gn.markComponentErrored(l, f, E);
    }
    function Kc(l, f, E) {
      gn !== null && typeof gn.markComponentSuspended == "function" && gn.markComponentSuspended(l, f, E);
    }
    function fl(l) {
      gn !== null && typeof gn.markLayoutEffectsStarted == "function" && gn.markLayoutEffectsStarted(l);
    }
    function bh() {
      gn !== null && typeof gn.markLayoutEffectsStopped == "function" && gn.markLayoutEffectsStopped();
    }
    function du(l) {
      gn !== null && typeof gn.markPassiveEffectsStarted == "function" && gn.markPassiveEffectsStarted(l);
    }
    function Qn() {
      gn !== null && typeof gn.markPassiveEffectsStopped == "function" && gn.markPassiveEffectsStopped();
    }
    function Rr(l) {
      gn !== null && typeof gn.markRenderStarted == "function" && gn.markRenderStarted(l);
    }
    function Zn() {
      gn !== null && typeof gn.markRenderYielded == "function" && gn.markRenderYielded();
    }
    function Yr() {
      gn !== null && typeof gn.markRenderStopped == "function" && gn.markRenderStopped();
    }
    function wo(l) {
      gn !== null && typeof gn.markRenderScheduled == "function" && gn.markRenderScheduled(l);
    }
    function Ws(l, f) {
      gn !== null && typeof gn.markForceUpdateScheduled == "function" && gn.markForceUpdateScheduled(l, f);
    }
    function Qc(l, f) {
      gn !== null && typeof gn.markStateUpdateScheduled == "function" && gn.markStateUpdateScheduled(l, f);
    }
    function vs(l, f) {
      return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
    }
    var Co = typeof Object.is == "function" ? Object.is : vs, ci = null, Ct = !1, Jr = !1;
    function Wn(l) {
      ci === null ? ci = [l] : ci.push(l);
    }
    function Pu(l) {
      Ct = !0, Wn(l);
    }
    function js() {
      Ct && Uo();
    }
    function Uo() {
      if (!Jr && ci !== null) {
        Jr = !0;
        var l = 0, f = ps();
        try {
          var E = !0, w = ci;
          for (mo(Ol); l < w.length; l++) {
            var L = w[l];
            do
              L = L(E);
            while (L !== null);
          }
          ci = null, Ct = !1;
        } catch (B) {
          throw ci !== null && (ci = ci.slice(l + 1)), _h(ya, Uo), B;
        } finally {
          mo(f), Jr = !1;
        }
      }
      return null;
    }
    function wi(l) {
      var f = l.current.memoizedState;
      return f.isDehydrated;
    }
    var Wf = s.ReactCurrentBatchConfig, Zc = null;
    function Jc() {
      return Wf.transition;
    }
    function zo(l, f) {
      if (Co(l, f))
        return !0;
      if (typeof l != "object" || l === null || typeof f != "object" || f === null)
        return !1;
      var E = Object.keys(l), w = Object.keys(f);
      if (E.length !== w.length)
        return !1;
      for (var L = 0; L < E.length; L++) {
        var B = E[L];
        if (!iu.call(f, B) || !Co(l[B], f[B]))
          return !1;
      }
      return !0;
    }
    function dl(l) {
      switch (l._debugOwner && l._debugOwner.type, l._debugSource, l.tag) {
        case ye:
          return Us(l.type);
        case Ue:
          return Us("Lazy");
        case X:
          return Us("Suspense");
        case je:
          return Us("SuspenseList");
        case Z:
        case J:
        case ce:
          return cs(l.type);
        case ue:
          return cs(l.type.render);
        case te:
          return xd(l.type);
        default:
          return "";
      }
    }
    function jf(l) {
      try {
        var f = "", E = l;
        do
          f += dl(E), E = E.return;
        while (E);
        return f;
      } catch (w) {
        return `
Error generating stack: ` + w.message + `
` + w.stack;
      }
    }
    var Ud = s.ReactDebugCurrentFrame, Yo = null, hl = !1;
    function Lm() {
      {
        if (Yo === null)
          return null;
        var l = Yo._debugOwner;
        if (l !== null && typeof l < "u")
          return Tt(l);
      }
      return null;
    }
    function fc() {
      return Yo === null ? "" : jf(Yo);
    }
    function go() {
      Ud.getCurrentStack = null, Yo = null, hl = !1;
    }
    function pi(l) {
      Ud.getCurrentStack = fc, Yo = l, hl = !1;
    }
    function Pl(l) {
      hl = l;
    }
    var $s = {
      recordUnsafeLifecycleWarnings: function(l, f) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(l, f) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var Om = function(l) {
        for (var f = null, E = l; E !== null; )
          E.mode & ma && (f = E), E = E.return;
        return f;
      }, Nl = function(l) {
        var f = [];
        return l.forEach(function(E) {
          f.push(E);
        }), f.sort().join(", ");
      }, ef = [], hu = [], Ul = [], Ro = [], Nu = [], $f = [], Xo = /* @__PURE__ */ new Set();
      $s.recordUnsafeLifecycleWarnings = function(l, f) {
        Xo.has(l.type) || (typeof f.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        f.componentWillMount.__suppressDeprecationWarning !== !0 && ef.push(l), l.mode & ma && typeof f.UNSAFE_componentWillMount == "function" && hu.push(l), typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Ul.push(l), l.mode & ma && typeof f.UNSAFE_componentWillReceiveProps == "function" && Ro.push(l), typeof f.componentWillUpdate == "function" && f.componentWillUpdate.__suppressDeprecationWarning !== !0 && Nu.push(l), l.mode & ma && typeof f.UNSAFE_componentWillUpdate == "function" && $f.push(l));
      }, $s.flushPendingUnsafeLifecycleWarnings = function() {
        var l = /* @__PURE__ */ new Set();
        ef.length > 0 && (ef.forEach(function(Et) {
          l.add(Tt(Et) || "Component"), Xo.add(Et.type);
        }), ef = []);
        var f = /* @__PURE__ */ new Set();
        hu.length > 0 && (hu.forEach(function(Et) {
          f.add(Tt(Et) || "Component"), Xo.add(Et.type);
        }), hu = []);
        var E = /* @__PURE__ */ new Set();
        Ul.length > 0 && (Ul.forEach(function(Et) {
          E.add(Tt(Et) || "Component"), Xo.add(Et.type);
        }), Ul = []);
        var w = /* @__PURE__ */ new Set();
        Ro.length > 0 && (Ro.forEach(function(Et) {
          w.add(Tt(Et) || "Component"), Xo.add(Et.type);
        }), Ro = []);
        var L = /* @__PURE__ */ new Set();
        Nu.length > 0 && (Nu.forEach(function(Et) {
          L.add(Tt(Et) || "Component"), Xo.add(Et.type);
        }), Nu = []);
        var B = /* @__PURE__ */ new Set();
        if ($f.length > 0 && ($f.forEach(function(Et) {
          B.add(Tt(Et) || "Component"), Xo.add(Et.type);
        }), $f = []), f.size > 0) {
          var K = Nl(f);
          y(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, K);
        }
        if (w.size > 0) {
          var re = Nl(w);
          y(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, re);
        }
        if (B.size > 0) {
          var fe = Nl(B);
          y(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, fe);
        }
        if (l.size > 0) {
          var Ce = Nl(l);
          v(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ce);
        }
        if (E.size > 0) {
          var ke = Nl(E);
          v(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ke);
        }
        if (L.size > 0) {
          var tt = Nl(L);
          v(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, tt);
        }
      };
      var tf = /* @__PURE__ */ new Map(), zl = /* @__PURE__ */ new Set();
      $s.recordLegacyContextWarning = function(l, f) {
        var E = Om(l);
        if (E === null) {
          y("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!zl.has(l.type)) {
          var w = tf.get(E);
          (l.type.contextTypes != null || l.type.childContextTypes != null || f !== null && typeof f.getChildContext == "function") && (w === void 0 && (w = [], tf.set(E, w)), w.push(l));
        }
      }, $s.flushLegacyContextWarning = function() {
        tf.forEach(function(l, f) {
          if (l.length !== 0) {
            var E = l[0], w = /* @__PURE__ */ new Set();
            l.forEach(function(B) {
              w.add(Tt(B) || "Component"), zl.add(B.type);
            });
            var L = Nl(w);
            try {
              pi(E), y(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, L);
            } finally {
              go();
            }
          }
        });
      }, $s.discardPendingWarnings = function() {
        ef = [], hu = [], Ul = [], Ro = [], Nu = [], $f = [], tf = /* @__PURE__ */ new Map();
      };
    }
    function Yf(l) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, E = f && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return E;
      }
    }
    function nf(l) {
      try {
        return pu(l), !1;
      } catch {
        return !0;
      }
    }
    function pu(l) {
      return "" + l;
    }
    function pl(l) {
      if (nf(l))
        return y("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Yf(l)), pu(l);
    }
    function Yg(l, f) {
      if (nf(l))
        return y("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", f, Yf(l)), pu(l);
    }
    function Xr(l, f) {
      if (l && l.defaultProps) {
        var E = b({}, f), w = l.defaultProps;
        for (var L in w)
          E[L] === void 0 && (E[L] = w[L]);
        return E;
      }
      return f;
    }
    var Xf = al(null), rf;
    rf = {};
    var Uu = null, dc = null, Pm = null, m = !1;
    function g() {
      Uu = null, dc = null, Pm = null, m = !1;
    }
    function R() {
      m = !0;
    }
    function z() {
      m = !1;
    }
    function V(l, f, E) {
      Ml ? (Gi(Xf, f._currentValue, l), f._currentValue = E, f._currentRenderer !== void 0 && f._currentRenderer !== null && f._currentRenderer !== rf && y("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), f._currentRenderer = rf) : (Gi(Xf, f._currentValue2, l), f._currentValue2 = E, f._currentRenderer2 !== void 0 && f._currentRenderer2 !== null && f._currentRenderer2 !== rf && y("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), f._currentRenderer2 = rf);
    }
    function Q(l, f) {
      var E = Xf.current;
      fo(Xf, f), Ml ? l._currentValue = E : l._currentValue2 = E;
    }
    function Me(l, f, E) {
      for (var w = l; w !== null; ) {
        var L = w.alternate;
        if (lu(w.childLanes, f) ? L !== null && !lu(L.childLanes, f) && (L.childLanes = Sr(L.childLanes, f)) : (w.childLanes = Sr(w.childLanes, f), L !== null && (L.childLanes = Sr(L.childLanes, f))), w === E)
          break;
        w = w.return;
      }
      w !== E && y("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function We(l, f, E) {
      Mt(l, f, E);
    }
    function Mt(l, f, E) {
      var w = l.child;
      for (w !== null && (w.return = l); w !== null; ) {
        var L = void 0, B = w.dependencies;
        if (B !== null) {
          L = w.child;
          for (var K = B.firstContext; K !== null; ) {
            if (K.context === f) {
              if (w.tag === te) {
                var re = Ff(E), fe = ar(_i, re);
                fe.tag = Va;
                var Ce = w.updateQueue;
                if (Ce !== null) {
                  var ke = Ce.shared, tt = ke.pending;
                  tt === null ? fe.next = fe : (fe.next = tt.next, tt.next = fe), ke.pending = fe;
                }
              }
              w.lanes = Sr(w.lanes, E);
              var Et = w.alternate;
              Et !== null && (Et.lanes = Sr(Et.lanes, E)), Me(w.return, E, l), B.lanes = Sr(B.lanes, E);
              break;
            }
            K = K.next;
          }
        } else if (w.tag === Te)
          L = w.type === l.type ? null : w.child;
        else if (w.tag === Ze) {
          var Dt = w.return;
          if (Dt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Dt.lanes = Sr(Dt.lanes, E);
          var Xt = Dt.alternate;
          Xt !== null && (Xt.lanes = Sr(Xt.lanes, E)), Me(Dt, E, l), L = w.sibling;
        } else
          L = w.child;
        if (L !== null)
          L.return = w;
        else
          for (L = w; L !== null; ) {
            if (L === l) {
              L = null;
              break;
            }
            var an = L.sibling;
            if (an !== null) {
              an.return = L.return, L = an;
              break;
            }
            L = L.return;
          }
        w = L;
      }
    }
    function Qt(l, f) {
      Uu = l, dc = null, Pm = null;
      var E = l.dependencies;
      if (E !== null) {
        var w = E.firstContext;
        w !== null && (hi(E.lanes, f) && Kx(), E.firstContext = null);
      }
    }
    function cn(l) {
      m && y("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var f = Ml ? l._currentValue : l._currentValue2;
      if (Pm !== l) {
        var E = {
          context: l,
          memoizedValue: f,
          next: null
        };
        if (dc === null) {
          if (Uu === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          dc = E, Uu.dependencies = {
            lanes: Gt,
            firstContext: E
          };
        } else
          dc = dc.next = E;
      }
      return f;
    }
    var sr = null;
    function Jn(l) {
      sr === null ? sr = [l] : sr.push(l);
    }
    function aa() {
      if (sr !== null) {
        for (var l = 0; l < sr.length; l++) {
          var f = sr[l], E = f.interleaved;
          if (E !== null) {
            f.interleaved = null;
            var w = E.next, L = f.pending;
            if (L !== null) {
              var B = L.next;
              L.next = w, E.next = B;
            }
            f.pending = E;
          }
        }
        sr = null;
      }
    }
    var yn = 0, fi = 1, Va = 2, ot = 3, Be = !1, vt, Pt;
    vt = !1, Pt = null;
    function Dn(l) {
      var f = {
        baseState: l.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Gt
        },
        effects: null
      };
      l.updateQueue = f;
    }
    function Ar(l, f) {
      var E = f.updateQueue, w = l.updateQueue;
      if (E === w) {
        var L = {
          baseState: w.baseState,
          firstBaseUpdate: w.firstBaseUpdate,
          lastBaseUpdate: w.lastBaseUpdate,
          shared: w.shared,
          effects: w.effects
        };
        f.updateQueue = L;
      }
    }
    function ar(l, f) {
      var E = {
        eventTime: l,
        lane: f,
        tag: yn,
        payload: null,
        callback: null,
        next: null
      };
      return E;
    }
    function Vr(l, f, E) {
      var w = l.updateQueue;
      if (w !== null) {
        var L = w.shared;
        if (v_(l)) {
          var B = L.interleaved;
          B === null ? (f.next = f, Jn(L)) : (f.next = B.next, B.next = f), L.interleaved = f;
        } else {
          var K = L.pending;
          K === null ? f.next = f : (f.next = K.next, K.next = f), L.pending = f;
        }
        Pt === L && !vt && (y("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), vt = !0);
      }
    }
    function _a(l, f, E) {
      var w = f.updateQueue;
      if (w !== null) {
        var L = w.shared;
        if (ds(E)) {
          var B = L.lanes;
          B = La(B, l.pendingLanes);
          var K = Sr(B, E);
          L.lanes = K, Mo(l, K);
        }
      }
    }
    function Gr(l, f) {
      var E = l.updateQueue, w = l.alternate;
      if (w !== null) {
        var L = w.updateQueue;
        if (E === L) {
          var B = null, K = null, re = E.firstBaseUpdate;
          if (re !== null) {
            var fe = re;
            do {
              var Ce = {
                eventTime: fe.eventTime,
                lane: fe.lane,
                tag: fe.tag,
                payload: fe.payload,
                callback: fe.callback,
                next: null
              };
              K === null ? B = K = Ce : (K.next = Ce, K = Ce), fe = fe.next;
            } while (fe !== null);
            K === null ? B = K = f : (K.next = f, K = f);
          } else
            B = K = f;
          E = {
            baseState: L.baseState,
            firstBaseUpdate: B,
            lastBaseUpdate: K,
            shared: L.shared,
            effects: L.effects
          }, l.updateQueue = E;
          return;
        }
      }
      var ke = E.lastBaseUpdate;
      ke === null ? E.firstBaseUpdate = f : ke.next = f, E.lastBaseUpdate = f;
    }
    function hc(l, f, E, w, L, B) {
      switch (E.tag) {
        case fi: {
          var K = E.payload;
          if (typeof K == "function") {
            R();
            var re = K.call(B, w, L);
            {
              if (l.mode & ma) {
                ui(!0);
                try {
                  K.call(B, w, L);
                } finally {
                  ui(!1);
                }
              }
              z();
            }
            return re;
          }
          return K;
        }
        case ot:
          l.flags = l.flags & ~en | rr;
        case yn: {
          var fe = E.payload, Ce;
          if (typeof fe == "function") {
            R(), Ce = fe.call(B, w, L);
            {
              if (l.mode & ma) {
                ui(!0);
                try {
                  fe.call(B, w, L);
                } finally {
                  ui(!1);
                }
              }
              z();
            }
          } else
            Ce = fe;
          return Ce == null ? w : b({}, w, Ce);
        }
        case Va:
          return Be = !0, w;
      }
      return w;
    }
    function Th(l, f, E, w) {
      var L = l.updateQueue;
      Be = !1, Pt = L.shared;
      var B = L.firstBaseUpdate, K = L.lastBaseUpdate, re = L.shared.pending;
      if (re !== null) {
        L.shared.pending = null;
        var fe = re, Ce = fe.next;
        fe.next = null, K === null ? B = Ce : K.next = Ce, K = fe;
        var ke = l.alternate;
        if (ke !== null) {
          var tt = ke.updateQueue, Et = tt.lastBaseUpdate;
          Et !== K && (Et === null ? tt.firstBaseUpdate = Ce : Et.next = Ce, tt.lastBaseUpdate = fe);
        }
      }
      if (B !== null) {
        var Dt = L.baseState, Xt = Gt, an = null, or = null, Wr = null, hr = B;
        do {
          var Xa = hr.lane, qa = hr.eventTime;
          if (lu(w, Xa)) {
            if (Wr !== null) {
              var Nt = {
                eventTime: qa,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Tr,
                tag: hr.tag,
                payload: hr.payload,
                callback: hr.callback,
                next: null
              };
              Wr = Wr.next = Nt;
            }
            Dt = hc(l, L, hr, Dt, f, E);
            var ut = hr.callback;
            if (ut !== null && // If the update was already committed, we should not queue its
            // callback again.
            hr.lane !== Tr) {
              l.flags |= ti;
              var un = L.effects;
              un === null ? L.effects = [hr] : un.push(hr);
            }
          } else {
            var ct = {
              eventTime: qa,
              lane: Xa,
              tag: hr.tag,
              payload: hr.payload,
              callback: hr.callback,
              next: null
            };
            Wr === null ? (or = Wr = ct, an = Dt) : Wr = Wr.next = ct, Xt = Sr(Xt, Xa);
          }
          if (hr = hr.next, hr === null) {
            if (re = L.shared.pending, re === null)
              break;
            var $n = re, Sn = $n.next;
            $n.next = null, hr = Sn, L.lastBaseUpdate = $n, L.shared.pending = null;
          }
        } while (!0);
        Wr === null && (an = Dt), L.baseState = an, L.firstBaseUpdate = or, L.lastBaseUpdate = Wr;
        var Dr = L.shared.interleaved;
        if (Dr !== null) {
          var Bi = Dr;
          do
            Xt = Sr(Xt, Bi.lane), Bi = Bi.next;
          while (Bi !== Dr);
        } else
          B === null && (L.shared.lanes = Gt);
        Oy(Xt), l.lanes = Xt, l.memoizedState = Dt;
      }
      Pt = null;
    }
    function T0(l, f) {
      if (typeof l != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + l));
      l.call(f);
    }
    function gp() {
      Be = !1;
    }
    function Xg() {
      return Be;
    }
    function qg(l, f, E) {
      var w = f.effects;
      if (f.effects = null, w !== null)
        for (var L = 0; L < w.length; L++) {
          var B = w[L], K = B.callback;
          K !== null && (B.callback = null, T0(K, E));
        }
    }
    var Nm = {}, Kg = new r.Component().refs, gs, qo, af, yp, zd, zu, yo, Sp, ys, M0;
    {
      gs = /* @__PURE__ */ new Set(), qo = /* @__PURE__ */ new Set(), af = /* @__PURE__ */ new Set(), yp = /* @__PURE__ */ new Set(), Sp = /* @__PURE__ */ new Set(), zd = /* @__PURE__ */ new Set(), ys = /* @__PURE__ */ new Set(), M0 = /* @__PURE__ */ new Set();
      var Qg = /* @__PURE__ */ new Set();
      yo = function(l, f) {
        if (!(l === null || typeof l == "function")) {
          var E = f + "_" + l;
          Qg.has(E) || (Qg.add(E), y("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, l));
        }
      }, zu = function(l, f) {
        if (f === void 0) {
          var E = Se(l) || "Component";
          zd.has(E) || (zd.add(E), y("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", E));
        }
      }, Object.defineProperty(Nm, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(Nm);
    }
    function xp(l, f, E, w) {
      var L = l.memoizedState, B = E(w, L);
      {
        if (l.mode & ma) {
          ui(!0);
          try {
            B = E(w, L);
          } finally {
            ui(!1);
          }
        }
        zu(f, B);
      }
      var K = B == null ? L : b({}, L, B);
      if (l.memoizedState = K, l.lanes === Gt) {
        var re = l.updateQueue;
        re.baseState = K;
      }
    }
    var Ao = {
      isMounted: za,
      enqueueSetState: function(l, f, E) {
        var w = M(l), L = Sl(), B = Bp(w), K = ar(L, B);
        K.payload = f, E != null && (yo(E, "setState"), K.callback = E), Vr(w, K);
        var re = Bo(w, B, L);
        re !== null && _a(re, w, B), Qc(w, B);
      },
      enqueueReplaceState: function(l, f, E) {
        var w = M(l), L = Sl(), B = Bp(w), K = ar(L, B);
        K.tag = fi, K.payload = f, E != null && (yo(E, "replaceState"), K.callback = E), Vr(w, K);
        var re = Bo(w, B, L);
        re !== null && _a(re, w, B), Qc(w, B);
      },
      enqueueForceUpdate: function(l, f) {
        var E = M(l), w = Sl(), L = Bp(E), B = ar(w, L);
        B.tag = Va, f != null && (yo(f, "forceUpdate"), B.callback = f), Vr(E, B);
        var K = Bo(E, L, w);
        K !== null && _a(K, E, L), Ws(E, L);
      }
    };
    function w0(l, f, E, w, L, B, K) {
      var re = l.stateNode;
      if (typeof re.shouldComponentUpdate == "function") {
        var fe = re.shouldComponentUpdate(w, B, K);
        {
          if (l.mode & ma) {
            ui(!0);
            try {
              fe = re.shouldComponentUpdate(w, B, K);
            } finally {
              ui(!1);
            }
          }
          fe === void 0 && y("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Se(f) || "Component");
        }
        return fe;
      }
      return f.prototype && f.prototype.isPureReactComponent ? !zo(E, w) || !zo(L, B) : !0;
    }
    function Pn(l, f, E) {
      var w = l.stateNode;
      {
        var L = Se(f) || "Component", B = w.render;
        B || (f.prototype && typeof f.prototype.render == "function" ? y("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", L) : y("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", L)), w.getInitialState && !w.getInitialState.isReactClassApproved && !w.state && y("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", L), w.getDefaultProps && !w.getDefaultProps.isReactClassApproved && y("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", L), w.propTypes && y("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", L), w.contextType && y("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", L), w.contextTypes && y("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", L), f.contextType && f.contextTypes && !ys.has(f) && (ys.add(f), y("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", L)), typeof w.componentShouldUpdate == "function" && y("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", L), f.prototype && f.prototype.isPureReactComponent && typeof w.shouldComponentUpdate < "u" && y("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Se(f) || "A pure component"), typeof w.componentDidUnmount == "function" && y("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", L), typeof w.componentDidReceiveProps == "function" && y("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", L), typeof w.componentWillRecieveProps == "function" && y("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", L), typeof w.UNSAFE_componentWillRecieveProps == "function" && y("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", L);
        var K = w.props !== E;
        w.props !== void 0 && K && y("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", L, L), w.defaultProps && y("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", L, L), typeof w.getSnapshotBeforeUpdate == "function" && typeof w.componentDidUpdate != "function" && !af.has(f) && (af.add(f), y("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Se(f))), typeof w.getDerivedStateFromProps == "function" && y("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", L), typeof w.getDerivedStateFromError == "function" && y("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", L), typeof f.getSnapshotBeforeUpdate == "function" && y("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", L);
        var re = w.state;
        re && (typeof re != "object" || ni(re)) && y("%s.state: must be set to an object or null", L), typeof w.getChildContext == "function" && typeof f.childContextTypes != "object" && y("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", L);
      }
    }
    function _p(l, f) {
      f.updater = Ao, l.stateNode = f, C(f, l), f._reactInternalInstance = Nm;
    }
    function Um(l, f, E) {
      var w = !1, L = Zr, B = Zr, K = f.contextType;
      if ("contextType" in f) {
        var re = (
          // Allow null for conditional declaration
          K === null || K !== void 0 && K.$$typeof === Kt && K._context === void 0
        );
        if (!re && !M0.has(f)) {
          M0.add(f);
          var fe = "";
          K === void 0 ? fe = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof K != "object" ? fe = " However, it is set to a " + typeof K + "." : K.$$typeof === Jt ? fe = " Did you accidentally pass the Context.Provider instead?" : K._context !== void 0 ? fe = " Did you accidentally pass the Context.Consumer instead?" : fe = " However, it is set to an object with keys {" + Object.keys(K).join(", ") + "}.", y("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Se(f) || "Component", fe);
        }
      }
      if (typeof K == "object" && K !== null)
        B = cn(K);
      else {
        L = ho(l, f, !0);
        var Ce = f.contextTypes;
        w = Ce != null, B = w ? rc(l, L) : Zr;
      }
      var ke = new f(E, B);
      if (l.mode & ma) {
        ui(!0);
        try {
          ke = new f(E, B);
        } finally {
          ui(!1);
        }
      }
      var tt = l.memoizedState = ke.state !== null && ke.state !== void 0 ? ke.state : null;
      _p(l, ke);
      {
        if (typeof f.getDerivedStateFromProps == "function" && tt === null) {
          var Et = Se(f) || "Component";
          qo.has(Et) || (qo.add(Et), y("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Et, ke.state === null ? "null" : "undefined", Et));
        }
        if (typeof f.getDerivedStateFromProps == "function" || typeof ke.getSnapshotBeforeUpdate == "function") {
          var Dt = null, Xt = null, an = null;
          if (typeof ke.componentWillMount == "function" && ke.componentWillMount.__suppressDeprecationWarning !== !0 ? Dt = "componentWillMount" : typeof ke.UNSAFE_componentWillMount == "function" && (Dt = "UNSAFE_componentWillMount"), typeof ke.componentWillReceiveProps == "function" && ke.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Xt = "componentWillReceiveProps" : typeof ke.UNSAFE_componentWillReceiveProps == "function" && (Xt = "UNSAFE_componentWillReceiveProps"), typeof ke.componentWillUpdate == "function" && ke.componentWillUpdate.__suppressDeprecationWarning !== !0 ? an = "componentWillUpdate" : typeof ke.UNSAFE_componentWillUpdate == "function" && (an = "UNSAFE_componentWillUpdate"), Dt !== null || Xt !== null || an !== null) {
            var or = Se(f) || "Component", Wr = typeof f.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            yp.has(or) || (yp.add(or), y(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, or, Wr, Dt !== null ? `
  ` + Dt : "", Xt !== null ? `
  ` + Xt : "", an !== null ? `
  ` + an : ""));
          }
        }
      }
      return w && Of(l, L, B), ke;
    }
    function xx(l, f) {
      var E = f.state;
      typeof f.componentWillMount == "function" && f.componentWillMount(), typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), E !== f.state && (y("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Tt(l) || "Component"), Ao.enqueueReplaceState(f, f.state, null));
    }
    function C0(l, f, E, w) {
      var L = f.state;
      if (typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(E, w), typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(E, w), f.state !== L) {
        {
          var B = Tt(l) || "Component";
          gs.has(B) || (gs.add(B), y("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", B));
        }
        Ao.enqueueReplaceState(f, f.state, null);
      }
    }
    function Ep(l, f, E, w) {
      Pn(l, f, E);
      var L = l.stateNode;
      L.props = E, L.state = l.memoizedState, L.refs = Kg, Dn(l);
      var B = f.contextType;
      if (typeof B == "object" && B !== null)
        L.context = cn(B);
      else {
        var K = ho(l, f, !0);
        L.context = rc(l, K);
      }
      {
        if (L.state === E) {
          var re = Se(f) || "Component";
          Sp.has(re) || (Sp.add(re), y("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", re));
        }
        l.mode & ma && $s.recordLegacyContextWarning(l, L), $s.recordUnsafeLifecycleWarnings(l, L);
      }
      L.state = l.memoizedState;
      var fe = f.getDerivedStateFromProps;
      if (typeof fe == "function" && (xp(l, f, fe, E), L.state = l.memoizedState), typeof f.getDerivedStateFromProps != "function" && typeof L.getSnapshotBeforeUpdate != "function" && (typeof L.UNSAFE_componentWillMount == "function" || typeof L.componentWillMount == "function") && (xx(l, L), Th(l, E, L, w), L.state = l.memoizedState), typeof L.componentDidMount == "function") {
        var Ce = ft;
        Ce |= qe, (l.mode & No) !== mr && (Ce |= dt), l.flags |= Ce;
      }
    }
    function Dv(l, f, E, w) {
      var L = l.stateNode, B = l.memoizedProps;
      L.props = B;
      var K = L.context, re = f.contextType, fe = Zr;
      if (typeof re == "object" && re !== null)
        fe = cn(re);
      else {
        var Ce = ho(l, f, !0);
        fe = rc(l, Ce);
      }
      var ke = f.getDerivedStateFromProps, tt = typeof ke == "function" || typeof L.getSnapshotBeforeUpdate == "function";
      !tt && (typeof L.UNSAFE_componentWillReceiveProps == "function" || typeof L.componentWillReceiveProps == "function") && (B !== E || K !== fe) && C0(l, L, E, fe), gp();
      var Et = l.memoizedState, Dt = L.state = Et;
      if (Th(l, E, L, w), Dt = l.memoizedState, B === E && Et === Dt && !eo() && !Xg()) {
        if (typeof L.componentDidMount == "function") {
          var Xt = ft;
          Xt |= qe, (l.mode & No) !== mr && (Xt |= dt), l.flags |= Xt;
        }
        return !1;
      }
      typeof ke == "function" && (xp(l, f, ke, E), Dt = l.memoizedState);
      var an = Xg() || w0(l, f, B, E, Et, Dt, fe);
      if (an) {
        if (!tt && (typeof L.UNSAFE_componentWillMount == "function" || typeof L.componentWillMount == "function") && (typeof L.componentWillMount == "function" && L.componentWillMount(), typeof L.UNSAFE_componentWillMount == "function" && L.UNSAFE_componentWillMount()), typeof L.componentDidMount == "function") {
          var or = ft;
          or |= qe, (l.mode & No) !== mr && (or |= dt), l.flags |= or;
        }
      } else {
        if (typeof L.componentDidMount == "function") {
          var Wr = ft;
          Wr |= qe, (l.mode & No) !== mr && (Wr |= dt), l.flags |= Wr;
        }
        l.memoizedProps = E, l.memoizedState = Dt;
      }
      return L.props = E, L.state = Dt, L.context = fe, an;
    }
    function R0(l, f, E, w, L) {
      var B = f.stateNode;
      Ar(l, f);
      var K = f.memoizedProps, re = f.type === f.elementType ? K : Xr(f.type, K);
      B.props = re;
      var fe = f.pendingProps, Ce = B.context, ke = E.contextType, tt = Zr;
      if (typeof ke == "object" && ke !== null)
        tt = cn(ke);
      else {
        var Et = ho(f, E, !0);
        tt = rc(f, Et);
      }
      var Dt = E.getDerivedStateFromProps, Xt = typeof Dt == "function" || typeof B.getSnapshotBeforeUpdate == "function";
      !Xt && (typeof B.UNSAFE_componentWillReceiveProps == "function" || typeof B.componentWillReceiveProps == "function") && (K !== fe || Ce !== tt) && C0(f, B, w, tt), gp();
      var an = f.memoizedState, or = B.state = an;
      if (Th(f, w, B, L), or = f.memoizedState, K === fe && an === or && !eo() && !Xg() && !N)
        return typeof B.componentDidUpdate == "function" && (K !== l.memoizedProps || an !== l.memoizedState) && (f.flags |= ft), typeof B.getSnapshotBeforeUpdate == "function" && (K !== l.memoizedProps || an !== l.memoizedState) && (f.flags |= oi), !1;
      typeof Dt == "function" && (xp(f, E, Dt, w), or = f.memoizedState);
      var Wr = Xg() || w0(f, E, re, w, an, or, tt) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      N;
      return Wr ? (!Xt && (typeof B.UNSAFE_componentWillUpdate == "function" || typeof B.componentWillUpdate == "function") && (typeof B.componentWillUpdate == "function" && B.componentWillUpdate(w, or, tt), typeof B.UNSAFE_componentWillUpdate == "function" && B.UNSAFE_componentWillUpdate(w, or, tt)), typeof B.componentDidUpdate == "function" && (f.flags |= ft), typeof B.getSnapshotBeforeUpdate == "function" && (f.flags |= oi)) : (typeof B.componentDidUpdate == "function" && (K !== l.memoizedProps || an !== l.memoizedState) && (f.flags |= ft), typeof B.getSnapshotBeforeUpdate == "function" && (K !== l.memoizedProps || an !== l.memoizedState) && (f.flags |= oi), f.memoizedProps = w, f.memoizedState = or), B.props = w, B.state = or, B.context = tt, Wr;
    }
    var Mh = [], bp = 0, Tp = null, kd = 0, Do = [], Ei = 0, Ga = null, ko = 1, mu = "";
    function Id(l) {
      return Fd(), (l.flags & ve) !== ge;
    }
    function of(l) {
      return Fd(), kd;
    }
    function _x() {
      var l = mu, f = ko, E = f & ~D0(f);
      return E.toString(32) + l;
    }
    function ml(l, f) {
      Fd(), Mh[bp++] = kd, Mh[bp++] = Tp, Tp = l, kd = f;
    }
    function A0(l, f, E) {
      Fd(), Do[Ei++] = ko, Do[Ei++] = mu, Do[Ei++] = Ga, Ga = l;
      var w = ko, L = mu, B = Lv(w) - 1, K = w & ~(1 << B), re = E + 1, fe = Lv(f) + B;
      if (fe > 30) {
        var Ce = B - B % 5, ke = (1 << Ce) - 1, tt = (K & ke).toString(32), Et = K >> Ce, Dt = B - Ce, Xt = Lv(f) + Dt, an = re << Dt, or = an | Et, Wr = tt + L;
        ko = 1 << Xt | or, mu = Wr;
      } else {
        var hr = re << B, Xa = hr | K, qa = L;
        ko = 1 << fe | Xa, mu = qa;
      }
    }
    function wh(l) {
      Fd();
      var f = l.return;
      if (f !== null) {
        var E = 1, w = 0;
        ml(l, E), A0(l, E, w);
      }
    }
    function Lv(l) {
      return 32 - ph(l);
    }
    function D0(l) {
      return 1 << Lv(l) - 1;
    }
    function Zg(l) {
      for (; l === Tp; )
        Tp = Mh[--bp], Mh[bp] = null, kd = Mh[--bp], Mh[bp] = null;
      for (; l === Ga; )
        Ga = Do[--Ei], Do[Ei] = null, mu = Do[--Ei], Do[Ei] = null, ko = Do[--Ei], Do[Ei] = null;
    }
    function Jg() {
      return Fd(), Ga !== null ? {
        id: ko,
        overflow: mu
      } : null;
    }
    function Ov(l, f) {
      Fd(), Do[Ei++] = ko, Do[Ei++] = mu, Do[Ei++] = Ga, ko = f.id, mu = f.overflow, Ga = l;
    }
    function Fd() {
      ji() || y("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Fi = null, xr = null, Li = !1, fa = !1, Oa = null;
    function ku() {
      Li && y("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function zm() {
      fa = !0;
    }
    function Ko(l) {
      if (!lo)
        return !1;
      var f = l.stateNode.containerInfo;
      return xr = eu(f), Fi = l, Li = !0, Oa = null, fa = !1, !0;
    }
    function Pv(l, f, E) {
      return lo ? (xr = fh(f), Fi = l, Li = !0, Oa = null, fa = !1, E !== null && Ov(l, E), !0) : !1;
    }
    function qf(l, f) {
      switch (l.tag) {
        case q:
          Af(l.stateNode.containerInfo, f);
          break;
        case ye:
          Sm(l.type, l.memoizedProps, l.stateNode, f);
          break;
        case X:
          var E = l.memoizedState;
          E.dehydrated !== null && nu(E.dehydrated, f);
          break;
      }
    }
    function Nv(l, f) {
      qf(l, f);
      var E = d1();
      E.stateNode = f, E.return = l;
      var w = l.deletions;
      w === null ? (l.deletions = [E], l.flags |= zn) : w.push(E);
    }
    function Ch(l, f) {
      {
        if (fa)
          return;
        switch (l.tag) {
          case q: {
            var E = l.stateNode.containerInfo;
            switch (f.tag) {
              case ye:
                var w = f.type, L = f.pendingProps;
                il(E, w, L);
                break;
              case de:
                var B = f.pendingProps;
                Ps(E, B);
                break;
              case X:
                zc(E);
                break;
            }
            break;
          }
          case ye: {
            var K = l.type, re = l.memoizedProps, fe = l.stateNode;
            switch (f.tag) {
              case ye:
                var Ce = f.type, ke = f.pendingProps;
                Ns(K, re, fe, Ce, ke);
                break;
              case de:
                var tt = f.pendingProps;
                bu(K, re, fe, tt);
                break;
              case X:
                ka(K, re, fe);
                break;
            }
            break;
          }
          case X: {
            var Et = l.memoizedState, Dt = Et.dehydrated;
            if (Dt !== null)
              switch (f.tag) {
                case ye:
                  var Xt = f.type, an = f.pendingProps;
                  kc(Dt, Xt, an);
                  break;
                case de:
                  var or = f.pendingProps;
                  ru(Dt, or);
                  break;
                case X:
                  Df(Dt);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function Rh(l, f) {
      f.flags = f.flags & ~Ji | Fe, Ch(l, f);
    }
    function vl(l, f) {
      switch (l.tag) {
        case ye: {
          var E = l.type, w = l.pendingProps, L = ri(f, E, w);
          return L !== null ? (l.stateNode = L, Fi = l, xr = rl(L), !0) : !1;
        }
        case de: {
          var B = l.pendingProps, K = Ti(f, B);
          return K !== null ? (l.stateNode = K, Fi = l, xr = null, !0) : !1;
        }
        case X: {
          {
            var re = Br(f);
            if (re !== null) {
              var fe = {
                dehydrated: re,
                treeContext: Jg(),
                retryLane: xi
              };
              l.memoizedState = fe;
              var Ce = Ki(re);
              return Ce.return = l, l.child = Ce, Fi = l, xr = null, !0;
            }
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Uv(l) {
      return (l.mode & Ii) !== mr && (l.flags & rr) === ge;
    }
    function Ah(l) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function sf(l) {
      if (Li) {
        var f = xr;
        if (!f) {
          Uv(l) && (Ch(Fi, l), Ah()), Rh(Fi, l), Li = !1, Fi = l;
          return;
        }
        var E = f;
        if (!vl(l, f)) {
          Uv(l) && (Ch(Fi, l), Ah()), f = Cl(E);
          var w = Fi;
          if (!f || !vl(l, f)) {
            Rh(Fi, l), Li = !1, Fi = l;
            return;
          }
          Nv(w, E);
        }
      }
    }
    function ey(l, f, E) {
      if (!lo)
        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var w = l.stateNode, L = !fa, B = tu(w, l.type, l.memoizedProps, f, E, l, L);
      return l.updateQueue = B, B !== null;
    }
    function Mp(l) {
      if (!lo)
        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var f = l.stateNode, E = l.memoizedProps, w = !fa, L = Rf(f, E, l, w);
      if (L) {
        var B = Fi;
        if (B !== null) {
          var K = (B.mode & Ii) !== mr;
          switch (B.tag) {
            case q: {
              var re = B.stateNode.containerInfo;
              ym(
                re,
                f,
                E,
                // TODO: Delete this argument when we remove the legacy root API.
                K
              );
              break;
            }
            case ye: {
              var fe = B.type, Ce = B.memoizedProps, ke = B.stateNode;
              vd(
                fe,
                Ce,
                ke,
                f,
                E,
                // TODO: Delete this argument when we remove the legacy root API.
                K
              );
              break;
            }
          }
        }
      }
      return L;
    }
    function Kf(l) {
      if (!lo)
        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var f = l.memoizedState, E = f !== null ? f.dehydrated : null;
      if (!E)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      dh(E, l);
    }
    function Dh(l) {
      if (!lo)
        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var f = l.memoizedState, E = f !== null ? f.dehydrated : null;
      if (!E)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return hm(E);
    }
    function Bd(l) {
      for (var f = l.return; f !== null && f.tag !== ye && f.tag !== q && f.tag !== X; )
        f = f.return;
      Fi = f;
    }
    function Lh(l) {
      if (!lo || l !== Fi)
        return !1;
      if (!Li)
        return Bd(l), Li = !0, !1;
      if (l.tag !== q && (l.tag !== ye || Cv(l.type) && !Mf(l.type, l.memoizedProps))) {
        var f = xr;
        if (f)
          if (Uv(l))
            zv(l), Ah();
          else
            for (; f; )
              Nv(l, f), f = Cl(f);
      }
      return Bd(l), l.tag === X ? xr = Dh(l) : xr = Fi ? Cl(l.stateNode) : null, !0;
    }
    function km() {
      return Li && xr !== null;
    }
    function zv(l) {
      for (var f = xr; f; )
        qf(l, f), f = Cl(f);
    }
    function pc() {
      lo && (Fi = null, xr = null, Li = !1, fa = !1);
    }
    function Oh() {
      Oa !== null && (Gh(Oa), Oa = null);
    }
    function ji() {
      return Li;
    }
    function So(l) {
      Oa === null ? Oa = [l] : Oa.push(l);
    }
    var Ss, xs, Ph, kv, wp, ty = function(l, f) {
    };
    Ss = !1, xs = !1, Ph = {}, kv = {}, wp = {}, ty = function(l, f) {
      if (!(l === null || typeof l != "object") && !(!l._store || l._store.validated || l.key != null)) {
        if (typeof l._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        l._store.validated = !0;
        var E = Tt(f) || "Component";
        kv[E] || (kv[E] = !0, y('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function gl(l, f, E) {
      var w = E.ref;
      if (w !== null && typeof w != "function" && typeof w != "object") {
        if ((l.mode & ma || k) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(E._owner && E._self && E._owner.stateNode !== E._self)) {
          var L = Tt(l) || "Component";
          Ph[L] || (y('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', w), Ph[L] = !0);
        }
        if (E._owner) {
          var B = E._owner, K;
          if (B) {
            var re = B;
            if (re.tag !== te)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            K = re.stateNode;
          }
          if (!K)
            throw new Error("Missing owner for string ref " + w + ". This error is likely caused by a bug in React. Please file an issue.");
          var fe = K;
          Yg(w, "ref");
          var Ce = "" + w;
          if (f !== null && f.ref !== null && typeof f.ref == "function" && f.ref._stringRef === Ce)
            return f.ref;
          var ke = function(tt) {
            var Et = fe.refs;
            Et === Kg && (Et = fe.refs = {}), tt === null ? delete Et[Ce] : Et[Ce] = tt;
          };
          return ke._stringRef = Ce, ke;
        } else {
          if (typeof w != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!E._owner)
            throw new Error("Element ref was specified as a string (" + w + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return w;
    }
    function Iv(l, f) {
      var E = Object.prototype.toString.call(f);
      throw new Error("Objects are not valid as a React child (found: " + (E === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : E) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Hd(l) {
      {
        var f = Tt(l) || "Component";
        if (wp[f])
          return;
        wp[f] = !0, y("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function Vd(l) {
      var f = l._payload, E = l._init;
      return E(f);
    }
    function ny(l) {
      function f(ct, Nt) {
        if (l) {
          var ut = ct.deletions;
          ut === null ? (ct.deletions = [Nt], ct.flags |= zn) : ut.push(Nt);
        }
      }
      function E(ct, Nt) {
        if (!l)
          return null;
        for (var ut = Nt; ut !== null; )
          f(ct, ut), ut = ut.sibling;
        return null;
      }
      function w(ct, Nt) {
        for (var ut = /* @__PURE__ */ new Map(), un = Nt; un !== null; )
          un.key !== null ? ut.set(un.key, un) : ut.set(un.index, un), un = un.sibling;
        return ut;
      }
      function L(ct, Nt) {
        var ut = Ri(ct, Nt);
        return ut.index = 0, ut.sibling = null, ut;
      }
      function B(ct, Nt, ut) {
        if (ct.index = ut, !l)
          return ct.flags |= ve, Nt;
        var un = ct.alternate;
        if (un !== null) {
          var $n = un.index;
          return $n < Nt ? (ct.flags |= Fe, Nt) : $n;
        } else
          return ct.flags |= Fe, Nt;
      }
      function K(ct) {
        return l && ct.alternate === null && (ct.flags |= Fe), ct;
      }
      function re(ct, Nt, ut, un) {
        if (Nt === null || Nt.tag !== de) {
          var $n = Xh(ut, ct.mode, un);
          return $n.return = ct, $n;
        } else {
          var Sn = L(Nt, ut);
          return Sn.return = ct, Sn;
        }
      }
      function fe(ct, Nt, ut, un) {
        var $n = ut.type;
        if ($n === et)
          return ke(ct, Nt, ut.props.children, un, ut.key);
        if (Nt !== null && (Nt.elementType === $n || // Keep this check inline so it only runs on the false path:
        hg(Nt, ut) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof $n == "object" && $n !== null && $n.$$typeof === se && Vd($n) === Nt.type)) {
          var Sn = L(Nt, ut.props);
          return Sn.ref = gl(ct, Nt, ut), Sn.return = ct, Sn._debugSource = ut._source, Sn._debugOwner = ut._owner, Sn;
        }
        var Dr = mg(ut, ct.mode, un);
        return Dr.ref = gl(ct, Nt, ut), Dr.return = ct, Dr;
      }
      function Ce(ct, Nt, ut, un) {
        if (Nt === null || Nt.tag !== oe || Nt.stateNode.containerInfo !== ut.containerInfo || Nt.stateNode.implementation !== ut.implementation) {
          var $n = vn(ut, ct.mode, un);
          return $n.return = ct, $n;
        } else {
          var Sn = L(Nt, ut.children || []);
          return Sn.return = ct, Sn;
        }
      }
      function ke(ct, Nt, ut, un, $n) {
        if (Nt === null || Nt.tag !== xe) {
          var Sn = rd(ut, ct.mode, un, $n);
          return Sn.return = ct, Sn;
        } else {
          var Dr = L(Nt, ut);
          return Dr.return = ct, Dr;
        }
      }
      function tt(ct, Nt, ut) {
        if (typeof Nt == "string" && Nt !== "" || typeof Nt == "number") {
          var un = Xh("" + Nt, ct.mode, ut);
          return un.return = ct, un;
        }
        if (typeof Nt == "object" && Nt !== null) {
          switch (Nt.$$typeof) {
            case he: {
              var $n = mg(Nt, ct.mode, ut);
              return $n.ref = gl(ct, null, Nt), $n.return = ct, $n;
            }
            case nt: {
              var Sn = vn(Nt, ct.mode, ut);
              return Sn.return = ct, Sn;
            }
            case se: {
              var Dr = Nt._payload, Bi = Nt._init;
              return tt(ct, Bi(Dr), ut);
            }
          }
          if (ni(Nt) || Xe(Nt)) {
            var ga = rd(Nt, ct.mode, ut, null);
            return ga.return = ct, ga;
          }
          Iv(ct, Nt);
        }
        return typeof Nt == "function" && Hd(ct), null;
      }
      function Et(ct, Nt, ut, un) {
        var $n = Nt !== null ? Nt.key : null;
        if (typeof ut == "string" && ut !== "" || typeof ut == "number")
          return $n !== null ? null : re(ct, Nt, "" + ut, un);
        if (typeof ut == "object" && ut !== null) {
          switch (ut.$$typeof) {
            case he:
              return ut.key === $n ? fe(ct, Nt, ut, un) : null;
            case nt:
              return ut.key === $n ? Ce(ct, Nt, ut, un) : null;
            case se: {
              var Sn = ut._payload, Dr = ut._init;
              return Et(ct, Nt, Dr(Sn), un);
            }
          }
          if (ni(ut) || Xe(ut))
            return $n !== null ? null : ke(ct, Nt, ut, un, null);
          Iv(ct, ut);
        }
        return typeof ut == "function" && Hd(ct), null;
      }
      function Dt(ct, Nt, ut, un, $n) {
        if (typeof un == "string" && un !== "" || typeof un == "number") {
          var Sn = ct.get(ut) || null;
          return re(Nt, Sn, "" + un, $n);
        }
        if (typeof un == "object" && un !== null) {
          switch (un.$$typeof) {
            case he: {
              var Dr = ct.get(un.key === null ? ut : un.key) || null;
              return fe(Nt, Dr, un, $n);
            }
            case nt: {
              var Bi = ct.get(un.key === null ? ut : un.key) || null;
              return Ce(Nt, Bi, un, $n);
            }
            case se: {
              var ga = un._payload, xn = un._init;
              return Dt(ct, Nt, ut, xn(ga), $n);
            }
          }
          if (ni(un) || Xe(un)) {
            var da = ct.get(ut) || null;
            return ke(Nt, da, un, $n, null);
          }
          Iv(Nt, un);
        }
        return typeof un == "function" && Hd(Nt), null;
      }
      function Xt(ct, Nt, ut) {
        {
          if (typeof ct != "object" || ct === null)
            return Nt;
          switch (ct.$$typeof) {
            case he:
            case nt:
              ty(ct, ut);
              var un = ct.key;
              if (typeof un != "string")
                break;
              if (Nt === null) {
                Nt = /* @__PURE__ */ new Set(), Nt.add(un);
                break;
              }
              if (!Nt.has(un)) {
                Nt.add(un);
                break;
              }
              y("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", un);
              break;
            case se: {
              var $n = ct._payload, Sn = ct._init;
              Xt(Sn($n), Nt, ut);
              break;
            }
          }
        }
        return Nt;
      }
      function an(ct, Nt, ut, un) {
        for (var $n = null, Sn = 0; Sn < ut.length; Sn++) {
          var Dr = ut[Sn];
          $n = Xt(Dr, $n, ct);
        }
        for (var Bi = null, ga = null, xn = Nt, da = 0, Hi = 0, qr = null; xn !== null && Hi < ut.length; Hi++) {
          xn.index > Hi ? (qr = xn, xn = null) : qr = xn.sibling;
          var ao = Et(ct, xn, ut[Hi], un);
          if (ao === null) {
            xn === null && (xn = qr);
            break;
          }
          l && xn && ao.alternate === null && f(ct, xn), da = B(ao, da, Hi), ga === null ? Bi = ao : ga.sibling = ao, ga = ao, xn = qr;
        }
        if (Hi === ut.length) {
          if (E(ct, xn), ji()) {
            var Ka = Hi;
            ml(ct, Ka);
          }
          return Bi;
        }
        if (xn === null) {
          for (; Hi < ut.length; Hi++) {
            var bc = tt(ct, ut[Hi], un);
            bc !== null && (da = B(bc, da, Hi), ga === null ? Bi = bc : ga.sibling = bc, ga = bc);
          }
          if (ji()) {
            var bs = Hi;
            ml(ct, bs);
          }
          return Bi;
        }
        for (var Tc = w(ct, xn); Hi < ut.length; Hi++) {
          var df = Dt(Tc, ct, Hi, ut[Hi], un);
          df !== null && (l && df.alternate !== null && Tc.delete(df.key === null ? Hi : df.key), da = B(df, da, Hi), ga === null ? Bi = df : ga.sibling = df, ga = df);
        }
        if (l && Tc.forEach(function($y) {
          return f(ct, $y);
        }), ji()) {
          var Kh = Hi;
          ml(ct, Kh);
        }
        return Bi;
      }
      function or(ct, Nt, ut, un) {
        var $n = Xe(ut);
        if (typeof $n != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          ut[Symbol.toStringTag] === "Generator" && (xs || y("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), xs = !0), ut.entries === $n && (Ss || y("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Ss = !0);
          var Sn = $n.call(ut);
          if (Sn)
            for (var Dr = null, Bi = Sn.next(); !Bi.done; Bi = Sn.next()) {
              var ga = Bi.value;
              Dr = Xt(ga, Dr, ct);
            }
        }
        var xn = $n.call(ut);
        if (xn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var da = null, Hi = null, qr = Nt, ao = 0, Ka = 0, bc = null, bs = xn.next(); qr !== null && !bs.done; Ka++, bs = xn.next()) {
          qr.index > Ka ? (bc = qr, qr = null) : bc = qr.sibling;
          var Tc = Et(ct, qr, bs.value, un);
          if (Tc === null) {
            qr === null && (qr = bc);
            break;
          }
          l && qr && Tc.alternate === null && f(ct, qr), ao = B(Tc, ao, Ka), Hi === null ? da = Tc : Hi.sibling = Tc, Hi = Tc, qr = bc;
        }
        if (bs.done) {
          if (E(ct, qr), ji()) {
            var df = Ka;
            ml(ct, df);
          }
          return da;
        }
        if (qr === null) {
          for (; !bs.done; Ka++, bs = xn.next()) {
            var Kh = tt(ct, bs.value, un);
            Kh !== null && (ao = B(Kh, ao, Ka), Hi === null ? da = Kh : Hi.sibling = Kh, Hi = Kh);
          }
          if (ji()) {
            var $y = Ka;
            ml(ct, $y);
          }
          return da;
        }
        for (var gg = w(ct, qr); !bs.done; Ka++, bs = xn.next()) {
          var Mc = Dt(gg, ct, Ka, bs.value, un);
          Mc !== null && (l && Mc.alternate !== null && gg.delete(Mc.key === null ? Ka : Mc.key), ao = B(Mc, ao, Ka), Hi === null ? da = Mc : Hi.sibling = Mc, Hi = Mc);
        }
        if (l && gg.forEach(function(B_) {
          return f(ct, B_);
        }), ji()) {
          var Vp = Ka;
          ml(ct, Vp);
        }
        return da;
      }
      function Wr(ct, Nt, ut, un) {
        if (Nt !== null && Nt.tag === de) {
          E(ct, Nt.sibling);
          var $n = L(Nt, ut);
          return $n.return = ct, $n;
        }
        E(ct, Nt);
        var Sn = Xh(ut, ct.mode, un);
        return Sn.return = ct, Sn;
      }
      function hr(ct, Nt, ut, un) {
        for (var $n = ut.key, Sn = Nt; Sn !== null; ) {
          if (Sn.key === $n) {
            var Dr = ut.type;
            if (Dr === et) {
              if (Sn.tag === xe) {
                E(ct, Sn.sibling);
                var Bi = L(Sn, ut.props.children);
                return Bi.return = ct, Bi._debugSource = ut._source, Bi._debugOwner = ut._owner, Bi;
              }
            } else if (Sn.elementType === Dr || // Keep this check inline so it only runs on the false path:
            hg(Sn, ut) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Dr == "object" && Dr !== null && Dr.$$typeof === se && Vd(Dr) === Sn.type) {
              E(ct, Sn.sibling);
              var ga = L(Sn, ut.props);
              return ga.ref = gl(ct, Sn, ut), ga.return = ct, ga._debugSource = ut._source, ga._debugOwner = ut._owner, ga;
            }
            E(ct, Sn);
            break;
          } else
            f(ct, Sn);
          Sn = Sn.sibling;
        }
        if (ut.type === et) {
          var xn = rd(ut.props.children, ct.mode, un, ut.key);
          return xn.return = ct, xn;
        } else {
          var da = mg(ut, ct.mode, un);
          return da.ref = gl(ct, Nt, ut), da.return = ct, da;
        }
      }
      function Xa(ct, Nt, ut, un) {
        for (var $n = ut.key, Sn = Nt; Sn !== null; ) {
          if (Sn.key === $n)
            if (Sn.tag === oe && Sn.stateNode.containerInfo === ut.containerInfo && Sn.stateNode.implementation === ut.implementation) {
              E(ct, Sn.sibling);
              var Dr = L(Sn, ut.children || []);
              return Dr.return = ct, Dr;
            } else {
              E(ct, Sn);
              break;
            }
          else
            f(ct, Sn);
          Sn = Sn.sibling;
        }
        var Bi = vn(ut, ct.mode, un);
        return Bi.return = ct, Bi;
      }
      function qa(ct, Nt, ut, un) {
        var $n = typeof ut == "object" && ut !== null && ut.type === et && ut.key === null;
        if ($n && (ut = ut.props.children), typeof ut == "object" && ut !== null) {
          switch (ut.$$typeof) {
            case he:
              return K(hr(ct, Nt, ut, un));
            case nt:
              return K(Xa(ct, Nt, ut, un));
            case se: {
              var Sn = ut._payload, Dr = ut._init;
              return qa(ct, Nt, Dr(Sn), un);
            }
          }
          if (ni(ut))
            return an(ct, Nt, ut, un);
          if (Xe(ut))
            return or(ct, Nt, ut, un);
          Iv(ct, ut);
        }
        return typeof ut == "string" && ut !== "" || typeof ut == "number" ? K(Wr(ct, Nt, "" + ut, un)) : (typeof ut == "function" && Hd(ct), E(ct, Nt));
      }
      return qa;
    }
    var mc = ny(!0), L0 = ny(!1);
    function ry(l, f) {
      if (l !== null && f.child !== l.child)
        throw new Error("Resuming work not yet implemented.");
      if (f.child !== null) {
        var E = f.child, w = Ri(E, E.pendingProps);
        for (f.child = w, w.return = f; E.sibling !== null; )
          E = E.sibling, w = w.sibling = Ri(E, E.pendingProps), w.return = f;
        w.sibling = null;
      }
    }
    function O0(l, f) {
      for (var E = l.child; E !== null; )
        Ks(E, f), E = E.sibling;
    }
    var Nh = {}, Uh = al(Nh), Fv = al(Nh), Bv = al(Nh);
    function Im(l) {
      if (l === Nh)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return l;
    }
    function Gd() {
      var l = Im(Bv.current);
      return l;
    }
    function P0(l, f) {
      Gi(Bv, f, l), Gi(Fv, l, l), Gi(Uh, Nh, l);
      var E = ta(f);
      fo(Uh, l), Gi(Uh, E, l);
    }
    function lf(l) {
      fo(Uh, l), fo(Fv, l), fo(Bv, l);
    }
    function Fm() {
      var l = Im(Uh.current);
      return l;
    }
    function no(l) {
      var f = Im(Bv.current), E = Im(Uh.current), w = Vi(E, l.type, f);
      E !== w && (Gi(Fv, l, l), Gi(Uh, w, l));
    }
    function N0(l) {
      Fv.current === l && (fo(Uh, l), fo(Fv, l));
    }
    var iy = 0, Ex = 1, bx = 1, Bm = 2, Iu = al(iy);
    function U0(l, f) {
      return (l & f) !== 0;
    }
    function Ys(l) {
      return l & Ex;
    }
    function Hv(l, f) {
      return l & Ex | f;
    }
    function ib(l, f) {
      return l | f;
    }
    function kl(l, f) {
      Gi(Iu, f, l);
    }
    function Wd(l) {
      fo(Iu, l);
    }
    function Cp(l, f) {
      var E = l.memoizedState;
      return E !== null ? E.dehydrated !== null : (l.memoizedProps, !0);
    }
    function zh(l) {
      for (var f = l; f !== null; ) {
        if (f.tag === X) {
          var E = f.memoizedState;
          if (E !== null) {
            var w = E.dehydrated;
            if (w === null || Qr(w) || li(w))
              return f;
          }
        } else if (f.tag === je && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        f.memoizedProps.revealOrder !== void 0) {
          var L = (f.flags & rr) !== ge;
          if (L)
            return f;
        } else if (f.child !== null) {
          f.child.return = f, f = f.child;
          continue;
        }
        if (f === l)
          return null;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === l)
            return null;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      return null;
    }
    var vu = (
      /*   */
      0
    ), oa = (
      /* */
      1
    ), kh = (
      /*  */
      2
    ), Wa = (
      /*    */
      4
    ), _s = (
      /*   */
      8
    ), Vv = [];
    function ay() {
      for (var l = 0; l < Vv.length; l++) {
        var f = Vv[l];
        Ml ? f._workInProgressVersionPrimary = null : f._workInProgressVersionSecondary = null;
      }
      Vv.length = 0;
    }
    function Gv(l, f) {
      var E = f._getVersion, w = E(f._source);
      l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [f, w] : l.mutableSourceEagerHydrationData.push(f, w);
    }
    var En = s.ReactCurrentDispatcher, Il = s.ReactCurrentBatchConfig, Wv, Rp;
    Wv = /* @__PURE__ */ new Set();
    var Ih = Gt, $i = null, ja = null, Lo = null, Ap = !1, Hm = !1, jv = 0, oy = 0, ab = 25, At = null, vc = null, uf = -1, c = !1;
    function d() {
      {
        var l = At;
        vc === null ? vc = [l] : vc.push(l);
      }
    }
    function x() {
      {
        var l = At;
        vc !== null && (uf++, vc[uf] !== l && F(l));
      }
    }
    function A(l) {
      l != null && !ni(l) && y("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", At, typeof l);
    }
    function F(l) {
      {
        var f = Tt($i);
        if (!Wv.has(f) && (Wv.add(f), vc !== null)) {
          for (var E = "", w = 30, L = 0; L <= uf; L++) {
            for (var B = vc[L], K = L === uf ? l : B, re = L + 1 + ". " + B; re.length < w; )
              re += " ";
            re += K + `
`, E += re;
          }
          y(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, f, E);
        }
      }
    }
    function W() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function ie(l, f) {
      if (c)
        return !1;
      if (f === null)
        return y("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", At), !1;
      l.length !== f.length && y(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, At, "[" + f.join(", ") + "]", "[" + l.join(", ") + "]");
      for (var E = 0; E < f.length && E < l.length; E++)
        if (!Co(l[E], f[E]))
          return !1;
      return !0;
    }
    function Ae(l, f, E, w, L, B) {
      Ih = B, $i = f, vc = l !== null ? l._debugHookTypes : null, uf = -1, c = l !== null && l.type !== f.type, f.memoizedState = null, f.updateQueue = null, f.lanes = Gt, l !== null && l.memoizedState !== null ? En.current = $a : vc !== null ? En.current = TM : En.current = hb;
      var K = E(w, L);
      if (Hm) {
        var re = 0;
        do {
          if (Hm = !1, jv = 0, re >= ab)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          re += 1, c = !1, ja = null, Lo = null, f.updateQueue = null, uf = -1, En.current = zx, K = E(w, L);
        } while (Hm);
      }
      En.current = Ux, f._debugHookTypes = vc;
      var fe = ja !== null && ja.next !== null;
      if (Ih = Gt, $i = null, ja = null, Lo = null, At = null, vc = null, uf = -1, l !== null && (l.flags & sn) !== (f.flags & sn) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (l.mode & Ii) !== mr && y("Internal React error: Expected static flag was missing. Please notify the React team."), Ap = !1, fe)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return K;
    }
    function Ie() {
      var l = jv !== 0;
      return jv = 0, l;
    }
    function pt(l, f, E) {
      f.updateQueue = l.updateQueue, (f.mode & No) !== mr ? f.flags &= ~(tn | dt | Ma | ft) : f.flags &= ~(Ma | ft), l.lanes = po(l.lanes, E);
    }
    function Yt() {
      if (En.current = Ux, Ap) {
        for (var l = $i.memoizedState; l !== null; ) {
          var f = l.queue;
          f !== null && (f.pending = null), l = l.next;
        }
        Ap = !1;
      }
      Ih = Gt, $i = null, ja = null, Lo = null, vc = null, uf = -1, At = null, fb = !1, Hm = !1, jv = 0;
    }
    function jt() {
      var l = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Lo === null ? $i.memoizedState = Lo = l : Lo = Lo.next = l, Lo;
    }
    function Ft() {
      var l;
      if (ja === null) {
        var f = $i.alternate;
        f !== null ? l = f.memoizedState : l = null;
      } else
        l = ja.next;
      var E;
      if (Lo === null ? E = $i.memoizedState : E = Lo.next, E !== null)
        Lo = E, E = Lo.next, ja = l;
      else {
        if (l === null)
          throw new Error("Rendered more hooks than during the previous render.");
        ja = l;
        var w = {
          memoizedState: ja.memoizedState,
          baseState: ja.baseState,
          baseQueue: ja.baseQueue,
          queue: ja.queue,
          next: null
        };
        Lo === null ? $i.memoizedState = Lo = w : Lo = Lo.next = w;
      }
      return Lo;
    }
    function Mn() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function Nn(l, f) {
      return typeof f == "function" ? f(l) : f;
    }
    function Fn(l, f, E) {
      var w = jt(), L;
      E !== void 0 ? L = E(f) : L = f, w.memoizedState = w.baseState = L;
      var B = {
        pending: null,
        interleaved: null,
        lanes: Gt,
        dispatch: null,
        lastRenderedReducer: l,
        lastRenderedState: L
      };
      w.queue = B;
      var K = B.dispatch = Gm.bind(null, $i, B);
      return [w.memoizedState, K];
    }
    function ro(l, f, E) {
      var w = Ft(), L = w.queue;
      if (L === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      L.lastRenderedReducer = l;
      var B = ja, K = B.baseQueue, re = L.pending;
      if (re !== null) {
        if (K !== null) {
          var fe = K.next, Ce = re.next;
          K.next = Ce, re.next = fe;
        }
        B.baseQueue !== K && y("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), B.baseQueue = K = re, L.pending = null;
      }
      if (K !== null) {
        var ke = K.next, tt = B.baseState, Et = null, Dt = null, Xt = null, an = ke;
        do {
          var or = an.lane;
          if (lu(Ih, or)) {
            if (Xt !== null) {
              var hr = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Tr,
                action: an.action,
                hasEagerState: an.hasEagerState,
                eagerState: an.eagerState,
                next: null
              };
              Xt = Xt.next = hr;
            }
            if (an.hasEagerState)
              tt = an.eagerState;
            else {
              var Xa = an.action;
              tt = l(tt, Xa);
            }
          } else {
            var Wr = {
              lane: or,
              action: an.action,
              hasEagerState: an.hasEagerState,
              eagerState: an.eagerState,
              next: null
            };
            Xt === null ? (Dt = Xt = Wr, Et = tt) : Xt = Xt.next = Wr, $i.lanes = Sr($i.lanes, or), Oy(or);
          }
          an = an.next;
        } while (an !== null && an !== ke);
        Xt === null ? Et = tt : Xt.next = Dt, Co(tt, w.memoizedState) || Kx(), w.memoizedState = tt, w.baseState = Et, w.baseQueue = Xt, L.lastRenderedState = tt;
      }
      var qa = L.interleaved;
      if (qa !== null) {
        var ct = qa;
        do {
          var Nt = ct.lane;
          $i.lanes = Sr($i.lanes, Nt), Oy(Nt), ct = ct.next;
        } while (ct !== qa);
      } else
        K === null && (L.lanes = Gt);
      var ut = L.dispatch;
      return [w.memoizedState, ut];
    }
    function Qe(l, f, E) {
      var w = Ft(), L = w.queue;
      if (L === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      L.lastRenderedReducer = l;
      var B = L.dispatch, K = L.pending, re = w.memoizedState;
      if (K !== null) {
        L.pending = null;
        var fe = K.next, Ce = fe;
        do {
          var ke = Ce.action;
          re = l(re, ke), Ce = Ce.next;
        } while (Ce !== fe);
        Co(re, w.memoizedState) || Kx(), w.memoizedState = re, w.baseQueue === null && (w.baseState = re), L.lastRenderedState = re;
      }
      return [re, B];
    }
    function Ve(l, f, E) {
    }
    function lt(l, f, E) {
    }
    function on(l, f, E) {
      var w = $i, L = jt(), B, K = ji();
      if (K) {
        if (E === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        B = E(), Rp || B !== E() && (y("The result of getServerSnapshot should be cached to avoid an infinite loop"), Rp = !0);
      } else {
        if (B = f(), !Rp) {
          var re = f();
          Co(B, re) || (y("The result of getSnapshot should be cached to avoid an infinite loop"), Rp = !0);
        }
        var fe = m_();
        if (fe === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        uc(fe, Ih) || In(w, f, B);
      }
      L.memoizedState = B;
      var Ce = {
        value: B,
        getSnapshot: f
      };
      return L.queue = Ce, $v(gr.bind(null, w, Ce, l), [l]), w.flags |= Ma, ly(oa | _s, er.bind(null, w, Ce, B, f), void 0, null), B;
    }
    function Bn(l, f, E) {
      var w = $i, L = Ft(), B = f();
      if (!Rp) {
        var K = f();
        Co(B, K) || (y("The result of getSnapshot should be cached to avoid an infinite loop"), Rp = !0);
      }
      var re = L.memoizedState, fe = !Co(re, B);
      fe && (L.memoizedState = B, Kx());
      var Ce = L.queue;
      if (Yv(gr.bind(null, w, Ce, l), [l]), Ce.getSnapshot !== f || fe || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Lo !== null && Lo.memoizedState.tag & oa) {
        w.flags |= Ma, ly(oa | _s, er.bind(null, w, Ce, B, f), void 0, null);
        var ke = m_();
        if (ke === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        uc(ke, Ih) || In(w, f, B);
      }
      return B;
    }
    function In(l, f, E) {
      l.flags |= _o;
      var w = {
        getSnapshot: f,
        value: E
      }, L = $i.updateQueue;
      if (L === null)
        L = Mn(), $i.updateQueue = L, L.stores = [w];
      else {
        var B = L.stores;
        B === null ? L.stores = [w] : B.push(w);
      }
    }
    function er(l, f, E, w) {
      f.value = E, f.getSnapshot = w, Qo(f) && Ci(l);
    }
    function gr(l, f, E) {
      var w = function() {
        Qo(f) && Ci(l);
      };
      return E(w);
    }
    function Qo(l) {
      var f = l.getSnapshot, E = l.value;
      try {
        var w = f();
        return !Co(E, w);
      } catch {
        return !0;
      }
    }
    function Ci(l) {
      Bo(l, wr, _i);
    }
    function gc(l) {
      var f = jt();
      typeof l == "function" && (l = l()), f.memoizedState = f.baseState = l;
      var E = {
        pending: null,
        interleaved: null,
        lanes: Gt,
        dispatch: null,
        lastRenderedReducer: Nn,
        lastRenderedState: l
      };
      f.queue = E;
      var w = E.dispatch = lA.bind(null, $i, E);
      return [f.memoizedState, w];
    }
    function sy(l) {
      return ro(Nn);
    }
    function Tx(l) {
      return Qe(Nn);
    }
    function ly(l, f, E, w) {
      var L = {
        tag: l,
        create: f,
        destroy: E,
        deps: w,
        // Circular
        next: null
      }, B = $i.updateQueue;
      if (B === null)
        B = Mn(), $i.updateQueue = B, B.lastEffect = L.next = L;
      else {
        var K = B.lastEffect;
        if (K === null)
          B.lastEffect = L.next = L;
        else {
          var re = K.next;
          K.next = L, L.next = re, B.lastEffect = L;
        }
      }
      return L;
    }
    function Mx(l) {
      var f = jt();
      {
        var E = {
          current: l
        };
        return f.memoizedState = E, E;
      }
    }
    function wx(l) {
      var f = Ft();
      return f.memoizedState;
    }
    function z0(l, f, E, w) {
      var L = jt(), B = w === void 0 ? null : w;
      $i.flags |= l, L.memoizedState = ly(oa | f, E, void 0, B);
    }
    function k0(l, f, E, w) {
      var L = Ft(), B = w === void 0 ? null : w, K = void 0;
      if (ja !== null) {
        var re = ja.memoizedState;
        if (K = re.destroy, B !== null) {
          var fe = re.deps;
          if (ie(B, fe)) {
            L.memoizedState = ly(f, E, K, B);
            return;
          }
        }
      }
      $i.flags |= l, L.memoizedState = ly(oa | f, E, K, B);
    }
    function $v(l, f) {
      return ($i.mode & No) !== mr ? z0(tn | Ma | ze, _s, l, f) : z0(Ma | ze, _s, l, f);
    }
    function Yv(l, f) {
      return k0(Ma, _s, l, f);
    }
    function ob(l, f) {
      return z0(ft, kh, l, f);
    }
    function Cx(l, f) {
      return k0(ft, kh, l, f);
    }
    function sb(l, f) {
      var E = ft;
      return E |= qe, ($i.mode & No) !== mr && (E |= dt), z0(E, Wa, l, f);
    }
    function Rx(l, f) {
      return k0(ft, Wa, l, f);
    }
    function SM(l, f) {
      if (typeof f == "function") {
        var E = f, w = l();
        return E(w), function() {
          E(null);
        };
      } else if (f != null) {
        var L = f;
        L.hasOwnProperty("current") || y("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(L).join(", ") + "}");
        var B = l();
        return L.current = B, function() {
          L.current = null;
        };
      }
    }
    function Vm(l, f, E) {
      typeof f != "function" && y("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", f !== null ? typeof f : "null");
      var w = E != null ? E.concat([l]) : null, L = ft;
      return L |= qe, ($i.mode & No) !== mr && (L |= dt), z0(L, Wa, SM.bind(null, f, l), w);
    }
    function uy(l, f, E) {
      typeof f != "function" && y("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", f !== null ? typeof f : "null");
      var w = E != null ? E.concat([l]) : null;
      return k0(ft, Wa, SM.bind(null, f, l), w);
    }
    function I0(l, f) {
    }
    var cy = I0;
    function lb(l, f) {
      var E = jt(), w = f === void 0 ? null : f;
      return E.memoizedState = [l, w], l;
    }
    function Ax(l, f) {
      var E = Ft(), w = f === void 0 ? null : f, L = E.memoizedState;
      if (L !== null && w !== null) {
        var B = L[1];
        if (ie(w, B))
          return L[0];
      }
      return E.memoizedState = [l, w], l;
    }
    function Dx(l, f) {
      var E = jt(), w = f === void 0 ? null : f, L = l();
      return E.memoizedState = [L, w], L;
    }
    function Lx(l, f) {
      var E = Ft(), w = f === void 0 ? null : f, L = E.memoizedState;
      if (L !== null && w !== null) {
        var B = L[1];
        if (ie(w, B))
          return L[0];
      }
      var K = l();
      return E.memoizedState = [K, w], K;
    }
    function fy(l) {
      var f = gc(l), E = f[0], w = f[1];
      return $v(function() {
        var L = Il.transition;
        Il.transition = {};
        try {
          w(l);
        } finally {
          Il.transition = L;
        }
      }, [l]), E;
    }
    function Xv(l) {
      var f = sy(), E = f[0], w = f[1];
      return Yv(function() {
        var L = Il.transition;
        Il.transition = {};
        try {
          w(l);
        } finally {
          Il.transition = L;
        }
      }, [l]), E;
    }
    function Ox(l) {
      var f = Tx(), E = f[0], w = f[1];
      return Yv(function() {
        var L = Il.transition;
        Il.transition = {};
        try {
          w(l);
        } finally {
          Il.transition = L;
        }
      }, [l]), E;
    }
    function xM(l, f, E) {
      var w = ps();
      mo(xh(w, Ld)), l(!0);
      var L = Il.transition;
      Il.transition = {};
      var B = Il.transition;
      Il.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        l(!1), f();
      } finally {
        if (mo(w), Il.transition = L, L === null && B._updatedFibers) {
          var K = B._updatedFibers.size;
          K > 10 && v("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), B._updatedFibers.clear();
        }
      }
    }
    function dy() {
      var l = gc(!1), f = l[0], E = l[1], w = xM.bind(null, E), L = jt();
      return L.memoizedState = w, [f, w];
    }
    function ub() {
      var l = sy(), f = l[0], E = Ft(), w = E.memoizedState;
      return [f, w];
    }
    function cb() {
      var l = Tx(), f = l[0], E = Ft(), w = E.memoizedState;
      return [f, w];
    }
    var fb = !1;
    function _M() {
      return fb;
    }
    function Px() {
      var l = jt(), f = m_(), E = f.identifierPrefix, w;
      if (ji()) {
        var L = _x();
        w = ":" + E + "R" + L;
        var B = jv++;
        B > 0 && (w += "H" + B.toString(32)), w += ":";
      } else {
        var K = oy++;
        w = ":" + E + "r" + K.toString(32) + ":";
      }
      return l.memoizedState = w, w;
    }
    function F0() {
      var l = Ft(), f = l.memoizedState;
      return f;
    }
    function Gm(l, f, E) {
      typeof arguments[3] == "function" && y("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var w = Bp(l), L = {
        lane: w,
        action: E,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (EM(l))
        bM(f, L);
      else {
        hy(l, f, L);
        var B = Sl(), K = Bo(l, w, B);
        K !== null && Nx(K, f, w);
      }
      db(l, w);
    }
    function lA(l, f, E) {
      typeof arguments[3] == "function" && y("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var w = Bp(l), L = {
        lane: w,
        action: E,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (EM(l))
        bM(f, L);
      else {
        hy(l, f, L);
        var B = l.alternate;
        if (l.lanes === Gt && (B === null || B.lanes === Gt)) {
          var K = f.lastRenderedReducer;
          if (K !== null) {
            var re;
            re = En.current, En.current = Fu;
            try {
              var fe = f.lastRenderedState, Ce = K(fe, E);
              if (L.hasEagerState = !0, L.eagerState = Ce, Co(Ce, fe))
                return;
            } catch {
            } finally {
              En.current = re;
            }
          }
        }
        var ke = Sl(), tt = Bo(l, w, ke);
        tt !== null && Nx(tt, f, w);
      }
      db(l, w);
    }
    function EM(l) {
      var f = l.alternate;
      return l === $i || f !== null && f === $i;
    }
    function bM(l, f) {
      Hm = Ap = !0;
      var E = l.pending;
      E === null ? f.next = f : (f.next = E.next, E.next = f), l.pending = f;
    }
    function hy(l, f, E, w) {
      if (v_(l)) {
        var L = f.interleaved;
        L === null ? (E.next = E, Jn(f)) : (E.next = L.next, L.next = E), f.interleaved = E;
      } else {
        var B = f.pending;
        B === null ? E.next = E : (E.next = B.next, B.next = E), f.pending = E;
      }
    }
    function Nx(l, f, E) {
      if (ds(E)) {
        var w = f.lanes;
        w = La(w, l.pendingLanes);
        var L = Sr(w, E);
        f.lanes = L, Mo(l, L);
      }
    }
    function db(l, f, E) {
      Qc(l, f);
    }
    var Ux = {
      readContext: cn,
      useCallback: W,
      useContext: W,
      useEffect: W,
      useImperativeHandle: W,
      useInsertionEffect: W,
      useLayoutEffect: W,
      useMemo: W,
      useReducer: W,
      useRef: W,
      useState: W,
      useDebugValue: W,
      useDeferredValue: W,
      useTransition: W,
      useMutableSource: W,
      useSyncExternalStore: W,
      useId: W,
      unstable_isNewReconciler: U
    }, hb = null, TM = null, $a = null, zx = null, cf = null, Fu = null, B0 = null;
    {
      var kx = function() {
        y("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, _r = function() {
        y("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      hb = {
        readContext: function(l) {
          return cn(l);
        },
        useCallback: function(l, f) {
          return At = "useCallback", d(), A(f), lb(l, f);
        },
        useContext: function(l) {
          return At = "useContext", d(), cn(l);
        },
        useEffect: function(l, f) {
          return At = "useEffect", d(), A(f), $v(l, f);
        },
        useImperativeHandle: function(l, f, E) {
          return At = "useImperativeHandle", d(), A(E), Vm(l, f, E);
        },
        useInsertionEffect: function(l, f) {
          return At = "useInsertionEffect", d(), A(f), ob(l, f);
        },
        useLayoutEffect: function(l, f) {
          return At = "useLayoutEffect", d(), A(f), sb(l, f);
        },
        useMemo: function(l, f) {
          At = "useMemo", d(), A(f);
          var E = En.current;
          En.current = cf;
          try {
            return Dx(l, f);
          } finally {
            En.current = E;
          }
        },
        useReducer: function(l, f, E) {
          At = "useReducer", d();
          var w = En.current;
          En.current = cf;
          try {
            return Fn(l, f, E);
          } finally {
            En.current = w;
          }
        },
        useRef: function(l) {
          return At = "useRef", d(), Mx(l);
        },
        useState: function(l) {
          At = "useState", d();
          var f = En.current;
          En.current = cf;
          try {
            return gc(l);
          } finally {
            En.current = f;
          }
        },
        useDebugValue: function(l, f) {
          return At = "useDebugValue", d(), void 0;
        },
        useDeferredValue: function(l) {
          return At = "useDeferredValue", d(), fy(l);
        },
        useTransition: function() {
          return At = "useTransition", d(), dy();
        },
        useMutableSource: function(l, f, E) {
          return At = "useMutableSource", d(), void 0;
        },
        useSyncExternalStore: function(l, f, E) {
          return At = "useSyncExternalStore", d(), on(l, f, E);
        },
        useId: function() {
          return At = "useId", d(), Px();
        },
        unstable_isNewReconciler: U
      }, TM = {
        readContext: function(l) {
          return cn(l);
        },
        useCallback: function(l, f) {
          return At = "useCallback", x(), lb(l, f);
        },
        useContext: function(l) {
          return At = "useContext", x(), cn(l);
        },
        useEffect: function(l, f) {
          return At = "useEffect", x(), $v(l, f);
        },
        useImperativeHandle: function(l, f, E) {
          return At = "useImperativeHandle", x(), Vm(l, f, E);
        },
        useInsertionEffect: function(l, f) {
          return At = "useInsertionEffect", x(), ob(l, f);
        },
        useLayoutEffect: function(l, f) {
          return At = "useLayoutEffect", x(), sb(l, f);
        },
        useMemo: function(l, f) {
          At = "useMemo", x();
          var E = En.current;
          En.current = cf;
          try {
            return Dx(l, f);
          } finally {
            En.current = E;
          }
        },
        useReducer: function(l, f, E) {
          At = "useReducer", x();
          var w = En.current;
          En.current = cf;
          try {
            return Fn(l, f, E);
          } finally {
            En.current = w;
          }
        },
        useRef: function(l) {
          return At = "useRef", x(), Mx(l);
        },
        useState: function(l) {
          At = "useState", x();
          var f = En.current;
          En.current = cf;
          try {
            return gc(l);
          } finally {
            En.current = f;
          }
        },
        useDebugValue: function(l, f) {
          return At = "useDebugValue", x(), void 0;
        },
        useDeferredValue: function(l) {
          return At = "useDeferredValue", x(), fy(l);
        },
        useTransition: function() {
          return At = "useTransition", x(), dy();
        },
        useMutableSource: function(l, f, E) {
          return At = "useMutableSource", x(), void 0;
        },
        useSyncExternalStore: function(l, f, E) {
          return At = "useSyncExternalStore", x(), on(l, f, E);
        },
        useId: function() {
          return At = "useId", x(), Px();
        },
        unstable_isNewReconciler: U
      }, $a = {
        readContext: function(l) {
          return cn(l);
        },
        useCallback: function(l, f) {
          return At = "useCallback", x(), Ax(l, f);
        },
        useContext: function(l) {
          return At = "useContext", x(), cn(l);
        },
        useEffect: function(l, f) {
          return At = "useEffect", x(), Yv(l, f);
        },
        useImperativeHandle: function(l, f, E) {
          return At = "useImperativeHandle", x(), uy(l, f, E);
        },
        useInsertionEffect: function(l, f) {
          return At = "useInsertionEffect", x(), Cx(l, f);
        },
        useLayoutEffect: function(l, f) {
          return At = "useLayoutEffect", x(), Rx(l, f);
        },
        useMemo: function(l, f) {
          At = "useMemo", x();
          var E = En.current;
          En.current = Fu;
          try {
            return Lx(l, f);
          } finally {
            En.current = E;
          }
        },
        useReducer: function(l, f, E) {
          At = "useReducer", x();
          var w = En.current;
          En.current = Fu;
          try {
            return ro(l, f, E);
          } finally {
            En.current = w;
          }
        },
        useRef: function(l) {
          return At = "useRef", x(), wx();
        },
        useState: function(l) {
          At = "useState", x();
          var f = En.current;
          En.current = Fu;
          try {
            return sy(l);
          } finally {
            En.current = f;
          }
        },
        useDebugValue: function(l, f) {
          return At = "useDebugValue", x(), cy();
        },
        useDeferredValue: function(l) {
          return At = "useDeferredValue", x(), Xv(l);
        },
        useTransition: function() {
          return At = "useTransition", x(), ub();
        },
        useMutableSource: function(l, f, E) {
          return At = "useMutableSource", x(), void 0;
        },
        useSyncExternalStore: function(l, f, E) {
          return At = "useSyncExternalStore", x(), Bn(l, f);
        },
        useId: function() {
          return At = "useId", x(), F0();
        },
        unstable_isNewReconciler: U
      }, zx = {
        readContext: function(l) {
          return cn(l);
        },
        useCallback: function(l, f) {
          return At = "useCallback", x(), Ax(l, f);
        },
        useContext: function(l) {
          return At = "useContext", x(), cn(l);
        },
        useEffect: function(l, f) {
          return At = "useEffect", x(), Yv(l, f);
        },
        useImperativeHandle: function(l, f, E) {
          return At = "useImperativeHandle", x(), uy(l, f, E);
        },
        useInsertionEffect: function(l, f) {
          return At = "useInsertionEffect", x(), Cx(l, f);
        },
        useLayoutEffect: function(l, f) {
          return At = "useLayoutEffect", x(), Rx(l, f);
        },
        useMemo: function(l, f) {
          At = "useMemo", x();
          var E = En.current;
          En.current = B0;
          try {
            return Lx(l, f);
          } finally {
            En.current = E;
          }
        },
        useReducer: function(l, f, E) {
          At = "useReducer", x();
          var w = En.current;
          En.current = B0;
          try {
            return Qe(l, f, E);
          } finally {
            En.current = w;
          }
        },
        useRef: function(l) {
          return At = "useRef", x(), wx();
        },
        useState: function(l) {
          At = "useState", x();
          var f = En.current;
          En.current = B0;
          try {
            return Tx(l);
          } finally {
            En.current = f;
          }
        },
        useDebugValue: function(l, f) {
          return At = "useDebugValue", x(), cy();
        },
        useDeferredValue: function(l) {
          return At = "useDeferredValue", x(), Ox(l);
        },
        useTransition: function() {
          return At = "useTransition", x(), cb();
        },
        useMutableSource: function(l, f, E) {
          return At = "useMutableSource", x(), void 0;
        },
        useSyncExternalStore: function(l, f, E) {
          return At = "useSyncExternalStore", x(), Bn(l, f);
        },
        useId: function() {
          return At = "useId", x(), F0();
        },
        unstable_isNewReconciler: U
      }, cf = {
        readContext: function(l) {
          return kx(), cn(l);
        },
        useCallback: function(l, f) {
          return At = "useCallback", _r(), d(), lb(l, f);
        },
        useContext: function(l) {
          return At = "useContext", _r(), d(), cn(l);
        },
        useEffect: function(l, f) {
          return At = "useEffect", _r(), d(), $v(l, f);
        },
        useImperativeHandle: function(l, f, E) {
          return At = "useImperativeHandle", _r(), d(), Vm(l, f, E);
        },
        useInsertionEffect: function(l, f) {
          return At = "useInsertionEffect", _r(), d(), ob(l, f);
        },
        useLayoutEffect: function(l, f) {
          return At = "useLayoutEffect", _r(), d(), sb(l, f);
        },
        useMemo: function(l, f) {
          At = "useMemo", _r(), d();
          var E = En.current;
          En.current = cf;
          try {
            return Dx(l, f);
          } finally {
            En.current = E;
          }
        },
        useReducer: function(l, f, E) {
          At = "useReducer", _r(), d();
          var w = En.current;
          En.current = cf;
          try {
            return Fn(l, f, E);
          } finally {
            En.current = w;
          }
        },
        useRef: function(l) {
          return At = "useRef", _r(), d(), Mx(l);
        },
        useState: function(l) {
          At = "useState", _r(), d();
          var f = En.current;
          En.current = cf;
          try {
            return gc(l);
          } finally {
            En.current = f;
          }
        },
        useDebugValue: function(l, f) {
          return At = "useDebugValue", _r(), d(), void 0;
        },
        useDeferredValue: function(l) {
          return At = "useDeferredValue", _r(), d(), fy(l);
        },
        useTransition: function() {
          return At = "useTransition", _r(), d(), dy();
        },
        useMutableSource: function(l, f, E) {
          return At = "useMutableSource", _r(), d(), void 0;
        },
        useSyncExternalStore: function(l, f, E) {
          return At = "useSyncExternalStore", _r(), d(), on(l, f, E);
        },
        useId: function() {
          return At = "useId", _r(), d(), Px();
        },
        unstable_isNewReconciler: U
      }, Fu = {
        readContext: function(l) {
          return kx(), cn(l);
        },
        useCallback: function(l, f) {
          return At = "useCallback", _r(), x(), Ax(l, f);
        },
        useContext: function(l) {
          return At = "useContext", _r(), x(), cn(l);
        },
        useEffect: function(l, f) {
          return At = "useEffect", _r(), x(), Yv(l, f);
        },
        useImperativeHandle: function(l, f, E) {
          return At = "useImperativeHandle", _r(), x(), uy(l, f, E);
        },
        useInsertionEffect: function(l, f) {
          return At = "useInsertionEffect", _r(), x(), Cx(l, f);
        },
        useLayoutEffect: function(l, f) {
          return At = "useLayoutEffect", _r(), x(), Rx(l, f);
        },
        useMemo: function(l, f) {
          At = "useMemo", _r(), x();
          var E = En.current;
          En.current = Fu;
          try {
            return Lx(l, f);
          } finally {
            En.current = E;
          }
        },
        useReducer: function(l, f, E) {
          At = "useReducer", _r(), x();
          var w = En.current;
          En.current = Fu;
          try {
            return ro(l, f, E);
          } finally {
            En.current = w;
          }
        },
        useRef: function(l) {
          return At = "useRef", _r(), x(), wx();
        },
        useState: function(l) {
          At = "useState", _r(), x();
          var f = En.current;
          En.current = Fu;
          try {
            return sy(l);
          } finally {
            En.current = f;
          }
        },
        useDebugValue: function(l, f) {
          return At = "useDebugValue", _r(), x(), cy();
        },
        useDeferredValue: function(l) {
          return At = "useDeferredValue", _r(), x(), Xv(l);
        },
        useTransition: function() {
          return At = "useTransition", _r(), x(), ub();
        },
        useMutableSource: function(l, f, E) {
          return At = "useMutableSource", _r(), x(), void 0;
        },
        useSyncExternalStore: function(l, f, E) {
          return At = "useSyncExternalStore", _r(), x(), Bn(l, f);
        },
        useId: function() {
          return At = "useId", _r(), x(), F0();
        },
        unstable_isNewReconciler: U
      }, B0 = {
        readContext: function(l) {
          return kx(), cn(l);
        },
        useCallback: function(l, f) {
          return At = "useCallback", _r(), x(), Ax(l, f);
        },
        useContext: function(l) {
          return At = "useContext", _r(), x(), cn(l);
        },
        useEffect: function(l, f) {
          return At = "useEffect", _r(), x(), Yv(l, f);
        },
        useImperativeHandle: function(l, f, E) {
          return At = "useImperativeHandle", _r(), x(), uy(l, f, E);
        },
        useInsertionEffect: function(l, f) {
          return At = "useInsertionEffect", _r(), x(), Cx(l, f);
        },
        useLayoutEffect: function(l, f) {
          return At = "useLayoutEffect", _r(), x(), Rx(l, f);
        },
        useMemo: function(l, f) {
          At = "useMemo", _r(), x();
          var E = En.current;
          En.current = Fu;
          try {
            return Lx(l, f);
          } finally {
            En.current = E;
          }
        },
        useReducer: function(l, f, E) {
          At = "useReducer", _r(), x();
          var w = En.current;
          En.current = Fu;
          try {
            return Qe(l, f, E);
          } finally {
            En.current = w;
          }
        },
        useRef: function(l) {
          return At = "useRef", _r(), x(), wx();
        },
        useState: function(l) {
          At = "useState", _r(), x();
          var f = En.current;
          En.current = Fu;
          try {
            return Tx(l);
          } finally {
            En.current = f;
          }
        },
        useDebugValue: function(l, f) {
          return At = "useDebugValue", _r(), x(), cy();
        },
        useDeferredValue: function(l) {
          return At = "useDeferredValue", _r(), x(), Ox(l);
        },
        useTransition: function() {
          return At = "useTransition", _r(), x(), cb();
        },
        useMutableSource: function(l, f, E) {
          return At = "useMutableSource", _r(), x(), void 0;
        },
        useSyncExternalStore: function(l, f, E) {
          return At = "useSyncExternalStore", _r(), x(), Bn(l, f);
        },
        useId: function() {
          return At = "useId", _r(), x(), F0();
        },
        unstable_isNewReconciler: U
      };
    }
    var Qf = a.unstable_now, MM = 0, qv = -1, Fh = -1, Ix = -1, Fx = !1, Bx = !1;
    function wM() {
      return Fx;
    }
    function yc() {
      Bx = !0;
    }
    function H0() {
      Fx = !1, Bx = !1;
    }
    function Hx() {
      Fx = Bx, Bx = !1;
    }
    function Dp() {
      return MM;
    }
    function pb() {
      MM = Qf();
    }
    function Lp(l) {
      Fh = Qf(), l.actualStartTime < 0 && (l.actualStartTime = Qf());
    }
    function Wm(l) {
      Fh = -1;
    }
    function Kv(l, f) {
      if (Fh >= 0) {
        var E = Qf() - Fh;
        l.actualDuration += E, f && (l.selfBaseDuration = E), Fh = -1;
      }
    }
    function Sc(l) {
      if (qv >= 0) {
        var f = Qf() - qv;
        qv = -1;
        for (var E = l.return; E !== null; ) {
          switch (E.tag) {
            case q:
              var w = E.stateNode;
              w.effectDuration += f;
              return;
            case we:
              var L = E.stateNode;
              L.effectDuration += f;
              return;
          }
          E = E.return;
        }
      }
    }
    function py(l) {
      if (Ix >= 0) {
        var f = Qf() - Ix;
        Ix = -1;
        for (var E = l.return; E !== null; ) {
          switch (E.tag) {
            case q:
              var w = E.stateNode;
              w !== null && (w.passiveEffectDuration += f);
              return;
            case we:
              var L = E.stateNode;
              L !== null && (L.passiveEffectDuration += f);
              return;
          }
          E = E.return;
        }
      }
    }
    function gu() {
      qv = Qf();
    }
    function Vx() {
      Ix = Qf();
    }
    function my(l) {
      for (var f = l.child; f; )
        l.actualDuration += f.actualDuration, f = f.sibling;
    }
    function V0(l, f) {
      return {
        value: l,
        source: f,
        stack: jf(f)
      };
    }
    function CM(l, f) {
      return !0;
    }
    function mb(l, f) {
      try {
        var E = CM(l, f);
        if (E === !1)
          return;
        var w = f.value, L = f.source, B = f.stack, K = B !== null ? B : "";
        if (w != null && w._suppressLogging) {
          if (l.tag === te)
            return;
          console.error(w);
        }
        var re = L ? Tt(L) : null, fe = re ? "The above error occurred in the <" + re + "> component:" : "The above error occurred in one of your React components:", Ce;
        if (l.tag === q)
          Ce = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var ke = Tt(l) || "Anonymous";
          Ce = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + ke + ".");
        }
        var tt = fe + `
` + K + `

` + ("" + Ce);
        console.error(tt);
      } catch (Et) {
        setTimeout(function() {
          throw Et;
        });
      }
    }
    var uA = typeof WeakMap == "function" ? WeakMap : Map;
    function G0(l, f, E) {
      var w = ar(_i, E);
      w.tag = ot, w.payload = {
        element: null
      };
      var L = f.value;
      return w.callback = function() {
        o1(L), mb(l, f);
      }, w;
    }
    function vy(l, f, E) {
      var w = ar(_i, E);
      w.tag = ot;
      var L = l.type.getDerivedStateFromError;
      if (typeof L == "function") {
        var B = f.value;
        w.payload = function() {
          return L(B);
        }, w.callback = function() {
          Ow(l), mb(l, f);
        };
      }
      var K = l.stateNode;
      return K !== null && typeof K.componentDidCatch == "function" && (w.callback = function() {
        Ow(l), mb(l, f), typeof L != "function" && i1(this);
        var fe = f.value, Ce = f.stack;
        this.componentDidCatch(fe, {
          componentStack: Ce !== null ? Ce : ""
        }), typeof L != "function" && (hi(l.lanes, wr) || y("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Tt(l) || "Unknown"));
      }), w;
    }
    function vb(l, f, E) {
      var w = l.pingCache, L;
      if (w === null ? (w = l.pingCache = new uA(), L = /* @__PURE__ */ new Set(), w.set(f, L)) : (L = w.get(f), L === void 0 && (L = /* @__PURE__ */ new Set(), w.set(f, L))), !L.has(E)) {
        L.add(E);
        var B = w_.bind(null, l, f, E);
        Ha && dg(l, E), f.then(B, B);
      }
    }
    function cA(l, f, E, w) {
      var L = l.updateQueue;
      if (L === null) {
        var B = /* @__PURE__ */ new Set();
        B.add(E), l.updateQueue = B;
      } else
        L.add(E);
    }
    function Gx(l, f) {
      var E = l.tag;
      if ((l.mode & Ii) === mr && (E === Z || E === ue || E === ce)) {
        var w = l.alternate;
        w ? (l.updateQueue = w.updateQueue, l.memoizedState = w.memoizedState, l.lanes = w.lanes) : (l.updateQueue = null, l.memoizedState = null);
      }
    }
    function RM(l) {
      var f = l;
      do {
        if (f.tag === X && Cp(f))
          return f;
        f = f.return;
      } while (f !== null);
      return null;
    }
    function AM(l, f, E, w, L) {
      if ((l.mode & Ii) === mr) {
        if (l === f)
          l.flags |= en;
        else {
          if (l.flags |= rr, E.flags |= _n, E.flags &= ~(Eo | Bt), jr && D) {
            var B = l.alternate;
            if (B === null) {
              var K = l.child, re = K.child;
              if (re !== null) {
                var fe = re.memoizedProps.children, Ce = mn("hidden", fe);
                re.pendingProps = Ce, re.memoizedProps = Ce;
              }
            }
          }
          if (E.tag === te) {
            var ke = E.alternate;
            if (ke === null)
              E.tag = Oe;
            else {
              var tt = ar(_i, wr);
              tt.tag = Va, Vr(E, tt);
            }
          }
          E.lanes = Sr(E.lanes, wr);
        }
        return l;
      }
      return l.flags |= en, l.lanes = L, l;
    }
    function fA(l, f, E, w, L) {
      if (E.flags |= Bt, Ha && dg(l, L), w !== null && typeof w == "object" && typeof w.then == "function") {
        var B = w;
        Gx(E);
        var K = RM(f);
        if (K !== null) {
          K.flags &= ~vr, AM(K, f, E, l, L), K.mode & Ii && vb(l, B, L), cA(K, l, B);
          return;
        } else {
          if (!ua(L)) {
            vb(l, B, L), mS();
            return;
          }
          var re = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          w = re;
        }
      } else if (ji() && E.mode & Ii) {
        zm();
        var fe = RM(f);
        if (fe !== null) {
          (fe.flags & en) === ge && (fe.flags |= vr), AM(fe, f, E, l, L), So(w);
          return;
        }
      }
      Ew(w), w = V0(w, E);
      var Ce = f;
      do {
        switch (Ce.tag) {
          case q: {
            var ke = w;
            Ce.flags |= en;
            var tt = Ff(L);
            Ce.lanes = Sr(Ce.lanes, tt);
            var Et = G0(Ce, ke, tt);
            Gr(Ce, Et);
            return;
          }
          case te:
            var Dt = w, Xt = Ce.type, an = Ce.stateNode;
            if ((Ce.flags & rr) === ge && (typeof Xt.getDerivedStateFromError == "function" || an !== null && typeof an.componentDidCatch == "function" && !M_(an))) {
              Ce.flags |= en;
              var or = Ff(L);
              Ce.lanes = Sr(Ce.lanes, or);
              var Wr = vy(Ce, Dt, or);
              Gr(Ce, Wr);
              return;
            }
            break;
        }
        Ce = Ce.return;
      } while (Ce !== null);
    }
    function dA() {
      return null;
    }
    function Bh(l) {
      l.flags |= ft;
    }
    function DM(l) {
      l.flags |= Ai, l.flags |= $e;
    }
    function LM(l, f) {
      var E = l !== null && l.child === f.child;
      if (E)
        return !0;
      if ((f.flags & zn) !== ge)
        return !1;
      for (var w = f.child; w !== null; ) {
        if ((w.flags & An) !== ge || (w.subtreeFlags & An) !== ge)
          return !1;
        w = w.sibling;
      }
      return !0;
    }
    var W0, j0, Wx, gy;
    if (ls)
      W0 = function(l, f, E, w) {
        for (var L = f.child; L !== null; ) {
          if (L.tag === ye || L.tag === de)
            Ds(l, L.stateNode);
          else if (L.tag !== oe) {
            if (L.child !== null) {
              L.child.return = L, L = L.child;
              continue;
            }
          }
          if (L === f)
            return;
          for (; L.sibling === null; ) {
            if (L.return === null || L.return === f)
              return;
            L = L.return;
          }
          L.sibling.return = L.return, L = L.sibling;
        }
      }, j0 = function(l, f) {
      }, Wx = function(l, f, E, w, L) {
        var B = l.memoizedProps;
        if (B !== w) {
          var K = f.stateNode, re = Fm(), fe = Go(K, E, B, w, L, re);
          f.updateQueue = fe, fe && Bh(f);
        }
      }, gy = function(l, f, E, w) {
        E !== w && Bh(f);
      };
    else if (jr) {
      W0 = function(l, f, E, w) {
        for (var L = f.child; L !== null; ) {
          if (L.tag === ye) {
            var B = L.stateNode;
            if (E && w) {
              var K = L.memoizedProps, re = L.type;
              B = qn(B, re, K, L);
            }
            Ds(l, B);
          } else if (L.tag === de) {
            var fe = L.stateNode;
            if (E && w) {
              var Ce = L.memoizedProps;
              fe = Nr(fe, Ce, L);
            }
            Ds(l, fe);
          } else if (L.tag !== oe) {
            if (L.tag === at && L.memoizedState !== null) {
              var ke = L.child;
              ke !== null && (ke.return = L), W0(l, L, !0, !0);
            } else if (L.child !== null) {
              L.child.return = L, L = L.child;
              continue;
            }
          }
          if (L = L, L === f)
            return;
          for (; L.sibling === null; ) {
            if (L.return === null || L.return === f)
              return;
            L = L.return;
          }
          L.sibling.return = L.return, L = L.sibling;
        }
      };
      var jx = function(l, f, E, w) {
        for (var L = f.child; L !== null; ) {
          if (L.tag === ye) {
            var B = L.stateNode;
            if (E && w) {
              var K = L.memoizedProps, re = L.type;
              B = qn(B, re, K, L);
            }
            yt(l, B);
          } else if (L.tag === de) {
            var fe = L.stateNode;
            if (E && w) {
              var Ce = L.memoizedProps;
              fe = Nr(fe, Ce, L);
            }
            yt(l, fe);
          } else if (L.tag !== oe) {
            if (L.tag === at && L.memoizedState !== null) {
              var ke = L.child;
              ke !== null && (ke.return = L), jx(l, L, !0, !0);
            } else if (L.child !== null) {
              L.child.return = L, L = L.child;
              continue;
            }
          }
          if (L = L, L === f)
            return;
          for (; L.sibling === null; ) {
            if (L.return === null || L.return === f)
              return;
            L = L.return;
          }
          L.sibling.return = L.return, L = L.sibling;
        }
      };
      j0 = function(l, f) {
        var E = f.stateNode, w = LM(l, f);
        if (!w) {
          var L = E.containerInfo, B = st(L);
          jx(B, f, !1, !1), E.pendingChildren = B, Bh(f), Zt(L, B);
        }
      }, Wx = function(l, f, E, w, L) {
        var B = l.stateNode, K = l.memoizedProps, re = LM(l, f);
        if (re && K === w) {
          f.stateNode = B;
          return;
        }
        var fe = f.stateNode, Ce = Fm(), ke = null;
        if (K !== w && (ke = Go(fe, E, K, w, L, Ce)), re && ke === null) {
          f.stateNode = B;
          return;
        }
        var tt = De(B, ke, E, K, w, f, re, fe);
        bl(tt, E, w, L, Ce) && Bh(f), f.stateNode = tt, re ? Bh(f) : W0(tt, f, !1, !1);
      }, gy = function(l, f, E, w) {
        if (E !== w) {
          var L = Gd(), B = Fm();
          f.stateNode = Qu(w, L, B, f), Bh(f);
        } else
          f.stateNode = l.stateNode;
      };
    } else
      j0 = function(l, f) {
      }, Wx = function(l, f, E, w, L) {
      }, gy = function(l, f, E, w) {
      };
    function Qv(l, f) {
      if (!ji())
        switch (l.tailMode) {
          case "hidden": {
            for (var E = l.tail, w = null; E !== null; )
              E.alternate !== null && (w = E), E = E.sibling;
            w === null ? l.tail = null : w.sibling = null;
            break;
          }
          case "collapsed": {
            for (var L = l.tail, B = null; L !== null; )
              L.alternate !== null && (B = L), L = L.sibling;
            B === null ? !f && l.tail !== null ? l.tail.sibling = null : l.tail = null : B.sibling = null;
            break;
          }
        }
    }
    function Xs(l) {
      var f = l.alternate !== null && l.alternate.child === l.child, E = Gt, w = ge;
      if (f) {
        if ((l.mode & Ur) !== mr) {
          for (var fe = l.selfBaseDuration, Ce = l.child; Ce !== null; )
            E = Sr(E, Sr(Ce.lanes, Ce.childLanes)), w |= Ce.subtreeFlags & sn, w |= Ce.flags & sn, fe += Ce.treeBaseDuration, Ce = Ce.sibling;
          l.treeBaseDuration = fe;
        } else
          for (var ke = l.child; ke !== null; )
            E = Sr(E, Sr(ke.lanes, ke.childLanes)), w |= ke.subtreeFlags & sn, w |= ke.flags & sn, ke.return = l, ke = ke.sibling;
        l.subtreeFlags |= w;
      } else {
        if ((l.mode & Ur) !== mr) {
          for (var L = l.actualDuration, B = l.selfBaseDuration, K = l.child; K !== null; )
            E = Sr(E, Sr(K.lanes, K.childLanes)), w |= K.subtreeFlags, w |= K.flags, L += K.actualDuration, B += K.treeBaseDuration, K = K.sibling;
          l.actualDuration = L, l.treeBaseDuration = B;
        } else
          for (var re = l.child; re !== null; )
            E = Sr(E, Sr(re.lanes, re.childLanes)), w |= re.subtreeFlags, w |= re.flags, re.return = l, re = re.sibling;
        l.subtreeFlags |= w;
      }
      return l.childLanes = E, f;
    }
    function OM(l, f, E) {
      var w = f.pendingProps;
      switch (Zg(f), f.tag) {
        case J:
        case Ue:
        case ce:
        case Z:
        case ue:
        case xe:
        case Re:
        case we:
        case Pe:
        case me:
          return Xs(f), null;
        case te: {
          var L = f.type;
          return Al(L) && Vc(f), Xs(f), null;
        }
        case q: {
          var B = f.stateNode;
          if (lf(f), Mu(f), ay(), B.pendingContext && (B.context = B.pendingContext, B.pendingContext = null), l === null || l.child === null) {
            var K = Lh(f);
            if (K)
              Bh(f);
            else if (l !== null) {
              var re = l.memoizedState;
              // Check if this is a client root
              (!re.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (f.flags & vr) !== ge) && (f.flags |= oi, Oh());
            }
          }
          return j0(l, f), Xs(f), null;
        }
        case ye: {
          N0(f);
          var fe = Gd(), Ce = f.type;
          if (l !== null && f.stateNode != null)
            Wx(l, f, Ce, w, fe), l.ref !== f.ref && DM(f);
          else {
            if (!w) {
              if (f.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Xs(f), null;
            }
            var ke = Fm(), tt = Lh(f);
            if (tt)
              ey(f, fe, ke) && Bh(f);
            else {
              var Et = El(Ce, w, fe, ke, f);
              W0(Et, f, !1, !1), f.stateNode = Et, bl(Et, Ce, w, fe, ke) && Bh(f);
            }
            f.ref !== null && DM(f);
          }
          return Xs(f), null;
        }
        case de: {
          var Dt = w;
          if (l && f.stateNode != null) {
            var Xt = l.memoizedProps;
            gy(l, f, Xt, Dt);
          } else {
            if (typeof Dt != "string" && f.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var an = Gd(), or = Fm(), Wr = Lh(f);
            Wr ? Mp(f) && Bh(f) : f.stateNode = Qu(Dt, an, or, f);
          }
          return Xs(f), null;
        }
        case X: {
          Wd(f);
          var hr = f.memoizedState;
          {
            if (km() && (f.mode & Ii) !== mr && (f.flags & rr) === ge)
              return zv(f), pc(), f.flags |= vr | Bt | en, f;
            if (hr !== null && hr.dehydrated !== null) {
              var Xa = Lh(f);
              if (l === null) {
                if (!Xa)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (Kf(f), Xs(f), (f.mode & Ur) !== mr) {
                  var qa = hr !== null;
                  if (qa) {
                    var ct = f.child;
                    ct !== null && (f.treeBaseDuration -= ct.treeBaseDuration);
                  }
                }
                return null;
              } else {
                if (pc(), (f.flags & rr) === ge && (f.memoizedState = null), f.flags |= ft, Xs(f), (f.mode & Ur) !== mr) {
                  var Nt = hr !== null;
                  if (Nt) {
                    var ut = f.child;
                    ut !== null && (f.treeBaseDuration -= ut.treeBaseDuration);
                  }
                }
                return null;
              }
            }
            Oh();
          }
          if ((f.flags & rr) !== ge)
            return f.lanes = E, (f.mode & Ur) !== mr && my(f), f;
          var un = hr !== null, $n = !1;
          if (l === null)
            Lh(f);
          else {
            var Sn = l.memoizedState;
            $n = Sn !== null;
          }
          if (un && !$n) {
            var Dr = f.child;
            if (Dr.flags |= ea, (f.mode & Ii) !== mr) {
              var Bi = l === null && (f.memoizedProps.unstable_avoidThisFallback !== !0 || !I);
              Bi || U0(Iu.current, bx) ? Jb() : mS();
            }
          }
          var ga = f.updateQueue;
          if (ga !== null && (f.flags |= ft), Xs(f), (f.mode & Ur) !== mr && un) {
            var xn = f.child;
            xn !== null && (f.treeBaseDuration -= xn.treeBaseDuration);
          }
          return null;
        }
        case oe:
          return lf(f), j0(l, f), l === null && lr(f.stateNode.containerInfo), Xs(f), null;
        case Te:
          var da = f.type._context;
          return Q(da, f), Xs(f), null;
        case Oe: {
          var Hi = f.type;
          return Al(Hi) && Vc(f), Xs(f), null;
        }
        case je: {
          Wd(f);
          var qr = f.memoizedState;
          if (qr === null)
            return Xs(f), null;
          var ao = (f.flags & rr) !== ge, Ka = qr.rendering;
          if (Ka === null)
            if (ao)
              Qv(qr, !1);
            else {
              var bc = e1() && (l === null || (l.flags & rr) === ge);
              if (!bc)
                for (var bs = f.child; bs !== null; ) {
                  var Tc = zh(bs);
                  if (Tc !== null) {
                    ao = !0, f.flags |= rr, Qv(qr, !1);
                    var df = Tc.updateQueue;
                    return df !== null && (f.updateQueue = df, f.flags |= ft), f.subtreeFlags = ge, O0(f, E), kl(f, Hv(Iu.current, Bm)), f.child;
                  }
                  bs = bs.sibling;
                }
              qr.tail !== null && Xi() > Xb() && (f.flags |= rr, ao = !0, Qv(qr, !1), f.lanes = zf);
            }
          else {
            if (!ao) {
              var Kh = zh(Ka);
              if (Kh !== null) {
                f.flags |= rr, ao = !0;
                var $y = Kh.updateQueue;
                if ($y !== null && (f.updateQueue = $y, f.flags |= ft), Qv(qr, !0), qr.tail === null && qr.tailMode === "hidden" && !Ka.alternate && !ji())
                  return Xs(f), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Xi() * 2 - qr.renderingStartTime > Xb() && E !== xi && (f.flags |= rr, ao = !0, Qv(qr, !1), f.lanes = zf);
            }
            if (qr.isBackwards)
              Ka.sibling = f.child, f.child = Ka;
            else {
              var gg = qr.last;
              gg !== null ? gg.sibling = Ka : f.child = Ka, qr.last = Ka;
            }
          }
          if (qr.tail !== null) {
            var Mc = qr.tail;
            qr.rendering = Mc, qr.tail = Mc.sibling, qr.renderingStartTime = Xi(), Mc.sibling = null;
            var Vp = Iu.current;
            return ao ? Vp = Hv(Vp, Bm) : Vp = Ys(Vp), kl(f, Vp), Mc;
          }
          return Xs(f), null;
        }
        case Je:
          break;
        case at:
        case xt: {
          pS(f);
          var B_ = f.memoizedState, RS = B_ !== null;
          if (l !== null) {
            var Qh = l.memoizedState, M1 = Qh !== null;
            M1 !== RS && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !O && (f.flags |= ea);
          }
          return !RS || (f.mode & Ii) === mr ? Xs(f) : hi(_c, xi) && (Xs(f), ls && f.subtreeFlags & (Fe | ft) && (f.flags |= ea)), null;
        }
        case $t:
          return null;
        case Ht:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + f.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    var Op = s.ReactCurrentOwner, Bu = !1, gb, yy, yb, Sb, $x, Zv, xb, $0;
    gb = {}, yy = {}, yb = {}, Sb = {}, $x = {}, Zv = !1, xb = {}, $0 = {};
    function yl(l, f, E, w) {
      l === null ? f.child = L0(f, null, E, w) : f.child = mc(f, l.child, E, w);
    }
    function Yx(l, f, E, w) {
      f.child = mc(f, l.child, null, w), f.child = mc(f, null, E, w);
    }
    function Y0(l, f, E, w, L) {
      if (f.type !== f.elementType) {
        var B = E.propTypes;
        B && Rl(
          B,
          w,
          // Resolved props
          "prop",
          Se(E)
        );
      }
      var K = E.render, re = f.ref, fe, Ce;
      Qt(f, L), Ou(f);
      {
        if (Op.current = f, Pl(!0), fe = Ae(l, f, K, w, re, L), Ce = Ie(), f.mode & ma) {
          ui(!0);
          try {
            fe = Ae(l, f, K, w, re, L), Ce = Ie();
          } finally {
            ui(!1);
          }
        }
        Pl(!1);
      }
      return cu(), l !== null && !Bu ? (pt(l, f, L), Pp(l, f, L)) : (ji() && Ce && wh(f), f.flags |= zt, yl(l, f, fe, L), f.child);
    }
    function Sy(l, f, E, w, L) {
      if (l === null) {
        var B = E.type;
        if (By(B) && E.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        E.defaultProps === void 0) {
          var K = B;
          return K = ov(B), f.tag = ce, f.type = K, wb(f, B), xy(l, f, K, w, L);
        }
        {
          var re = B.propTypes;
          re && Rl(
            re,
            w,
            // Resolved props
            "prop",
            Se(B)
          );
        }
        var fe = Hy(E.type, null, w, f, f.mode, L);
        return fe.ref = f.ref, fe.return = f, f.child = fe, fe;
      }
      {
        var Ce = E.type, ke = Ce.propTypes;
        ke && Rl(
          ke,
          w,
          // Resolved props
          "prop",
          Se(Ce)
        );
      }
      var tt = l.child, Et = Ob(l, L);
      if (!Et) {
        var Dt = tt.memoizedProps, Xt = E.compare;
        if (Xt = Xt !== null ? Xt : zo, Xt(Dt, w) && l.ref === f.ref)
          return Pp(l, f, L);
      }
      f.flags |= zt;
      var an = Ri(tt, w);
      return an.ref = f.ref, an.return = f, f.child = an, an;
    }
    function xy(l, f, E, w, L) {
      if (f.type !== f.elementType) {
        var B = f.elementType;
        if (B.$$typeof === se) {
          var K = B, re = K._payload, fe = K._init;
          try {
            B = fe(re);
          } catch {
            B = null;
          }
          var Ce = B && B.propTypes;
          Ce && Rl(
            Ce,
            w,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Se(B)
          );
        }
      }
      if (l !== null) {
        var ke = l.memoizedProps;
        if (zo(ke, w) && l.ref === f.ref && // Prevent bailout if the implementation changed due to hot reload.
        f.type === l.type)
          if (Bu = !1, Ob(l, L))
            (l.flags & _n) !== ge && (Bu = !0);
          else
            return f.lanes = l.lanes, Pp(l, f, L);
      }
      return UM(l, f, E, w, L);
    }
    function PM(l, f, E) {
      var w = f.pendingProps, L = w.children, B = l !== null ? l.memoizedState : null;
      if (w.mode === "hidden" || O)
        if ((f.mode & Ii) === mr) {
          var K = {
            baseLanes: Gt,
            cachePool: null
          };
          f.memoizedState = K, Ly(f, E);
        } else if (hi(E, xi)) {
          var tt = {
            baseLanes: Gt,
            cachePool: null
          };
          f.memoizedState = tt;
          var Et = B !== null ? B.baseLanes : E;
          Ly(f, Et);
        } else {
          var re = null, fe;
          if (B !== null) {
            var Ce = B.baseLanes;
            fe = Sr(Ce, E);
          } else
            fe = E;
          f.lanes = f.childLanes = xi;
          var ke = {
            baseLanes: fe,
            cachePool: re
          };
          return f.memoizedState = ke, f.updateQueue = null, Ly(f, fe), null;
        }
      else {
        var Dt;
        B !== null ? (Dt = Sr(B.baseLanes, E), f.memoizedState = null) : Dt = E, Ly(f, Dt);
      }
      return yl(l, f, L, E), f.child;
    }
    function _b(l, f, E) {
      var w = f.pendingProps;
      return yl(l, f, w, E), f.child;
    }
    function Eb(l, f, E) {
      var w = f.pendingProps.children;
      return yl(l, f, w, E), f.child;
    }
    function hA(l, f, E) {
      {
        f.flags |= ft;
        {
          var w = f.stateNode;
          w.effectDuration = 0, w.passiveEffectDuration = 0;
        }
      }
      var L = f.pendingProps, B = L.children;
      return yl(l, f, B, E), f.child;
    }
    function NM(l, f) {
      var E = f.ref;
      (l === null && E !== null || l !== null && l.ref !== E) && (f.flags |= Ai, f.flags |= $e);
    }
    function UM(l, f, E, w, L) {
      if (f.type !== f.elementType) {
        var B = E.propTypes;
        B && Rl(
          B,
          w,
          // Resolved props
          "prop",
          Se(E)
        );
      }
      var K;
      {
        var re = ho(f, E, !0);
        K = rc(f, re);
      }
      var fe, Ce;
      Qt(f, L), Ou(f);
      {
        if (Op.current = f, Pl(!0), fe = Ae(l, f, E, w, K, L), Ce = Ie(), f.mode & ma) {
          ui(!0);
          try {
            fe = Ae(l, f, E, w, K, L), Ce = Ie();
          } finally {
            ui(!1);
          }
        }
        Pl(!1);
      }
      return cu(), l !== null && !Bu ? (pt(l, f, L), Pp(l, f, L)) : (ji() && Ce && wh(f), f.flags |= zt, yl(l, f, fe, L), f.child);
    }
    function zM(l, f, E, w, L) {
      {
        switch (x1(f)) {
          case !1: {
            var B = f.stateNode, K = f.type, re = new K(f.memoizedProps, B.context), fe = re.state;
            B.updater.enqueueSetState(B, fe, null);
            break;
          }
          case !0: {
            f.flags |= rr, f.flags |= en;
            var Ce = new Error("Simulated error coming from DevTools"), ke = Ff(L);
            f.lanes = Sr(f.lanes, ke);
            var tt = vy(f, V0(Ce, f), ke);
            Gr(f, tt);
            break;
          }
        }
        if (f.type !== f.elementType) {
          var Et = E.propTypes;
          Et && Rl(
            Et,
            w,
            // Resolved props
            "prop",
            Se(E)
          );
        }
      }
      var Dt;
      Al(E) ? (Dt = !0, na(f)) : Dt = !1, Qt(f, L);
      var Xt = f.stateNode, an;
      Xt === null ? (l !== null && (l.alternate = null, f.alternate = null, f.flags |= Fe), Um(f, E, w), Ep(f, E, w, L), an = !0) : l === null ? an = Dv(f, E, w, L) : an = R0(l, f, E, w, L);
      var or = bb(l, f, E, an, Dt, L);
      {
        var Wr = f.stateNode;
        an && Wr.props !== w && (Zv || y("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Tt(f) || "a component"), Zv = !0);
      }
      return or;
    }
    function bb(l, f, E, w, L, B) {
      NM(l, f);
      var K = (f.flags & rr) !== ge;
      if (!w && !K)
        return L && Md(f, E, !1), Pp(l, f, B);
      var re = f.stateNode;
      Op.current = f;
      var fe;
      if (K && typeof E.getDerivedStateFromError != "function")
        fe = null, Wm();
      else {
        Ou(f);
        {
          if (Pl(!0), fe = re.render(), f.mode & ma) {
            ui(!0);
            try {
              re.render();
            } finally {
              ui(!1);
            }
          }
          Pl(!1);
        }
        cu();
      }
      return f.flags |= zt, l !== null && K ? Yx(l, f, fe, B) : yl(l, f, fe, B), f.memoizedState = re.state, L && Md(f, E, !0), f.child;
    }
    function kM(l) {
      var f = l.stateNode;
      f.pendingContext ? au(l, f.pendingContext, f.pendingContext !== f.context) : f.context && au(l, f.context, !1), P0(l, f.containerInfo);
    }
    function pA(l, f, E) {
      if (kM(f), l === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var w = f.pendingProps, L = f.memoizedState, B = L.element;
      Ar(l, f), Th(f, w, null, E);
      var K = f.memoizedState;
      f.stateNode;
      var re = K.element;
      if (lo && L.isDehydrated) {
        var fe = {
          element: re,
          isDehydrated: !1,
          cache: K.cache,
          transitions: K.transitions
        }, Ce = f.updateQueue;
        if (Ce.baseState = fe, f.memoizedState = fe, f.flags & vr) {
          var ke = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
          return IM(l, f, re, E, ke);
        } else if (re !== B) {
          var tt = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
          return IM(l, f, re, E, tt);
        } else {
          Ko(f);
          var Et = L0(f, null, re, E);
          f.child = Et;
          for (var Dt = Et; Dt; )
            Dt.flags = Dt.flags & ~Fe | Ji, Dt = Dt.sibling;
        }
      } else {
        if (pc(), re === B)
          return Pp(l, f, E);
        yl(l, f, re, E);
      }
      return f.child;
    }
    function IM(l, f, E, w, L) {
      return pc(), So(L), f.flags |= vr, yl(l, f, E, w), f.child;
    }
    function mA(l, f, E) {
      no(f), l === null && sf(f);
      var w = f.type, L = f.pendingProps, B = l !== null ? l.memoizedProps : null, K = L.children, re = Mf(w, L);
      return re ? K = null : B !== null && Mf(w, B) && (f.flags |= yr), NM(l, f), yl(l, f, K, E), f.child;
    }
    function Tb(l, f) {
      return l === null && sf(f), null;
    }
    function vA(l, f, E, w) {
      l !== null && (l.alternate = null, f.alternate = null, f.flags |= Fe);
      var L = f.pendingProps, B = E, K = B._payload, re = B._init, fe = re(K);
      f.type = fe;
      var Ce = f.tag = pg(fe), ke = Xr(fe, L), tt;
      switch (Ce) {
        case Z:
          return wb(f, fe), f.type = fe = ov(fe), tt = UM(null, f, fe, ke, w), tt;
        case te:
          return f.type = fe = c1(fe), tt = zM(null, f, fe, ke, w), tt;
        case ue:
          return f.type = fe = $h(fe), tt = Y0(null, f, fe, ke, w), tt;
        case me: {
          if (f.type !== f.elementType) {
            var Et = fe.propTypes;
            Et && Rl(
              Et,
              ke,
              // Resolved for outer only
              "prop",
              Se(fe)
            );
          }
          return tt = Sy(
            null,
            f,
            fe,
            Xr(fe.type, ke),
            // The inner type can have defaults too
            w
          ), tt;
        }
      }
      var Dt = "";
      throw fe !== null && typeof fe == "object" && fe.$$typeof === se && (Dt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + fe + ". " + ("Lazy element type must resolve to a class or function." + Dt));
    }
    function gA(l, f, E, w, L) {
      l !== null && (l.alternate = null, f.alternate = null, f.flags |= Fe), f.tag = te;
      var B;
      return Al(E) ? (B = !0, na(f)) : B = !1, Qt(f, L), Um(f, E, w), Ep(f, E, w, L), bb(null, f, E, !0, B, L);
    }
    function Mb(l, f, E, w) {
      l !== null && (l.alternate = null, f.alternate = null, f.flags |= Fe);
      var L = f.pendingProps, B;
      {
        var K = ho(f, E, !1);
        B = rc(f, K);
      }
      Qt(f, w);
      var re, fe;
      Ou(f);
      {
        if (E.prototype && typeof E.prototype.render == "function") {
          var Ce = Se(E) || "Unknown";
          gb[Ce] || (y("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Ce, Ce), gb[Ce] = !0);
        }
        f.mode & ma && $s.recordLegacyContextWarning(f, null), Pl(!0), Op.current = f, re = Ae(null, f, E, L, B, w), fe = Ie(), Pl(!1);
      }
      if (cu(), f.flags |= zt, typeof re == "object" && re !== null && typeof re.render == "function" && re.$$typeof === void 0) {
        var ke = Se(E) || "Unknown";
        yy[ke] || (y("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ke, ke, ke), yy[ke] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof re == "object" && re !== null && typeof re.render == "function" && re.$$typeof === void 0
      ) {
        {
          var tt = Se(E) || "Unknown";
          yy[tt] || (y("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", tt, tt, tt), yy[tt] = !0);
        }
        f.tag = te, f.memoizedState = null, f.updateQueue = null;
        var Et = !1;
        return Al(E) ? (Et = !0, na(f)) : Et = !1, f.memoizedState = re.state !== null && re.state !== void 0 ? re.state : null, Dn(f), _p(f, re), Ep(f, E, L, w), bb(null, f, E, !0, Et, w);
      } else {
        if (f.tag = Z, f.mode & ma) {
          ui(!0);
          try {
            re = Ae(null, f, E, L, B, w), fe = Ie();
          } finally {
            ui(!1);
          }
        }
        return ji() && fe && wh(f), yl(null, f, re, w), wb(f, E), f.child;
      }
    }
    function wb(l, f) {
      {
        if (f && f.childContextTypes && y("%s(...): childContextTypes cannot be defined on a function component.", f.displayName || f.name || "Component"), l.ref !== null) {
          var E = "", w = Lm();
          w && (E += `

Check the render method of \`` + w + "`.");
          var L = w || "", B = l._debugSource;
          B && (L = B.fileName + ":" + B.lineNumber), $x[L] || ($x[L] = !0, y("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", E));
        }
        if (typeof f.getDerivedStateFromProps == "function") {
          var K = Se(f) || "Unknown";
          Sb[K] || (y("%s: Function components do not support getDerivedStateFromProps.", K), Sb[K] = !0);
        }
        if (typeof f.contextType == "object" && f.contextType !== null) {
          var re = Se(f) || "Unknown";
          yb[re] || (y("%s: Function components do not support contextType.", re), yb[re] = !0);
        }
      }
    }
    var _y = {
      dehydrated: null,
      treeContext: null,
      retryLane: Tr
    };
    function X0(l) {
      return {
        baseLanes: l,
        cachePool: dA()
      };
    }
    function FM(l, f) {
      var E = null;
      return {
        baseLanes: Sr(l.baseLanes, f),
        cachePool: E
      };
    }
    function yA(l, f, E, w) {
      if (f !== null) {
        var L = f.memoizedState;
        if (L === null)
          return !1;
      }
      return U0(l, Bm);
    }
    function BM(l, f) {
      return po(l.childLanes, f);
    }
    function HM(l, f, E) {
      var w = f.pendingProps;
      E1(f) && (f.flags |= rr);
      var L = Iu.current, B = !1, K = (f.flags & rr) !== ge;
      if (K || yA(L, l) ? (B = !0, f.flags &= ~rr) : (l === null || l.memoizedState !== null) && (L = ib(L, bx)), L = Ys(L), kl(f, L), l === null) {
        sf(f);
        {
          var re = f.memoizedState;
          if (re !== null) {
            var fe = re.dehydrated;
            if (fe !== null)
              return Rb(f, fe);
          }
        }
        var Ce = w.children, ke = w.fallback;
        if (B) {
          var tt = SA(f, Ce, ke, E), Et = f.child;
          return Et.memoizedState = X0(E), f.memoizedState = _y, tt;
        } else
          return Xx(f, Ce);
      } else {
        var Dt = l.memoizedState;
        if (Dt !== null) {
          {
            var Xt = Dt.dehydrated;
            if (Xt !== null)
              if (K) {
                if (f.flags & vr)
                  return f.flags &= ~vr, qx(l, f, E, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                if (f.memoizedState !== null)
                  return f.child = l.child, f.flags |= rr, null;
                var an = w.children, or = w.fallback, Wr = xA(l, f, an, or, E), hr = f.child;
                return hr.memoizedState = X0(E), f.memoizedState = _y, Wr;
              } else
                return _A(l, f, Xt, Dt, E);
          }
          if (B) {
            var Xa = w.fallback, qa = w.children, ct = WM(l, f, qa, Xa, E), Nt = f.child, ut = l.child.memoizedState;
            return Nt.memoizedState = ut === null ? X0(E) : FM(ut, E), Nt.childLanes = BM(l, E), f.memoizedState = _y, ct;
          } else {
            var un = w.children, $n = GM(l, f, un, E);
            return f.memoizedState = null, $n;
          }
        } else if (B) {
          var Sn = w.fallback, Dr = w.children, Bi = WM(l, f, Dr, Sn, E), ga = f.child, xn = l.child.memoizedState;
          return ga.memoizedState = xn === null ? X0(E) : FM(xn, E), ga.childLanes = BM(l, E), f.memoizedState = _y, Bi;
        } else {
          var da = w.children, Hi = GM(l, f, da, E);
          return f.memoizedState = null, Hi;
        }
      }
    }
    function Xx(l, f, E) {
      var w = l.mode, L = {
        mode: "visible",
        children: f
      }, B = Cb(L, w);
      return B.return = l, l.child = B, B;
    }
    function SA(l, f, E, w) {
      var L = l.mode, B = l.child, K = {
        mode: "hidden",
        children: f
      }, re, fe;
      return (L & Ii) === mr && B !== null ? (re = B, re.childLanes = Gt, re.pendingProps = K, l.mode & Ur && (re.actualDuration = 0, re.actualStartTime = -1, re.selfBaseDuration = 0, re.treeBaseDuration = 0), fe = rd(E, L, w, null)) : (re = Cb(K, L), fe = rd(E, L, w, null)), re.return = l, fe.return = l, re.sibling = fe, l.child = re, fe;
    }
    function Cb(l, f, E) {
      return ff(l, f, Gt, null);
    }
    function VM(l, f) {
      return Ri(l, f);
    }
    function GM(l, f, E, w) {
      var L = l.child, B = L.sibling, K = VM(L, {
        mode: "visible",
        children: E
      });
      if ((f.mode & Ii) === mr && (K.lanes = w), K.return = f, K.sibling = null, B !== null) {
        var re = f.deletions;
        re === null ? (f.deletions = [B], f.flags |= zn) : re.push(B);
      }
      return f.child = K, K;
    }
    function WM(l, f, E, w, L) {
      var B = f.mode, K = l.child, re = K.sibling, fe = {
        mode: "hidden",
        children: E
      }, Ce;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (B & Ii) === mr && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        f.child !== K
      ) {
        var ke = f.child;
        Ce = ke, Ce.childLanes = Gt, Ce.pendingProps = fe, f.mode & Ur && (Ce.actualDuration = 0, Ce.actualStartTime = -1, Ce.selfBaseDuration = K.selfBaseDuration, Ce.treeBaseDuration = K.treeBaseDuration), f.deletions = null;
      } else
        Ce = VM(K, fe), Ce.subtreeFlags = K.subtreeFlags & sn;
      var tt;
      return re !== null ? tt = Ri(re, w) : (tt = rd(w, B, L, null), tt.flags |= Fe), tt.return = f, Ce.return = f, Ce.sibling = tt, f.child = Ce, tt;
    }
    function qx(l, f, E, w) {
      w !== null && So(w), mc(f, l.child, null, E);
      var L = f.pendingProps, B = L.children, K = Xx(f, B);
      return K.flags |= Fe, f.memoizedState = null, K;
    }
    function xA(l, f, E, w, L) {
      var B = f.mode, K = {
        mode: "visible",
        children: E
      }, re = Cb(K, B), fe = rd(w, B, L, null);
      return fe.flags |= Fe, re.return = f, fe.return = f, re.sibling = fe, f.child = re, (f.mode & Ii) !== mr && mc(f, l.child, null, L), fe;
    }
    function Rb(l, f, E) {
      return (l.mode & Ii) === mr ? (y("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), l.lanes = wr) : li(f) ? l.lanes = ic : l.lanes = xi, null;
    }
    function _A(l, f, E, w, L) {
      if (ku(), (f.mode & Ii) === mr)
        return qx(
          l,
          f,
          L,
          // TODO: When we delete legacy mode, we should make this error argument
          // required  every concurrent mode path that causes hydration to
          // de-opt to client rendering should have an error message.
          null
        );
      if (li(E))
        return qx(
          l,
          f,
          L,
          // TODO: The server should serialize the error message so we can log it
          // here on the client. Or, in production, a hash/id that corresponds to
          // the error.
          new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")
        );
      var B = hi(L, l.childLanes);
      if (Bu || B) {
        var K = m_();
        if (K !== null) {
          var re = hs(K, L);
          if (re !== Tr && re !== w.retryLane) {
            w.retryLane = re;
            var fe = _i;
            Bo(l, re, fe);
          }
        }
        return mS(), qx(l, f, L, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
      } else if (Qr(E)) {
        f.flags |= rr, f.child = l.child;
        var Ce = ww.bind(null, l);
        return $r(E, Ce), null;
      } else {
        Pv(f, E, w.treeContext);
        var ke = f.pendingProps, tt = ke.children, Et = Xx(f, tt);
        return Et.flags |= Ji, Et;
      }
    }
    function jM(l, f, E) {
      l.lanes = Sr(l.lanes, f);
      var w = l.alternate;
      w !== null && (w.lanes = Sr(w.lanes, f)), Me(l.return, f, E);
    }
    function EA(l, f, E) {
      for (var w = f; w !== null; ) {
        if (w.tag === X) {
          var L = w.memoizedState;
          L !== null && jM(w, E, l);
        } else if (w.tag === je)
          jM(w, E, l);
        else if (w.child !== null) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === l)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === l)
            return;
          w = w.return;
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function bA(l) {
      for (var f = l, E = null; f !== null; ) {
        var w = f.alternate;
        w !== null && zh(w) === null && (E = f), f = f.sibling;
      }
      return E;
    }
    function TA(l) {
      if (l !== void 0 && l !== "forwards" && l !== "backwards" && l !== "together" && !xb[l])
        if (xb[l] = !0, typeof l == "string")
          switch (l.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              y('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', l, l.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              y('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', l, l.toLowerCase());
              break;
            }
            default:
              y('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', l);
              break;
          }
        else
          y('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', l);
    }
    function MA(l, f) {
      l !== void 0 && !$0[l] && (l !== "collapsed" && l !== "hidden" ? ($0[l] = !0, y('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', l)) : f !== "forwards" && f !== "backwards" && ($0[l] = !0, y('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', l)));
    }
    function $M(l, f) {
      {
        var E = ni(l), w = !E && typeof Xe(l) == "function";
        if (E || w) {
          var L = E ? "array" : "iterable";
          return y("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", L, f, L), !1;
        }
      }
      return !0;
    }
    function wA(l, f) {
      if ((f === "forwards" || f === "backwards") && l !== void 0 && l !== null && l !== !1)
        if (ni(l)) {
          for (var E = 0; E < l.length; E++)
            if (!$M(l[E], E))
              return;
        } else {
          var w = Xe(l);
          if (typeof w == "function") {
            var L = w.call(l);
            if (L)
              for (var B = L.next(), K = 0; !B.done; B = L.next()) {
                if (!$M(B.value, K))
                  return;
                K++;
              }
          } else
            y('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', f);
        }
    }
    function Ab(l, f, E, w, L) {
      var B = l.memoizedState;
      B === null ? l.memoizedState = {
        isBackwards: f,
        rendering: null,
        renderingStartTime: 0,
        last: w,
        tail: E,
        tailMode: L
      } : (B.isBackwards = f, B.rendering = null, B.renderingStartTime = 0, B.last = w, B.tail = E, B.tailMode = L);
    }
    function Db(l, f, E) {
      var w = f.pendingProps, L = w.revealOrder, B = w.tail, K = w.children;
      TA(L), MA(B, L), wA(K, L), yl(l, f, K, E);
      var re = Iu.current, fe = U0(re, Bm);
      if (fe)
        re = Hv(re, Bm), f.flags |= rr;
      else {
        var Ce = l !== null && (l.flags & rr) !== ge;
        Ce && EA(f, f.child, E), re = Ys(re);
      }
      if (kl(f, re), (f.mode & Ii) === mr)
        f.memoizedState = null;
      else
        switch (L) {
          case "forwards": {
            var ke = bA(f.child), tt;
            ke === null ? (tt = f.child, f.child = null) : (tt = ke.sibling, ke.sibling = null), Ab(
              f,
              !1,
              // isBackwards
              tt,
              ke,
              B
            );
            break;
          }
          case "backwards": {
            var Et = null, Dt = f.child;
            for (f.child = null; Dt !== null; ) {
              var Xt = Dt.alternate;
              if (Xt !== null && zh(Xt) === null) {
                f.child = Dt;
                break;
              }
              var an = Dt.sibling;
              Dt.sibling = Et, Et = Dt, Dt = an;
            }
            Ab(
              f,
              !0,
              // isBackwards
              Et,
              null,
              // last
              B
            );
            break;
          }
          case "together": {
            Ab(
              f,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            f.memoizedState = null;
        }
      return f.child;
    }
    function Lb(l, f, E) {
      P0(f, f.stateNode.containerInfo);
      var w = f.pendingProps;
      return l === null ? f.child = mc(f, null, w, E) : yl(l, f, w, E), f.child;
    }
    var YM = !1;
    function CA(l, f, E) {
      var w = f.type, L = w._context, B = f.pendingProps, K = f.memoizedProps, re = B.value;
      {
        "value" in B || YM || (YM = !0, y("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var fe = f.type.propTypes;
        fe && Rl(fe, B, "prop", "Context.Provider");
      }
      if (V(f, L, re), K !== null) {
        var Ce = K.value;
        if (Co(Ce, re)) {
          if (K.children === B.children && !eo())
            return Pp(l, f, E);
        } else
          We(f, L, E);
      }
      var ke = B.children;
      return yl(l, f, ke, E), f.child;
    }
    var q0 = !1;
    function K0(l, f, E) {
      var w = f.type;
      w._context === void 0 ? w !== w.Consumer && (q0 || (q0 = !0, y("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : w = w._context;
      var L = f.pendingProps, B = L.children;
      typeof B != "function" && y("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Qt(f, E);
      var K = cn(w);
      Ou(f);
      var re;
      return Op.current = f, Pl(!0), re = B(K), Pl(!1), cu(), f.flags |= zt, yl(l, f, re, E), f.child;
    }
    function Kx() {
      Bu = !0;
    }
    function Pp(l, f, E) {
      return l !== null && (f.dependencies = l.dependencies), Wm(), Oy(f.lanes), hi(E, f.childLanes) ? (ry(l, f), f.child) : null;
    }
    function RA(l, f, E) {
      {
        var w = f.return;
        if (w === null)
          throw new Error("Cannot swap the root fiber.");
        if (l.alternate = null, f.alternate = null, E.index = f.index, E.sibling = f.sibling, E.return = f.return, E.ref = f.ref, f === w.child)
          w.child = E;
        else {
          var L = w.child;
          if (L === null)
            throw new Error("Expected parent to have a child.");
          for (; L.sibling !== f; )
            if (L = L.sibling, L === null)
              throw new Error("Expected to find the previous sibling.");
          L.sibling = E;
        }
        var B = w.deletions;
        return B === null ? (w.deletions = [l], w.flags |= zn) : B.push(l), E.flags |= Fe, E;
      }
    }
    function Ob(l, f) {
      var E = l.lanes;
      return !!hi(E, f);
    }
    function AA(l, f, E) {
      switch (f.tag) {
        case q:
          kM(f), f.stateNode, pc();
          break;
        case ye:
          no(f);
          break;
        case te: {
          var w = f.type;
          Al(w) && na(f);
          break;
        }
        case oe:
          P0(f, f.stateNode.containerInfo);
          break;
        case Te: {
          var L = f.memoizedProps.value, B = f.type._context;
          V(f, B, L);
          break;
        }
        case we:
          {
            var K = hi(E, f.childLanes);
            K && (f.flags |= ft);
            {
              var re = f.stateNode;
              re.effectDuration = 0, re.passiveEffectDuration = 0;
            }
          }
          break;
        case X: {
          var fe = f.memoizedState;
          if (fe !== null) {
            if (fe.dehydrated !== null)
              return kl(f, Ys(Iu.current)), f.flags |= rr, null;
            var Ce = f.child, ke = Ce.childLanes;
            if (hi(E, ke))
              return HM(l, f, E);
            kl(f, Ys(Iu.current));
            var tt = Pp(l, f, E);
            return tt !== null ? tt.sibling : null;
          } else
            kl(f, Ys(Iu.current));
          break;
        }
        case je: {
          var Et = (l.flags & rr) !== ge, Dt = hi(E, f.childLanes);
          if (Et) {
            if (Dt)
              return Db(l, f, E);
            f.flags |= rr;
          }
          var Xt = f.memoizedState;
          if (Xt !== null && (Xt.rendering = null, Xt.tail = null, Xt.lastEffect = null), kl(f, Iu.current), Dt)
            break;
          return null;
        }
        case at:
        case xt:
          return f.lanes = Gt, PM(l, f, E);
      }
      return Pp(l, f, E);
    }
    function XM(l, f, E) {
      if (f._debugNeedsRemount && l !== null)
        return RA(l, f, Hy(f.type, f.key, f.pendingProps, f._debugOwner || null, f.mode, f.lanes));
      if (l !== null) {
        var w = l.memoizedProps, L = f.pendingProps;
        if (w !== L || eo() || // Force a re-render if the implementation changed due to hot reload:
        f.type !== l.type)
          Bu = !0;
        else {
          var B = Ob(l, E);
          if (!B && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (f.flags & rr) === ge)
            return Bu = !1, AA(l, f, E);
          (l.flags & _n) !== ge ? Bu = !0 : Bu = !1;
        }
      } else if (Bu = !1, ji() && Id(f)) {
        var K = f.index, re = of();
        A0(f, re, K);
      }
      switch (f.lanes = Gt, f.tag) {
        case J:
          return Mb(l, f, f.type, E);
        case Ue: {
          var fe = f.elementType;
          return vA(l, f, fe, E);
        }
        case Z: {
          var Ce = f.type, ke = f.pendingProps, tt = f.elementType === Ce ? ke : Xr(Ce, ke);
          return UM(l, f, Ce, tt, E);
        }
        case te: {
          var Et = f.type, Dt = f.pendingProps, Xt = f.elementType === Et ? Dt : Xr(Et, Dt);
          return zM(l, f, Et, Xt, E);
        }
        case q:
          return pA(l, f, E);
        case ye:
          return mA(l, f, E);
        case de:
          return Tb(l, f);
        case X:
          return HM(l, f, E);
        case oe:
          return Lb(l, f, E);
        case ue: {
          var an = f.type, or = f.pendingProps, Wr = f.elementType === an ? or : Xr(an, or);
          return Y0(l, f, an, Wr, E);
        }
        case xe:
          return _b(l, f, E);
        case Re:
          return Eb(l, f, E);
        case we:
          return hA(l, f, E);
        case Te:
          return CA(l, f, E);
        case Pe:
          return K0(l, f, E);
        case me: {
          var hr = f.type, Xa = f.pendingProps, qa = Xr(hr, Xa);
          if (f.type !== f.elementType) {
            var ct = hr.propTypes;
            ct && Rl(
              ct,
              qa,
              // Resolved for outer only
              "prop",
              Se(hr)
            );
          }
          return qa = Xr(hr.type, qa), Sy(l, f, hr, qa, E);
        }
        case ce:
          return xy(l, f, f.type, f.pendingProps, E);
        case Oe: {
          var Nt = f.type, ut = f.pendingProps, un = f.elementType === Nt ? ut : Xr(Nt, ut);
          return gA(l, f, Nt, un, E);
        }
        case je:
          return Db(l, f, E);
        case Je:
          break;
        case at:
          return PM(l, f, E);
      }
      throw new Error("Unknown unit of work tag (" + f.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function DA(l, f, E) {
      switch (Zg(f), f.tag) {
        case te: {
          var w = f.type;
          Al(w) && Vc(f);
          var L = f.flags;
          return L & en ? (f.flags = L & ~en | rr, (f.mode & Ur) !== mr && my(f), f) : null;
        }
        case q: {
          lf(f), Mu(f), ay();
          var B = f.flags;
          return (B & en) !== ge && (B & rr) === ge ? (f.flags = B & ~en | rr, f) : null;
        }
        case ye:
          return N0(f), null;
        case X: {
          Wd(f);
          {
            var K = f.memoizedState;
            if (K !== null && K.dehydrated !== null) {
              if (f.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              pc();
            }
          }
          var re = f.flags;
          return re & en ? (f.flags = re & ~en | rr, (f.mode & Ur) !== mr && my(f), f) : null;
        }
        case je:
          return Wd(f), null;
        case oe:
          return lf(f), null;
        case Te:
          var fe = f.type._context;
          return Q(fe, f), null;
        case at:
        case xt:
          return pS(f), null;
        case $t:
          return null;
        default:
          return null;
      }
    }
    function Pb(l, f, E) {
      switch (Zg(f), f.tag) {
        case te: {
          var w = f.type.childContextTypes;
          w != null && Vc(f);
          break;
        }
        case q: {
          lf(f), Mu(f), ay();
          break;
        }
        case ye: {
          N0(f);
          break;
        }
        case oe:
          lf(f);
          break;
        case X:
          Wd(f);
          break;
        case je:
          Wd(f);
          break;
        case Te:
          var L = f.type._context;
          Q(L, f);
          break;
        case at:
        case xt:
          pS(f);
          break;
      }
    }
    function qM(l, f, E, w, L, B, K, re, fe) {
      var Ce = Array.prototype.slice.call(arguments, 3);
      try {
        f.apply(E, Ce);
      } catch (ke) {
        this.onError(ke);
      }
    }
    var KM = qM;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Nb = document.createElement("react");
      KM = function(f, E, w, L, B, K, re, fe, Ce) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var ke = document.createEvent("Event"), tt = !1, Et = !0, Dt = window.event, Xt = Object.getOwnPropertyDescriptor(window, "event");
        function an() {
          Nb.removeEventListener(Nt, Wr, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Dt);
        }
        var or = Array.prototype.slice.call(arguments, 3);
        function Wr() {
          tt = !0, an(), E.apply(w, or), Et = !1;
        }
        var hr, Xa = !1, qa = !1;
        function ct(ut) {
          if (hr = ut.error, Xa = !0, hr === null && ut.colno === 0 && ut.lineno === 0 && (qa = !0), ut.defaultPrevented && hr != null && typeof hr == "object")
            try {
              hr._suppressLogging = !0;
            } catch {
            }
        }
        var Nt = "react-" + (f || "invokeguardedcallback");
        if (window.addEventListener("error", ct), Nb.addEventListener(Nt, Wr, !1), ke.initEvent(Nt, !1, !1), Nb.dispatchEvent(ke), Xt && Object.defineProperty(window, "event", Xt), tt && Et && (Xa ? qa && (hr = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : hr = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(hr)), window.removeEventListener("error", ct), !tt)
          return an(), qM.apply(this, arguments);
      };
    }
    var LA = KM, Q0 = !1, Qx = null, OA = {
      onError: function(l) {
        Q0 = !0, Qx = l;
      }
    };
    function QM(l, f, E, w, L, B, K, re, fe) {
      Q0 = !1, Qx = null, LA.apply(OA, arguments);
    }
    function PA() {
      return Q0;
    }
    function ZM() {
      if (Q0) {
        var l = Qx;
        return Q0 = !1, Qx = null, l;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    var JM = null;
    JM = /* @__PURE__ */ new Set();
    var Zx = !1, jm = !1, NA = typeof WeakSet == "function" ? WeakSet : Set, Tn = null, Ey = null, jd = null;
    function Io(l) {
      QM(null, function() {
        throw l;
      }), ZM();
    }
    var Ub = function(l, f) {
      if (f.props = l.memoizedProps, f.state = l.memoizedState, l.mode & Ur)
        try {
          gu(), f.componentWillUnmount();
        } finally {
          Sc(l);
        }
      else
        f.componentWillUnmount();
    };
    function by(l, f) {
      try {
        Zf(Wa, l);
      } catch (E) {
        Io(E), Jo(l, f, E);
      }
    }
    function Z0(l, f, E) {
      try {
        Ub(l, E);
      } catch (w) {
        Io(w), Jo(l, f, w);
      }
    }
    function UA(l, f, E) {
      try {
        E.componentDidMount();
      } catch (w) {
        Io(w), Jo(l, f, w);
      }
    }
    function ew(l, f) {
      try {
        tS(l);
      } catch (E) {
        Io(E), Jo(l, f, E);
      }
    }
    function Jx(l, f) {
      var E = l.ref;
      if (E !== null)
        if (typeof E == "function") {
          var w;
          try {
            if (j && Y && l.mode & Ur)
              try {
                gu(), w = E(null);
              } finally {
                Sc(l);
              }
            else
              w = E(null);
          } catch (L) {
            Io(L), Jo(l, f, L);
          }
          typeof w == "function" && y("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Tt(l));
        } else
          E.current = null;
    }
    function $m(l, f, E) {
      try {
        E();
      } catch (w) {
        Io(w), Jo(l, f, w);
      }
    }
    var J0 = !1;
    function tw(l, f) {
      Po(l.containerInfo), Tn = f, eS();
      var E = J0;
      return J0 = !1, E;
    }
    function eS() {
      for (; Tn !== null; ) {
        var l = Tn, f = l.child;
        (l.subtreeFlags & pn) !== ge && f !== null ? (td(f, l), Tn = f) : Jv();
      }
    }
    function Jv() {
      for (; Tn !== null; ) {
        var l = Tn;
        pi(l);
        try {
          Ym(l);
        } catch (E) {
          Io(E), Jo(l, l.return, E);
        }
        go();
        var f = l.sibling;
        if (f !== null) {
          td(f, l.return), Tn = f;
          return;
        }
        Tn = l.return;
      }
    }
    function Ym(l) {
      var f = l.alternate, E = l.flags;
      if ((E & oi) !== ge) {
        switch (pi(l), l.tag) {
          case Z:
          case ue:
          case ce:
            break;
          case te: {
            if (f !== null) {
              var w = f.memoizedProps, L = f.memoizedState, B = l.stateNode;
              l.type === l.elementType && !Zv && (B.props !== l.memoizedProps && y("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Tt(l) || "instance"), B.state !== l.memoizedState && y("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Tt(l) || "instance"));
              var K = B.getSnapshotBeforeUpdate(l.elementType === l.type ? w : Xr(l.type, w), L);
              {
                var re = JM;
                K === void 0 && !re.has(l.type) && (re.add(l.type), y("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Tt(l)));
              }
              B.__reactInternalSnapshotBeforeUpdate = K;
            }
            break;
          }
          case q: {
            if (ls) {
              var fe = l.stateNode;
              ne(fe.containerInfo);
            }
            break;
          }
          case ye:
          case de:
          case oe:
          case Oe:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        go();
      }
    }
    function qs(l, f, E) {
      var w = f.updateQueue, L = w !== null ? w.lastEffect : null;
      if (L !== null) {
        var B = L.next, K = B;
        do {
          if ((K.tag & l) === l) {
            var re = K.destroy;
            K.destroy = void 0, re !== void 0 && ((l & _s) !== vu ? Gs(f) : (l & Wa) !== vu && qc(f), $m(f, E, re), (l & _s) !== vu ? Dm() : (l & Wa) !== vu && cl());
          }
          K = K.next;
        } while (K !== B);
      }
    }
    function Zf(l, f) {
      var E = f.updateQueue, w = E !== null ? E.lastEffect : null;
      if (w !== null) {
        var L = w.next, B = L;
        do {
          if ((B.tag & l) === l) {
            (l & _s) !== vu ? Hf(f) : (l & Wa) !== vu && Gf(f);
            var K = B.create;
            B.destroy = K(), (l & _s) !== vu ? Vf() : (l & Wa) !== vu && Nd();
            {
              var re = B.destroy;
              if (re !== void 0 && typeof re != "function") {
                var fe = void 0;
                (B.tag & Wa) !== ge ? fe = "useLayoutEffect" : (B.tag & kh) !== ge ? fe = "useInsertionEffect" : fe = "useEffect";
                var Ce = void 0;
                re === null ? Ce = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof re.then == "function" ? Ce = `

It looks like you wrote ` + fe + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + fe + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : Ce = " You returned: " + re, y("%s must not return anything besides a function, which is used for clean-up.%s", fe, Ce);
              }
            }
          }
          B = B.next;
        } while (B !== L);
      }
    }
    function zb(l, f) {
      if ((f.flags & ft) !== ge)
        switch (f.tag) {
          case we: {
            var E = f.stateNode.passiveEffectDuration, w = f.memoizedProps, L = w.id, B = w.onPostCommit, K = Dp(), re = f.alternate === null ? "mount" : "update";
            wM() && (re = "nested-update"), typeof B == "function" && B(L, re, E, K);
            var fe = f.return;
            e:
              for (; fe !== null; ) {
                switch (fe.tag) {
                  case q:
                    var Ce = fe.stateNode;
                    Ce.passiveEffectDuration += E;
                    break e;
                  case we:
                    var ke = fe.stateNode;
                    ke.passiveEffectDuration += E;
                    break e;
                }
                fe = fe.return;
              }
            break;
          }
        }
    }
    function zA(l, f, E, w) {
      if ((E.flags & Gn) !== ge)
        switch (E.tag) {
          case Z:
          case ue:
          case ce: {
            if (!jm)
              if (E.mode & Ur)
                try {
                  gu(), Zf(Wa | oa, E);
                } finally {
                  Sc(E);
                }
              else
                Zf(Wa | oa, E);
            break;
          }
          case te: {
            var L = E.stateNode;
            if (E.flags & ft && !jm)
              if (f === null)
                if (E.type === E.elementType && !Zv && (L.props !== E.memoizedProps && y("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Tt(E) || "instance"), L.state !== E.memoizedState && y("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Tt(E) || "instance")), E.mode & Ur)
                  try {
                    gu(), L.componentDidMount();
                  } finally {
                    Sc(E);
                  }
                else
                  L.componentDidMount();
              else {
                var B = E.elementType === E.type ? f.memoizedProps : Xr(E.type, f.memoizedProps), K = f.memoizedState;
                if (E.type === E.elementType && !Zv && (L.props !== E.memoizedProps && y("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Tt(E) || "instance"), L.state !== E.memoizedState && y("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Tt(E) || "instance")), E.mode & Ur)
                  try {
                    gu(), L.componentDidUpdate(B, K, L.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Sc(E);
                  }
                else
                  L.componentDidUpdate(B, K, L.__reactInternalSnapshotBeforeUpdate);
              }
            var re = E.updateQueue;
            re !== null && (E.type === E.elementType && !Zv && (L.props !== E.memoizedProps && y("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Tt(E) || "instance"), L.state !== E.memoizedState && y("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Tt(E) || "instance")), qg(E, re, L));
            break;
          }
          case q: {
            var fe = E.updateQueue;
            if (fe !== null) {
              var Ce = null;
              if (E.child !== null)
                switch (E.child.tag) {
                  case ye:
                    Ce = ss(E.child.stateNode);
                    break;
                  case te:
                    Ce = E.child.stateNode;
                    break;
                }
              qg(E, fe, Ce);
            }
            break;
          }
          case ye: {
            var ke = E.stateNode;
            if (f === null && E.flags & ft) {
              var tt = E.type, Et = E.memoizedProps;
              Jl(ke, tt, Et, E);
            }
            break;
          }
          case de:
            break;
          case oe:
            break;
          case we: {
            {
              var Dt = E.memoizedProps, Xt = Dt.onCommit, an = Dt.onRender, or = E.stateNode.effectDuration, Wr = Dp(), hr = f === null ? "mount" : "update";
              wM() && (hr = "nested-update"), typeof an == "function" && an(E.memoizedProps.id, hr, E.actualDuration, E.treeBaseDuration, E.actualStartTime, Wr);
              {
                typeof Xt == "function" && Xt(E.memoizedProps.id, hr, or, Wr), WA(E);
                var Xa = E.return;
                e:
                  for (; Xa !== null; ) {
                    switch (Xa.tag) {
                      case q:
                        var qa = Xa.stateNode;
                        qa.effectDuration += or;
                        break e;
                      case we:
                        var ct = Xa.stateNode;
                        ct.effectDuration += or;
                        break e;
                    }
                    Xa = Xa.return;
                  }
              }
            }
            break;
          }
          case X: {
            t_(l, E);
            break;
          }
          case je:
          case Oe:
          case Je:
          case at:
          case xt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      jm || E.flags & Ai && tS(E);
    }
    function nw(l) {
      switch (l.tag) {
        case Z:
        case ue:
        case ce: {
          if (l.mode & Ur)
            try {
              gu(), by(l, l.return);
            } finally {
              Sc(l);
            }
          else
            by(l, l.return);
          break;
        }
        case te: {
          var f = l.stateNode;
          typeof f.componentDidMount == "function" && UA(l, l.return, f), ew(l, l.return);
          break;
        }
        case ye: {
          ew(l, l.return);
          break;
        }
      }
    }
    function rw(l, f) {
      var E = null;
      if (ls)
        for (var w = l; ; ) {
          if (w.tag === ye) {
            if (E === null) {
              E = w;
              var L = w.stateNode;
              f ? md(L) : op(w.stateNode, w.memoizedProps);
            }
          } else if (w.tag === de) {
            if (E === null) {
              var B = w.stateNode;
              f ? Os(B) : nl(B, w.memoizedProps);
            }
          } else if (!((w.tag === at || w.tag === xt) && w.memoizedState !== null && w !== l)) {
            if (w.child !== null) {
              w.child.return = w, w = w.child;
              continue;
            }
          }
          if (w === l)
            return;
          for (; w.sibling === null; ) {
            if (w.return === null || w.return === l)
              return;
            E === w && (E = null), w = w.return;
          }
          E === w && (E = null), w.sibling.return = w.return, w = w.sibling;
        }
    }
    function tS(l) {
      var f = l.ref;
      if (f !== null) {
        var E = l.stateNode, w;
        switch (l.tag) {
          case ye:
            w = ss(E);
            break;
          default:
            w = E;
        }
        if (typeof f == "function") {
          var L;
          if (l.mode & Ur)
            try {
              gu(), L = f(w);
            } finally {
              Sc(l);
            }
          else
            L = f(w);
          typeof L == "function" && y("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Tt(l));
        } else
          f.hasOwnProperty("current") || y("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Tt(l)), f.current = w;
      }
    }
    function $d(l) {
      var f = l.ref;
      if (f !== null)
        if (typeof f == "function")
          if (l.mode & Ur)
            try {
              gu(), f(null);
            } finally {
              Sc(l);
            }
          else
            f(null);
        else
          f.current = null;
    }
    function e_(l, f, E) {
      switch (ca(f), f.tag) {
        case Z:
        case ue:
        case me:
        case ce: {
          var w = f.updateQueue;
          if (w !== null) {
            var L = w.lastEffect;
            if (L !== null) {
              var B = L.next, K = B;
              do {
                var re = K, fe = re.destroy, Ce = re.tag;
                fe !== void 0 && ((Ce & kh) !== vu ? $m(f, E, fe) : (Ce & Wa) !== vu && (qc(f), f.mode & Ur ? (gu(), $m(f, E, fe), Sc(f)) : $m(f, E, fe), cl())), K = K.next;
              } while (K !== B);
            }
          }
          return;
        }
        case te: {
          Jx(f, E);
          var ke = f.stateNode;
          typeof ke.componentWillUnmount == "function" && Z0(f, E, ke);
          return;
        }
        case ye: {
          Jx(f, E);
          return;
        }
        case oe: {
          ls ? Ib(l, f, E) : jr && yu(f);
          return;
        }
        case Ze:
          return;
        case Je:
          return;
      }
    }
    function nS(l, f, E) {
      for (var w = f; ; ) {
        if (e_(l, w, E), w.child !== null && // If we use mutation we drill down into portals using commitUnmount above.
        // If we don't use mutation we drill down into portals here instead.
        (!ls || w.tag !== oe)) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === f)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === f)
            return;
          w = w.return;
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function Np(l) {
      var f = l.alternate;
      f !== null && (f.return = null), l.return = null;
    }
    function Up(l) {
      var f = l.alternate;
      f !== null && (l.alternate = null, Up(f));
      {
        if (l.child = null, l.deletions = null, l.sibling = null, l.tag === ye) {
          var E = l.stateNode;
          E !== null && pa(E);
        }
        l.stateNode = null, l._debugOwner = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
      }
    }
    function yu(l) {
      if (jr) {
        var f = l.stateNode, E = f.containerInfo, w = st(E);
        Xn(E, w);
      }
    }
    function Su(l) {
      if (jr) {
        switch (l.tag) {
          case te:
          case ye:
          case de:
            return;
          case q:
          case oe: {
            var f = l.stateNode, E = f.containerInfo, w = f.pendingChildren;
            Xn(E, w);
            return;
          }
        }
        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function kb(l) {
      for (var f = l.return; f !== null; ) {
        if (xc(f))
          return f;
        f = f.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function xc(l) {
      return l.tag === ye || l.tag === q || l.tag === oe;
    }
    function Hh(l) {
      var f = l;
      e:
        for (; ; ) {
          for (; f.sibling === null; ) {
            if (f.return === null || xc(f.return))
              return null;
            f = f.return;
          }
          for (f.sibling.return = f.return, f = f.sibling; f.tag !== ye && f.tag !== de && f.tag !== Ze; ) {
            if (f.flags & Fe || f.child === null || f.tag === oe)
              continue e;
            f.child.return = f, f = f.child;
          }
          if (!(f.flags & Fe))
            return f.stateNode;
        }
    }
    function Yd(l) {
      if (ls) {
        var f = kb(l);
        switch (f.tag) {
          case ye: {
            var E = f.stateNode;
            f.flags & yr && (tc(E), f.flags &= ~yr);
            var w = Hh(l);
            Xm(l, w, E);
            break;
          }
          case q:
          case oe: {
            var L = f.stateNode.containerInfo, B = Hh(l);
            rS(l, B, L);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function rS(l, f, E) {
      var w = l.tag, L = w === ye || w === de;
      if (L) {
        var B = l.stateNode;
        f ? co(E, B, f) : Eu(E, B);
      } else if (w !== oe) {
        var K = l.child;
        if (K !== null) {
          rS(K, f, E);
          for (var re = K.sibling; re !== null; )
            rS(re, f, E), re = re.sibling;
        }
      }
    }
    function Xm(l, f, E) {
      var w = l.tag, L = w === ye || w === de;
      if (L) {
        var B = l.stateNode;
        f ? Wo(E, B, f) : Nc(E, B);
      } else if (w !== oe) {
        var K = l.child;
        if (K !== null) {
          Xm(K, f, E);
          for (var re = K.sibling; re !== null; )
            Xm(re, f, E), re = re.sibling;
        }
      }
    }
    function Ib(l, f, E) {
      for (var w = f, L = !1, B, K; ; ) {
        if (!L) {
          var re = w.return;
          e:
            for (; ; ) {
              if (re === null)
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              var fe = re.stateNode;
              switch (re.tag) {
                case ye:
                  B = fe, K = !1;
                  break e;
                case q:
                  B = fe.containerInfo, K = !0;
                  break e;
                case oe:
                  B = fe.containerInfo, K = !0;
                  break e;
              }
              re = re.return;
            }
          L = !0;
        }
        if (w.tag === ye || w.tag === de)
          nS(l, w, E), K ? ec(B, w.stateNode) : Uc(B, w.stateNode);
        else if (w.tag === Ze)
          K ? gm(B, w.stateNode) : vm(B, w.stateNode);
        else if (w.tag === oe) {
          if (w.child !== null) {
            B = w.stateNode.containerInfo, K = !0, w.child.return = w, w = w.child;
            continue;
          }
        } else if (e_(l, w, E), w.child !== null) {
          w.child.return = w, w = w.child;
          continue;
        }
        if (w === f)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === f)
            return;
          w = w.return, w.tag === oe && (L = !1);
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }
    function Ty(l, f, E) {
      ls ? Ib(l, f, E) : nS(l, f, E), Np(f);
    }
    function My(l, f) {
      if (!ls) {
        switch (f.tag) {
          case Z:
          case ue:
          case me:
          case ce: {
            if (qs(kh | oa, f, f.return), Zf(kh | oa, f), f.mode & Ur)
              try {
                gu(), qs(Wa | oa, f, f.return);
              } finally {
                Sc(f);
              }
            else
              qs(Wa | oa, f, f.return);
            return;
          }
          case we:
            return;
          case X: {
            Xd(f), wy(f);
            return;
          }
          case je: {
            wy(f);
            return;
          }
          case q: {
            if (lo && l !== null) {
              var E = l.memoizedState;
              if (E.isDehydrated) {
                var w = f.stateNode;
                pm(w.containerInfo);
              }
            }
            break;
          }
          case at:
          case xt:
            return;
        }
        Su(f);
        return;
      }
      switch (f.tag) {
        case Z:
        case ue:
        case me:
        case ce: {
          if (qs(kh | oa, f, f.return), Zf(kh | oa, f), f.mode & Ur)
            try {
              gu(), qs(Wa | oa, f, f.return);
            } finally {
              Sc(f);
            }
          else
            qs(Wa | oa, f, f.return);
          return;
        }
        case te:
          return;
        case ye: {
          var L = f.stateNode;
          if (L != null) {
            var B = f.memoizedProps, K = l !== null ? l.memoizedProps : B, re = f.type, fe = f.updateQueue;
            f.updateQueue = null, fe !== null && Cf(L, fe, re, K, B, f);
          }
          return;
        }
        case de: {
          if (f.stateNode === null)
            throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var Ce = f.stateNode, ke = f.memoizedProps, tt = l !== null ? l.memoizedProps : ke;
          wl(Ce, tt, ke);
          return;
        }
        case q: {
          if (lo && l !== null) {
            var Et = l.memoizedState;
            if (Et.isDehydrated) {
              var Dt = f.stateNode;
              pm(Dt.containerInfo);
            }
          }
          return;
        }
        case we:
          return;
        case X: {
          Xd(f), wy(f);
          return;
        }
        case je: {
          wy(f);
          return;
        }
        case Oe:
          return;
      }
      throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Xd(l) {
      l.memoizedState;
    }
    function t_(l, f) {
      if (lo) {
        var E = f.memoizedState;
        if (E === null) {
          var w = f.alternate;
          if (w !== null) {
            var L = w.memoizedState;
            if (L !== null) {
              var B = L.dehydrated;
              B !== null && mm(B);
            }
          }
        }
      }
    }
    function wy(l) {
      var f = l.updateQueue;
      if (f !== null) {
        l.updateQueue = null;
        var E = l.stateNode;
        E === null && (E = l.stateNode = new NA()), f.forEach(function(w) {
          var L = Cw.bind(null, l, w);
          if (!E.has(w)) {
            if (E.add(w), Ha)
              if (Ey !== null && jd !== null)
                dg(jd, Ey);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            w.then(L, L);
          }
        });
      }
    }
    function iw(l) {
      ls && tc(l.stateNode);
    }
    function aw(l, f, E) {
      Ey = E, jd = l, Tn = f, n_(l, E), Ey = null, jd = null;
    }
    function n_(l, f) {
      for (; Tn !== null; ) {
        var E = Tn, w = E.deletions;
        if (w !== null)
          for (var L = 0; L < w.length; L++) {
            var B = w[L];
            try {
              Ty(l, B, E);
            } catch (re) {
              Io(re), Jo(B, E, re);
            }
          }
        var K = E.child;
        (E.subtreeFlags & An) !== ge && K !== null ? (td(K, E), Tn = K) : ow(l, f);
      }
    }
    function ow(l, f) {
      for (; Tn !== null; ) {
        var E = Tn;
        pi(E);
        try {
          kA(E, l, f);
        } catch (L) {
          Io(L), Jo(E, E.return, L);
        }
        go();
        var w = E.sibling;
        if (w !== null) {
          td(w, E.return), Tn = w;
          return;
        }
        Tn = E.return;
      }
    }
    function kA(l, f, E) {
      var w = l.flags;
      if (w & yr && iw(l), w & Ai) {
        var L = l.alternate;
        L !== null && $d(L);
      }
      if (w & ea)
        switch (l.tag) {
          case X: {
            var B = l.memoizedState, K = B !== null;
            if (K) {
              var re = l.alternate, fe = re !== null && re.memoizedState !== null;
              fe || T_();
            }
            break;
          }
          case at: {
            var Ce = l.memoizedState, ke = Ce !== null, tt = l.alternate, Et = tt !== null && tt.memoizedState !== null, Dt = l;
            ls && rw(Dt, ke);
            {
              if (ke && !Et && (Dt.mode & Ii) !== mr) {
                Tn = Dt;
                for (var Xt = Dt.child; Xt !== null; )
                  Tn = Xt, Fb(Xt), Xt = Xt.sibling;
              }
              break;
            }
          }
        }
      var an = w & (Fe | ft | Ji);
      switch (an) {
        case Fe: {
          Yd(l), l.flags &= ~Fe;
          break;
        }
        case ln: {
          Yd(l), l.flags &= ~Fe;
          var or = l.alternate;
          My(or, l);
          break;
        }
        case Ji: {
          l.flags &= ~Ji;
          break;
        }
        case _l: {
          l.flags &= ~Ji;
          var Wr = l.alternate;
          My(Wr, l);
          break;
        }
        case ft: {
          var hr = l.alternate;
          My(hr, l);
          break;
        }
      }
    }
    function qm(l, f, E) {
      Ey = E, jd = f, Tn = l, iS(l, f, E), Ey = null, jd = null;
    }
    function iS(l, f, E) {
      for (var w = (l.mode & Ii) !== mr; Tn !== null; ) {
        var L = Tn, B = L.child;
        if (L.tag === at && w) {
          var K = L.memoizedState !== null, re = K || Zx;
          if (re) {
            qd(l, f, E);
            continue;
          } else {
            var fe = L.alternate, Ce = fe !== null && fe.memoizedState !== null, ke = Ce || jm, tt = Zx, Et = jm;
            Zx = re, jm = ke, jm && !Et && (Tn = L, sw(L));
            for (var Dt = B; Dt !== null; )
              Tn = Dt, iS(
                Dt,
                // New root; bubble back up to here and stop.
                f,
                E
              ), Dt = Dt.sibling;
            Tn = L, Zx = tt, jm = Et, qd(l, f, E);
            continue;
          }
        }
        (L.subtreeFlags & Gn) !== ge && B !== null ? (td(B, L), Tn = B) : qd(l, f, E);
      }
    }
    function qd(l, f, E) {
      for (; Tn !== null; ) {
        var w = Tn;
        if ((w.flags & Gn) !== ge) {
          var L = w.alternate;
          pi(w);
          try {
            zA(f, L, w, E);
          } catch (K) {
            Io(K), Jo(w, w.return, K);
          }
          go();
        }
        if (w === l) {
          Tn = null;
          return;
        }
        var B = w.sibling;
        if (B !== null) {
          td(B, w.return), Tn = B;
          return;
        }
        Tn = w.return;
      }
    }
    function Fb(l) {
      for (; Tn !== null; ) {
        var f = Tn, E = f.child;
        switch (f.tag) {
          case Z:
          case ue:
          case me:
          case ce: {
            if (f.mode & Ur)
              try {
                gu(), qs(Wa, f, f.return);
              } finally {
                Sc(f);
              }
            else
              qs(Wa, f, f.return);
            break;
          }
          case te: {
            Jx(f, f.return);
            var w = f.stateNode;
            typeof w.componentWillUnmount == "function" && Z0(f, f.return, w);
            break;
          }
          case ye: {
            Jx(f, f.return);
            break;
          }
          case at: {
            var L = f.memoizedState !== null;
            if (L) {
              r_(l);
              continue;
            }
            break;
          }
        }
        E !== null ? (E.return = f, Tn = E) : r_(l);
      }
    }
    function r_(l) {
      for (; Tn !== null; ) {
        var f = Tn;
        if (f === l) {
          Tn = null;
          return;
        }
        var E = f.sibling;
        if (E !== null) {
          E.return = f.return, Tn = E;
          return;
        }
        Tn = f.return;
      }
    }
    function sw(l) {
      for (; Tn !== null; ) {
        var f = Tn, E = f.child;
        if (f.tag === at) {
          var w = f.memoizedState !== null;
          if (w) {
            lw(l);
            continue;
          }
        }
        E !== null ? (E.return = f, Tn = E) : lw(l);
      }
    }
    function lw(l) {
      for (; Tn !== null; ) {
        var f = Tn;
        pi(f);
        try {
          nw(f);
        } catch (w) {
          Io(w), Jo(f, f.return, w);
        }
        if (go(), f === l) {
          Tn = null;
          return;
        }
        var E = f.sibling;
        if (E !== null) {
          E.return = f.return, Tn = E;
          return;
        }
        Tn = f.return;
      }
    }
    function uw(l, f) {
      Tn = f, Km(f, l);
    }
    function Km(l, f) {
      for (; Tn !== null; ) {
        var E = Tn, w = E.child;
        (E.subtreeFlags & cr) !== ge && w !== null ? (td(w, E), Tn = w) : Cy(l, f);
      }
    }
    function Cy(l, f) {
      for (; Tn !== null; ) {
        var E = Tn;
        if ((E.flags & Ma) !== ge) {
          pi(E);
          try {
            Ry(f, E);
          } catch (L) {
            Io(L), Jo(E, E.return, L);
          }
          go();
        }
        if (E === l) {
          Tn = null;
          return;
        }
        var w = E.sibling;
        if (w !== null) {
          td(w, E.return), Tn = w;
          return;
        }
        Tn = E.return;
      }
    }
    function Ry(l, f) {
      switch (f.tag) {
        case Z:
        case ue:
        case ce: {
          if (f.mode & Ur) {
            Vx();
            try {
              Zf(_s | oa, f);
            } finally {
              py(f);
            }
          } else
            Zf(_s | oa, f);
          break;
        }
      }
    }
    function i_(l) {
      Tn = l, a_();
    }
    function a_() {
      for (; Tn !== null; ) {
        var l = Tn, f = l.child;
        if ((Tn.flags & zn) !== ge) {
          var E = l.deletions;
          if (E !== null) {
            for (var w = 0; w < E.length; w++) {
              var L = E[w];
              Tn = L, eg(L, l);
            }
            {
              var B = l.alternate;
              if (B !== null) {
                var K = B.child;
                if (K !== null) {
                  B.child = null;
                  do {
                    var re = K.sibling;
                    K.sibling = null, K = re;
                  } while (K !== null);
                }
              }
            }
            Tn = l;
          }
        }
        (l.subtreeFlags & cr) !== ge && f !== null ? (td(f, l), Tn = f) : Jf();
      }
    }
    function Jf() {
      for (; Tn !== null; ) {
        var l = Tn;
        (l.flags & Ma) !== ge && (pi(l), ed(l), go());
        var f = l.sibling;
        if (f !== null) {
          td(f, l.return), Tn = f;
          return;
        }
        Tn = l.return;
      }
    }
    function ed(l) {
      switch (l.tag) {
        case Z:
        case ue:
        case ce: {
          l.mode & Ur ? (Vx(), qs(_s | oa, l, l.return), py(l)) : qs(_s | oa, l, l.return);
          break;
        }
      }
    }
    function eg(l, f) {
      for (; Tn !== null; ) {
        var E = Tn;
        pi(E), kp(E, f), go();
        var w = E.child;
        w !== null ? (td(w, E), Tn = w) : zp(l);
      }
    }
    function zp(l) {
      for (; Tn !== null; ) {
        var f = Tn, E = f.sibling, w = f.return;
        if (Up(f), f === l) {
          Tn = null;
          return;
        }
        if (E !== null) {
          td(E, w), Tn = E;
          return;
        }
        Tn = w;
      }
    }
    function kp(l, f) {
      switch (l.tag) {
        case Z:
        case ue:
        case ce: {
          l.mode & Ur ? (Vx(), qs(_s, l, f), py(l)) : qs(_s, l, f);
          break;
        }
      }
    }
    var cw = !1;
    function td(l, f) {
      !cw && l.return !== f && (cw = !0, y("Internal React error: Return pointer is inconsistent with parent.")), l.return = f;
    }
    function IA(l) {
      switch (l.tag) {
        case Z:
        case ue:
        case ce: {
          try {
            Zf(Wa | oa, l);
          } catch (E) {
            Io(E), Jo(l, l.return, E);
          }
          break;
        }
        case te: {
          var f = l.stateNode;
          try {
            f.componentDidMount();
          } catch (E) {
            Io(E), Jo(l, l.return, E);
          }
          break;
        }
      }
    }
    function tg(l) {
      switch (l.tag) {
        case Z:
        case ue:
        case ce: {
          try {
            Zf(_s | oa, l);
          } catch (f) {
            Io(f), Jo(l, l.return, f);
          }
          break;
        }
      }
    }
    function fw(l) {
      switch (l.tag) {
        case Z:
        case ue:
        case ce: {
          try {
            qs(Wa | oa, l, l.return);
          } catch (E) {
            Io(E), Jo(l, l.return, E);
          }
          break;
        }
        case te: {
          var f = l.stateNode;
          typeof f.componentWillUnmount == "function" && Z0(l, l.return, f);
          break;
        }
      }
    }
    function Bb(l) {
      switch (l.tag) {
        case Z:
        case ue:
        case ce:
          try {
            qs(_s | oa, l, l.return);
          } catch (f) {
            Io(f), Jo(l, l.return, f);
          }
      }
    }
    var ng = 0, o_ = 1, Ay = 2, s_ = 3, l_ = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var Kd = Symbol.for;
      ng = Kd("selector.component"), o_ = Kd("selector.has_pseudo_class"), Ay = Kd("selector.role"), s_ = Kd("selector.test_id"), l_ = Kd("selector.text");
    }
    function Fl(l) {
      return {
        $$typeof: ng,
        value: l
      };
    }
    function nd(l) {
      return {
        $$typeof: o_,
        value: l
      };
    }
    function Qd(l) {
      return {
        $$typeof: Ay,
        value: l
      };
    }
    function rg(l) {
      return {
        $$typeof: l_,
        value: l
      };
    }
    function Qm(l) {
      return {
        $$typeof: s_,
        value: l
      };
    }
    function Hb(l) {
      var f = wf(l);
      if (f != null) {
        if (typeof f.memoizedProps["data-testname"] != "string")
          throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return f;
      } else {
        var E = Ca(l);
        if (E === null)
          throw new Error("Could not find React container within specified host subtree.");
        return E.stateNode.current;
      }
    }
    function u_(l, f) {
      switch (f.$$typeof) {
        case ng:
          if (l.type === f.value)
            return !0;
          break;
        case o_:
          return FA(l, f.value);
        case Ay:
          if (l.tag === ye) {
            var E = l.stateNode;
            if (uo(E, f.value))
              return !0;
          }
          break;
        case l_:
          if (l.tag === ye || l.tag === de) {
            var w = dm(l);
            if (w !== null && w.indexOf(f.value) >= 0)
              return !0;
          }
          break;
        case s_:
          if (l.tag === ye) {
            var L = l.memoizedProps["data-testname"];
            if (typeof L == "string" && L.toLowerCase() === f.value.toLowerCase())
              return !0;
          }
          break;
        default:
          throw new Error("Invalid selector type specified.");
      }
      return !1;
    }
    function Vb(l) {
      switch (l.$$typeof) {
        case ng:
          var f = Se(l.value) || "Unknown";
          return "<" + f + ">";
        case o_:
          return ":has(" + (Vb(l) || "") + ")";
        case Ay:
          return '[role="' + l.value + '"]';
        case l_:
          return '"' + l.value + '"';
        case s_:
          return '[data-testname="' + l.value + '"]';
        default:
          throw new Error("Invalid selector type specified.");
      }
    }
    function dw(l, f) {
      for (var E = [], w = [l, 0], L = 0; L < w.length; ) {
        var B = w[L++], K = w[L++], re = f[K];
        if (!(B.tag === ye && si(B))) {
          for (; re != null && u_(B, re); )
            K++, re = f[K];
          if (K === f.length)
            E.push(B);
          else
            for (var fe = B.child; fe !== null; )
              w.push(fe, K), fe = fe.sibling;
        }
      }
      return E;
    }
    function FA(l, f) {
      for (var E = [l, 0], w = 0; w < E.length; ) {
        var L = E[w++], B = E[w++], K = f[B];
        if (!(L.tag === ye && si(L))) {
          for (; K != null && u_(L, K); )
            B++, K = f[B];
          if (B === f.length)
            return !0;
          for (var re = L.child; re !== null; )
            E.push(re, B), re = re.sibling;
        }
      }
      return !1;
    }
    function aS(l, f) {
      if (!Ls)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var E = Hb(l), w = dw(E, f), L = [], B = Array.from(w), K = 0; K < B.length; ) {
        var re = B[K++];
        if (re.tag === ye) {
          if (si(re))
            continue;
          L.push(re.stateNode);
        } else
          for (var fe = re.child; fe !== null; )
            B.push(fe), fe = fe.sibling;
      }
      return L;
    }
    function hw(l, f) {
      if (!Ls)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var E = Hb(l), w = 0, L = [], B = [E, 0], K = 0; K < B.length; ) {
        var re = B[K++], fe = B[K++], Ce = f[fe];
        if (!(re.tag === ye && si(re)) && (u_(re, Ce) && (L.push(Vb(Ce)), fe++, fe > w && (w = fe)), fe < f.length))
          for (var ke = re.child; ke !== null; )
            B.push(ke, fe), ke = ke.sibling;
      }
      if (w < f.length) {
        for (var tt = [], Et = w; Et < f.length; Et++)
          tt.push(Vb(f[Et]));
        return `findAllNodes was able to match part of the selector:
` + ("  " + L.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + tt.join(" > "));
      }
      return null;
    }
    function Gb(l, f) {
      if (!Ls)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var E = aS(l, f), w = [], L = 0; L < E.length; L++)
        w.push(zi(E[L]));
      for (var B = w.length - 1; B > 0; B--)
        for (var K = w[B], re = K.x, fe = re + K.width, Ce = K.y, ke = Ce + K.height, tt = B - 1; tt >= 0; tt--)
          if (B !== tt) {
            var Et = w[tt], Dt = Et.x, Xt = Dt + Et.width, an = Et.y, or = an + Et.height;
            if (re >= Dt && Ce >= an && fe <= Xt && ke <= or) {
              w.splice(B, 1);
              break;
            } else if (re === Dt && K.width === Et.width && !(or < Ce) && !(an > ke)) {
              an > Ce && (Et.height += an - Ce, Et.y = Ce), or < ke && (Et.height = ke - an), w.splice(B, 1);
              break;
            } else if (Ce === an && K.height === Et.height && !(Xt < re) && !(Dt > fe)) {
              Dt > re && (Et.width += Dt - re, Et.x = re), Xt < fe && (Et.width = fe - Dt), w.splice(B, 1);
              break;
            }
          }
      return w;
    }
    function pw(l, f) {
      if (!Ls)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var E = Hb(l), w = dw(E, f), L = Array.from(w), B = 0; B < L.length; ) {
        var K = L[B++];
        if (!si(K)) {
          if (K.tag === ye) {
            var re = K.stateNode;
            if (Ju(re))
              return !0;
          }
          for (var fe = K.child; fe !== null; )
            L.push(fe), fe = fe.sibling;
        }
      }
      return !1;
    }
    var oS = [];
    function Wb() {
      Ls && oS.forEach(function(l) {
        return l();
      });
    }
    function jb(l, f, E, w) {
      if (!Ls)
        throw new Error("Test selector API is not supported by this renderer.");
      var L = aS(l, f), B = ch(L, E, w), K = B.disconnect, re = B.observe, fe = B.unobserve, Ce = function() {
        var ke = aS(l, f);
        L.forEach(function(tt) {
          ke.indexOf(tt) < 0 && fe(tt);
        }), ke.forEach(function(tt) {
          L.indexOf(tt) < 0 && re(tt);
        });
      };
      return oS.push(Ce), {
        disconnect: function() {
          var ke = oS.indexOf(Ce);
          ke >= 0 && oS.splice(ke, 1), K();
        }
      };
    }
    var $b = s.ReactCurrentActQueue;
    function BA(l) {
      {
        var f = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), E = typeof jest < "u";
        return Zu && E && f !== !1;
      }
    }
    function mw() {
      {
        var l = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !l && $b.current !== null && y("The current testing environment is not configured to support act(...)"), l;
      }
    }
    var HA = Math.ceil, Yb = s.ReactCurrentDispatcher, c_ = s.ReactCurrentOwner, Ya = s.ReactCurrentBatchConfig, Zd = s.ReactCurrentActQueue, Zo = (
      /*             */
      0
    ), Zm = (
      /*               */
      1
    ), Bl = (
      /*                */
      2
    ), Pa = (
      /*                */
      4
    ), Jd = 0, sS = 1, ig = 2, f_ = 3, Hu = 4, vw = 5, Ip = 6, kr = Zo, Es = null, Na = null, Oo = Gt, _c = Gt, ag = al(Gt), io = Jd, Jm = null, lS = Gt, Vu = Gt, Dy = Gt, og = null, Hl = null, ev = 0, d_ = 500, uS = 1 / 0, h_ = 500;
    function sg() {
      uS = Xi() + h_;
    }
    function Xb() {
      return uS;
    }
    var cS = !1, fS = null, tv = null, lg = !1, Fp = null, Vh = Gt, Fo = [], ug = 50, cg = 0, qb = null, gw = 50, p_ = 0, dS = _i, Vl = Gt;
    function m_() {
      return Es;
    }
    function Sl() {
      return (kr & (Bl | Pa)) !== Zo ? Xi() : (dS !== _i || (dS = Xi()), dS);
    }
    function Bp(l) {
      var f = l.mode;
      if ((f & Ii) === mr)
        return wr;
      if ((kr & Bl) !== Zo && Oo !== Gt)
        return Ff(Oo);
      var E = Jc() !== Zc;
      if (E) {
        if (Ya.transition !== null) {
          var w = Ya.transition;
          w._updatedFibers || (w._updatedFibers = /* @__PURE__ */ new Set()), w._updatedFibers.add(l);
        }
        return Vl === Tr && (Vl = bo()), Vl;
      }
      var L = ps();
      if (L !== Tr)
        return L;
      var B = pd();
      return B;
    }
    function yw(l) {
      var f = l.mode;
      return (f & Ii) === mr ? wr : Sh();
    }
    function Bo(l, f, E) {
      Rw();
      var w = fg(l, f);
      return w === null ? null : (To(w, f, E), (kr & Bl) !== Gt && w === Es ? ky(l) : (Ha && ra(w, l, f), Lw(l), w === Es && ((kr & Bl) === Zo && (Vu = Sr(Vu, f)), io === Hu && Wh(w, Oo)), Gl(w, E), f === wr && kr === Zo && (l.mode & Ii) === mr && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Zd.isBatchingLegacy && (sg(), js())), w);
    }
    function Kb(l, f, E) {
      var w = l.current;
      w.lanes = f, To(l, f, E), Gl(l, E);
    }
    function fg(l, f) {
      l.lanes = Sr(l.lanes, f);
      var E = l.alternate;
      E !== null && (E.lanes = Sr(E.lanes, f)), E === null && (l.flags & (Fe | Ji)) !== ge && Uy(l);
      for (var w = l, L = l.return; L !== null; )
        L.childLanes = Sr(L.childLanes, f), E = L.alternate, E !== null ? E.childLanes = Sr(E.childLanes, f) : (L.flags & (Fe | Ji)) !== ge && Uy(l), w = L, L = L.return;
      if (w.tag === q) {
        var B = w.stateNode;
        return B;
      } else
        return null;
    }
    function v_(l, f) {
      return (
        // TODO: Optimize slightly by comparing to root that fiber belongs to.
        // Requires some refactoring. Not a big deal though since it's rare for
        // concurrent apps to have more than a single root.
        Es !== null && (l.mode & Ii) !== mr && // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),
        // then don't treat this as an interleaved update. This pattern is
        // accompanied by a warning but we haven't fully deprecated it yet. We can
        // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.
        (kr & Bl) === Zo
      );
    }
    function Gl(l, f) {
      var E = l.callbackNode;
      Da(l, f);
      var w = di(l, l === Es ? Oo : Gt);
      if (w === Gt) {
        E !== null && Dw(E), l.callbackNode = null, l.callbackPriority = Tr;
        return;
      }
      var L = su(w), B = l.callbackPriority;
      if (B === L && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Zd.current !== null && E !== R_)) {
        E == null && B !== wr && y("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      E != null && Dw(E);
      var K;
      if (L === wr)
        l.tag === Pf ? (Zd.isBatchingLegacy !== null && (Zd.didScheduleLegacyUpdate = !0), Pu(Sw.bind(null, l))) : Wn(Sw.bind(null, l)), br ? Zd.current !== null ? Zd.current.push(Uo) : us(function() {
          kr === Zo && Uo();
        }) : Iy(ya, Uo), K = null;
      else {
        var re;
        switch (uu(w)) {
          case Ol:
            re = ya;
            break;
          case Ld:
            re = dn;
            break;
          case $c:
            re = Wi;
            break;
          case Od:
            re = Ba;
            break;
          default:
            re = Wi;
            break;
        }
        K = Iy(re, g_.bind(null, l));
      }
      l.callbackPriority = L, l.callbackNode = K;
    }
    function g_(l, f) {
      if (H0(), dS = _i, Vl = Gt, (kr & (Bl | Pa)) !== Zo)
        throw new Error("Should not already be working.");
      var E = l.callbackNode, w = jh();
      if (w && l.callbackNode !== E)
        return null;
      var L = di(l, l === Es ? Oo : Gt);
      if (L === Gt)
        return null;
      var B = !uc(l, L) && !Av(l, L) && !f, K = B ? GA(l, L) : Py(l, L);
      if (K !== Jd) {
        if (K === ig) {
          var re = Bs(l);
          re !== Gt && (L = re, K = y_(l, re));
        }
        if (K === sS) {
          var fe = Jm;
          throw Hp(l, Gt), Wh(l, L), Gl(l, Xi()), fe;
        }
        if (K === Ip)
          Wh(l, L);
        else {
          var Ce = !uc(l, L), ke = l.current.alternate;
          if (Ce && !S_(ke)) {
            if (K = Py(l, L), K === ig) {
              var tt = Bs(l);
              tt !== Gt && (L = tt, K = y_(l, tt));
            }
            if (K === sS) {
              var Et = Jm;
              throw Hp(l, Gt), Wh(l, L), Gl(l, Xi()), Et;
            }
          }
          l.finishedWork = ke, l.finishedLanes = L, nv(l, K, L);
        }
      }
      return Gl(l, Xi()), l.callbackNode === E ? g_.bind(null, l) : null;
    }
    function y_(l, f) {
      var E = og;
      if (wi(l)) {
        var w = Hp(l, f);
        w.flags |= vr, Ra(l.containerInfo);
      }
      var L = Py(l, f);
      if (L !== ig) {
        var B = Hl;
        Hl = E, B !== null && Gh(B);
      }
      return L;
    }
    function Gh(l) {
      Hl === null ? Hl = l : Hl.push.apply(Hl, l);
    }
    function nv(l, f, E) {
      switch (f) {
        case Jd:
        case sS:
          throw new Error("Root did not complete. This is a bug in React.");
        case ig: {
          rv(l, Hl);
          break;
        }
        case f_: {
          if (Wh(l, E), lc(E) && // do not delay if we're inside an act() scope
          !u1()) {
            var w = ev + d_ - Xi();
            if (w > 10) {
              var L = di(l, Gt);
              if (L !== Gt)
                break;
              var B = l.suspendedLanes;
              if (!lu(B, E)) {
                Sl(), mp(l, B);
                break;
              }
              l.timeoutHandle = fm(rv.bind(null, l, Hl), w);
              break;
            }
          }
          rv(l, Hl);
          break;
        }
        case Hu: {
          if (Wh(l, E), If(E))
            break;
          if (!u1()) {
            var K = Au(l, E), re = K, fe = Xi() - re, Ce = Ny(fe) - fe;
            if (Ce > 10) {
              l.timeoutHandle = fm(rv.bind(null, l, Hl), Ce);
              break;
            }
          }
          rv(l, Hl);
          break;
        }
        case vw: {
          rv(l, Hl);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function S_(l) {
      for (var f = l; ; ) {
        if (f.flags & _o) {
          var E = f.updateQueue;
          if (E !== null) {
            var w = E.stores;
            if (w !== null)
              for (var L = 0; L < w.length; L++) {
                var B = w[L], K = B.getSnapshot, re = B.value;
                try {
                  if (!Co(K(), re))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var fe = f.child;
        if (f.subtreeFlags & _o && fe !== null) {
          fe.return = f, f = fe;
          continue;
        }
        if (f === l)
          return !0;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === l)
            return !0;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      return !0;
    }
    function Wh(l, f) {
      f = po(f, Dy), f = po(f, Vu), wm(l, f);
    }
    function Sw(l) {
      if (Hx(), (kr & (Bl | Pa)) !== Zo)
        throw new Error("Should not already be working.");
      jh();
      var f = di(l, Gt);
      if (!hi(f, wr))
        return Gl(l, Xi()), null;
      var E = Py(l, f);
      if (l.tag !== Pf && E === ig) {
        var w = Bs(l);
        w !== Gt && (f = w, E = y_(l, w));
      }
      if (E === sS) {
        var L = Jm;
        throw Hp(l, Gt), Wh(l, f), Gl(l, Xi()), L;
      }
      if (E === Ip)
        throw new Error("Root did not complete. This is a bug in React.");
      var B = l.current.alternate;
      return l.finishedWork = B, l.finishedLanes = f, rv(l, Hl), Gl(l, Xi()), null;
    }
    function x_(l, f) {
      f !== Gt && (Mo(l, Sr(f, wr)), Gl(l, Xi()), (kr & (Bl | Pa)) === Zo && (sg(), Uo()));
    }
    function VA(l) {
      var f = ps(), E = Ya.transition;
      try {
        return Ya.transition = null, mo($c), l();
      } finally {
        mo(f), Ya.transition = E;
      }
    }
    function xw(l, f) {
      var E = kr;
      kr |= Zm;
      try {
        return l(f);
      } finally {
        kr = E, kr === Zo && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Zd.isBatchingLegacy && (sg(), js());
      }
    }
    function __(l, f, E, w, L) {
      var B = ps(), K = Ya.transition;
      try {
        return Ya.transition = null, mo(Ol), l(f, E, w, L);
      } finally {
        mo(B), Ya.transition = K, kr === Zo && sg();
      }
    }
    function hS(l) {
      Fp !== null && Fp.tag === Pf && (kr & (Bl | Pa)) === Zo && jh();
      var f = kr;
      kr |= Zm;
      var E = Ya.transition, w = ps();
      try {
        return Ya.transition = null, mo(Ol), l ? l() : void 0;
      } finally {
        mo(w), Ya.transition = E, kr = f, (kr & (Bl | Pa)) === Zo && Uo();
      }
    }
    function Qb() {
      return (kr & (Bl | Pa)) !== Zo;
    }
    function _w(l) {
      var f = kr;
      kr |= Zm;
      var E = Ya.transition, w = ps();
      try {
        Ya.transition = null, mo(Ol), l();
      } finally {
        mo(w), Ya.transition = E, kr = f, kr === Zo && (sg(), Uo());
      }
    }
    function Ly(l, f) {
      Gi(ag, _c, l), _c = Sr(_c, f);
    }
    function pS(l) {
      _c = ag.current, fo(ag, l);
    }
    function Hp(l, f) {
      l.finishedWork = null, l.finishedLanes = Gt;
      var E = l.timeoutHandle;
      if (E !== Kr && (l.timeoutHandle = Kr, Tl(E)), Na !== null)
        for (var w = Na.return; w !== null; ) {
          var L = w.alternate;
          Pb(L, w), w = w.return;
        }
      Es = l;
      var B = Ri(l.current, null);
      return Na = B, Oo = _c = f, io = Jd, Jm = null, lS = Gt, Vu = Gt, Dy = Gt, og = null, Hl = null, aa(), $s.discardPendingWarnings(), B;
    }
    function E_(l, f) {
      do {
        var E = Na;
        try {
          if (g(), Yt(), go(), c_.current = null, E === null || E.return === null) {
            io = sS, Jm = f, Na = null;
            return;
          }
          if (j && E.mode & Ur && Kv(E, !0), G)
            if (cu(), f !== null && typeof f == "object" && typeof f.then == "function") {
              var w = f;
              Kc(E, w, Oo);
            } else
              fu(E, f, Oo);
          fA(l, E.return, E, f, Oo), Mw(E);
        } catch (L) {
          f = L, Na === E && E !== null ? (E = E.return, Na = E) : E = Na;
          continue;
        }
        return;
      } while (!0);
    }
    function b_() {
      var l = Yb.current;
      return Yb.current = Ux, l === null ? Ux : l;
    }
    function Zb(l) {
      Yb.current = l;
    }
    function T_() {
      ev = Xi();
    }
    function Oy(l) {
      lS = Sr(l, lS);
    }
    function Jb() {
      io === Jd && (io = f_);
    }
    function mS() {
      (io === Jd || io === f_ || io === ig) && (io = Hu), Es !== null && (Hs(lS) || Hs(Vu)) && Wh(Es, Oo);
    }
    function Ew(l) {
      io !== Hu && (io = ig), og === null ? og = [l] : og.push(l);
    }
    function e1() {
      return io === Jd;
    }
    function Py(l, f) {
      var E = kr;
      kr |= Bl;
      var w = b_();
      if (Es !== l || Oo !== f) {
        if (Ha) {
          var L = l.memoizedUpdaters;
          L.size > 0 && (dg(l, Oo), L.clear()), ll(l, f);
        }
        Hp(l, f);
      }
      Rr(f);
      do
        try {
          bw();
          break;
        } catch (B) {
          E_(l, B);
        }
      while (!0);
      if (g(), kr = E, Zb(w), Na !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Yr(), Es = null, Oo = Gt, io;
    }
    function bw() {
      for (; Na !== null; )
        t1(Na);
    }
    function GA(l, f) {
      var E = kr;
      kr |= Bl;
      var w = b_();
      if (Es !== l || Oo !== f) {
        if (Ha) {
          var L = l.memoizedUpdaters;
          L.size > 0 && (dg(l, Oo), L.clear()), ll(l, f);
        }
        sg(), Hp(l, f);
      }
      Rr(f);
      do
        try {
          Tw();
          break;
        } catch (B) {
          E_(l, B);
        }
      while (!0);
      return g(), Zb(w), kr = E, Na !== null ? (Zn(), Jd) : (Yr(), Es = null, Oo = Gt, io);
    }
    function Tw() {
      for (; Na !== null && !Rm(); )
        t1(Na);
    }
    function t1(l) {
      var f = l.alternate;
      pi(l);
      var E;
      (l.mode & Ur) !== mr ? (Lp(l), E = zy(f, l, _c), Kv(l, !0)) : E = zy(f, l, _c), go(), l.memoizedProps = l.pendingProps, E === null ? Mw(l) : Na = E, c_.current = null;
    }
    function Mw(l) {
      var f = l;
      do {
        var E = f.alternate, w = f.return;
        if ((f.flags & Bt) === ge) {
          pi(f);
          var L = void 0;
          if ((f.mode & Ur) === mr ? L = OM(E, f, _c) : (Lp(f), L = OM(E, f, _c), Kv(f, !1)), go(), L !== null) {
            Na = L;
            return;
          }
        } else {
          var B = DA(E, f);
          if (B !== null) {
            B.flags &= Le, Na = B;
            return;
          }
          if ((f.mode & Ur) !== mr) {
            Kv(f, !1);
            for (var K = f.actualDuration, re = f.child; re !== null; )
              K += re.actualDuration, re = re.sibling;
            f.actualDuration = K;
          }
          if (w !== null)
            w.flags |= Bt, w.subtreeFlags = ge, w.deletions = null;
          else {
            io = Ip, Na = null;
            return;
          }
        }
        var fe = f.sibling;
        if (fe !== null) {
          Na = fe;
          return;
        }
        f = w, Na = f;
      } while (f !== null);
      io === Jd && (io = vw);
    }
    function rv(l, f) {
      var E = ps(), w = Ya.transition;
      try {
        Ya.transition = null, mo(Ol), n1(l, f, E);
      } finally {
        Ya.transition = w, mo(E);
      }
      return null;
    }
    function n1(l, f, E) {
      do
        jh();
      while (Fp !== null);
      if (jA(), (kr & (Bl | Pa)) !== Zo)
        throw new Error("Should not already be working.");
      var w = l.finishedWork, L = l.finishedLanes;
      if (vo(L), w === null)
        return Pd(), null;
      if (L === Gt && y("root.finishedLanes should not be empty during a commit. This is a bug in React."), l.finishedWork = null, l.finishedLanes = Gt, w === l.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      l.callbackNode = null, l.callbackPriority = Tr;
      var B = Sr(w.lanes, w.childLanes);
      jc(l, B), l === Es && (Es = null, Na = null, Oo = Gt), ((w.subtreeFlags & cr) !== ge || (w.flags & cr) !== ge) && (lg || (lg = !0, Iy(Wi, function() {
        return jh(), null;
      })));
      var K = (w.subtreeFlags & (pn | An | Gn | cr)) !== ge, re = (w.flags & (pn | An | Gn | cr)) !== ge;
      if (K || re) {
        var fe = Ya.transition;
        Ya.transition = null;
        var Ce = ps();
        mo(Ol);
        var ke = kr;
        kr |= Pa, c_.current = null, tw(l, w), pb(), aw(l, w, L), Ui(l.containerInfo), l.current = w, fl(L), qm(w, l, L), bh(), Eh(), kr = ke, mo(Ce), Ya.transition = fe;
      } else
        l.current = w, pb();
      var tt = lg;
      if (lg && (lg = !1, Fp = l, Vh = L), B = l.pendingLanes, B === Gt && (tv = null), tt || Aw(l.current, !1), zr(w.stateNode, E), Ha && l.memoizedUpdaters.clear(), Wb(), Gl(l, Xi()), f !== null)
        for (var Et = l.onRecoverableError, Dt = 0; Dt < f.length; Dt++) {
          var Xt = f[Dt];
          Et(Xt);
        }
      if (cS) {
        cS = !1;
        var an = fS;
        throw fS = null, an;
      }
      return hi(Vh, wr) && l.tag !== Pf && jh(), B = l.pendingLanes, hi(B, wr) ? (yc(), l === qb ? cg++ : (cg = 0, qb = l)) : cg = 0, Uo(), Pd(), null;
    }
    function jh() {
      if (Fp !== null) {
        var l = uu(Vh), f = Cm($c, l), E = Ya.transition, w = ps();
        try {
          return Ya.transition = null, mo(f), r1();
        } finally {
          mo(w), Ya.transition = E;
        }
      }
      return !1;
    }
    function WA(l) {
      Fo.push(l), lg || (lg = !0, Iy(Wi, function() {
        return jh(), null;
      }));
    }
    function r1() {
      if (Fp === null)
        return !1;
      var l = Fp, f = Vh;
      if (Fp = null, Vh = Gt, (kr & (Bl | Pa)) !== Zo)
        throw new Error("Cannot flush passive effects while already rendering.");
      du(f);
      var E = kr;
      kr |= Pa, i_(l.current), uw(l, l.current);
      {
        var w = Fo;
        Fo = [];
        for (var L = 0; L < w.length; L++) {
          var B = w[L];
          zb(l, B);
        }
      }
      Qn(), Aw(l.current, !0), kr = E, Uo(), p_ = Fp === null ? 0 : p_ + 1, ia(l);
      {
        var K = l.current.stateNode;
        K.effectDuration = 0, K.passiveEffectDuration = 0;
      }
      return !0;
    }
    function M_(l) {
      return tv !== null && tv.has(l);
    }
    function i1(l) {
      tv === null ? tv = /* @__PURE__ */ new Set([l]) : tv.add(l);
    }
    function a1(l) {
      cS || (cS = !0, fS = l);
    }
    var o1 = a1;
    function s1(l, f, E) {
      var w = V0(E, f), L = G0(l, w, wr);
      Vr(l, L);
      var B = Sl(), K = fg(l, wr);
      K !== null && (To(K, wr, B), Gl(K, B));
    }
    function Jo(l, f, E) {
      if (l.tag === q) {
        s1(l, l, E);
        return;
      }
      var w = null;
      for (w = f; w !== null; ) {
        if (w.tag === q) {
          s1(w, l, E);
          return;
        } else if (w.tag === te) {
          var L = w.type, B = w.stateNode;
          if (typeof L.getDerivedStateFromError == "function" || typeof B.componentDidCatch == "function" && !M_(B)) {
            var K = V0(E, l), re = vy(w, K, wr);
            Vr(w, re);
            var fe = Sl(), Ce = fg(w, wr);
            Ce !== null && (To(Ce, wr, fe), Gl(Ce, fe));
            return;
          }
        }
        w = w.return;
      }
      y(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, E);
    }
    function w_(l, f, E) {
      var w = l.pingCache;
      w !== null && w.delete(f);
      var L = Sl();
      mp(l, E), yS(l), Es === l && lu(Oo, E) && (io === Hu || io === f_ && lc(Oo) && Xi() - ev < d_ ? Hp(l, Gt) : Dy = Sr(Dy, E)), Gl(l, L);
    }
    function vS(l, f) {
      f === Tr && (f = yw(l));
      var E = Sl(), w = fg(l, f);
      w !== null && (To(w, f, E), Gl(w, E));
    }
    function ww(l) {
      var f = l.memoizedState, E = Tr;
      f !== null && (E = f.retryLane), vS(l, E);
    }
    function Cw(l, f) {
      var E = Tr, w;
      switch (l.tag) {
        case X:
          w = l.stateNode;
          var L = l.memoizedState;
          L !== null && (E = L.retryLane);
          break;
        case je:
          w = l.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      w !== null && w.delete(f), vS(l, E);
    }
    function Ny(l) {
      return l < 120 ? 120 : l < 480 ? 480 : l < 1080 ? 1080 : l < 1920 ? 1920 : l < 3e3 ? 3e3 : l < 4320 ? 4320 : HA(l / 1960) * 1960;
    }
    function Rw() {
      if (cg > ug)
        throw cg = 0, qb = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      p_ > gw && (p_ = 0, y("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function jA() {
      $s.flushLegacyContextWarning(), $s.flushPendingUnsafeLifecycleWarnings();
    }
    function Aw(l, f) {
      pi(l), iv(l, dt, fw), f && iv(l, tn, Bb), iv(l, dt, IA), f && iv(l, tn, tg), go();
    }
    function iv(l, f, E) {
      for (var w = l, L = null; w !== null; ) {
        var B = w.subtreeFlags & f;
        w !== L && w.child !== null && B !== ge ? w = w.child : ((w.flags & f) !== ge && E(w), w.sibling !== null ? w = w.sibling : w = L = w.return);
      }
    }
    var eh = null;
    function Uy(l) {
      {
        if ((kr & Bl) !== Zo || !(l.mode & Ii))
          return;
        var f = l.tag;
        if (f !== J && f !== q && f !== te && f !== Z && f !== ue && f !== me && f !== ce)
          return;
        var E = Tt(l) || "ReactComponent";
        if (eh !== null) {
          if (eh.has(E))
            return;
          eh.add(E);
        } else
          eh = /* @__PURE__ */ new Set([E]);
        var w = Yo;
        try {
          pi(l), y("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          w ? pi(l) : go();
        }
      }
    }
    var zy;
    {
      var C_ = null;
      zy = function(l, f, E) {
        var w = vg(C_, f);
        try {
          return XM(l, f, E);
        } catch (B) {
          if (B !== null && typeof B == "object" && typeof B.then == "function")
            throw B;
          if (g(), Yt(), Pb(l, f), vg(f, w), f.mode & Ur && Lp(f), QM(null, XM, null, l, f, E), PA()) {
            var L = ZM();
            typeof L == "object" && L !== null && L._suppressLogging && typeof B == "object" && B !== null && !B._suppressLogging && (B._suppressLogging = !0);
          }
          throw B;
        }
      };
    }
    var l1 = !1, gS;
    gS = /* @__PURE__ */ new Set();
    function ky(l) {
      if (hl && !_M())
        switch (l.tag) {
          case Z:
          case ue:
          case ce: {
            var f = Na && Tt(Na) || "Unknown", E = f;
            if (!gS.has(E)) {
              gS.add(E);
              var w = Tt(l) || "Unknown";
              y("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", w, f, f);
            }
            break;
          }
          case te: {
            l1 || (y("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), l1 = !0);
            break;
          }
        }
    }
    function dg(l, f) {
      if (Ha) {
        var E = l.memoizedUpdaters;
        E.forEach(function(w) {
          ra(l, w, f);
        });
      }
    }
    var R_ = {};
    function Iy(l, f) {
      {
        var E = Zd.current;
        return E !== null ? (E.push(f), R_) : _h(l, f);
      }
    }
    function Dw(l) {
      if (l !== R_)
        return Yc(l);
    }
    function u1() {
      return Zd.current !== null;
    }
    function Lw(l) {
      {
        if (l.mode & Ii) {
          if (!mw())
            return;
        } else if (!BA() || kr !== Zo || l.tag !== Z && l.tag !== ue && l.tag !== ce)
          return;
        if (Zd.current === null) {
          var f = Yo;
          try {
            pi(l), y(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Tt(l));
          } finally {
            f ? pi(l) : go();
          }
        }
      }
    }
    function yS(l) {
      l.tag !== Pf && mw() && Zd.current === null && y(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    var Ho = null, av = null, Fy = function(l) {
      Ho = l;
    };
    function ov(l) {
      {
        if (Ho === null)
          return l;
        var f = Ho(l);
        return f === void 0 ? l : f.current;
      }
    }
    function c1(l) {
      return ov(l);
    }
    function $h(l) {
      {
        if (Ho === null)
          return l;
        var f = Ho(l);
        if (f === void 0) {
          if (l != null && typeof l.render == "function") {
            var E = ov(l.render);
            if (l.render !== E) {
              var w = {
                $$typeof: qt,
                render: E
              };
              return l.displayName !== void 0 && (w.displayName = l.displayName), w;
            }
          }
          return l;
        }
        return f.current;
      }
    }
    function hg(l, f) {
      {
        if (Ho === null)
          return !1;
        var E = l.elementType, w = f.type, L = !1, B = typeof w == "object" && w !== null ? w.$$typeof : null;
        switch (l.tag) {
          case te: {
            typeof w == "function" && (L = !0);
            break;
          }
          case Z: {
            (typeof w == "function" || B === se) && (L = !0);
            break;
          }
          case ue: {
            (B === qt || B === se) && (L = !0);
            break;
          }
          case me:
          case ce: {
            (B === Yn || B === se) && (L = !0);
            break;
          }
          default:
            return !1;
        }
        if (L) {
          var K = Ho(E);
          if (K !== void 0 && K === Ho(w))
            return !0;
        }
        return !1;
      }
    }
    function Ow(l) {
      {
        if (Ho === null || typeof WeakSet != "function")
          return;
        av === null && (av = /* @__PURE__ */ new WeakSet()), av.add(l);
      }
    }
    var A_ = function(l, f) {
      {
        if (Ho === null)
          return;
        var E = f.staleFamilies, w = f.updatedFamilies;
        jh(), hS(function() {
          es(l.current, w, E);
        });
      }
    }, Ec = function(l, f) {
      {
        if (l.context !== Zr)
          return;
        jh(), hS(function() {
          L_(f, l, null, null);
        });
      }
    };
    function es(l, f, E) {
      {
        var w = l.alternate, L = l.child, B = l.sibling, K = l.tag, re = l.type, fe = null;
        switch (K) {
          case Z:
          case ce:
          case te:
            fe = re;
            break;
          case ue:
            fe = re.render;
            break;
        }
        if (Ho === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var Ce = !1, ke = !1;
        if (fe !== null) {
          var tt = Ho(fe);
          tt !== void 0 && (E.has(tt) ? ke = !0 : f.has(tt) && (K === te ? ke = !0 : Ce = !0));
        }
        av !== null && (av.has(l) || w !== null && av.has(w)) && (ke = !0), ke && (l._debugNeedsRemount = !0), (ke || Ce) && Bo(l, wr, _i), L !== null && !ke && es(L, f, E), B !== null && es(B, f, E);
      }
    }
    var Yh = function(l, f) {
      {
        var E = /* @__PURE__ */ new Set(), w = new Set(f.map(function(L) {
          return L.current;
        }));
        return ts(l.current, w, E), E;
      }
    };
    function ts(l, f, E) {
      {
        var w = l.child, L = l.sibling, B = l.tag, K = l.type, re = null;
        switch (B) {
          case Z:
          case ce:
          case te:
            re = K;
            break;
          case ue:
            re = K.render;
            break;
        }
        var fe = !1;
        re !== null && f.has(re) && (fe = !0), fe ? Wl(l, E) : w !== null && ts(w, f, E), L !== null && ts(L, f, E);
      }
    }
    function Wl(l, f) {
      {
        var E = f1(l, f);
        if (E)
          return;
        for (var w = l; ; ) {
          switch (w.tag) {
            case ye:
              f.add(w.stateNode);
              return;
            case oe:
              f.add(w.stateNode.containerInfo);
              return;
            case q:
              f.add(w.stateNode.containerInfo);
              return;
          }
          if (w.return === null)
            throw new Error("Expected to reach root first.");
          w = w.return;
        }
      }
    }
    function f1(l, f) {
      for (var E = l, w = !1; ; ) {
        if (E.tag === ye)
          w = !0, f.add(E.stateNode);
        else if (E.child !== null) {
          E.child.return = E, E = E.child;
          continue;
        }
        if (E === l)
          return w;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === l)
            return w;
          E = E.return;
        }
        E.sibling.return = E.return, E = E.sibling;
      }
      return !1;
    }
    var SS;
    {
      SS = !1;
      try {
        var Pw = Object.preventExtensions({});
      } catch {
        SS = !0;
      }
    }
    function wn(l, f, E, w) {
      this.tag = l, this.key = E, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = f, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = w, this.flags = ge, this.subtreeFlags = ge, this.deletions = null, this.lanes = Gt, this.childLanes = Gt, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !SS && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var jl = function(l, f, E, w) {
      return new wn(l, f, E, w);
    };
    function xS(l) {
      var f = l.prototype;
      return !!(f && f.isReactComponent);
    }
    function By(l) {
      return typeof l == "function" && !xS(l) && l.defaultProps === void 0;
    }
    function pg(l) {
      if (typeof l == "function")
        return xS(l) ? te : Z;
      if (l != null) {
        var f = l.$$typeof;
        if (f === qt)
          return ue;
        if (f === Yn)
          return me;
      }
      return J;
    }
    function Ri(l, f) {
      var E = l.alternate;
      E === null ? (E = jl(l.tag, f, l.key, l.mode), E.elementType = l.elementType, E.type = l.type, E.stateNode = l.stateNode, E._debugSource = l._debugSource, E._debugOwner = l._debugOwner, E._debugHookTypes = l._debugHookTypes, E.alternate = l, l.alternate = E) : (E.pendingProps = f, E.type = l.type, E.flags = ge, E.subtreeFlags = ge, E.deletions = null, E.actualDuration = 0, E.actualStartTime = -1), E.flags = l.flags & sn, E.childLanes = l.childLanes, E.lanes = l.lanes, E.child = l.child, E.memoizedProps = l.memoizedProps, E.memoizedState = l.memoizedState, E.updateQueue = l.updateQueue;
      var w = l.dependencies;
      switch (E.dependencies = w === null ? null : {
        lanes: w.lanes,
        firstContext: w.firstContext
      }, E.sibling = l.sibling, E.index = l.index, E.ref = l.ref, E.selfBaseDuration = l.selfBaseDuration, E.treeBaseDuration = l.treeBaseDuration, E._debugNeedsRemount = l._debugNeedsRemount, E.tag) {
        case J:
        case Z:
        case ce:
          E.type = ov(l.type);
          break;
        case te:
          E.type = c1(l.type);
          break;
        case ue:
          E.type = $h(l.type);
          break;
      }
      return E;
    }
    function Ks(l, f) {
      l.flags &= sn | Fe;
      var E = l.alternate;
      if (E === null)
        l.childLanes = Gt, l.lanes = f, l.child = null, l.subtreeFlags = ge, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null, l.selfBaseDuration = 0, l.treeBaseDuration = 0;
      else {
        l.childLanes = E.childLanes, l.lanes = E.lanes, l.child = E.child, l.subtreeFlags = ge, l.deletions = null, l.memoizedProps = E.memoizedProps, l.memoizedState = E.memoizedState, l.updateQueue = E.updateQueue, l.type = E.type;
        var w = E.dependencies;
        l.dependencies = w === null ? null : {
          lanes: w.lanes,
          firstContext: w.firstContext
        }, l.selfBaseDuration = E.selfBaseDuration, l.treeBaseDuration = E.treeBaseDuration;
      }
      return l;
    }
    function Qs(l, f, E) {
      var w;
      return l === Em ? (w = Ii, f === !0 && (w |= ma, w |= No)) : w = mr, Ha && (w |= Ur), jl(q, null, null, w);
    }
    function Hy(l, f, E, w, L, B) {
      var K = J, re = l;
      if (typeof l == "function")
        xS(l) ? (K = te, re = c1(re)) : re = ov(re);
      else if (typeof l == "string")
        K = ye;
      else
        e:
          switch (l) {
            case et:
              return rd(E.children, L, B, f);
            case Rt:
              K = Re, L |= ma, (L & Ii) !== mr && (L |= No);
              break;
            case gt:
              return $A(E, L, B, f);
            case hn:
              return YA(E, L, B, f);
            case Rn:
              return kt(E, L, B, f);
            case wt:
              return ff(E, L, B, f);
            case _t:
            case ae:
            case Vt:
            case fn:
            case Ke:
            default: {
              if (typeof l == "object" && l !== null)
                switch (l.$$typeof) {
                  case Jt:
                    K = Te;
                    break e;
                  case Kt:
                    K = Pe;
                    break e;
                  case qt:
                    K = ue, re = $h(re);
                    break e;
                  case Yn:
                    K = me;
                    break e;
                  case se:
                    K = Ue, re = null;
                    break e;
                }
              var fe = "";
              {
                (l === void 0 || typeof l == "object" && l !== null && Object.keys(l).length === 0) && (fe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var Ce = w ? Tt(w) : null;
                Ce && (fe += `

Check the render method of \`` + Ce + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (l == null ? l : typeof l) + "." + fe));
            }
          }
      var ke = jl(K, E, f, L);
      return ke.elementType = l, ke.type = re, ke.lanes = B, ke._debugOwner = w, ke;
    }
    function mg(l, f, E) {
      var w = null;
      w = l._owner;
      var L = l.type, B = l.key, K = l.props, re = Hy(L, B, K, w, f, E);
      return re._debugSource = l._source, re._debugOwner = l._owner, re;
    }
    function rd(l, f, E, w) {
      var L = jl(xe, l, w, f);
      return L.lanes = E, L;
    }
    function $A(l, f, E, w) {
      typeof l.id != "string" && y('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof l.id);
      var L = jl(we, l, w, f | Ur);
      return L.elementType = gt, L.lanes = E, L.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, L;
    }
    function YA(l, f, E, w) {
      var L = jl(X, l, w, f);
      return L.elementType = hn, L.lanes = E, L;
    }
    function kt(l, f, E, w) {
      var L = jl(je, l, w, f);
      return L.elementType = Rn, L.lanes = E, L;
    }
    function ff(l, f, E, w) {
      var L = jl(at, l, w, f);
      L.elementType = wt, L.lanes = E;
      var B = {};
      return L.stateNode = B, L;
    }
    function Xh(l, f, E) {
      var w = jl(de, l, null, f);
      return w.lanes = E, w;
    }
    function d1() {
      var l = jl(ye, null, null, mr);
      return l.elementType = "DELETED", l;
    }
    function Ki(l) {
      var f = jl(Ze, null, null, mr);
      return f.stateNode = l, f;
    }
    function vn(l, f, E) {
      var w = l.children !== null ? l.children : [], L = jl(oe, w, l.key, f);
      return L.lanes = E, L.stateNode = {
        containerInfo: l.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: l.implementation
      }, L;
    }
    function vg(l, f) {
      return l === null && (l = jl(J, null, null, mr)), l.tag = f.tag, l.key = f.key, l.elementType = f.elementType, l.type = f.type, l.stateNode = f.stateNode, l.return = f.return, l.child = f.child, l.sibling = f.sibling, l.index = f.index, l.ref = f.ref, l.pendingProps = f.pendingProps, l.memoizedProps = f.memoizedProps, l.updateQueue = f.updateQueue, l.memoizedState = f.memoizedState, l.dependencies = f.dependencies, l.mode = f.mode, l.flags = f.flags, l.subtreeFlags = f.subtreeFlags, l.deletions = f.deletions, l.lanes = f.lanes, l.childLanes = f.childLanes, l.alternate = f.alternate, l.actualDuration = f.actualDuration, l.actualStartTime = f.actualStartTime, l.selfBaseDuration = f.selfBaseDuration, l.treeBaseDuration = f.treeBaseDuration, l._debugSource = f._debugSource, l._debugOwner = f._debugOwner, l._debugNeedsRemount = f._debugNeedsRemount, l._debugHookTypes = f._debugHookTypes, l;
    }
    function XA(l, f, E, w, L) {
      this.tag = f, this.containerInfo = l, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = Kr, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Tr, this.eventTimes = sl(Gt), this.expirationTimes = sl(_i), this.pendingLanes = Gt, this.suspendedLanes = Gt, this.pingedLanes = Gt, this.expiredLanes = Gt, this.mutableReadLanes = Gt, this.finishedLanes = Gt, this.entangledLanes = Gt, this.entanglements = sl(Gt), this.identifierPrefix = w, this.onRecoverableError = L, lo && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var B = this.pendingUpdatersLaneMap = [], K = 0; K < vh; K++)
          B.push(/* @__PURE__ */ new Set());
      }
      switch (f) {
        case Em:
          this._debugRootType = E ? "hydrateRoot()" : "createRoot()";
          break;
        case Pf:
          this._debugRootType = E ? "hydrate()" : "render()";
          break;
      }
    }
    function $l(l, f, E, w, L, B, K, re, fe, Ce) {
      var ke = new XA(l, f, E, re, fe), tt = Qs(f, B);
      ke.current = tt, tt.stateNode = ke;
      {
        var Et = {
          element: w,
          isDehydrated: E,
          cache: null,
          // not enabled yet
          transitions: null
        };
        tt.memoizedState = Et;
      }
      return Dn(tt), ke;
    }
    var h1 = "18.0.0-fc46dba67-20220329";
    function Vy(l, f, E) {
      var w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return pl(w), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: nt,
        key: w == null ? null : "" + w,
        children: l,
        containerInfo: f,
        implementation: E
      };
    }
    var sv, D_;
    sv = !1, D_ = {};
    function p1(l) {
      if (!l)
        return Zr;
      var f = M(l), E = fp(f);
      if (f.tag === te) {
        var w = f.type;
        if (Al(w))
          return Dl(f, w, E);
      }
      return E;
    }
    function qh(l) {
      var f = M(l);
      if (f === void 0) {
        if (typeof l.render == "function")
          throw new Error("Unable to find node on an unmounted component.");
        var E = Object.keys(l).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + E);
      }
      var w = ir(f);
      return w === null ? null : w.stateNode;
    }
    function id(l, f) {
      {
        var E = M(l);
        if (E === void 0) {
          if (typeof l.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var w = Object.keys(l).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + w);
        }
        var L = ir(E);
        if (L === null)
          return null;
        if (L.mode & ma) {
          var B = Tt(E) || "Component";
          if (!D_[B]) {
            D_[B] = !0;
            var K = Yo;
            try {
              pi(L), E.mode & ma ? y("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", f, f, B) : y("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", f, f, B);
            } finally {
              K ? pi(K) : go();
            }
          }
        }
        return L.stateNode;
      }
    }
    function Nw(l, f, E, w, L, B, K, re) {
      var fe = !1, Ce = null;
      return $l(l, f, fe, Ce, E, w, L, B, K);
    }
    function m1(l, f, E, w, L, B, K, re, fe, Ce) {
      var ke = !0, tt = $l(E, w, ke, l, L, B, K, re, fe);
      tt.context = p1(null);
      var Et = tt.current, Dt = Sl(), Xt = Bp(Et), an = ar(Dt, Xt);
      return an.callback = f ?? null, Vr(Et, an), Kb(tt, Xt, Dt), tt;
    }
    function L_(l, f, E, w) {
      xa(f, l);
      var L = f.current, B = Sl(), K = Bp(L);
      wo(K);
      var re = p1(E);
      f.context === null ? f.context = re : f.pendingContext = re, hl && Yo !== null && !sv && (sv = !0, y(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Tt(Yo) || "Unknown"));
      var fe = ar(B, K);
      fe.payload = {
        element: l
      }, w = w === void 0 ? null : w, w !== null && (typeof w != "function" && y("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", w), fe.callback = w), Vr(L, fe);
      var Ce = Bo(L, K, B);
      return Ce !== null && _a(Ce, L, K), K;
    }
    function v1(l) {
      var f = l.current;
      if (!f.child)
        return null;
      switch (f.child.tag) {
        case ye:
          return ss(f.child.stateNode);
        default:
          return f.child.stateNode;
      }
    }
    function g1(l) {
      switch (l.tag) {
        case q:
          var f = l.stateNode;
          if (wi(f)) {
            var E = fs(f);
            x_(f, E);
          }
          break;
        case X:
          var w = Sl();
          hS(function() {
            return Bo(l, wr, w);
          });
          var L = wr;
          Uw(l, L);
          break;
      }
    }
    function qA(l, f) {
      var E = l.memoizedState;
      E !== null && E.dehydrated !== null && (E.retryLane = rn(E.retryLane, f));
    }
    function Uw(l, f) {
      qA(l, f);
      var E = l.alternate;
      E && qA(E, f);
    }
    function y1(l) {
      if (l.tag === X) {
        var f = Sl(), E = kf;
        Bo(l, E, f), Uw(l, E);
      }
    }
    function O_(l) {
      if (l.tag === X) {
        var f = Sl(), E = Bp(l);
        Bo(l, E, f), Uw(l, E);
      }
    }
    function zw(l) {
      var f = fr(l);
      return f === null ? null : f.stateNode;
    }
    var S1 = function(l) {
      return null;
    };
    function x1(l) {
      return S1(l);
    }
    var _1 = function(l) {
      return !1;
    };
    function E1(l) {
      return _1(l);
    }
    var _S = null, P_ = null, N_ = null, Gy = null, U_ = null, ES = null, Wy = null, bS = null, TS = null;
    {
      var jy = function(l, f, E) {
        var w = f[E], L = ni(l) ? l.slice() : b({}, l);
        return E + 1 === f.length ? (ni(L) ? L.splice(w, 1) : delete L[w], L) : (L[w] = jy(l[w], f, E + 1), L);
      }, z_ = function(l, f) {
        return jy(l, f, 0);
      }, MS = function(l, f, E, w) {
        var L = f[w], B = ni(l) ? l.slice() : b({}, l);
        if (w + 1 === f.length) {
          var K = E[w];
          B[K] = B[L], ni(B) ? B.splice(L, 1) : delete B[L];
        } else
          B[L] = MS(
            // $FlowFixMe number or string is fine here
            l[L],
            f,
            E,
            w + 1
          );
        return B;
      }, k_ = function(l, f, E) {
        if (f.length !== E.length) {
          v("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var w = 0; w < E.length - 1; w++)
            if (f[w] !== E[w]) {
              v("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return MS(l, f, E, 0);
      }, wS = function(l, f, E, w) {
        if (E >= f.length)
          return w;
        var L = f[E], B = ni(l) ? l.slice() : b({}, l);
        return B[L] = wS(l[L], f, E + 1, w), B;
      }, b1 = function(l, f, E) {
        return wS(l, f, 0, E);
      }, CS = function(l, f) {
        for (var E = l.memoizedState; E !== null && f > 0; )
          E = E.next, f--;
        return E;
      };
      _S = function(l, f, E, w) {
        var L = CS(l, f);
        if (L !== null) {
          var B = b1(L.memoizedState, E, w);
          L.memoizedState = B, L.baseState = B, l.memoizedProps = b({}, l.memoizedProps), Bo(l, wr, _i);
        }
      }, P_ = function(l, f, E) {
        var w = CS(l, f);
        if (w !== null) {
          var L = z_(w.memoizedState, E);
          w.memoizedState = L, w.baseState = L, l.memoizedProps = b({}, l.memoizedProps), Bo(l, wr, _i);
        }
      }, N_ = function(l, f, E, w) {
        var L = CS(l, f);
        if (L !== null) {
          var B = k_(L.memoizedState, E, w);
          L.memoizedState = B, L.baseState = B, l.memoizedProps = b({}, l.memoizedProps), Bo(l, wr, _i);
        }
      }, Gy = function(l, f, E) {
        l.pendingProps = b1(l.memoizedProps, f, E), l.alternate && (l.alternate.pendingProps = l.pendingProps), Bo(l, wr, _i);
      }, U_ = function(l, f) {
        l.pendingProps = z_(l.memoizedProps, f), l.alternate && (l.alternate.pendingProps = l.pendingProps), Bo(l, wr, _i);
      }, ES = function(l, f, E) {
        l.pendingProps = k_(l.memoizedProps, f, E), l.alternate && (l.alternate.pendingProps = l.pendingProps), Bo(l, wr, _i);
      }, Wy = function(l) {
        Bo(l, wr, _i);
      }, bS = function(l) {
        S1 = l;
      }, TS = function(l) {
        _1 = l;
      };
    }
    function I_(l) {
      var f = ir(l);
      return f === null ? null : f.stateNode;
    }
    function KA(l) {
      return null;
    }
    function F_() {
      return Yo;
    }
    function T1(l) {
      var f = l.findFiberByHostInstance, E = s.ReactCurrentDispatcher;
      return cc({
        bundleType: l.bundleType,
        version: l.version,
        rendererPackageName: l.rendererPackageName,
        rendererConfig: l.rendererConfig,
        overrideHookState: _S,
        overrideHookStateDeletePath: P_,
        overrideHookStateRenamePath: N_,
        overrideProps: Gy,
        overridePropsDeletePath: U_,
        overridePropsRenamePath: ES,
        setErrorHandler: bS,
        setSuspenseHandler: TS,
        scheduleUpdate: Wy,
        currentDispatcherRef: E,
        findHostInstanceByFiber: I_,
        findFiberByHostInstance: f || KA,
        // React Refresh
        findHostInstancesForRefresh: Yh,
        scheduleRefresh: A_,
        scheduleRoot: Ec,
        setRefreshHandler: Fy,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: F_,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: h1
      });
    }
    return t.attemptContinuousHydration = y1, t.attemptHydrationAtCurrentPriority = O_, t.attemptSynchronousHydration = g1, t.batchedUpdates = xw, t.createComponentSelector = Fl, t.createContainer = Nw, t.createHasPseudoClassSelector = nd, t.createHydrationContainer = m1, t.createPortal = Vy, t.createRoleSelector = Qd, t.createTestNameSelector = Qm, t.createTextSelector = rg, t.deferredUpdates = VA, t.discreteUpdates = __, t.findAllNodes = aS, t.findBoundingRects = Gb, t.findHostInstance = qh, t.findHostInstanceWithNoPortals = zw, t.findHostInstanceWithWarning = id, t.flushControlled = _w, t.flushPassiveEffects = jh, t.flushSync = hS, t.focusWithin = pw, t.getCurrentUpdatePriority = ps, t.getFindAllNodesFailureDescription = hw, t.getPublicRootInstance = v1, t.injectIntoDevTools = T1, t.isAlreadyRendering = Qb, t.observeVisibleRects = jb, t.registerMutableSourceForHydration = Gv, t.runWithPriority = va, t.shouldError = x1, t.shouldSuspend = E1, t.updateContainer = L_, t;
  })), H2.exports;
}
process.env.NODE_ENV === "production" ? iO.exports = gX() : iO.exports = yX();
var SX = iO.exports;
const xX = /* @__PURE__ */ GE(SX), CP = {}, _X = (n) => void Object.assign(CP, n);
function EX(n, e) {
  function t(_, {
    args: b = [],
    attach: M,
    ...C
  }, D) {
    let U = `${_[0].toUpperCase()}${_.slice(1)}`, N;
    if (_ === "primitive") {
      if (C.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const O = C.object;
      N = bE(O, {
        type: _,
        root: D,
        attach: M,
        primitive: !0
      });
    } else {
      const O = CP[U];
      if (!O)
        throw new Error(`R3F: ${U} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(b))
        throw new Error("R3F: The args prop must be an array!");
      N = bE(new O(...b), {
        type: _,
        root: D,
        attach: M,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args: b
        }
      });
    }
    return N.__r3f.attach === void 0 && (N instanceof yi ? N.__r3f.attach = "geometry" : N instanceof Ku && (N.__r3f.attach = "material")), U !== "inject" && W2(N, C), N;
  }
  function r(_, b) {
    let M = !1;
    if (b) {
      var C, D;
      (C = b.__r3f) != null && C.attach ? G2(_, b, b.__r3f.attach) : b.isObject3D && _.isObject3D && (_.add(b), M = !0), M || (D = _.__r3f) == null || D.objects.push(b), b.__r3f || bE(b, {}), b.__r3f.parent = _, sO(b), TE(b);
    }
  }
  function a(_, b, M) {
    let C = !1;
    if (b) {
      var D, U;
      if ((D = b.__r3f) != null && D.attach)
        G2(_, b, b.__r3f.attach);
      else if (b.isObject3D && _.isObject3D) {
        b.parent = _, b.dispatchEvent({
          type: "added"
        });
        const N = _.children.filter((I) => I !== b), O = N.indexOf(M);
        _.children = [...N.slice(0, O), b, ...N.slice(O)], C = !0;
      }
      C || (U = _.__r3f) == null || U.objects.push(b), b.__r3f || bE(b, {}), b.__r3f.parent = _, sO(b), TE(b);
    }
  }
  function s(_, b, M = !1) {
    _ && [..._].forEach((C) => u(b, C, M));
  }
  function u(_, b, M) {
    if (b) {
      var C, D, U;
      if (b.__r3f && (b.__r3f.parent = null), (C = _.__r3f) != null && C.objects && (_.__r3f.objects = _.__r3f.objects.filter((G) => G !== b)), (D = b.__r3f) != null && D.attach)
        Fz(_, b, b.__r3f.attach);
      else if (b.isObject3D && _.isObject3D) {
        var N;
        _.remove(b), (N = b.__r3f) != null && N.root && AX(b.__r3f.root, b);
      }
      const I = (U = b.__r3f) == null ? void 0 : U.primitive, k = M === void 0 ? b.dispose !== null && !I : M;
      if (!I) {
        var O;
        s((O = b.__r3f) == null ? void 0 : O.objects, b, k), s(b.children, b, k);
      }
      b.__r3f && (delete b.__r3f.root, delete b.__r3f.objects, delete b.__r3f.handlers, delete b.__r3f.memoizedProps, I || delete b.__r3f), k && b.dispose && b.type !== "Scene" && xR.unstable_scheduleCallback(xR.unstable_IdlePriority, () => {
        try {
          b.dispose();
        } catch {
        }
      }), TE(_);
    }
  }
  function h(_, b, M, C) {
    var D;
    const U = (D = _.__r3f) == null ? void 0 : D.parent;
    if (!U)
      return;
    const N = t(b, M, _.__r3f.root);
    if (_.children) {
      for (const O of _.children)
        O.__r3f && r(N, O);
      _.children = _.children.filter((O) => !O.__r3f);
    }
    _.__r3f.objects.forEach((O) => r(N, O)), _.__r3f.objects = [], _.__r3f.autoRemovedBeforeAppend || u(U, _), N.parent && (N.__r3f.autoRemovedBeforeAppend = !0), r(U, N), N.raycast && N.__r3f.eventCount && N.__r3f.root.getState().internal.interaction.push(N), [C, C.alternate].forEach((O) => {
      O !== null && (O.stateNode = N, O.ref && (typeof O.ref == "function" ? O.ref(N) : O.ref.current = N));
    });
  }
  const v = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
  return {
    reconciler: xX({
      createInstance: t,
      removeChild: u,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: a,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (_, b) => {
        if (!b)
          return;
        const M = _.getState().scene;
        M.__r3f && (M.__r3f.root = _, r(M, b));
      },
      removeChildFromContainer: (_, b) => {
        b && u(_.getState().scene, b);
      },
      insertInContainerBefore: (_, b, M) => {
        if (!b || !M)
          return;
        const C = _.getState().scene;
        C.__r3f && a(C, b, M);
      },
      getRootHostContext: () => null,
      getChildHostContext: (_) => _,
      finalizeInitialChildren(_) {
        var b;
        return !!((b = _ == null ? void 0 : _.__r3f) != null ? b : {}).handlers;
      },
      prepareUpdate(_, b, M, C) {
        if (_.__r3f.primitive && C.object && C.object !== _)
          return [!0];
        {
          const {
            args: D = [],
            children: U,
            ...N
          } = C, {
            args: O = [],
            children: I,
            ...k
          } = M;
          if (!Array.isArray(D))
            throw new Error("R3F: the args prop must be an array!");
          if (D.some((j, Y) => j !== O[Y]))
            return [!0];
          const G = VB(_, N, k, !0);
          return G.changes.length ? [!1, G] : null;
        }
      },
      commitUpdate(_, [b, M], C, D, U, N) {
        b ? h(_, C, U, N) : W2(_, M);
      },
      commitMount(_, b, M, C) {
        var D;
        const U = (D = _.__r3f) != null ? D : {};
        _.raycast && U.handlers && U.eventCount && _.__r3f.root.getState().internal.interaction.push(_);
      },
      getPublicInstance: (_) => _,
      prepareForCommit: () => null,
      preparePortalMount: (_) => bE(_.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(_) {
        var b;
        const {
          attach: M,
          parent: C
        } = (b = _.__r3f) != null ? b : {};
        M && C && Fz(C, _, M), _.isObject3D && (_.visible = !1), TE(_);
      },
      unhideInstance(_, b) {
        var M;
        const {
          attach: C,
          parent: D
        } = (M = _.__r3f) != null ? M : {};
        C && D && G2(D, _, C), (_.isObject3D && b.visible == null || b.visible) && (_.visible = !0), TE(_);
      },
      createTextInstance: v,
      hideTextInstance: v,
      unhideTextInstance: v,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
      // @ts-ignore
      getCurrentEventPriority: () => e ? e() : AE.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && Vo.fun(performance.now) ? performance.now : Vo.fun(Date.now) ? Date.now : () => 0,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
      scheduleTimeout: Vo.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Vo.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: W2
  };
}
var Uz, zz;
const V2 = (n) => "colorSpace" in n || "outputColorSpace" in n, zB = () => {
  var n;
  return (n = CP.ColorManagement) != null ? n : null;
}, kB = (n) => n && n.isOrthographicCamera, bX = (n) => n && n.hasOwnProperty("current"), cM = typeof window < "u" && ((Uz = window.document) != null && Uz.createElement || ((zz = window.navigator) == null ? void 0 : zz.product) === "ReactNative") ? le.useLayoutEffect : le.useEffect;
function IB(n) {
  const e = le.useRef(n);
  return cM(() => void (e.current = n), [n]), e;
}
function TX({
  set: n
}) {
  return cM(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class FB extends le.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
FB.getDerivedStateFromError = () => ({
  error: !0
});
const BB = "__default", kz = /* @__PURE__ */ new Map(), MX = (n) => n && !!n.memoized && !!n.changes;
function HB(n) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const iT = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
}, Vo = {
  obj: (n) => n === Object(n) && !Vo.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(n, e, {
    arrays: t = "shallow",
    objects: r = "reference",
    strict: a = !0
  } = {}) {
    if (typeof n != typeof e || !!n != !!e)
      return !1;
    if (Vo.str(n) || Vo.num(n))
      return n === e;
    const s = Vo.obj(n);
    if (s && r === "reference")
      return n === e;
    const u = Vo.arr(n);
    if (u && t === "reference")
      return n === e;
    if ((u || s) && n === e)
      return !0;
    let h;
    for (h in n)
      if (!(h in e))
        return !1;
    if (s && t === "shallow" && r === "shallow") {
      for (h in a ? e : n)
        if (!Vo.equ(n[h], e[h], {
          strict: a,
          objects: "reference"
        }))
          return !1;
    } else
      for (h in a ? e : n)
        if (n[h] !== e[h])
          return !1;
    if (Vo.und(h)) {
      if (u && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
        return !0;
      if (n !== e)
        return !1;
    }
    return !0;
  }
};
function wX(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n)
    e.dispose == null || e.dispose(), delete n[e];
}
function bE(n, e) {
  const t = n;
  return (e != null && e.primitive || !t.__r3f) && (t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }), n;
}
function oO(n, e) {
  let t = n;
  if (e.includes("-")) {
    const r = e.split("-"), a = r.pop();
    return t = r.reduce((s, u) => s[u], n), {
      target: t,
      key: a
    };
  } else
    return {
      target: t,
      key: e
    };
}
const Iz = /-\d+$/;
function G2(n, e, t) {
  if (Vo.str(t)) {
    if (Iz.test(t)) {
      const s = t.replace(Iz, ""), {
        target: u,
        key: h
      } = oO(n, s);
      Array.isArray(u[h]) || (u[h] = []);
    }
    const {
      target: r,
      key: a
    } = oO(n, t);
    e.__r3f.previousAttach = r[a], r[a] = e;
  } else
    e.__r3f.previousAttach = t(n, e);
}
function Fz(n, e, t) {
  var r, a;
  if (Vo.str(t)) {
    const {
      target: s,
      key: u
    } = oO(n, t), h = e.__r3f.previousAttach;
    h === void 0 ? delete s[u] : s[u] = h;
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e);
  (a = e.__r3f) == null || delete a.previousAttach;
}
function VB(n, {
  children: e,
  key: t,
  ref: r,
  ...a
}, {
  children: s,
  key: u,
  ref: h,
  ...v
} = {}, y = !1) {
  var _;
  const b = (_ = n == null ? void 0 : n.__r3f) != null ? _ : {}, M = Object.entries(a), C = [];
  if (y) {
    const U = Object.keys(v);
    for (let N = 0; N < U.length; N++)
      a.hasOwnProperty(U[N]) || M.unshift([U[N], BB + "remove"]);
  }
  M.forEach(([U, N]) => {
    var O;
    if ((O = n.__r3f) != null && O.primitive && U === "object" || Vo.equ(N, v[U]))
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(U))
      return C.push([U, N, !0, []]);
    let I = [];
    U.includes("-") && (I = U.split("-")), C.push([U, N, !1, I]);
    for (const k in a) {
      const G = a[k];
      k.startsWith(`${U}-`) && C.push([k, G, !1, k.split("-")]);
    }
  });
  const D = {
    ...a
  };
  return b.memoizedProps && b.memoizedProps.args && (D.args = b.memoizedProps.args), b.memoizedProps && b.memoizedProps.attach && (D.attach = b.memoizedProps.attach), {
    memoized: D,
    changes: C
  };
}
function W2(n, e) {
  var t, r, a;
  const s = (t = n.__r3f) != null ? t : {}, u = s.root, h = (r = u == null || u.getState == null ? void 0 : u.getState()) != null ? r : {}, {
    memoized: v,
    changes: y
  } = MX(e) ? e : VB(n, e), _ = s.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = v);
  for (let M = 0; M < y.length; M++) {
    let [C, D, U, N] = y[M];
    if (V2(n)) {
      const G = "srgb", j = "srgb-linear";
      C === "encoding" ? (C = "colorSpace", D = D === 3001 ? G : j) : C === "outputEncoding" && (C = "outputColorSpace", D = D === 3001 ? G : j);
    }
    let O = n, I = O[C];
    if (N.length && (I = N.reduce((k, G) => k[G], n), !(I && I.set))) {
      const [k, ...G] = N.reverse();
      O = G.reverse().reduce((j, Y) => j[Y], n), C = k;
    }
    if (D === BB + "remove")
      if (O.constructor) {
        let k = kz.get(O.constructor);
        k || (k = new O.constructor(), kz.set(O.constructor, k)), D = k[C];
      } else
        D = 0;
    if (U)
      D ? s.handlers[C] = D : delete s.handlers[C], s.eventCount = Object.keys(s.handlers).length;
    else if (I && I.set && (I.copy || I instanceof rx)) {
      if (Array.isArray(D))
        I.fromArray ? I.fromArray(D) : I.set(...D);
      else if (I.copy && D && D.constructor && I.constructor === D.constructor)
        I.copy(D);
      else if (D !== void 0) {
        const k = I instanceof Un;
        !k && I.setScalar ? I.setScalar(D) : I instanceof rx && D instanceof rx ? I.mask = D.mask : I.set(D), !zB() && !h.linear && k && I.convertSRGBToLinear();
      }
    } else if (O[C] = D, O[C] instanceof Rs && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
    O[C].format === dd && O[C].type === Sv) {
      const k = O[C];
      V2(k) && V2(h.gl) ? k.colorSpace = h.gl.outputColorSpace : k.encoding = h.gl.outputEncoding;
    }
    TE(n);
  }
  if (s.parent && h.internal && n.raycast && _ !== s.eventCount) {
    const M = h.internal.interaction.indexOf(n);
    M > -1 && h.internal.interaction.splice(M, 1), s.eventCount && h.internal.interaction.push(n);
  }
  return !(y.length === 1 && y[0][0] === "onUpdate") && y.length && (a = n.__r3f) != null && a.parent && sO(n), n;
}
function TE(n) {
  var e, t;
  const r = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function sO(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function CX(n, e) {
  n.manual || (kB(n) ? (n.left = e.width / -2, n.right = e.width / 2, n.top = e.height / 2, n.bottom = e.height / -2) : n.aspect = e.width / e.height, n.updateProjectionMatrix(), n.updateMatrixWorld());
}
function XC(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function RX() {
  var n;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e)
    return AE.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return AE.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return AE.ContinuousEventPriority;
    default:
      return AE.DefaultEventPriority;
  }
}
function GB(n, e, t, r) {
  const a = t.get(e);
  a && (t.delete(e), t.size === 0 && (n.delete(r), a.target.releasePointerCapture(r)));
}
function AX(n, e) {
  const {
    internal: t
  } = n.getState();
  t.interaction = t.interaction.filter((r) => r !== e), t.initialHits = t.initialHits.filter((r) => r !== e), t.hovered.forEach((r, a) => {
    (r.eventObject === e || r.object === e) && t.hovered.delete(a);
  }), t.capturedMap.forEach((r, a) => {
    GB(t.capturedMap, e, r, a);
  });
}
function DX(n) {
  function e(v) {
    const {
      internal: y
    } = n.getState(), _ = v.offsetX - y.initialClick[0], b = v.offsetY - y.initialClick[1];
    return Math.round(Math.sqrt(_ * _ + b * b));
  }
  function t(v) {
    return v.filter((y) => ["Move", "Over", "Enter", "Out", "Leave"].some((_) => {
      var b;
      return (b = y.__r3f) == null ? void 0 : b.handlers["onPointer" + _];
    }));
  }
  function r(v, y) {
    const _ = n.getState(), b = /* @__PURE__ */ new Set(), M = [], C = y ? y(_.internal.interaction) : _.internal.interaction;
    for (let O = 0; O < C.length; O++) {
      const I = iT(C[O]);
      I && (I.raycaster.camera = void 0);
    }
    _.previousRoot || _.events.compute == null || _.events.compute(v, _);
    function D(O) {
      const I = iT(O);
      if (!I || !I.events.enabled || I.raycaster.camera === null)
        return [];
      if (I.raycaster.camera === void 0) {
        var k;
        I.events.compute == null || I.events.compute(v, I, (k = I.previousRoot) == null ? void 0 : k.getState()), I.raycaster.camera === void 0 && (I.raycaster.camera = null);
      }
      return I.raycaster.camera ? I.raycaster.intersectObject(O, !0) : [];
    }
    let U = C.flatMap(D).sort((O, I) => {
      const k = iT(O.object), G = iT(I.object);
      return !k || !G ? O.distance - I.distance : G.events.priority - k.events.priority || O.distance - I.distance;
    }).filter((O) => {
      const I = XC(O);
      return b.has(I) ? !1 : (b.add(I), !0);
    });
    _.events.filter && (U = _.events.filter(U, _));
    for (const O of U) {
      let I = O.object;
      for (; I; ) {
        var N;
        (N = I.__r3f) != null && N.eventCount && M.push({
          ...O,
          eventObject: I
        }), I = I.parent;
      }
    }
    if ("pointerId" in v && _.internal.capturedMap.has(v.pointerId))
      for (let O of _.internal.capturedMap.get(v.pointerId).values())
        b.has(XC(O.intersection)) || M.push(O.intersection);
    return M;
  }
  function a(v, y, _, b) {
    const M = n.getState();
    if (v.length) {
      const C = {
        stopped: !1
      };
      for (const D of v) {
        const U = iT(D.object) || M, {
          raycaster: N,
          pointer: O,
          camera: I,
          internal: k
        } = U, G = new be(O.x, O.y, 0).unproject(I), j = (q) => {
          var oe, ye;
          return (oe = (ye = k.capturedMap.get(q)) == null ? void 0 : ye.has(D.eventObject)) != null ? oe : !1;
        }, Y = (q) => {
          const oe = {
            intersection: D,
            target: y.target
          };
          k.capturedMap.has(q) ? k.capturedMap.get(q).set(D.eventObject, oe) : k.capturedMap.set(q, /* @__PURE__ */ new Map([[D.eventObject, oe]])), y.target.setPointerCapture(q);
        }, Z = (q) => {
          const oe = k.capturedMap.get(q);
          oe && GB(k.capturedMap, D.eventObject, oe, q);
        };
        let te = {};
        for (let q in y) {
          let oe = y[q];
          typeof oe != "function" && (te[q] = oe);
        }
        let J = {
          ...D,
          ...te,
          pointer: O,
          intersections: v,
          stopped: C.stopped,
          delta: _,
          unprojectedPoint: G,
          ray: N.ray,
          camera: I,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const q = "pointerId" in y && k.capturedMap.get(y.pointerId);
            if (
              // ...if this pointer hasn't been captured
              (!q || // ... or if the hit object is capturing the pointer
              q.has(D.eventObject)) && (J.stopped = C.stopped = !0, k.hovered.size && Array.from(k.hovered.values()).find((oe) => oe.eventObject === D.eventObject))
            ) {
              const oe = v.slice(0, v.indexOf(D));
              s([...oe, D]);
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture: j,
            setPointerCapture: Y,
            releasePointerCapture: Z
          },
          currentTarget: {
            hasPointerCapture: j,
            setPointerCapture: Y,
            releasePointerCapture: Z
          },
          nativeEvent: y
        };
        if (b(J), C.stopped === !0)
          break;
      }
    }
    return v;
  }
  function s(v) {
    const {
      internal: y
    } = n.getState();
    for (const _ of y.hovered.values())
      if (!v.length || !v.find((b) => b.object === _.object && b.index === _.index && b.instanceId === _.instanceId)) {
        const M = _.eventObject.__r3f, C = M == null ? void 0 : M.handlers;
        if (y.hovered.delete(XC(_)), M != null && M.eventCount) {
          const D = {
            ..._,
            intersections: v
          };
          C.onPointerOut == null || C.onPointerOut(D), C.onPointerLeave == null || C.onPointerLeave(D);
        }
      }
  }
  function u(v, y) {
    for (let _ = 0; _ < y.length; _++) {
      const b = y[_].__r3f;
      b == null || b.handlers.onPointerMissed == null || b.handlers.onPointerMissed(v);
    }
  }
  function h(v) {
    switch (v) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (y) => {
          const {
            internal: _
          } = n.getState();
          "pointerId" in y && _.capturedMap.has(y.pointerId) && requestAnimationFrame(() => {
            _.capturedMap.has(y.pointerId) && (_.capturedMap.delete(y.pointerId), s([]));
          });
        };
    }
    return function(_) {
      const {
        onPointerMissed: b,
        internal: M
      } = n.getState();
      M.lastEvent.current = _;
      const C = v === "onPointerMove", D = v === "onClick" || v === "onContextMenu" || v === "onDoubleClick", N = r(_, C ? t : void 0), O = D ? e(_) : 0;
      v === "onPointerDown" && (M.initialClick = [_.offsetX, _.offsetY], M.initialHits = N.map((k) => k.eventObject)), D && !N.length && O <= 2 && (u(_, M.interaction), b && b(_)), C && s(N);
      function I(k) {
        const G = k.eventObject, j = G.__r3f, Y = j == null ? void 0 : j.handlers;
        if (j != null && j.eventCount)
          if (C) {
            if (Y.onPointerOver || Y.onPointerEnter || Y.onPointerOut || Y.onPointerLeave) {
              const Z = XC(k), te = M.hovered.get(Z);
              te ? te.stopped && k.stopPropagation() : (M.hovered.set(Z, k), Y.onPointerOver == null || Y.onPointerOver(k), Y.onPointerEnter == null || Y.onPointerEnter(k));
            }
            Y.onPointerMove == null || Y.onPointerMove(k);
          } else {
            const Z = Y[v];
            Z ? (!D || M.initialHits.includes(G)) && (u(_, M.interaction.filter((te) => !M.initialHits.includes(te))), Z(k)) : D && M.initialHits.includes(G) && u(_, M.interaction.filter((te) => !M.initialHits.includes(te)));
          }
      }
      a(N, _, O, I);
    };
  }
  return {
    handlePointer: h
  };
}
const WB = (n) => !!(n != null && n.render), jB = /* @__PURE__ */ le.createContext(null), LX = (n, e) => {
  const t = UB((h, v) => {
    const y = new be(), _ = new be(), b = new be();
    function M(O = v().camera, I = _, k = v().size) {
      const {
        width: G,
        height: j,
        top: Y,
        left: Z
      } = k, te = G / j;
      I instanceof be ? b.copy(I) : b.set(...I);
      const J = O.getWorldPosition(y).distanceTo(b);
      if (kB(O))
        return {
          width: G / O.zoom,
          height: j / O.zoom,
          top: Y,
          left: Z,
          factor: 1,
          distance: J,
          aspect: te
        };
      {
        const q = O.fov * Math.PI / 180, oe = 2 * Math.tan(q / 2) * J, ye = oe * (G / j);
        return {
          width: ye,
          height: oe,
          top: Y,
          left: Z,
          factor: G / ye,
          distance: J,
          aspect: te
        };
      }
    }
    let C;
    const D = (O) => h((I) => ({
      performance: {
        ...I.performance,
        current: O
      }
    })), U = new It();
    return {
      set: h,
      get: v,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      scene: null,
      invalidate: (O = 1) => n(v(), O),
      advance: (O, I) => e(O, I, v()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new EP(),
      pointer: U,
      mouse: U,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const O = v();
          C && clearTimeout(C), O.performance.current !== O.performance.min && D(O.performance.min), C = setTimeout(() => D(v().performance.max), O.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: M
      },
      setEvents: (O) => h((I) => ({
        ...I,
        events: {
          ...I.events,
          ...O
        }
      })),
      setSize: (O, I, k, G, j) => {
        const Y = v().camera, Z = {
          width: O,
          height: I,
          top: G || 0,
          left: j || 0,
          updateStyle: k
        };
        h((te) => ({
          size: Z,
          viewport: {
            ...te.viewport,
            ...M(Y, _, Z)
          }
        }));
      },
      setDpr: (O) => h((I) => {
        const k = HB(O);
        return {
          viewport: {
            ...I.viewport,
            dpr: k,
            initialDpr: I.viewport.initialDpr || k
          }
        };
      }),
      setFrameloop: (O = "always") => {
        const I = v().clock;
        I.stop(), I.elapsedTime = 0, O !== "never" && (I.start(), I.elapsedTime = 0), h(() => ({
          frameloop: O
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ le.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (O, I, k) => {
          const G = v().internal;
          return G.priority = G.priority + (I > 0 ? 1 : 0), G.subscribers.push({
            ref: O,
            priority: I,
            store: k
          }), G.subscribers = G.subscribers.sort((j, Y) => j.priority - Y.priority), () => {
            const j = v().internal;
            j != null && j.subscribers && (j.priority = j.priority - (I > 0 ? 1 : 0), j.subscribers = j.subscribers.filter((Y) => Y.ref !== O));
          };
        }
      }
    };
  }), r = t.getState();
  let a = r.size, s = r.viewport.dpr, u = r.camera;
  return t.subscribe(() => {
    const {
      camera: h,
      size: v,
      viewport: y,
      gl: _,
      set: b
    } = t.getState();
    if (v !== a || y.dpr !== s) {
      var M;
      a = v, s = y.dpr, CX(h, v), _.setPixelRatio(y.dpr);
      const C = (M = v.updateStyle) != null ? M : typeof HTMLCanvasElement < "u" && _.domElement instanceof HTMLCanvasElement;
      _.setSize(v.width, v.height, C);
    }
    h !== u && (u = h, b((C) => ({
      viewport: {
        ...C.viewport,
        ...C.viewport.getCurrentViewport(h)
      }
    })));
  }), t.subscribe((h) => n(h)), t;
};
let qC, OX = /* @__PURE__ */ new Set(), PX = /* @__PURE__ */ new Set(), NX = /* @__PURE__ */ new Set();
function j2(n, e) {
  if (n.size)
    for (const {
      callback: t
    } of n.values())
      t(e);
}
function aT(n, e) {
  switch (n) {
    case "before":
      return j2(OX, e);
    case "after":
      return j2(PX, e);
    case "tail":
      return j2(NX, e);
  }
}
let $2, Y2;
function X2(n, e, t) {
  let r = e.clock.getDelta();
  for (e.frameloop === "never" && typeof n == "number" && (r = n - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n), $2 = e.internal.subscribers, qC = 0; qC < $2.length; qC++)
    Y2 = $2[qC], Y2.ref.current(Y2.store.getState(), r, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function UX(n) {
  let e = !1, t, r, a;
  function s(v) {
    r = requestAnimationFrame(s), e = !0, t = 0, aT("before", v);
    for (const _ of n.values()) {
      var y;
      a = _.store.getState(), a.internal.active && (a.frameloop === "always" || a.internal.frames > 0) && !((y = a.gl.xr) != null && y.isPresenting) && (t += X2(v, a));
    }
    if (aT("after", v), t === 0)
      return aT("tail", v), e = !1, cancelAnimationFrame(r);
  }
  function u(v, y = 1) {
    var _;
    if (!v)
      return n.forEach((b) => u(b.store.getState()), y);
    (_ = v.gl.xr) != null && _.isPresenting || !v.internal.active || v.frameloop === "never" || (v.internal.frames = Math.min(60, v.internal.frames + y), e || (e = !0, requestAnimationFrame(s)));
  }
  function h(v, y = !0, _, b) {
    if (y && aT("before", v), _)
      X2(v, _, b);
    else
      for (const M of n.values())
        X2(v, M.store.getState());
    y && aT("after", v);
  }
  return {
    loop: s,
    /**
     * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.
     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate
     */
    invalidate: u,
    /**
     * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop="never"`.
     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance
     */
    advance: h
  };
}
function $B() {
  const n = le.useContext(jB);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function hv(n = (t) => t, e) {
  return $B()(n, e);
}
function RP(n, e = 0) {
  const t = $B(), r = t.getState().internal.subscribe, a = IB(n);
  return cM(() => r(a, e, t), [e, r, t]), null;
}
const FE = /* @__PURE__ */ new Map(), {
  invalidate: Bz,
  advance: Hz
} = UX(FE), {
  reconciler: _R,
  applyProps: yE
} = EX(FE, RX), SE = {
  objects: "shallow",
  strict: !1
}, zX = (n, e) => {
  const t = typeof n == "function" ? n(e) : n;
  return WB(t) ? t : new rP({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...n
  });
};
function kX(n, e) {
  if (e)
    return e;
  if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) {
    const {
      width: t,
      height: r,
      top: a,
      left: s
    } = n.parentElement.getBoundingClientRect();
    return {
      width: t,
      height: r,
      top: a,
      left: s
    };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function IX(n) {
  const e = FE.get(n), t = e == null ? void 0 : e.fiber, r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const a = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), s = r || LX(Bz, Hz), u = t || _R.createContainer(s, AE.ConcurrentRoot, null, !1, null, "", a, null);
  e || FE.set(n, {
    fiber: u,
    store: s
  });
  let h, v = !1, y;
  return {
    configure(_ = {}) {
      let {
        gl: b,
        size: M,
        scene: C,
        events: D,
        onCreated: U,
        shadows: N = !1,
        linear: O = !1,
        flat: I = !1,
        legacy: k = !1,
        orthographic: G = !1,
        frameloop: j = "always",
        dpr: Y = [1, 2],
        performance: Z,
        raycaster: te,
        camera: J,
        onPointerMissed: q
      } = _, oe = s.getState(), ye = oe.gl;
      oe.gl || oe.set({
        gl: ye = zX(b, n)
      });
      let de = oe.raycaster;
      de || oe.set({
        raycaster: de = new wP()
      });
      const {
        params: xe,
        ...Re
      } = te || {};
      if (Vo.equ(Re, de, SE) || yE(de, {
        ...Re
      }), Vo.equ(xe, de.params, SE) || yE(de, {
        params: {
          ...de.params,
          ...xe
        }
      }), !oe.camera || oe.camera === y && !Vo.equ(y, J, SE)) {
        y = J;
        const me = J instanceof qT, ce = me ? J : G ? new zg(0, 0, 0, 0, 0.1, 1e3) : new Cs(75, 0, 0.1, 1e3);
        me || (ce.position.z = 5, J && yE(ce, J), !oe.camera && !(J != null && J.rotation) && ce.lookAt(0, 0, 0)), oe.set({
          camera: ce
        });
      }
      if (!oe.scene) {
        let me;
        C instanceof SR ? me = C : (me = new SR(), C && yE(me, C)), oe.set({
          scene: bE(me)
        });
      }
      if (!oe.xr) {
        const me = (Oe, Ze) => {
          const je = s.getState();
          je.frameloop !== "never" && Hz(Oe, !0, je, Ze);
        }, ce = () => {
          const Oe = s.getState();
          Oe.gl.xr.enabled = Oe.gl.xr.isPresenting, Oe.gl.xr.setAnimationLoop(Oe.gl.xr.isPresenting ? me : null), Oe.gl.xr.isPresenting || Bz(Oe);
        }, Ue = {
          connect() {
            const Oe = s.getState().gl;
            Oe.xr.addEventListener("sessionstart", ce), Oe.xr.addEventListener("sessionend", ce);
          },
          disconnect() {
            const Oe = s.getState().gl;
            Oe.xr.removeEventListener("sessionstart", ce), Oe.xr.removeEventListener("sessionend", ce);
          }
        };
        ye.xr && Ue.connect(), oe.set({
          xr: Ue
        });
      }
      if (ye.shadowMap) {
        const me = ye.shadowMap.enabled, ce = ye.shadowMap.type;
        if (ye.shadowMap.enabled = !!N, Vo.boo(N))
          ye.shadowMap.type = pT;
        else if (Vo.str(N)) {
          var Pe;
          const Ue = {
            basic: OI,
            percentage: IR,
            soft: pT,
            variance: Zp
          };
          ye.shadowMap.type = (Pe = Ue[N]) != null ? Pe : pT;
        } else
          Vo.obj(N) && Object.assign(ye.shadowMap, N);
        (me !== ye.shadowMap.enabled || ce !== ye.shadowMap.type) && (ye.shadowMap.needsUpdate = !0);
      }
      const Te = zB();
      Te && ("enabled" in Te ? Te.enabled = !k : "legacyMode" in Te && (Te.legacyMode = k)), yE(ye, {
        outputEncoding: O ? 3e3 : 3001,
        toneMapping: I ? em : IO
      }), oe.legacy !== k && oe.set(() => ({
        legacy: k
      })), oe.linear !== O && oe.set(() => ({
        linear: O
      })), oe.flat !== I && oe.set(() => ({
        flat: I
      })), b && !Vo.fun(b) && !WB(b) && !Vo.equ(b, ye, SE) && yE(ye, b), D && !oe.events.handlers && oe.set({
        events: D(s)
      });
      const X = kX(n, M);
      return Vo.equ(X, oe.size, SE) || oe.setSize(X.width, X.height, X.updateStyle, X.top, X.left), Y && oe.viewport.dpr !== HB(Y) && oe.setDpr(Y), oe.frameloop !== j && oe.setFrameloop(j), oe.onPointerMissed || oe.set({
        onPointerMissed: q
      }), Z && !Vo.equ(Z, oe.performance, SE) && oe.set((me) => ({
        performance: {
          ...me.performance,
          ...Z
        }
      })), h = U, v = !0, this;
    },
    render(_) {
      return v || this.configure(), _R.updateContainer(/* @__PURE__ */ le.createElement(FX, {
        store: s,
        children: _,
        onCreated: h,
        rootElement: n
      }), u, null, () => {
      }), s;
    },
    unmount() {
      YB(n);
    }
  };
}
function FX({
  store: n,
  children: e,
  onCreated: t,
  rootElement: r
}) {
  return cM(() => {
    const a = n.getState();
    a.set((s) => ({
      internal: {
        ...s.internal,
        active: !0
      }
    })), t && t(a), n.getState().events.connected || a.events.connect == null || a.events.connect(r);
  }, []), /* @__PURE__ */ le.createElement(jB.Provider, {
    value: n
  }, e);
}
function YB(n, e) {
  const t = FE.get(n), r = t == null ? void 0 : t.fiber;
  if (r) {
    const a = t == null ? void 0 : t.store.getState();
    a && (a.internal.active = !1), _R.updateContainer(null, r, null, () => {
      a && setTimeout(() => {
        try {
          var s, u, h, v;
          a.events.disconnect == null || a.events.disconnect(), (s = a.gl) == null || (u = s.renderLists) == null || u.dispose == null || u.dispose(), (h = a.gl) == null || h.forceContextLoss == null || h.forceContextLoss(), (v = a.gl) != null && v.xr && a.xr.disconnect(), wX(a), FE.delete(n), e && e(n);
        } catch {
        }
      }, 500);
    });
  }
}
_R.injectIntoDevTools({
  bundleType: process.env.NODE_ENV === "production" ? 0 : 1,
  rendererPackageName: "@react-three/fiber",
  version: le.version
});
function HT() {
  return HT = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, HT.apply(null, arguments);
}
function lO(n, e, t) {
  var r, a, s, u, h;
  e == null && (e = 100);
  function v() {
    var _ = Date.now() - u;
    _ < e && _ >= 0 ? r = setTimeout(v, e - _) : (r = null, t || (h = n.apply(s, a), s = a = null));
  }
  var y = function() {
    s = this, a = arguments, u = Date.now();
    var _ = t && !r;
    return r || (r = setTimeout(v, e)), _ && (h = n.apply(s, a), s = a = null), h;
  };
  return y.clear = function() {
    r && (clearTimeout(r), r = null);
  }, y.flush = function() {
    r && (h = n.apply(s, a), s = a = null, clearTimeout(r), r = null);
  }, y;
}
lO.debounce = lO;
var BX = lO;
const Vz = /* @__PURE__ */ GE(BX);
function HX(n) {
  let {
    debounce: e,
    scroll: t,
    polyfill: r,
    offsetSize: a
  } = n === void 0 ? {
    debounce: 0,
    scroll: !1,
    offsetSize: !1
  } : n;
  const s = r || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!s)
    throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [u, h] = le.useState({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  }), v = le.useRef({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: u
  }), y = e ? typeof e == "number" ? e : e.scroll : null, _ = e ? typeof e == "number" ? e : e.resize : null, b = le.useRef(!1);
  le.useEffect(() => (b.current = !0, () => void (b.current = !1)));
  const [M, C, D] = le.useMemo(() => {
    const I = () => {
      if (!v.current.element)
        return;
      const {
        left: k,
        top: G,
        width: j,
        height: Y,
        bottom: Z,
        right: te,
        x: J,
        y: q
      } = v.current.element.getBoundingClientRect(), oe = {
        left: k,
        top: G,
        width: j,
        height: Y,
        bottom: Z,
        right: te,
        x: J,
        y: q
      };
      v.current.element instanceof HTMLElement && a && (oe.height = v.current.element.offsetHeight, oe.width = v.current.element.offsetWidth), Object.freeze(oe), b.current && !jX(v.current.lastBounds, oe) && h(v.current.lastBounds = oe);
    };
    return [I, _ ? Vz(I, _) : I, y ? Vz(I, y) : I];
  }, [h, a, y, _]);
  function U() {
    v.current.scrollContainers && (v.current.scrollContainers.forEach((I) => I.removeEventListener("scroll", D, !0)), v.current.scrollContainers = null), v.current.resizeObserver && (v.current.resizeObserver.disconnect(), v.current.resizeObserver = null);
  }
  function N() {
    v.current.element && (v.current.resizeObserver = new s(D), v.current.resizeObserver.observe(v.current.element), t && v.current.scrollContainers && v.current.scrollContainers.forEach((I) => I.addEventListener("scroll", D, {
      capture: !0,
      passive: !0
    })));
  }
  const O = (I) => {
    !I || I === v.current.element || (U(), v.current.element = I, v.current.scrollContainers = XB(I), N());
  };
  return GX(D, !!t), VX(C), le.useEffect(() => {
    U(), N();
  }, [t, D, C]), le.useEffect(() => U, []), [O, u, M];
}
function VX(n) {
  le.useEffect(() => {
    const e = n;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [n]);
}
function GX(n, e) {
  le.useEffect(() => {
    if (e) {
      const t = n;
      return window.addEventListener("scroll", t, {
        capture: !0,
        passive: !0
      }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [n, e]);
}
function XB(n) {
  const e = [];
  if (!n || n === document.body)
    return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: a
  } = window.getComputedStyle(n);
  return [t, r, a].some((s) => s === "auto" || s === "scroll") && e.push(n), [...e, ...XB(n.parentElement)];
}
const WX = ["x", "y", "top", "bottom", "left", "right", "width", "height"], jX = (n, e) => WX.every((t) => n[t] === e[t]);
var $X = Object.defineProperty, YX = Object.defineProperties, XX = Object.getOwnPropertyDescriptors, Gz = Object.getOwnPropertySymbols, qX = Object.prototype.hasOwnProperty, KX = Object.prototype.propertyIsEnumerable, Wz = (n, e, t) => e in n ? $X(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, jz = (n, e) => {
  for (var t in e || (e = {}))
    qX.call(e, t) && Wz(n, t, e[t]);
  if (Gz)
    for (var t of Gz(e))
      KX.call(e, t) && Wz(n, t, e[t]);
  return n;
}, QX = (n, e) => YX(n, XX(e)), $z, Yz;
typeof window < "u" && (($z = window.document) != null && $z.createElement || ((Yz = window.navigator) == null ? void 0 : Yz.product) === "ReactNative") ? le.useLayoutEffect : le.useEffect;
function qB(n, e, t) {
  if (!n)
    return;
  if (t(n) === !0)
    return n;
  let r = e ? n.return : n.child;
  for (; r; ) {
    const a = qB(r, e, t);
    if (a)
      return a;
    r = e ? null : r.sibling;
  }
}
function KB(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return n;
  }
}
const Xz = console.error;
console.error = function() {
  const n = [...arguments].join("");
  if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
    console.error = Xz;
    return;
  }
  return Xz.apply(this, arguments);
};
const AP = KB(le.createContext(null));
class QB extends le.Component {
  render() {
    return /* @__PURE__ */ le.createElement(AP.Provider, {
      value: this._reactInternals
    }, this.props.children);
  }
}
function ZX() {
  const n = le.useContext(AP);
  if (n === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = le.useId();
  return le.useMemo(() => {
    for (const r of [n, n == null ? void 0 : n.alternate]) {
      if (!r)
        continue;
      const a = qB(r, !1, (s) => {
        let u = s.memoizedState;
        for (; u; ) {
          if (u.memoizedState === e)
            return !0;
          u = u.next;
        }
      });
      if (a)
        return a;
    }
  }, [n, e]);
}
function JX() {
  const n = ZX(), [e] = le.useState(() => /* @__PURE__ */ new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const a = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
      a && a !== AP && !e.has(a) && e.set(a, le.useContext(KB(a)));
    }
    t = t.return;
  }
  return e;
}
function eq() {
  const n = JX();
  return le.useMemo(
    () => Array.from(n.keys()).reduce(
      (e, t) => (r) => /* @__PURE__ */ le.createElement(e, null, /* @__PURE__ */ le.createElement(t.Provider, QX(jz({}, r), {
        value: n.get(t)
      }))),
      (e) => /* @__PURE__ */ le.createElement(QB, jz({}, e))
    ),
    [n]
  );
}
const q2 = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function tq(n) {
  const {
    handlePointer: e
  } = DX(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, a) {
      r.pointer.set(t.offsetX / r.size.width * 2 - 1, -(t.offsetY / r.size.height) * 2 + 1), r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(q2).reduce((t, r) => ({
      ...t,
      [r]: e(r)
    }), {}),
    update: () => {
      var t;
      const {
        events: r,
        internal: a
      } = n.getState();
      (t = a.lastEvent) != null && t.current && r.handlers && r.handlers.onPointerMove(a.lastEvent.current);
    },
    connect: (t) => {
      var r;
      const {
        set: a,
        events: s
      } = n.getState();
      s.disconnect == null || s.disconnect(), a((u) => ({
        events: {
          ...u.events,
          connected: t
        }
      })), Object.entries((r = s.handlers) != null ? r : []).forEach(([u, h]) => {
        const [v, y] = q2[u];
        t.addEventListener(v, h, {
          passive: y
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: r
      } = n.getState();
      if (r.connected) {
        var a;
        Object.entries((a = r.handlers) != null ? a : []).forEach(([s, u]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [h] = q2[s];
            r.connected.removeEventListener(h, u);
          }
        }), t((s) => ({
          events: {
            ...s.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
const nq = /* @__PURE__ */ le.forwardRef(function({
  children: e,
  fallback: t,
  resize: r,
  style: a,
  gl: s,
  events: u = tq,
  eventSource: h,
  eventPrefix: v,
  shadows: y,
  linear: _,
  flat: b,
  legacy: M,
  orthographic: C,
  frameloop: D,
  dpr: U,
  performance: N,
  raycaster: O,
  camera: I,
  onPointerMissed: k,
  onCreated: G,
  ...j
}, Y) {
  le.useMemo(() => _X(cX), []);
  const Z = eq(), [te, J] = HX({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...r
  }), q = le.useRef(null), oe = le.useRef(null);
  le.useImperativeHandle(Y, () => q.current);
  const ye = IB(k), [de, xe] = le.useState(!1), [Re, Pe] = le.useState(!1);
  if (de)
    throw de;
  if (Re)
    throw Re;
  const Te = le.useRef(null);
  cM(() => {
    const we = q.current;
    J.width > 0 && J.height > 0 && we && (Te.current || (Te.current = IX(we)), Te.current.configure({
      gl: s,
      events: u,
      shadows: y,
      linear: _,
      flat: b,
      legacy: M,
      orthographic: C,
      frameloop: D,
      dpr: U,
      performance: N,
      raycaster: O,
      camera: I,
      size: J,
      // Pass mutable reference to onPointerMissed so it's free to update
      onPointerMissed: (...X) => ye.current == null ? void 0 : ye.current(...X),
      onCreated: (X) => {
        X.events.connect == null || X.events.connect(h ? bX(h) ? h.current : h : oe.current), v && X.setEvents({
          compute: (me, ce) => {
            const Ue = me[v + "X"], Oe = me[v + "Y"];
            ce.pointer.set(Ue / ce.size.width * 2 - 1, -(Oe / ce.size.height) * 2 + 1), ce.raycaster.setFromCamera(ce.pointer, ce.camera);
          }
        }), G == null || G(X);
      }
    }), Te.current.render(/* @__PURE__ */ le.createElement(Z, null, /* @__PURE__ */ le.createElement(FB, {
      set: Pe
    }, /* @__PURE__ */ le.createElement(le.Suspense, {
      fallback: /* @__PURE__ */ le.createElement(TX, {
        set: xe
      })
    }, e)))));
  }), le.useEffect(() => {
    const we = q.current;
    if (we)
      return () => YB(we);
  }, []);
  const ue = h ? "none" : "auto";
  return /* @__PURE__ */ le.createElement("div", HT({
    ref: oe,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: ue,
      ...a
    }
  }, j), /* @__PURE__ */ le.createElement("div", {
    ref: te,
    style: {
      width: "100%",
      height: "100%"
    }
  }, /* @__PURE__ */ le.createElement("canvas", {
    ref: q,
    style: {
      display: "block"
    }
  }, t)));
}), rq = /* @__PURE__ */ le.forwardRef(function(e, t) {
  return /* @__PURE__ */ le.createElement(QB, null, /* @__PURE__ */ le.createElement(nq, HT({}, e, {
    ref: t
  })));
});
function iq(n, e, t) {
  return Math.max(e, Math.min(n, t));
}
const Lc = {
  toVector(n, e) {
    return n === void 0 && (n = e), Array.isArray(n) ? n : [n, n];
  },
  add(n, e) {
    return [n[0] + e[0], n[1] + e[1]];
  },
  sub(n, e) {
    return [n[0] - e[0], n[1] - e[1]];
  },
  addTo(n, e) {
    n[0] += e[0], n[1] += e[1];
  },
  subTo(n, e) {
    n[0] -= e[0], n[1] -= e[1];
  }
};
function qz(n, e, t) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(n, t * 5) : n * e * t / (e + t * n);
}
function Kz(n, e, t, r = 0.15) {
  return r === 0 ? iq(n, e, t) : n < e ? -qz(e - n, t - e, r) + e : n > t ? +qz(n - t, t - e, r) + t : n;
}
function aq(n, [e, t], [r, a]) {
  const [[s, u], [h, v]] = n;
  return [Kz(e, s, u, r), Kz(t, h, v, a)];
}
function oq(n, e) {
  if (typeof n != "object" || n === null)
    return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (typeof r != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function sq(n) {
  var e = oq(n, "string");
  return typeof e == "symbol" ? e : String(e);
}
function cd(n, e, t) {
  return e = sq(e), e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Qz(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(n, a).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function os(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Qz(Object(t), !0).forEach(function(r) {
      cd(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Qz(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
const ZB = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function Zz(n) {
  return n ? n[0].toUpperCase() + n.slice(1) : "";
}
const lq = ["enter", "leave"];
function uq(n = !1, e) {
  return n && !lq.includes(e);
}
function cq(n, e = "", t = !1) {
  const r = ZB[n], a = r && r[e] || e;
  return "on" + Zz(n) + Zz(a) + (uq(t, a) ? "Capture" : "");
}
const fq = ["gotpointercapture", "lostpointercapture"];
function dq(n) {
  let e = n.substring(2).toLowerCase();
  const t = !!~e.indexOf("passive");
  t && (e = e.replace("passive", ""));
  const r = fq.includes(e) ? "capturecapture" : "capture", a = !!~e.indexOf(r);
  return a && (e = e.replace("capture", "")), {
    device: e,
    capture: a,
    passive: t
  };
}
function hq(n, e = "") {
  const t = ZB[n], r = t && t[e] || e;
  return n + r;
}
function eA(n) {
  return "touches" in n;
}
function JB(n) {
  return eA(n) ? "touch" : "pointerType" in n ? n.pointerType : "mouse";
}
function pq(n) {
  return Array.from(n.touches).filter((e) => {
    var t, r;
    return e.target === n.currentTarget || ((t = n.currentTarget) === null || t === void 0 || (r = t.contains) === null || r === void 0 ? void 0 : r.call(t, e.target));
  });
}
function mq(n) {
  return n.type === "touchend" || n.type === "touchcancel" ? n.changedTouches : n.targetTouches;
}
function eH(n) {
  return eA(n) ? mq(n)[0] : n;
}
function vq(n) {
  return pq(n).map((e) => e.identifier);
}
function K2(n) {
  const e = eH(n);
  return eA(n) ? e.identifier : e.pointerId;
}
function Jz(n) {
  const e = eH(n);
  return [e.clientX, e.clientY];
}
function gq(n) {
  const e = {};
  if ("buttons" in n && (e.buttons = n.buttons), "shiftKey" in n) {
    const {
      shiftKey: t,
      altKey: r,
      metaKey: a,
      ctrlKey: s
    } = n;
    Object.assign(e, {
      shiftKey: t,
      altKey: r,
      metaKey: a,
      ctrlKey: s
    });
  }
  return e;
}
function ER(n, ...e) {
  return typeof n == "function" ? n(...e) : n;
}
function yq() {
}
function Sq(...n) {
  return n.length === 0 ? yq : n.length === 1 ? n[0] : function() {
    let e;
    for (const t of n)
      e = t.apply(this, arguments) || e;
    return e;
  };
}
function ek(n, e) {
  return Object.assign({}, e, n || {});
}
const xq = 32;
class _q {
  constructor(e, t, r) {
    this.ctrl = e, this.args = t, this.key = r, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(e) {
    this.ctrl.state[this.key] = e;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: e,
      shared: t,
      ingKey: r,
      args: a
    } = this;
    t[r] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], e.args = a, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0;
  }
  start(e) {
    const t = this.state, r = this.config;
    t._active || (this.reset(), this.computeInitial(), t._active = !0, t.target = e.target, t.currentTarget = e.currentTarget, t.lastOffset = r.from ? ER(r.from, t) : t.offset, t.offset = t.lastOffset, t.startTime = t.timeStamp = e.timeStamp);
  }
  computeValues(e) {
    const t = this.state;
    t._values = e, t.values = this.config.transform(e);
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values;
  }
  compute(e) {
    const {
      state: t,
      config: r,
      shared: a
    } = this;
    t.args = this.args;
    let s = 0;
    if (e && (t.event = e, r.preventDefault && e.cancelable && t.event.preventDefault(), t.type = e.type, a.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, a.locked = !!document.pointerLockElement, Object.assign(a, gq(e)), a.down = a.pressed = a.buttons % 2 === 1 || a.touches > 0, s = e.timeStamp - t.timeStamp, t.timeStamp = e.timeStamp, t.elapsedTime = t.timeStamp - t.startTime), t._active) {
      const Y = t._delta.map(Math.abs);
      Lc.addTo(t._distance, Y);
    }
    this.axisIntent && this.axisIntent(e);
    const [u, h] = t._movement, [v, y] = r.threshold, {
      _step: _,
      values: b
    } = t;
    if (r.hasCustomTransform ? (_[0] === !1 && (_[0] = Math.abs(u) >= v && b[0]), _[1] === !1 && (_[1] = Math.abs(h) >= y && b[1])) : (_[0] === !1 && (_[0] = Math.abs(u) >= v && Math.sign(u) * v), _[1] === !1 && (_[1] = Math.abs(h) >= y && Math.sign(h) * y)), t.intentional = _[0] !== !1 || _[1] !== !1, !t.intentional)
      return;
    const M = [0, 0];
    if (r.hasCustomTransform) {
      const [Y, Z] = b;
      M[0] = _[0] !== !1 ? Y - _[0] : 0, M[1] = _[1] !== !1 ? Z - _[1] : 0;
    } else
      M[0] = _[0] !== !1 ? u - _[0] : 0, M[1] = _[1] !== !1 ? h - _[1] : 0;
    this.restrictToAxis && !t._blocked && this.restrictToAxis(M);
    const C = t.offset, D = t._active && !t._blocked || t.active;
    D && (t.first = t._active && !t.active, t.last = !t._active && t.active, t.active = a[this.ingKey] = t._active, e && (t.first && ("bounds" in r && (t._bounds = ER(r.bounds, t)), this.setup && this.setup()), t.movement = M, this.computeOffset()));
    const [U, N] = t.offset, [[O, I], [k, G]] = t._bounds;
    t.overflow = [U < O ? -1 : U > I ? 1 : 0, N < k ? -1 : N > G ? 1 : 0], t._movementBound[0] = t.overflow[0] ? t._movementBound[0] === !1 ? t._movement[0] : t._movementBound[0] : !1, t._movementBound[1] = t.overflow[1] ? t._movementBound[1] === !1 ? t._movement[1] : t._movementBound[1] : !1;
    const j = t._active ? r.rubberband || [0, 0] : [0, 0];
    if (t.offset = aq(t._bounds, t.offset, j), t.delta = Lc.sub(t.offset, C), this.computeMovement(), D && (!t.last || s > xq)) {
      t.delta = Lc.sub(t.offset, C);
      const Y = t.delta.map(Math.abs);
      Lc.addTo(t.distance, Y), t.direction = t.delta.map(Math.sign), t._direction = t._delta.map(Math.sign), !t.first && s > 0 && (t.velocity = [Y[0] / s, Y[1] / s], t.timeDelta = s);
    }
  }
  emit() {
    const e = this.state, t = this.shared, r = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !r.triggerAllEvents)
      return;
    const a = this.handler(os(os(os({}, t), e), {}, {
      [this.aliasKey]: e.values
    }));
    a !== void 0 && (e.memo = a);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function Eq([n, e], t) {
  const r = Math.abs(n), a = Math.abs(e);
  if (r > a && r > t)
    return "x";
  if (a > r && a > t)
    return "y";
}
class bq extends _q {
  constructor(...e) {
    super(...e), cd(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = Lc.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = Lc.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(e) {
    const t = this.state, r = this.config;
    if (!t.axis && e) {
      const a = typeof r.axisThreshold == "object" ? r.axisThreshold[JB(e)] : r.axisThreshold;
      t.axis = Eq(t._movement, a);
    }
    t._blocked = (r.lockDirection || !!r.axis) && !t.axis || !!r.axis && r.axis !== t.axis;
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          e[1] = 0;
          break;
        case "y":
          e[0] = 0;
          break;
      }
  }
}
const tk = (n) => n, nk = 0.15, DP = {
  enabled(n = !0) {
    return n;
  },
  eventOptions(n, e, t) {
    return os(os({}, t.shared.eventOptions), n);
  },
  preventDefault(n = !1) {
    return n;
  },
  triggerAllEvents(n = !1) {
    return n;
  },
  rubberband(n = 0) {
    switch (n) {
      case !0:
        return [nk, nk];
      case !1:
        return [0, 0];
      default:
        return Lc.toVector(n);
    }
  },
  from(n) {
    if (typeof n == "function")
      return n;
    if (n != null)
      return Lc.toVector(n);
  },
  transform(n, e, t) {
    const r = n || t.shared.transform;
    if (this.hasCustomTransform = !!r, process.env.NODE_ENV === "development") {
      const a = r || tk;
      return (s) => {
        const u = a(s);
        return (!isFinite(u[0]) || !isFinite(u[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${u[0]},${[1]}]`), u;
      };
    }
    return r || tk;
  },
  threshold(n) {
    return Lc.toVector(n, 0);
  }
};
process.env.NODE_ENV === "development" && Object.assign(DP, {
  domTarget(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const Tq = 0, fM = os(os({}, DP), {}, {
  axis(n, e, {
    axis: t
  }) {
    if (this.lockDirection = t === "lock", !this.lockDirection)
      return t;
  },
  axisThreshold(n = Tq) {
    return n;
  },
  bounds(n = {}) {
    if (typeof n == "function")
      return (s) => fM.bounds(n(s));
    if ("current" in n)
      return () => n.current;
    if (typeof HTMLElement == "function" && n instanceof HTMLElement)
      return n;
    const {
      left: e = -1 / 0,
      right: t = 1 / 0,
      top: r = -1 / 0,
      bottom: a = 1 / 0
    } = n;
    return [[e, t], [r, a]];
  }
}), rk = {
  ArrowRight: (n, e = 1) => [n * e, 0],
  ArrowLeft: (n, e = 1) => [-1 * n * e, 0],
  ArrowUp: (n, e = 1) => [0, -1 * n * e],
  ArrowDown: (n, e = 1) => [0, n * e]
};
class Mq extends bq {
  constructor(...e) {
    super(...e), cd(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const e = this.state;
    e._pointerId = void 0, e._pointerActive = !1, e._keyboardActive = !1, e._preventScroll = !1, e._delayed = !1, e.swipe = [0, 0], e.tap = !1, e.canceled = !1, e.cancel = this.cancel.bind(this);
  }
  setup() {
    const e = this.state;
    if (e._bounds instanceof HTMLElement) {
      const t = e._bounds.getBoundingClientRect(), r = e.currentTarget.getBoundingClientRect(), a = {
        left: t.left - r.left + e.offset[0],
        right: t.right - r.right + e.offset[0],
        top: t.top - r.top + e.offset[1],
        bottom: t.bottom - r.bottom + e.offset[1]
      };
      e._bounds = fM.bounds(a);
    }
  }
  cancel() {
    const e = this.state;
    e.canceled || (e.canceled = !0, e._active = !1, setTimeout(() => {
      this.compute(), this.emit();
    }, 0));
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean();
  }
  pointerDown(e) {
    const t = this.config, r = this.state;
    if (e.buttons != null && (Array.isArray(t.pointerButtons) ? !t.pointerButtons.includes(e.buttons) : t.pointerButtons !== -1 && t.pointerButtons !== e.buttons))
      return;
    const a = this.ctrl.setEventIds(e);
    t.pointerCapture && e.target.setPointerCapture(e.pointerId), !(a && a.size > 1 && r._pointerActive) && (this.start(e), this.setupPointer(e), r._pointerId = K2(e), r._pointerActive = !0, this.computeValues(Jz(e)), this.computeInitial(), t.preventScrollAxis && JB(e) !== "mouse" ? (r._active = !1, this.setupScrollPrevention(e)) : t.delay > 0 ? (this.setupDelayTrigger(e), t.triggerAllEvents && (this.compute(e), this.emit())) : this.startPointerDrag(e));
  }
  startPointerDrag(e) {
    const t = this.state;
    t._active = !0, t._preventScroll = !0, t._delayed = !1, this.compute(e), this.emit();
  }
  pointerMove(e) {
    const t = this.state, r = this.config;
    if (!t._pointerActive)
      return;
    const a = K2(e);
    if (t._pointerId !== void 0 && a !== t._pointerId)
      return;
    const s = Jz(e);
    if (document.pointerLockElement === e.target ? t._delta = [e.movementX, e.movementY] : (t._delta = Lc.sub(s, t._values), this.computeValues(s)), Lc.addTo(t._movement, t._delta), this.compute(e), t._delayed && t.intentional) {
      this.timeoutStore.remove("dragDelay"), t.active = !1, this.startPointerDrag(e);
      return;
    }
    if (r.preventScrollAxis && !t._preventScroll)
      if (t.axis)
        if (t.axis === r.preventScrollAxis || r.preventScrollAxis === "xy") {
          t._active = !1, this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(e);
          return;
        }
      else
        return;
    this.emit();
  }
  pointerUp(e) {
    this.ctrl.setEventIds(e);
    try {
      this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId);
    } catch {
      process.env.NODE_ENV === "development" && console.warn("[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \n\nPlease upgrade to the latest version.");
    }
    const t = this.state, r = this.config;
    if (!t._active || !t._pointerActive)
      return;
    const a = K2(e);
    if (t._pointerId !== void 0 && a !== t._pointerId)
      return;
    this.state._pointerActive = !1, this.setActive(), this.compute(e);
    const [s, u] = t._distance;
    if (t.tap = s <= r.tapsThreshold && u <= r.tapsThreshold, t.tap && r.filterTaps)
      t._force = !0;
    else {
      const [h, v] = t._delta, [y, _] = t._movement, [b, M] = r.swipe.velocity, [C, D] = r.swipe.distance, U = r.swipe.duration;
      if (t.elapsedTime < U) {
        const N = Math.abs(h / t.timeDelta), O = Math.abs(v / t.timeDelta);
        N > b && Math.abs(y) > C && (t.swipe[0] = Math.sign(h)), O > M && Math.abs(_) > D && (t.swipe[1] = Math.sign(v));
      }
    }
    this.emit();
  }
  pointerClick(e) {
    !this.state.tap && e.detail > 0 && (e.preventDefault(), e.stopPropagation());
  }
  setupPointer(e) {
    const t = this.config, r = t.device;
    if (process.env.NODE_ENV === "development")
      try {
        if (r === "pointer" && t.preventScrollDelay === void 0) {
          const a = "uv" in e ? e.sourceEvent.currentTarget : e.currentTarget;
          window.getComputedStyle(a).touchAction === "auto" && console.warn("[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.", a);
        }
      } catch {
      }
    t.pointerLock && e.currentTarget.requestPointerLock(), t.pointerCapture || (this.eventStore.add(this.sharedConfig.window, r, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, r, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, r, "cancel", this.pointerUp.bind(this)));
  }
  pointerClean() {
    this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock();
  }
  preventScroll(e) {
    this.state._preventScroll && e.cancelable && e.preventDefault();
  }
  setupScrollPrevention(e) {
    this.state._preventScroll = !1, wq(e);
    const t = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: !1
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", t), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", t), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e);
  }
  setupDelayTrigger(e) {
    this.state._delayed = !0, this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0], this.startPointerDrag(e);
    }, this.config.delay);
  }
  keyDown(e) {
    const t = rk[e.key];
    if (t) {
      const r = this.state, a = e.shiftKey ? 10 : e.altKey ? 0.1 : 1;
      this.start(e), r._delta = t(this.config.keyboardDisplacement, a), r._keyboardActive = !0, Lc.addTo(r._movement, r._delta), this.compute(e), this.emit();
    }
  }
  keyUp(e) {
    e.key in rk && (this.state._keyboardActive = !1, this.setActive(), this.compute(e), this.emit());
  }
  bind(e) {
    const t = this.config.device;
    e(t, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (e(t, "change", this.pointerMove.bind(this)), e(t, "end", this.pointerUp.bind(this)), e(t, "cancel", this.pointerUp.bind(this)), e("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (e("key", "down", this.keyDown.bind(this)), e("key", "up", this.keyUp.bind(this))), this.config.filterTaps && e("click", "", this.pointerClick.bind(this), {
      capture: !0,
      passive: !1
    });
  }
}
function wq(n) {
  "persist" in n && typeof n.persist == "function" && n.persist();
}
const dM = typeof window < "u" && window.document && window.document.createElement;
function tH() {
  return dM && "ontouchstart" in window;
}
function Cq() {
  return tH() || dM && window.navigator.maxTouchPoints > 1;
}
function Rq() {
  return dM && "onpointerdown" in window;
}
function Aq() {
  return dM && "exitPointerLock" in window.document;
}
function Dq() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const rp = {
  isBrowser: dM,
  gesture: Dq(),
  touch: tH(),
  touchscreen: Cq(),
  pointer: Rq(),
  pointerLock: Aq()
}, Lq = 250, Oq = 180, Pq = 0.5, Nq = 50, Uq = 250, zq = 10, ik = {
  mouse: 0,
  touch: 0,
  pen: 8
}, nH = os(os({}, fM), {}, {
  device(n, e, {
    pointer: {
      touch: t = !1,
      lock: r = !1,
      mouse: a = !1
    } = {}
  }) {
    return this.pointerLock = r && rp.pointerLock, rp.touch && t ? "touch" : this.pointerLock ? "mouse" : rp.pointer && !a ? "pointer" : rp.touch ? "touch" : "mouse";
  },
  preventScrollAxis(n, e, {
    preventScroll: t
  }) {
    if (this.preventScrollDelay = typeof t == "number" ? t : t || t === void 0 && n ? Lq : void 0, !(!rp.touchscreen || t === !1))
      return n || (t !== void 0 ? "y" : void 0);
  },
  pointerCapture(n, e, {
    pointer: {
      capture: t = !0,
      buttons: r = 1,
      keys: a = !0
    } = {}
  }) {
    return this.pointerButtons = r, this.keys = a, !this.pointerLock && this.device === "pointer" && t;
  },
  threshold(n, e, {
    filterTaps: t = !1,
    tapsThreshold: r = 3,
    axis: a = void 0
  }) {
    const s = Lc.toVector(n, t ? r : a ? 1 : 0);
    return this.filterTaps = t, this.tapsThreshold = r, s;
  },
  swipe({
    velocity: n = Pq,
    distance: e = Nq,
    duration: t = Uq
  } = {}) {
    return {
      velocity: this.transform(Lc.toVector(n)),
      distance: this.transform(Lc.toVector(e)),
      duration: t
    };
  },
  delay(n = 0) {
    switch (n) {
      case !0:
        return Oq;
      case !1:
        return 0;
      default:
        return n;
    }
  },
  axisThreshold(n) {
    return n ? os(os({}, ik), n) : ik;
  },
  keyboardDisplacement(n = zq) {
    return n;
  }
});
process.env.NODE_ENV === "development" && Object.assign(nH, {
  useTouch(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
os(os({}, DP), {}, {
  device(n, e, {
    shared: t,
    pointer: {
      touch: r = !1
    } = {}
  }) {
    if (t.target && !rp.touch && rp.gesture)
      return "gesture";
    if (rp.touch && r)
      return "touch";
    if (rp.touchscreen) {
      if (rp.pointer)
        return "pointer";
      if (rp.touch)
        return "touch";
    }
  },
  bounds(n, e, {
    scaleBounds: t = {},
    angleBounds: r = {}
  }) {
    const a = (u) => {
      const h = ek(ER(t, u), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [h.min, h.max];
    }, s = (u) => {
      const h = ek(ER(r, u), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [h.min, h.max];
    };
    return typeof t != "function" && typeof r != "function" ? [a(), s()] : (u) => [a(u), s(u)];
  },
  threshold(n, e, t) {
    return this.lockDirection = t.axis === "lock", Lc.toVector(n, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(n) {
    return n === void 0 ? "ctrlKey" : n;
  },
  pinchOnWheel(n = !0) {
    return n;
  }
});
os(os({}, fM), {}, {
  mouseOnly: (n = !0) => n
});
os(os({}, fM), {}, {
  mouseOnly: (n = !0) => n
});
const rH = /* @__PURE__ */ new Map(), uO = /* @__PURE__ */ new Map();
function kq(n) {
  rH.set(n.key, n.engine), uO.set(n.key, n.resolver);
}
const Iq = {
  key: "drag",
  engine: Mq,
  resolver: nH
};
function Fq(n, e) {
  if (n == null)
    return {};
  var t = {}, r = Object.keys(n), a, s;
  for (s = 0; s < r.length; s++)
    a = r[s], !(e.indexOf(a) >= 0) && (t[a] = n[a]);
  return t;
}
function Bq(n, e) {
  if (n == null)
    return {};
  var t = Fq(n, e), r, a;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (a = 0; a < s.length; a++)
      r = s[a], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]);
  }
  return t;
}
const Hq = {
  target(n) {
    if (n)
      return () => "current" in n ? n.current : n;
  },
  enabled(n = !0) {
    return n;
  },
  window(n = rp.isBrowser ? window : void 0) {
    return n;
  },
  eventOptions({
    passive: n = !0,
    capture: e = !1
  } = {}) {
    return {
      passive: n,
      capture: e
    };
  },
  transform(n) {
    return n;
  }
}, Vq = ["target", "eventOptions", "window", "enabled", "transform"];
function hR(n = {}, e) {
  const t = {};
  for (const [r, a] of Object.entries(e))
    switch (typeof a) {
      case "function":
        if (process.env.NODE_ENV === "development") {
          const s = a.call(t, n[r], r, n);
          Number.isNaN(s) || (t[r] = s);
        } else
          t[r] = a.call(t, n[r], r, n);
        break;
      case "object":
        t[r] = hR(n[r], a);
        break;
      case "boolean":
        a && (t[r] = n[r]);
        break;
    }
  return t;
}
function Gq(n, e, t = {}) {
  const r = n, {
    target: a,
    eventOptions: s,
    window: u,
    enabled: h,
    transform: v
  } = r, y = Bq(r, Vq);
  if (t.shared = hR({
    target: a,
    eventOptions: s,
    window: u,
    enabled: h,
    transform: v
  }, Hq), e) {
    const _ = uO.get(e);
    t[e] = hR(os({
      shared: t.shared
    }, y), _);
  } else
    for (const _ in y) {
      const b = uO.get(_);
      if (b)
        t[_] = hR(os({
          shared: t.shared
        }, y[_]), b);
      else if (process.env.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(_)) {
        if (_ === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${_}\` was used. Please read the documentation for further information.`);
      }
    }
  return t;
}
class iH {
  constructor(e, t) {
    cd(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = e, this._gestureKey = t;
  }
  add(e, t, r, a, s) {
    const u = this._listeners, h = hq(t, r), v = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, y = os(os({}, v), s);
    e.addEventListener(h, a, y);
    const _ = () => {
      e.removeEventListener(h, a, y), u.delete(_);
    };
    return u.add(_), _;
  }
  clean() {
    this._listeners.forEach((e) => e()), this._listeners.clear();
  }
}
class Wq {
  constructor() {
    cd(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(e, t, r = 140, ...a) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(t, r, ...a));
  }
  remove(e) {
    const t = this._timeouts.get(e);
    t && window.clearTimeout(t);
  }
  clean() {
    this._timeouts.forEach((e) => void window.clearTimeout(e)), this._timeouts.clear();
  }
}
class jq {
  constructor(e) {
    cd(this, "gestures", /* @__PURE__ */ new Set()), cd(this, "_targetEventStore", new iH(this)), cd(this, "gestureEventStores", {}), cd(this, "gestureTimeoutStores", {}), cd(this, "handlers", {}), cd(this, "config", {}), cd(this, "pointerIds", /* @__PURE__ */ new Set()), cd(this, "touchIds", /* @__PURE__ */ new Set()), cd(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), $q(this, e);
  }
  setEventIds(e) {
    if (eA(e))
      return this.touchIds = new Set(vq(e)), this.touchIds;
    if ("pointerId" in e)
      return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds;
  }
  applyHandlers(e, t) {
    this.handlers = e, this.nativeHandlers = t;
  }
  applyConfig(e, t) {
    this.config = Gq(e, t, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures)
      this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...e) {
    const t = this.config.shared, r = {};
    let a;
    if (!(t.target && (a = t.target(), !a))) {
      if (t.enabled) {
        for (const u of this.gestures) {
          const h = this.config[u], v = ak(r, h.eventOptions, !!a);
          if (h.enabled) {
            const y = rH.get(u);
            new y(this, e, u).bind(v);
          }
        }
        const s = ak(r, t.eventOptions, !!a);
        for (const u in this.nativeHandlers)
          s(u, "", (h) => this.nativeHandlers[u](os(os({}, this.state.shared), {}, {
            event: h,
            args: e
          })), void 0, !0);
      }
      for (const s in r)
        r[s] = Sq(...r[s]);
      if (!a)
        return r;
      for (const s in r) {
        const {
          device: u,
          capture: h,
          passive: v
        } = dq(s);
        this._targetEventStore.add(a, u, "", r[s], {
          capture: h,
          passive: v
        });
      }
    }
  }
}
function xE(n, e) {
  n.gestures.add(e), n.gestureEventStores[e] = new iH(n, e), n.gestureTimeoutStores[e] = new Wq();
}
function $q(n, e) {
  e.drag && xE(n, "drag"), e.wheel && xE(n, "wheel"), e.scroll && xE(n, "scroll"), e.move && xE(n, "move"), e.pinch && xE(n, "pinch"), e.hover && xE(n, "hover");
}
const ak = (n, e, t) => (r, a, s, u = {}, h = !1) => {
  var v, y;
  const _ = (v = u.capture) !== null && v !== void 0 ? v : e.capture, b = (y = u.passive) !== null && y !== void 0 ? y : e.passive;
  let M = h ? r : cq(r, a, _);
  t && b && (M += "Passive"), n[M] = n[M] || [], n[M].push(s);
};
function Yq(n, e = {}, t, r) {
  const a = Ne.useMemo(() => new jq(n), []);
  if (a.applyHandlers(n, r), a.applyConfig(e, t), Ne.useEffect(a.effect.bind(a)), Ne.useEffect(() => a.clean.bind(a), []), e.target === void 0)
    return a.bind.bind(a);
}
function Xq(n, e) {
  return kq(Iq), Yq({
    drag: n
  }, e || {}, "drag");
}
const qq = (n) => (e, t, r) => {
  const a = r.subscribe;
  return r.subscribe = (u, h, v) => {
    let y = u;
    if (h) {
      const _ = (v == null ? void 0 : v.equalityFn) || Object.is;
      let b = u(r.getState());
      y = (M) => {
        const C = u(M);
        if (!_(b, C)) {
          const D = b;
          h(b = C, D);
        }
      }, v != null && v.fireImmediately && h(b, b);
    }
    return a(y);
  }, n(e, t, r);
};
var Kq = Object.defineProperty, Qq = (n, e, t) => e in n ? Kq(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Qp = (n, e, t) => (Qq(n, typeof e != "symbol" ? e + "" : e, t), t);
class Q2 {
  /**
   * You can pass in a random number generator object if you like.
   * It is assumed to have a random() method.
   */
  constructor(e = Math) {
    Qp(this, "grad3", [
      [1, 1, 0],
      [-1, 1, 0],
      [1, -1, 0],
      [-1, -1, 0],
      [1, 0, 1],
      [-1, 0, 1],
      [1, 0, -1],
      [-1, 0, -1],
      [0, 1, 1],
      [0, -1, 1],
      [0, 1, -1],
      [0, -1, -1]
    ]), Qp(this, "grad4", [
      [0, 1, 1, 1],
      [0, 1, 1, -1],
      [0, 1, -1, 1],
      [0, 1, -1, -1],
      [0, -1, 1, 1],
      [0, -1, 1, -1],
      [0, -1, -1, 1],
      [0, -1, -1, -1],
      [1, 0, 1, 1],
      [1, 0, 1, -1],
      [1, 0, -1, 1],
      [1, 0, -1, -1],
      [-1, 0, 1, 1],
      [-1, 0, 1, -1],
      [-1, 0, -1, 1],
      [-1, 0, -1, -1],
      [1, 1, 0, 1],
      [1, 1, 0, -1],
      [1, -1, 0, 1],
      [1, -1, 0, -1],
      [-1, 1, 0, 1],
      [-1, 1, 0, -1],
      [-1, -1, 0, 1],
      [-1, -1, 0, -1],
      [1, 1, 1, 0],
      [1, 1, -1, 0],
      [1, -1, 1, 0],
      [1, -1, -1, 0],
      [-1, 1, 1, 0],
      [-1, 1, -1, 0],
      [-1, -1, 1, 0],
      [-1, -1, -1, 0]
    ]), Qp(this, "p", []), Qp(this, "perm", []), Qp(this, "simplex", [
      [0, 1, 2, 3],
      [0, 1, 3, 2],
      [0, 0, 0, 0],
      [0, 2, 3, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 3, 0],
      [0, 2, 1, 3],
      [0, 0, 0, 0],
      [0, 3, 1, 2],
      [0, 3, 2, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 3, 2, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 0, 3],
      [0, 0, 0, 0],
      [1, 3, 0, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 3, 0, 1],
      [2, 3, 1, 0],
      [1, 0, 2, 3],
      [1, 0, 3, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 3, 1],
      [0, 0, 0, 0],
      [2, 1, 3, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 1, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 0, 1, 2],
      [3, 0, 2, 1],
      [0, 0, 0, 0],
      [3, 1, 2, 0],
      [2, 1, 0, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 1, 0, 2],
      [0, 0, 0, 0],
      [3, 2, 0, 1],
      [3, 2, 1, 0]
    ]), Qp(this, "dot", (t, r, a) => t[0] * r + t[1] * a), Qp(this, "dot3", (t, r, a, s) => t[0] * r + t[1] * a + t[2] * s), Qp(this, "dot4", (t, r, a, s, u) => t[0] * r + t[1] * a + t[2] * s + t[3] * u), Qp(this, "noise", (t, r) => {
      let a, s, u;
      const h = 0.5 * (Math.sqrt(3) - 1), v = (t + r) * h, y = Math.floor(t + v), _ = Math.floor(r + v), b = (3 - Math.sqrt(3)) / 6, M = (y + _) * b, C = y - M, D = _ - M, U = t - C, N = r - D;
      let O = 0, I = 1;
      U > N && (O = 1, I = 0);
      const k = U - O + b, G = N - I + b, j = U - 1 + 2 * b, Y = N - 1 + 2 * b, Z = y & 255, te = _ & 255, J = this.perm[Z + this.perm[te]] % 12, q = this.perm[Z + O + this.perm[te + I]] % 12, oe = this.perm[Z + 1 + this.perm[te + 1]] % 12;
      let ye = 0.5 - U * U - N * N;
      ye < 0 ? a = 0 : (ye *= ye, a = ye * ye * this.dot(this.grad3[J], U, N));
      let de = 0.5 - k * k - G * G;
      de < 0 ? s = 0 : (de *= de, s = de * de * this.dot(this.grad3[q], k, G));
      let xe = 0.5 - j * j - Y * Y;
      return xe < 0 ? u = 0 : (xe *= xe, u = xe * xe * this.dot(this.grad3[oe], j, Y)), 70 * (a + s + u);
    }), Qp(this, "noise3d", (t, r, a) => {
      let s, u, h, v;
      const _ = (t + r + a) * 0.3333333333333333, b = Math.floor(t + _), M = Math.floor(r + _), C = Math.floor(a + _), D = 1 / 6, U = (b + M + C) * D, N = b - U, O = M - U, I = C - U, k = t - N, G = r - O, j = a - I;
      let Y, Z, te, J, q, oe;
      k >= G ? G >= j ? (Y = 1, Z = 0, te = 0, J = 1, q = 1, oe = 0) : k >= j ? (Y = 1, Z = 0, te = 0, J = 1, q = 0, oe = 1) : (Y = 0, Z = 0, te = 1, J = 1, q = 0, oe = 1) : G < j ? (Y = 0, Z = 0, te = 1, J = 0, q = 1, oe = 1) : k < j ? (Y = 0, Z = 1, te = 0, J = 0, q = 1, oe = 1) : (Y = 0, Z = 1, te = 0, J = 1, q = 1, oe = 0);
      const ye = k - Y + D, de = G - Z + D, xe = j - te + D, Re = k - J + 2 * D, Pe = G - q + 2 * D, Te = j - oe + 2 * D, ue = k - 1 + 3 * D, we = G - 1 + 3 * D, X = j - 1 + 3 * D, me = b & 255, ce = M & 255, Ue = C & 255, Oe = this.perm[me + this.perm[ce + this.perm[Ue]]] % 12, Ze = this.perm[me + Y + this.perm[ce + Z + this.perm[Ue + te]]] % 12, je = this.perm[me + J + this.perm[ce + q + this.perm[Ue + oe]]] % 12, Je = this.perm[me + 1 + this.perm[ce + 1 + this.perm[Ue + 1]]] % 12;
      let at = 0.6 - k * k - G * G - j * j;
      at < 0 ? s = 0 : (at *= at, s = at * at * this.dot3(this.grad3[Oe], k, G, j));
      let xt = 0.6 - ye * ye - de * de - xe * xe;
      xt < 0 ? u = 0 : (xt *= xt, u = xt * xt * this.dot3(this.grad3[Ze], ye, de, xe));
      let $t = 0.6 - Re * Re - Pe * Pe - Te * Te;
      $t < 0 ? h = 0 : ($t *= $t, h = $t * $t * this.dot3(this.grad3[je], Re, Pe, Te));
      let Ht = 0.6 - ue * ue - we * we - X * X;
      return Ht < 0 ? v = 0 : (Ht *= Ht, v = Ht * Ht * this.dot3(this.grad3[Je], ue, we, X)), 32 * (s + u + h + v);
    }), Qp(this, "noise4d", (t, r, a, s) => {
      const u = this.grad4, h = this.simplex, v = this.perm, y = (Math.sqrt(5) - 1) / 4, _ = (5 - Math.sqrt(5)) / 20;
      let b, M, C, D, U;
      const N = (t + r + a + s) * y, O = Math.floor(t + N), I = Math.floor(r + N), k = Math.floor(a + N), G = Math.floor(s + N), j = (O + I + k + G) * _, Y = O - j, Z = I - j, te = k - j, J = G - j, q = t - Y, oe = r - Z, ye = a - te, de = s - J, xe = q > oe ? 32 : 0, Re = q > ye ? 16 : 0, Pe = oe > ye ? 8 : 0, Te = q > de ? 4 : 0, ue = oe > de ? 2 : 0, we = ye > de ? 1 : 0, X = xe + Re + Pe + Te + ue + we;
      let me, ce, Ue, Oe, Ze, je, Je, at, xt, $t, Ht, he;
      me = h[X][0] >= 3 ? 1 : 0, ce = h[X][1] >= 3 ? 1 : 0, Ue = h[X][2] >= 3 ? 1 : 0, Oe = h[X][3] >= 3 ? 1 : 0, Ze = h[X][0] >= 2 ? 1 : 0, je = h[X][1] >= 2 ? 1 : 0, Je = h[X][2] >= 2 ? 1 : 0, at = h[X][3] >= 2 ? 1 : 0, xt = h[X][0] >= 1 ? 1 : 0, $t = h[X][1] >= 1 ? 1 : 0, Ht = h[X][2] >= 1 ? 1 : 0, he = h[X][3] >= 1 ? 1 : 0;
      const nt = q - me + _, et = oe - ce + _, Rt = ye - Ue + _, gt = de - Oe + _, Jt = q - Ze + 2 * _, Kt = oe - je + 2 * _, qt = ye - Je + 2 * _, hn = de - at + 2 * _, Rn = q - xt + 3 * _, Yn = oe - $t + 3 * _, se = ye - Ht + 3 * _, ae = de - he + 3 * _, Ke = q - 1 + 4 * _, wt = oe - 1 + 4 * _, _t = ye - 1 + 4 * _, Vt = de - 1 + 4 * _, fn = O & 255, Wt = I & 255, Ee = k & 255, Xe = G & 255, St = v[fn + v[Wt + v[Ee + v[Xe]]]] % 32, Ut = v[fn + me + v[Wt + ce + v[Ee + Ue + v[Xe + Oe]]]] % 32, Se = v[fn + Ze + v[Wt + je + v[Ee + Je + v[Xe + at]]]] % 32, Ye = v[fn + xt + v[Wt + $t + v[Ee + Ht + v[Xe + he]]]] % 32, bt = v[fn + 1 + v[Wt + 1 + v[Ee + 1 + v[Xe + 1]]]] % 32;
      let Tt = 0.6 - q * q - oe * oe - ye * ye - de * de;
      Tt < 0 ? b = 0 : (Tt *= Tt, b = Tt * Tt * this.dot4(u[St], q, oe, ye, de));
      let ge = 0.6 - nt * nt - et * et - Rt * Rt - gt * gt;
      ge < 0 ? M = 0 : (ge *= ge, M = ge * ge * this.dot4(u[Ut], nt, et, Rt, gt));
      let zt = 0.6 - Jt * Jt - Kt * Kt - qt * qt - hn * hn;
      zt < 0 ? C = 0 : (zt *= zt, C = zt * zt * this.dot4(u[Se], Jt, Kt, qt, hn));
      let Fe = 0.6 - Rn * Rn - Yn * Yn - se * se - ae * ae;
      Fe < 0 ? D = 0 : (Fe *= Fe, D = Fe * Fe * this.dot4(u[Ye], Rn, Yn, se, ae));
      let ft = 0.6 - Ke * Ke - wt * wt - _t * _t - Vt * Vt;
      return ft < 0 ? U = 0 : (ft *= ft, U = ft * ft * this.dot4(u[bt], Ke, wt, _t, Vt)), 27 * (b + M + C + D + U);
    });
    for (let t = 0; t < 256; t++)
      this.p[t] = Math.floor(e.random() * 256);
    for (let t = 0; t < 512; t++)
      this.perm[t] = this.p[t & 255];
  }
}
var Zq = Object.defineProperty, Jq = (n, e, t) => e in n ? Zq(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Fr = (n, e, t) => (Jq(n, typeof e != "symbol" ? e + "" : e, t), t);
const KC = new mx(), ok = new pv(), eK = Math.cos(70 * (Math.PI / 180)), sk = (n, e) => (n % e + e) % e;
let tK = class extends Tv {
  constructor(e, t) {
    super(), Fr(this, "object"), Fr(this, "domElement"), Fr(this, "enabled", !0), Fr(this, "target", new be()), Fr(this, "minDistance", 0), Fr(this, "maxDistance", 1 / 0), Fr(this, "minZoom", 0), Fr(this, "maxZoom", 1 / 0), Fr(this, "minPolarAngle", 0), Fr(this, "maxPolarAngle", Math.PI), Fr(this, "minAzimuthAngle", -1 / 0), Fr(this, "maxAzimuthAngle", 1 / 0), Fr(this, "enableDamping", !1), Fr(this, "dampingFactor", 0.05), Fr(this, "enableZoom", !0), Fr(this, "zoomSpeed", 1), Fr(this, "enableRotate", !0), Fr(this, "rotateSpeed", 1), Fr(this, "enablePan", !0), Fr(this, "panSpeed", 1), Fr(this, "screenSpacePanning", !0), Fr(this, "keyPanSpeed", 7), Fr(this, "zoomToCursor", !1), Fr(this, "autoRotate", !1), Fr(this, "autoRotateSpeed", 2), Fr(this, "reverseOrbit", !1), Fr(this, "reverseHorizontalOrbit", !1), Fr(this, "reverseVerticalOrbit", !1), Fr(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), Fr(this, "mouseButtons", {
      LEFT: jS.ROTATE,
      MIDDLE: jS.DOLLY,
      RIGHT: jS.PAN
    }), Fr(this, "touches", { ONE: $S.ROTATE, TWO: $S.DOLLY_PAN }), Fr(this, "target0"), Fr(this, "position0"), Fr(this, "zoom0"), Fr(this, "_domElementKeyEvents", null), Fr(this, "getPolarAngle"), Fr(this, "getAzimuthalAngle"), Fr(this, "setPolarAngle"), Fr(this, "setAzimuthalAngle"), Fr(this, "getDistance"), Fr(this, "listenToKeyEvents"), Fr(this, "stopListenToKeyEvents"), Fr(this, "saveState"), Fr(this, "reset"), Fr(this, "update"), Fr(this, "connect"), Fr(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => _.phi, this.getAzimuthalAngle = () => _.theta, this.setPolarAngle = (Se) => {
      let Ye = sk(Se, 2 * Math.PI), bt = _.phi;
      bt < 0 && (bt += 2 * Math.PI), Ye < 0 && (Ye += 2 * Math.PI);
      let Tt = Math.abs(Ye - bt);
      2 * Math.PI - Tt < Tt && (Ye < bt ? Ye += 2 * Math.PI : bt += 2 * Math.PI), b.phi = Ye - bt, r.update();
    }, this.setAzimuthalAngle = (Se) => {
      let Ye = sk(Se, 2 * Math.PI), bt = _.theta;
      bt < 0 && (bt += 2 * Math.PI), Ye < 0 && (Ye += 2 * Math.PI);
      let Tt = Math.abs(Ye - bt);
      2 * Math.PI - Tt < Tt && (Ye < bt ? Ye += 2 * Math.PI : bt += 2 * Math.PI), b.theta = Ye - bt, r.update();
    }, this.getDistance = () => r.object.position.distanceTo(r.target), this.listenToKeyEvents = (Se) => {
      Se.addEventListener("keydown", _t), this._domElementKeyEvents = Se;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", _t), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      r.target0.copy(r.target), r.position0.copy(r.object.position), r.zoom0 = r.object.zoom;
    }, this.reset = () => {
      r.target.copy(r.target0), r.object.position.copy(r.position0), r.object.zoom = r.zoom0, r.object.updateProjectionMatrix(), r.dispatchEvent(a), r.update(), v = h.NONE;
    }, this.update = (() => {
      const Se = new be(), Ye = new be(0, 1, 0), bt = new Oc().setFromUnitVectors(e.up, Ye), Tt = bt.clone().invert(), ge = new be(), zt = new Oc(), Fe = 2 * Math.PI;
      return function() {
        const ln = r.object.position;
        bt.setFromUnitVectors(e.up, Ye), Tt.copy(bt).invert(), Se.copy(ln).sub(r.target), Se.applyQuaternion(bt), _.setFromVector3(Se), r.autoRotate && v === h.NONE && xe(ye()), r.enableDamping ? (_.theta += b.theta * r.dampingFactor, _.phi += b.phi * r.dampingFactor) : (_.theta += b.theta, _.phi += b.phi);
        let zn = r.minAzimuthAngle, yr = r.maxAzimuthAngle;
        isFinite(zn) && isFinite(yr) && (zn < -Math.PI ? zn += Fe : zn > Math.PI && (zn -= Fe), yr < -Math.PI ? yr += Fe : yr > Math.PI && (yr -= Fe), zn <= yr ? _.theta = Math.max(zn, Math.min(yr, _.theta)) : _.theta = _.theta > (zn + yr) / 2 ? Math.max(zn, _.theta) : Math.min(yr, _.theta)), _.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, _.phi)), _.makeSafe(), r.enableDamping === !0 ? r.target.addScaledVector(C, r.dampingFactor) : r.target.add(C), r.zoomToCursor && J || r.object.isOrthographicCamera ? _.radius = ce(_.radius) : _.radius = ce(_.radius * M), Se.setFromSpherical(_), Se.applyQuaternion(Tt), ln.copy(r.target).add(Se), r.object.matrixAutoUpdate || r.object.updateMatrix(), r.object.lookAt(r.target), r.enableDamping === !0 ? (b.theta *= 1 - r.dampingFactor, b.phi *= 1 - r.dampingFactor, C.multiplyScalar(1 - r.dampingFactor)) : (b.set(0, 0, 0), C.set(0, 0, 0));
        let ti = !1;
        if (r.zoomToCursor && J) {
          let rr = null;
          if (r.object instanceof Cs && r.object.isPerspectiveCamera) {
            const vr = Se.length();
            rr = ce(vr * M);
            const Ai = vr - rr;
            r.object.position.addScaledVector(Z, Ai), r.object.updateMatrixWorld();
          } else if (r.object.isOrthographicCamera) {
            const vr = new be(te.x, te.y, 0);
            vr.unproject(r.object), r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / M)), r.object.updateProjectionMatrix(), ti = !0;
            const Ai = new be(te.x, te.y, 0);
            Ai.unproject(r.object), r.object.position.sub(Ai).add(vr), r.object.updateMatrixWorld(), rr = Se.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), r.zoomToCursor = !1;
          rr !== null && (r.screenSpacePanning ? r.target.set(0, 0, -1).transformDirection(r.object.matrix).multiplyScalar(rr).add(r.object.position) : (KC.origin.copy(r.object.position), KC.direction.set(0, 0, -1).transformDirection(r.object.matrix), Math.abs(r.object.up.dot(KC.direction)) < eK ? e.lookAt(r.target) : (ok.setFromNormalAndCoplanarPoint(r.object.up, r.target), KC.intersectPlane(ok, r.target))));
        } else
          r.object instanceof zg && r.object.isOrthographicCamera && (ti = M !== 1, ti && (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / M)), r.object.updateProjectionMatrix()));
        return M = 1, J = !1, ti || ge.distanceToSquared(r.object.position) > y || 8 * (1 - zt.dot(r.object.quaternion)) > y ? (r.dispatchEvent(a), ge.copy(r.object.position), zt.copy(r.object.quaternion), ti = !1, !0) : !1;
      };
    })(), this.connect = (Se) => {
      r.domElement = Se, r.domElement.style.touchAction = "none", r.domElement.addEventListener("contextmenu", Wt), r.domElement.addEventListener("pointerdown", Rn), r.domElement.addEventListener("pointercancel", se), r.domElement.addEventListener("wheel", wt);
    }, this.dispose = () => {
      var Se, Ye, bt, Tt, ge, zt;
      r.domElement && (r.domElement.style.touchAction = "auto"), (Se = r.domElement) == null || Se.removeEventListener("contextmenu", Wt), (Ye = r.domElement) == null || Ye.removeEventListener("pointerdown", Rn), (bt = r.domElement) == null || bt.removeEventListener("pointercancel", se), (Tt = r.domElement) == null || Tt.removeEventListener("wheel", wt), (ge = r.domElement) == null || ge.ownerDocument.removeEventListener("pointermove", Yn), (zt = r.domElement) == null || zt.ownerDocument.removeEventListener("pointerup", se), r._domElementKeyEvents !== null && r._domElementKeyEvents.removeEventListener("keydown", _t);
    };
    const r = this, a = { type: "change" }, s = { type: "start" }, u = { type: "end" }, h = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let v = h.NONE;
    const y = 1e-6, _ = new nO(), b = new nO();
    let M = 1;
    const C = new be(), D = new It(), U = new It(), N = new It(), O = new It(), I = new It(), k = new It(), G = new It(), j = new It(), Y = new It(), Z = new be(), te = new It();
    let J = !1;
    const q = [], oe = {};
    function ye() {
      return 2 * Math.PI / 60 / 60 * r.autoRotateSpeed;
    }
    function de() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function xe(Se) {
      r.reverseOrbit || r.reverseHorizontalOrbit ? b.theta += Se : b.theta -= Se;
    }
    function Re(Se) {
      r.reverseOrbit || r.reverseVerticalOrbit ? b.phi += Se : b.phi -= Se;
    }
    const Pe = (() => {
      const Se = new be();
      return function(bt, Tt) {
        Se.setFromMatrixColumn(Tt, 0), Se.multiplyScalar(-bt), C.add(Se);
      };
    })(), Te = (() => {
      const Se = new be();
      return function(bt, Tt) {
        r.screenSpacePanning === !0 ? Se.setFromMatrixColumn(Tt, 1) : (Se.setFromMatrixColumn(Tt, 0), Se.crossVectors(r.object.up, Se)), Se.multiplyScalar(bt), C.add(Se);
      };
    })(), ue = (() => {
      const Se = new be();
      return function(bt, Tt) {
        const ge = r.domElement;
        if (ge && r.object instanceof Cs && r.object.isPerspectiveCamera) {
          const zt = r.object.position;
          Se.copy(zt).sub(r.target);
          let Fe = Se.length();
          Fe *= Math.tan(r.object.fov / 2 * Math.PI / 180), Pe(2 * bt * Fe / ge.clientHeight, r.object.matrix), Te(2 * Tt * Fe / ge.clientHeight, r.object.matrix);
        } else
          ge && r.object instanceof zg && r.object.isOrthographicCamera ? (Pe(
            bt * (r.object.right - r.object.left) / r.object.zoom / ge.clientWidth,
            r.object.matrix
          ), Te(
            Tt * (r.object.top - r.object.bottom) / r.object.zoom / ge.clientHeight,
            r.object.matrix
          )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r.enablePan = !1);
      };
    })();
    function we(Se) {
      r.object instanceof Cs && r.object.isPerspectiveCamera || r.object instanceof zg && r.object.isOrthographicCamera ? M /= Se : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1);
    }
    function X(Se) {
      r.object instanceof Cs && r.object.isPerspectiveCamera || r.object instanceof zg && r.object.isOrthographicCamera ? M *= Se : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1);
    }
    function me(Se) {
      if (!r.zoomToCursor || !r.domElement)
        return;
      J = !0;
      const Ye = r.domElement.getBoundingClientRect(), bt = Se.clientX - Ye.left, Tt = Se.clientY - Ye.top, ge = Ye.width, zt = Ye.height;
      te.x = bt / ge * 2 - 1, te.y = -(Tt / zt) * 2 + 1, Z.set(te.x, te.y, 1).unproject(r.object).sub(r.object.position).normalize();
    }
    function ce(Se) {
      return Math.max(r.minDistance, Math.min(r.maxDistance, Se));
    }
    function Ue(Se) {
      D.set(Se.clientX, Se.clientY);
    }
    function Oe(Se) {
      me(Se), G.set(Se.clientX, Se.clientY);
    }
    function Ze(Se) {
      O.set(Se.clientX, Se.clientY);
    }
    function je(Se) {
      U.set(Se.clientX, Se.clientY), N.subVectors(U, D).multiplyScalar(r.rotateSpeed);
      const Ye = r.domElement;
      Ye && (xe(2 * Math.PI * N.x / Ye.clientHeight), Re(2 * Math.PI * N.y / Ye.clientHeight)), D.copy(U), r.update();
    }
    function Je(Se) {
      j.set(Se.clientX, Se.clientY), Y.subVectors(j, G), Y.y > 0 ? we(de()) : Y.y < 0 && X(de()), G.copy(j), r.update();
    }
    function at(Se) {
      I.set(Se.clientX, Se.clientY), k.subVectors(I, O).multiplyScalar(r.panSpeed), ue(k.x, k.y), O.copy(I), r.update();
    }
    function xt(Se) {
      me(Se), Se.deltaY < 0 ? X(de()) : Se.deltaY > 0 && we(de()), r.update();
    }
    function $t(Se) {
      let Ye = !1;
      switch (Se.code) {
        case r.keys.UP:
          ue(0, r.keyPanSpeed), Ye = !0;
          break;
        case r.keys.BOTTOM:
          ue(0, -r.keyPanSpeed), Ye = !0;
          break;
        case r.keys.LEFT:
          ue(r.keyPanSpeed, 0), Ye = !0;
          break;
        case r.keys.RIGHT:
          ue(-r.keyPanSpeed, 0), Ye = !0;
          break;
      }
      Ye && (Se.preventDefault(), r.update());
    }
    function Ht() {
      if (q.length == 1)
        D.set(q[0].pageX, q[0].pageY);
      else {
        const Se = 0.5 * (q[0].pageX + q[1].pageX), Ye = 0.5 * (q[0].pageY + q[1].pageY);
        D.set(Se, Ye);
      }
    }
    function he() {
      if (q.length == 1)
        O.set(q[0].pageX, q[0].pageY);
      else {
        const Se = 0.5 * (q[0].pageX + q[1].pageX), Ye = 0.5 * (q[0].pageY + q[1].pageY);
        O.set(Se, Ye);
      }
    }
    function nt() {
      const Se = q[0].pageX - q[1].pageX, Ye = q[0].pageY - q[1].pageY, bt = Math.sqrt(Se * Se + Ye * Ye);
      G.set(0, bt);
    }
    function et() {
      r.enableZoom && nt(), r.enablePan && he();
    }
    function Rt() {
      r.enableZoom && nt(), r.enableRotate && Ht();
    }
    function gt(Se) {
      if (q.length == 1)
        U.set(Se.pageX, Se.pageY);
      else {
        const bt = Ut(Se), Tt = 0.5 * (Se.pageX + bt.x), ge = 0.5 * (Se.pageY + bt.y);
        U.set(Tt, ge);
      }
      N.subVectors(U, D).multiplyScalar(r.rotateSpeed);
      const Ye = r.domElement;
      Ye && (xe(2 * Math.PI * N.x / Ye.clientHeight), Re(2 * Math.PI * N.y / Ye.clientHeight)), D.copy(U);
    }
    function Jt(Se) {
      if (q.length == 1)
        I.set(Se.pageX, Se.pageY);
      else {
        const Ye = Ut(Se), bt = 0.5 * (Se.pageX + Ye.x), Tt = 0.5 * (Se.pageY + Ye.y);
        I.set(bt, Tt);
      }
      k.subVectors(I, O).multiplyScalar(r.panSpeed), ue(k.x, k.y), O.copy(I);
    }
    function Kt(Se) {
      const Ye = Ut(Se), bt = Se.pageX - Ye.x, Tt = Se.pageY - Ye.y, ge = Math.sqrt(bt * bt + Tt * Tt);
      j.set(0, ge), Y.set(0, Math.pow(j.y / G.y, r.zoomSpeed)), we(Y.y), G.copy(j);
    }
    function qt(Se) {
      r.enableZoom && Kt(Se), r.enablePan && Jt(Se);
    }
    function hn(Se) {
      r.enableZoom && Kt(Se), r.enableRotate && gt(Se);
    }
    function Rn(Se) {
      var Ye, bt;
      r.enabled !== !1 && (q.length === 0 && ((Ye = r.domElement) == null || Ye.ownerDocument.addEventListener("pointermove", Yn), (bt = r.domElement) == null || bt.ownerDocument.addEventListener("pointerup", se)), Ee(Se), Se.pointerType === "touch" ? Vt(Se) : ae(Se));
    }
    function Yn(Se) {
      r.enabled !== !1 && (Se.pointerType === "touch" ? fn(Se) : Ke(Se));
    }
    function se(Se) {
      var Ye, bt, Tt;
      Xe(Se), q.length === 0 && ((Ye = r.domElement) == null || Ye.releasePointerCapture(Se.pointerId), (bt = r.domElement) == null || bt.ownerDocument.removeEventListener("pointermove", Yn), (Tt = r.domElement) == null || Tt.ownerDocument.removeEventListener("pointerup", se)), r.dispatchEvent(u), v = h.NONE;
    }
    function ae(Se) {
      let Ye;
      switch (Se.button) {
        case 0:
          Ye = r.mouseButtons.LEFT;
          break;
        case 1:
          Ye = r.mouseButtons.MIDDLE;
          break;
        case 2:
          Ye = r.mouseButtons.RIGHT;
          break;
        default:
          Ye = -1;
      }
      switch (Ye) {
        case jS.DOLLY:
          if (r.enableZoom === !1)
            return;
          Oe(Se), v = h.DOLLY;
          break;
        case jS.ROTATE:
          if (Se.ctrlKey || Se.metaKey || Se.shiftKey) {
            if (r.enablePan === !1)
              return;
            Ze(Se), v = h.PAN;
          } else {
            if (r.enableRotate === !1)
              return;
            Ue(Se), v = h.ROTATE;
          }
          break;
        case jS.PAN:
          if (Se.ctrlKey || Se.metaKey || Se.shiftKey) {
            if (r.enableRotate === !1)
              return;
            Ue(Se), v = h.ROTATE;
          } else {
            if (r.enablePan === !1)
              return;
            Ze(Se), v = h.PAN;
          }
          break;
        default:
          v = h.NONE;
      }
      v !== h.NONE && r.dispatchEvent(s);
    }
    function Ke(Se) {
      if (r.enabled !== !1)
        switch (v) {
          case h.ROTATE:
            if (r.enableRotate === !1)
              return;
            je(Se);
            break;
          case h.DOLLY:
            if (r.enableZoom === !1)
              return;
            Je(Se);
            break;
          case h.PAN:
            if (r.enablePan === !1)
              return;
            at(Se);
            break;
        }
    }
    function wt(Se) {
      r.enabled === !1 || r.enableZoom === !1 || v !== h.NONE && v !== h.ROTATE || (Se.preventDefault(), r.dispatchEvent(s), xt(Se), r.dispatchEvent(u));
    }
    function _t(Se) {
      r.enabled === !1 || r.enablePan === !1 || $t(Se);
    }
    function Vt(Se) {
      switch (St(Se), q.length) {
        case 1:
          switch (r.touches.ONE) {
            case $S.ROTATE:
              if (r.enableRotate === !1)
                return;
              Ht(), v = h.TOUCH_ROTATE;
              break;
            case $S.PAN:
              if (r.enablePan === !1)
                return;
              he(), v = h.TOUCH_PAN;
              break;
            default:
              v = h.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case $S.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1)
                return;
              et(), v = h.TOUCH_DOLLY_PAN;
              break;
            case $S.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1)
                return;
              Rt(), v = h.TOUCH_DOLLY_ROTATE;
              break;
            default:
              v = h.NONE;
          }
          break;
        default:
          v = h.NONE;
      }
      v !== h.NONE && r.dispatchEvent(s);
    }
    function fn(Se) {
      switch (St(Se), v) {
        case h.TOUCH_ROTATE:
          if (r.enableRotate === !1)
            return;
          gt(Se), r.update();
          break;
        case h.TOUCH_PAN:
          if (r.enablePan === !1)
            return;
          Jt(Se), r.update();
          break;
        case h.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1)
            return;
          qt(Se), r.update();
          break;
        case h.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1)
            return;
          hn(Se), r.update();
          break;
        default:
          v = h.NONE;
      }
    }
    function Wt(Se) {
      r.enabled !== !1 && Se.preventDefault();
    }
    function Ee(Se) {
      q.push(Se);
    }
    function Xe(Se) {
      delete oe[Se.pointerId];
      for (let Ye = 0; Ye < q.length; Ye++)
        if (q[Ye].pointerId == Se.pointerId) {
          q.splice(Ye, 1);
          return;
        }
    }
    function St(Se) {
      let Ye = oe[Se.pointerId];
      Ye === void 0 && (Ye = new It(), oe[Se.pointerId] = Ye), Ye.set(Se.pageX, Se.pageY);
    }
    function Ut(Se) {
      const Ye = Se.pointerId === q[0].pointerId ? q[1] : q[0];
      return oe[Ye.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
};
function hM(n, e) {
  if (Object.is(n, e))
    return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  const t = Object.keys(n);
  if (t.length !== Object.keys(e).length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!Object.prototype.hasOwnProperty.call(e, t[r]) || !Object.is(n[t[r]], e[t[r]]))
      return !1;
  return !0;
}
const nK = /* @__PURE__ */ le.forwardRef(({
  makeDefault: n,
  camera: e,
  regress: t,
  domElement: r,
  enableDamping: a = !0,
  keyEvents: s = !1,
  onChange: u,
  onStart: h,
  onEnd: v,
  ...y
}, _) => {
  const b = hv((Y) => Y.invalidate), M = hv((Y) => Y.camera), C = hv((Y) => Y.gl), D = hv((Y) => Y.events), U = hv((Y) => Y.setEvents), N = hv((Y) => Y.set), O = hv((Y) => Y.get), I = hv((Y) => Y.performance), k = e || M, G = r || D.connected || C.domElement, j = le.useMemo(() => new tK(k), [k]);
  return RP(() => {
    j.enabled && j.update();
  }, -1), le.useEffect(() => (s && j.connect(s === !0 ? G : s), j.connect(G), () => void j.dispose()), [s, G, t, j, b]), le.useEffect(() => {
    const Y = (J) => {
      b(), t && I.regress(), u && u(J);
    }, Z = (J) => {
      h && h(J);
    }, te = (J) => {
      v && v(J);
    };
    return j.addEventListener("change", Y), j.addEventListener("start", Z), j.addEventListener("end", te), () => {
      j.removeEventListener("start", Z), j.removeEventListener("end", te), j.removeEventListener("change", Y);
    };
  }, [u, h, v, j, b, U]), le.useEffect(() => {
    if (n) {
      const Y = O().controls;
      return N({
        controls: j
      }), () => N({
        controls: Y
      });
    }
  }, [n, j]), /* @__PURE__ */ le.createElement("primitive", HT({
    ref: _,
    object: j,
    enableDamping: a
  }, y));
}), rK = /* @__PURE__ */ le.forwardRef(({
  intensity: n = 1,
  decay: e,
  decayRate: t = 0.65,
  maxYaw: r = 0.1,
  maxPitch: a = 0.1,
  maxRoll: s = 0.1,
  yawFrequency: u = 0.1,
  pitchFrequency: h = 0.1,
  rollFrequency: v = 0.1
}, y) => {
  const _ = hv((I) => I.camera), b = hv((I) => I.controls), M = le.useRef(n), C = le.useRef(_.rotation.clone()), [D] = le.useState(() => new Q2()), [U] = le.useState(() => new Q2()), [N] = le.useState(() => new Q2()), O = () => {
    (M.current < 0 || M.current > 1) && (M.current = M.current < 0 ? 0 : 1);
  };
  return le.useImperativeHandle(y, () => ({
    getIntensity: () => M.current,
    setIntensity: (I) => {
      M.current = I, O();
    }
  }), []), le.useEffect(() => {
    if (b) {
      const I = () => void (C.current = _.rotation.clone());
      return b.addEventListener("change", I), I(), () => void b.removeEventListener("change", I);
    }
  }, [_, b]), RP((I, k) => {
    const G = Math.pow(M.current, 2), j = r * G * D.noise(I.clock.elapsedTime * u, 1), Y = a * G * U.noise(I.clock.elapsedTime * h, 1), Z = s * G * N.noise(I.clock.elapsedTime * v, 1);
    _.rotation.set(C.current.x + Y, C.current.y + j, C.current.z + Z), e && M.current > 0 && (M.current -= t * k, O());
  }), null;
});
var cO = { exports: {} }, QC = { exports: {} }, ba = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lk;
function iK() {
  if (lk)
    return ba;
  lk = 1;
  var n = typeof Symbol == "function" && Symbol.for, e = n ? Symbol.for("react.element") : 60103, t = n ? Symbol.for("react.portal") : 60106, r = n ? Symbol.for("react.fragment") : 60107, a = n ? Symbol.for("react.strict_mode") : 60108, s = n ? Symbol.for("react.profiler") : 60114, u = n ? Symbol.for("react.provider") : 60109, h = n ? Symbol.for("react.context") : 60110, v = n ? Symbol.for("react.async_mode") : 60111, y = n ? Symbol.for("react.concurrent_mode") : 60111, _ = n ? Symbol.for("react.forward_ref") : 60112, b = n ? Symbol.for("react.suspense") : 60113, M = n ? Symbol.for("react.suspense_list") : 60120, C = n ? Symbol.for("react.memo") : 60115, D = n ? Symbol.for("react.lazy") : 60116, U = n ? Symbol.for("react.block") : 60121, N = n ? Symbol.for("react.fundamental") : 60117, O = n ? Symbol.for("react.responder") : 60118, I = n ? Symbol.for("react.scope") : 60119;
  function k(j) {
    if (typeof j == "object" && j !== null) {
      var Y = j.$$typeof;
      switch (Y) {
        case e:
          switch (j = j.type, j) {
            case v:
            case y:
            case r:
            case s:
            case a:
            case b:
              return j;
            default:
              switch (j = j && j.$$typeof, j) {
                case h:
                case _:
                case D:
                case C:
                case u:
                  return j;
                default:
                  return Y;
              }
          }
        case t:
          return Y;
      }
    }
  }
  function G(j) {
    return k(j) === y;
  }
  return ba.AsyncMode = v, ba.ConcurrentMode = y, ba.ContextConsumer = h, ba.ContextProvider = u, ba.Element = e, ba.ForwardRef = _, ba.Fragment = r, ba.Lazy = D, ba.Memo = C, ba.Portal = t, ba.Profiler = s, ba.StrictMode = a, ba.Suspense = b, ba.isAsyncMode = function(j) {
    return G(j) || k(j) === v;
  }, ba.isConcurrentMode = G, ba.isContextConsumer = function(j) {
    return k(j) === h;
  }, ba.isContextProvider = function(j) {
    return k(j) === u;
  }, ba.isElement = function(j) {
    return typeof j == "object" && j !== null && j.$$typeof === e;
  }, ba.isForwardRef = function(j) {
    return k(j) === _;
  }, ba.isFragment = function(j) {
    return k(j) === r;
  }, ba.isLazy = function(j) {
    return k(j) === D;
  }, ba.isMemo = function(j) {
    return k(j) === C;
  }, ba.isPortal = function(j) {
    return k(j) === t;
  }, ba.isProfiler = function(j) {
    return k(j) === s;
  }, ba.isStrictMode = function(j) {
    return k(j) === a;
  }, ba.isSuspense = function(j) {
    return k(j) === b;
  }, ba.isValidElementType = function(j) {
    return typeof j == "string" || typeof j == "function" || j === r || j === y || j === s || j === a || j === b || j === M || typeof j == "object" && j !== null && (j.$$typeof === D || j.$$typeof === C || j.$$typeof === u || j.$$typeof === h || j.$$typeof === _ || j.$$typeof === N || j.$$typeof === O || j.$$typeof === I || j.$$typeof === U);
  }, ba.typeOf = k, ba;
}
var Ta = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uk;
function aK() {
  return uk || (uk = 1, process.env.NODE_ENV !== "production" && function() {
    var n = typeof Symbol == "function" && Symbol.for, e = n ? Symbol.for("react.element") : 60103, t = n ? Symbol.for("react.portal") : 60106, r = n ? Symbol.for("react.fragment") : 60107, a = n ? Symbol.for("react.strict_mode") : 60108, s = n ? Symbol.for("react.profiler") : 60114, u = n ? Symbol.for("react.provider") : 60109, h = n ? Symbol.for("react.context") : 60110, v = n ? Symbol.for("react.async_mode") : 60111, y = n ? Symbol.for("react.concurrent_mode") : 60111, _ = n ? Symbol.for("react.forward_ref") : 60112, b = n ? Symbol.for("react.suspense") : 60113, M = n ? Symbol.for("react.suspense_list") : 60120, C = n ? Symbol.for("react.memo") : 60115, D = n ? Symbol.for("react.lazy") : 60116, U = n ? Symbol.for("react.block") : 60121, N = n ? Symbol.for("react.fundamental") : 60117, O = n ? Symbol.for("react.responder") : 60118, I = n ? Symbol.for("react.scope") : 60119;
    function k(he) {
      return typeof he == "string" || typeof he == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      he === r || he === y || he === s || he === a || he === b || he === M || typeof he == "object" && he !== null && (he.$$typeof === D || he.$$typeof === C || he.$$typeof === u || he.$$typeof === h || he.$$typeof === _ || he.$$typeof === N || he.$$typeof === O || he.$$typeof === I || he.$$typeof === U);
    }
    function G(he) {
      if (typeof he == "object" && he !== null) {
        var nt = he.$$typeof;
        switch (nt) {
          case e:
            var et = he.type;
            switch (et) {
              case v:
              case y:
              case r:
              case s:
              case a:
              case b:
                return et;
              default:
                var Rt = et && et.$$typeof;
                switch (Rt) {
                  case h:
                  case _:
                  case D:
                  case C:
                  case u:
                    return Rt;
                  default:
                    return nt;
                }
            }
          case t:
            return nt;
        }
      }
    }
    var j = v, Y = y, Z = h, te = u, J = e, q = _, oe = r, ye = D, de = C, xe = t, Re = s, Pe = a, Te = b, ue = !1;
    function we(he) {
      return ue || (ue = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), X(he) || G(he) === v;
    }
    function X(he) {
      return G(he) === y;
    }
    function me(he) {
      return G(he) === h;
    }
    function ce(he) {
      return G(he) === u;
    }
    function Ue(he) {
      return typeof he == "object" && he !== null && he.$$typeof === e;
    }
    function Oe(he) {
      return G(he) === _;
    }
    function Ze(he) {
      return G(he) === r;
    }
    function je(he) {
      return G(he) === D;
    }
    function Je(he) {
      return G(he) === C;
    }
    function at(he) {
      return G(he) === t;
    }
    function xt(he) {
      return G(he) === s;
    }
    function $t(he) {
      return G(he) === a;
    }
    function Ht(he) {
      return G(he) === b;
    }
    Ta.AsyncMode = j, Ta.ConcurrentMode = Y, Ta.ContextConsumer = Z, Ta.ContextProvider = te, Ta.Element = J, Ta.ForwardRef = q, Ta.Fragment = oe, Ta.Lazy = ye, Ta.Memo = de, Ta.Portal = xe, Ta.Profiler = Re, Ta.StrictMode = Pe, Ta.Suspense = Te, Ta.isAsyncMode = we, Ta.isConcurrentMode = X, Ta.isContextConsumer = me, Ta.isContextProvider = ce, Ta.isElement = Ue, Ta.isForwardRef = Oe, Ta.isFragment = Ze, Ta.isLazy = je, Ta.isMemo = Je, Ta.isPortal = at, Ta.isProfiler = xt, Ta.isStrictMode = $t, Ta.isSuspense = Ht, Ta.isValidElementType = k, Ta.typeOf = G;
  }()), Ta;
}
var ck;
function aH() {
  return ck || (ck = 1, process.env.NODE_ENV === "production" ? QC.exports = iK() : QC.exports = aK()), QC.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Z2, fk;
function oK() {
  if (fk)
    return Z2;
  fk = 1;
  var n = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, t = Object.prototype.propertyIsEnumerable;
  function r(s) {
    if (s == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(s);
  }
  function a() {
    try {
      if (!Object.assign)
        return !1;
      var s = new String("abc");
      if (s[5] = "de", Object.getOwnPropertyNames(s)[0] === "5")
        return !1;
      for (var u = {}, h = 0; h < 10; h++)
        u["_" + String.fromCharCode(h)] = h;
      var v = Object.getOwnPropertyNames(u).map(function(_) {
        return u[_];
      });
      if (v.join("") !== "0123456789")
        return !1;
      var y = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(_) {
        y[_] = _;
      }), Object.keys(Object.assign({}, y)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Z2 = a() ? Object.assign : function(s, u) {
    for (var h, v = r(s), y, _ = 1; _ < arguments.length; _++) {
      h = Object(arguments[_]);
      for (var b in h)
        e.call(h, b) && (v[b] = h[b]);
      if (n) {
        y = n(h);
        for (var M = 0; M < y.length; M++)
          t.call(h, y[M]) && (v[y[M]] = h[y[M]]);
      }
    }
    return v;
  }, Z2;
}
var J2, dk;
function LP() {
  if (dk)
    return J2;
  dk = 1;
  var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return J2 = n, J2;
}
var eL, hk;
function oH() {
  return hk || (hk = 1, eL = Function.call.bind(Object.prototype.hasOwnProperty)), eL;
}
var tL, pk;
function sK() {
  if (pk)
    return tL;
  pk = 1;
  var n = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = LP(), t = {}, r = oH();
    n = function(s) {
      var u = "Warning: " + s;
      typeof console < "u" && console.error(u);
      try {
        throw new Error(u);
      } catch {
      }
    };
  }
  function a(s, u, h, v, y) {
    if (process.env.NODE_ENV !== "production") {
      for (var _ in s)
        if (r(s, _)) {
          var b;
          try {
            if (typeof s[_] != "function") {
              var M = Error(
                (v || "React class") + ": " + h + " type `" + _ + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[_] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw M.name = "Invariant Violation", M;
            }
            b = s[_](u, _, v, h, null, e);
          } catch (D) {
            b = D;
          }
          if (b && !(b instanceof Error) && n(
            (v || "React class") + ": type specification of " + h + " `" + _ + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof b + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), b instanceof Error && !(b.message in t)) {
            t[b.message] = !0;
            var C = y ? y() : "";
            n(
              "Failed " + h + " type: " + b.message + (C ?? "")
            );
          }
        }
    }
  }
  return a.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (t = {});
  }, tL = a, tL;
}
var nL, mk;
function lK() {
  if (mk)
    return nL;
  mk = 1;
  var n = aH(), e = oK(), t = LP(), r = oH(), a = sK(), s = function() {
  };
  process.env.NODE_ENV !== "production" && (s = function(h) {
    var v = "Warning: " + h;
    typeof console < "u" && console.error(v);
    try {
      throw new Error(v);
    } catch {
    }
  });
  function u() {
    return null;
  }
  return nL = function(h, v) {
    var y = typeof Symbol == "function" && Symbol.iterator, _ = "@@iterator";
    function b(X) {
      var me = X && (y && X[y] || X[_]);
      if (typeof me == "function")
        return me;
    }
    var M = "<<anonymous>>", C = {
      array: O("array"),
      bigint: O("bigint"),
      bool: O("boolean"),
      func: O("function"),
      number: O("number"),
      object: O("object"),
      string: O("string"),
      symbol: O("symbol"),
      any: I(),
      arrayOf: k,
      element: G(),
      elementType: j(),
      instanceOf: Y,
      node: q(),
      objectOf: te,
      oneOf: Z,
      oneOfType: J,
      shape: ye,
      exact: de
    };
    function D(X, me) {
      return X === me ? X !== 0 || 1 / X === 1 / me : X !== X && me !== me;
    }
    function U(X, me) {
      this.message = X, this.data = me && typeof me == "object" ? me : {}, this.stack = "";
    }
    U.prototype = Error.prototype;
    function N(X) {
      if (process.env.NODE_ENV !== "production")
        var me = {}, ce = 0;
      function Ue(Ze, je, Je, at, xt, $t, Ht) {
        if (at = at || M, $t = $t || Je, Ht !== t) {
          if (v) {
            var he = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw he.name = "Invariant Violation", he;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var nt = at + ":" + Je;
            !me[nt] && // Avoid spamming the console because they are often not actionable except for lib authors
            ce < 3 && (s(
              "You are manually calling a React.PropTypes validation function for the `" + $t + "` prop on `" + at + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), me[nt] = !0, ce++);
          }
        }
        return je[Je] == null ? Ze ? je[Je] === null ? new U("The " + xt + " `" + $t + "` is marked as required " + ("in `" + at + "`, but its value is `null`.")) : new U("The " + xt + " `" + $t + "` is marked as required in " + ("`" + at + "`, but its value is `undefined`.")) : null : X(je, Je, at, xt, $t);
      }
      var Oe = Ue.bind(null, !1);
      return Oe.isRequired = Ue.bind(null, !0), Oe;
    }
    function O(X) {
      function me(ce, Ue, Oe, Ze, je, Je) {
        var at = ce[Ue], xt = Pe(at);
        if (xt !== X) {
          var $t = Te(at);
          return new U(
            "Invalid " + Ze + " `" + je + "` of type " + ("`" + $t + "` supplied to `" + Oe + "`, expected ") + ("`" + X + "`."),
            { expectedType: X }
          );
        }
        return null;
      }
      return N(me);
    }
    function I() {
      return N(u);
    }
    function k(X) {
      function me(ce, Ue, Oe, Ze, je) {
        if (typeof X != "function")
          return new U("Property `" + je + "` of component `" + Oe + "` has invalid PropType notation inside arrayOf.");
        var Je = ce[Ue];
        if (!Array.isArray(Je)) {
          var at = Pe(Je);
          return new U("Invalid " + Ze + " `" + je + "` of type " + ("`" + at + "` supplied to `" + Oe + "`, expected an array."));
        }
        for (var xt = 0; xt < Je.length; xt++) {
          var $t = X(Je, xt, Oe, Ze, je + "[" + xt + "]", t);
          if ($t instanceof Error)
            return $t;
        }
        return null;
      }
      return N(me);
    }
    function G() {
      function X(me, ce, Ue, Oe, Ze) {
        var je = me[ce];
        if (!h(je)) {
          var Je = Pe(je);
          return new U("Invalid " + Oe + " `" + Ze + "` of type " + ("`" + Je + "` supplied to `" + Ue + "`, expected a single ReactElement."));
        }
        return null;
      }
      return N(X);
    }
    function j() {
      function X(me, ce, Ue, Oe, Ze) {
        var je = me[ce];
        if (!n.isValidElementType(je)) {
          var Je = Pe(je);
          return new U("Invalid " + Oe + " `" + Ze + "` of type " + ("`" + Je + "` supplied to `" + Ue + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return N(X);
    }
    function Y(X) {
      function me(ce, Ue, Oe, Ze, je) {
        if (!(ce[Ue] instanceof X)) {
          var Je = X.name || M, at = we(ce[Ue]);
          return new U("Invalid " + Ze + " `" + je + "` of type " + ("`" + at + "` supplied to `" + Oe + "`, expected ") + ("instance of `" + Je + "`."));
        }
        return null;
      }
      return N(me);
    }
    function Z(X) {
      if (!Array.isArray(X))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? s(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : s("Invalid argument supplied to oneOf, expected an array.")), u;
      function me(ce, Ue, Oe, Ze, je) {
        for (var Je = ce[Ue], at = 0; at < X.length; at++)
          if (D(Je, X[at]))
            return null;
        var xt = JSON.stringify(X, function(Ht, he) {
          var nt = Te(he);
          return nt === "symbol" ? String(he) : he;
        });
        return new U("Invalid " + Ze + " `" + je + "` of value `" + String(Je) + "` " + ("supplied to `" + Oe + "`, expected one of " + xt + "."));
      }
      return N(me);
    }
    function te(X) {
      function me(ce, Ue, Oe, Ze, je) {
        if (typeof X != "function")
          return new U("Property `" + je + "` of component `" + Oe + "` has invalid PropType notation inside objectOf.");
        var Je = ce[Ue], at = Pe(Je);
        if (at !== "object")
          return new U("Invalid " + Ze + " `" + je + "` of type " + ("`" + at + "` supplied to `" + Oe + "`, expected an object."));
        for (var xt in Je)
          if (r(Je, xt)) {
            var $t = X(Je, xt, Oe, Ze, je + "." + xt, t);
            if ($t instanceof Error)
              return $t;
          }
        return null;
      }
      return N(me);
    }
    function J(X) {
      if (!Array.isArray(X))
        return process.env.NODE_ENV !== "production" && s("Invalid argument supplied to oneOfType, expected an instance of array."), u;
      for (var me = 0; me < X.length; me++) {
        var ce = X[me];
        if (typeof ce != "function")
          return s(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ue(ce) + " at index " + me + "."
          ), u;
      }
      function Ue(Oe, Ze, je, Je, at) {
        for (var xt = [], $t = 0; $t < X.length; $t++) {
          var Ht = X[$t], he = Ht(Oe, Ze, je, Je, at, t);
          if (he == null)
            return null;
          he.data && r(he.data, "expectedType") && xt.push(he.data.expectedType);
        }
        var nt = xt.length > 0 ? ", expected one of type [" + xt.join(", ") + "]" : "";
        return new U("Invalid " + Je + " `" + at + "` supplied to " + ("`" + je + "`" + nt + "."));
      }
      return N(Ue);
    }
    function q() {
      function X(me, ce, Ue, Oe, Ze) {
        return xe(me[ce]) ? null : new U("Invalid " + Oe + " `" + Ze + "` supplied to " + ("`" + Ue + "`, expected a ReactNode."));
      }
      return N(X);
    }
    function oe(X, me, ce, Ue, Oe) {
      return new U(
        (X || "React class") + ": " + me + " type `" + ce + "." + Ue + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Oe + "`."
      );
    }
    function ye(X) {
      function me(ce, Ue, Oe, Ze, je) {
        var Je = ce[Ue], at = Pe(Je);
        if (at !== "object")
          return new U("Invalid " + Ze + " `" + je + "` of type `" + at + "` " + ("supplied to `" + Oe + "`, expected `object`."));
        for (var xt in X) {
          var $t = X[xt];
          if (typeof $t != "function")
            return oe(Oe, Ze, je, xt, Te($t));
          var Ht = $t(Je, xt, Oe, Ze, je + "." + xt, t);
          if (Ht)
            return Ht;
        }
        return null;
      }
      return N(me);
    }
    function de(X) {
      function me(ce, Ue, Oe, Ze, je) {
        var Je = ce[Ue], at = Pe(Je);
        if (at !== "object")
          return new U("Invalid " + Ze + " `" + je + "` of type `" + at + "` " + ("supplied to `" + Oe + "`, expected `object`."));
        var xt = e({}, ce[Ue], X);
        for (var $t in xt) {
          var Ht = X[$t];
          if (r(X, $t) && typeof Ht != "function")
            return oe(Oe, Ze, je, $t, Te(Ht));
          if (!Ht)
            return new U(
              "Invalid " + Ze + " `" + je + "` key `" + $t + "` supplied to `" + Oe + "`.\nBad object: " + JSON.stringify(ce[Ue], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(X), null, "  ")
            );
          var he = Ht(Je, $t, Oe, Ze, je + "." + $t, t);
          if (he)
            return he;
        }
        return null;
      }
      return N(me);
    }
    function xe(X) {
      switch (typeof X) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !X;
        case "object":
          if (Array.isArray(X))
            return X.every(xe);
          if (X === null || h(X))
            return !0;
          var me = b(X);
          if (me) {
            var ce = me.call(X), Ue;
            if (me !== X.entries) {
              for (; !(Ue = ce.next()).done; )
                if (!xe(Ue.value))
                  return !1;
            } else
              for (; !(Ue = ce.next()).done; ) {
                var Oe = Ue.value;
                if (Oe && !xe(Oe[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Re(X, me) {
      return X === "symbol" ? !0 : me ? me["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && me instanceof Symbol : !1;
    }
    function Pe(X) {
      var me = typeof X;
      return Array.isArray(X) ? "array" : X instanceof RegExp ? "object" : Re(me, X) ? "symbol" : me;
    }
    function Te(X) {
      if (typeof X > "u" || X === null)
        return "" + X;
      var me = Pe(X);
      if (me === "object") {
        if (X instanceof Date)
          return "date";
        if (X instanceof RegExp)
          return "regexp";
      }
      return me;
    }
    function ue(X) {
      var me = Te(X);
      switch (me) {
        case "array":
        case "object":
          return "an " + me;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + me;
        default:
          return me;
      }
    }
    function we(X) {
      return !X.constructor || !X.constructor.name ? M : X.constructor.name;
    }
    return C.checkPropTypes = a, C.resetWarningCache = a.resetWarningCache, C.PropTypes = C, C;
  }, nL;
}
var rL, vk;
function uK() {
  if (vk)
    return rL;
  vk = 1;
  var n = LP();
  function e() {
  }
  function t() {
  }
  return t.resetWarningCache = e, rL = function() {
    function r(u, h, v, y, _, b) {
      if (b !== n) {
        var M = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw M.name = "Invariant Violation", M;
      }
    }
    r.isRequired = r;
    function a() {
      return r;
    }
    var s = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: a,
      element: r,
      elementType: r,
      instanceOf: a,
      node: r,
      objectOf: a,
      oneOf: a,
      oneOfType: a,
      shape: a,
      exact: a,
      checkPropTypes: t,
      resetWarningCache: e
    };
    return s.PropTypes = s, s;
  }, rL;
}
if (process.env.NODE_ENV !== "production") {
  var cK = aH(), fK = !0;
  cO.exports = lK()(cK.isElement, fK);
} else
  cO.exports = uK()();
var dK = cO.exports;
const xo = /* @__PURE__ */ GE(dK);
function hK(n, e) {
  typeof n == "function" ? n(e) : n != null && (n.current = e);
}
function sH(...n) {
  return (e) => n.forEach((t) => hK(t, e));
}
function Sx(...n) {
  return le.useCallback(sH(...n), n);
}
var lH = le.forwardRef((n, e) => {
  const { children: t, ...r } = n, a = le.Children.toArray(t), s = a.find(pK);
  if (s) {
    const u = s.props.children, h = a.map((v) => v === s ? le.Children.count(u) > 1 ? le.Children.only(null) : le.isValidElement(u) ? u.props.children : null : v);
    return /* @__PURE__ */ Or.jsx(fO, { ...r, ref: e, children: le.isValidElement(u) ? le.cloneElement(u, void 0, h) : null });
  }
  return /* @__PURE__ */ Or.jsx(fO, { ...r, ref: e, children: t });
});
lH.displayName = "Slot";
var fO = le.forwardRef((n, e) => {
  const { children: t, ...r } = n;
  if (le.isValidElement(t)) {
    const a = vK(t);
    return le.cloneElement(t, {
      ...mK(r, t.props),
      // @ts-ignore
      ref: e ? sH(e, a) : a
    });
  }
  return le.Children.count(t) > 1 ? le.Children.only(null) : null;
});
fO.displayName = "SlotClone";
var uH = ({ children: n }) => /* @__PURE__ */ Or.jsx(Or.Fragment, { children: n });
function pK(n) {
  return le.isValidElement(n) && n.type === uH;
}
function mK(n, e) {
  const t = { ...e };
  for (const r in e) {
    const a = n[r], s = e[r];
    /^on[A-Z]/.test(r) ? a && s ? t[r] = (...h) => {
      s(...h), a(...h);
    } : a && (t[r] = a) : r === "style" ? t[r] = { ...a, ...s } : r === "className" && (t[r] = [a, s].filter(Boolean).join(" "));
  }
  return { ...n, ...t };
}
function vK(n) {
  var r, a;
  let e = (r = Object.getOwnPropertyDescriptor(n.props, "ref")) == null ? void 0 : r.get, t = e && "isReactWarning" in e && e.isReactWarning;
  return t ? n.ref : (e = (a = Object.getOwnPropertyDescriptor(n, "ref")) == null ? void 0 : a.get, t = e && "isReactWarning" in e && e.isReactWarning, t ? n.props.ref : n.props.ref || n.ref);
}
var gK = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], b0 = gK.reduce((n, e) => {
  const t = le.forwardRef((r, a) => {
    const { asChild: s, ...u } = r, h = s ? lH : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ Or.jsx(h, { ...u, ref: a });
  });
  return t.displayName = `Primitive.${e}`, { ...n, [e]: t };
}, {});
function yK(n, e) {
  n && $T.flushSync(() => n.dispatchEvent(e));
}
var fx = globalThis != null && globalThis.document ? le.useLayoutEffect : () => {
}, SK = "Portal", cH = le.forwardRef((n, e) => {
  var h;
  const { container: t, ...r } = n, [a, s] = le.useState(!1);
  fx(() => s(!0), []);
  const u = t || a && ((h = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : h.body);
  return u ? AI.createPortal(/* @__PURE__ */ Or.jsx(b0.div, { ...r, ref: e }), u) : null;
});
cH.displayName = SK;
var xK = cH, gk = Object.prototype.hasOwnProperty;
function VT(n, e) {
  var t, r;
  if (n === e)
    return !0;
  if (n && e && (t = n.constructor) === e.constructor) {
    if (t === Date)
      return n.getTime() === e.getTime();
    if (t === RegExp)
      return n.toString() === e.toString();
    if (t === Array) {
      if ((r = n.length) === e.length)
        for (; r-- && VT(n[r], e[r]); )
          ;
      return r === -1;
    }
    if (!t || typeof n == "object") {
      r = 0;
      for (t in n)
        if (gk.call(n, t) && ++r && !gk.call(e, t) || !(t in e) || !VT(n[t], e[t]))
          return !1;
      return Object.keys(e).length === r;
    }
  }
  return n !== n && e !== e;
}
var tA = function(e, t, r, a) {
  this.name = e, this.fn = t, this.args = r, this.modifiers = a;
};
tA.prototype._test = function(e) {
  var t = this.fn;
  try {
    PE(this.modifiers.slice(), t, this)(e);
  } catch {
    t = function() {
      return !1;
    };
  }
  try {
    return PE(this.modifiers.slice(), t, this)(e);
  } catch {
    return !1;
  }
};
tA.prototype._check = function(e) {
  try {
    PE(this.modifiers.slice(), this.fn, this)(e);
  } catch {
    if (PE(this.modifiers.slice(), function(r) {
      return r;
    }, this)(!1))
      return;
  }
  if (!PE(this.modifiers.slice(), this.fn, this)(e))
    throw null;
};
tA.prototype._testAsync = function(e) {
  var t = this;
  return new Promise(function(r, a) {
    dH(
      t.modifiers.slice(),
      t.fn,
      t
    )(e).then(function(s) {
      s ? r(e) : a(null);
    }).catch(function(s) {
      return a(s);
    });
  });
};
function fH(n, e) {
  return e === void 0 && (e = "simple"), typeof n == "object" ? n[e] : n;
}
function PE(n, e, t) {
  if (n.length) {
    var r = n.shift(), a = PE(n, e, t);
    return r.perform(a, t);
  } else
    return fH(e);
}
function dH(n, e, t) {
  if (n.length) {
    var r = n.shift(), a = dH(n, e, t);
    return r.performAsync(a, t);
  } else
    return function(s) {
      return Promise.resolve(fH(e, "async")(s));
    };
}
var _K = function(e, t, r) {
  this.name = e, this.perform = t, this.performAsync = r;
}, OP = /* @__PURE__ */ function(n) {
  function e(t, r, a, s) {
    for (var u = [], h = arguments.length - 4; h-- > 0; )
      u[h] = arguments[h + 4];
    n.call(this, u), n.captureStackTrace && n.captureStackTrace(this, e), this.rule = t, this.value = r, this.cause = a, this.target = s;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e;
}(Error), Ev = function(e, t) {
  e === void 0 && (e = []), t === void 0 && (t = []), this.chain = e, this.nextRuleModifiers = t;
};
Ev.prototype._applyRule = function(e, t) {
  var r = this;
  return function() {
    for (var a = [], s = arguments.length; s--; )
      a[s] = arguments[s];
    return r.chain.push(
      new tA(t, e.apply(r, a), a, r.nextRuleModifiers)
    ), r.nextRuleModifiers = [], r;
  };
};
Ev.prototype._applyModifier = function(e, t) {
  return this.nextRuleModifiers.push(
    new _K(t, e.simple, e.async)
  ), this;
};
Ev.prototype._clone = function() {
  return new Ev(this.chain.slice(), this.nextRuleModifiers.slice());
};
Ev.prototype.test = function(e) {
  return this.chain.every(function(t) {
    return t._test(e);
  });
};
Ev.prototype.testAll = function(e) {
  var t = [];
  return this.chain.forEach(function(r) {
    try {
      r._check(e);
    } catch (a) {
      t.push(new OP(r, e, a));
    }
  }), t;
};
Ev.prototype.check = function(e) {
  this.chain.forEach(function(t) {
    try {
      t._check(e);
    } catch (r) {
      throw new OP(t, e, r);
    }
  });
};
Ev.prototype.testAsync = function(e) {
  var t = this;
  return new Promise(function(r, a) {
    hH(e, t.chain.slice(), r, a);
  });
};
function hH(n, e, t, r) {
  if (e.length) {
    var a = e.shift();
    a._testAsync(n).then(
      function() {
        hH(n, e, t, r);
      },
      function(s) {
        r(new OP(a, n, s));
      }
    );
  } else
    t(n);
}
var yk = function(n, e) {
  return e && typeof n == "string" && n.trim().length === 0 ? !0 : n == null;
};
function EK(n, e) {
  return e === void 0 && (e = !1), {
    simple: function(t) {
      return yk(t, e) || n.check(t) === void 0;
    },
    async: function(t) {
      return yk(t, e) || n.testAsync(t);
    }
  };
}
function hd() {
  return typeof Proxy < "u" ? pH(new Ev()) : dO(new Ev());
}
var GT = {};
hd.extend = function(n) {
  Object.assign(GT, n);
};
hd.clearCustomRules = function() {
  GT = {};
};
function pH(n) {
  return new Proxy(n, {
    get: function(t, r) {
      if (r in t)
        return t[r];
      var a = pH(n._clone());
      if (r in bR)
        return a._applyModifier(bR[r], r);
      if (r in GT)
        return a._applyRule(GT[r], r);
      if (r in hO)
        return a._applyRule(hO[r], r);
    }
  });
}
function dO(n) {
  var e = function(a, s) {
    return Object.keys(a).forEach(function(u) {
      s[u] = function() {
        for (var h = [], v = arguments.length; v--; )
          h[v] = arguments[v];
        var y = dO(s._clone()), _ = y._applyRule(
          a[u],
          u
        ).apply(void 0, h);
        return _;
      };
    }), s;
  }, t = e(hO, n), r = e(
    GT,
    t
  );
  return Object.keys(bR).forEach(function(a) {
    Object.defineProperty(r, a, {
      get: function() {
        var s = dO(r._clone());
        return s._applyModifier(bR[a], a);
      }
    });
  }), r;
}
var bR = {
  not: {
    simple: function(n) {
      return function(e) {
        return !n(e);
      };
    },
    async: function(n) {
      return function(e) {
        return Promise.resolve(n(e)).then(function(t) {
          return !t;
        }).catch(function() {
          return !0;
        });
      };
    }
  },
  some: {
    simple: function(n) {
      return function(e) {
        return ZC(e).some(function(t) {
          try {
            return n(t);
          } catch {
            return !1;
          }
        });
      };
    },
    async: function(n) {
      return function(e) {
        return Promise.all(
          ZC(e).map(function(t) {
            try {
              return n(t).catch(function() {
                return !1;
              });
            } catch {
              return !1;
            }
          })
        ).then(function(t) {
          return t.some(Boolean);
        });
      };
    }
  },
  every: {
    simple: function(n) {
      return function(e) {
        return e !== !1 && ZC(e).every(n);
      };
    },
    async: function(n) {
      return function(e) {
        return Promise.all(ZC(e).map(n)).then(function(t) {
          return t.every(Boolean);
        });
      };
    }
  },
  strict: {
    simple: function(n, e) {
      return function(t) {
        return Sk(e) && t && typeof t == "object" ? Object.keys(e.args[0]).length === Object.keys(t).length && n(t) : n(t);
      };
    },
    async: function(n, e) {
      return function(t) {
        return Promise.resolve(n(t)).then(function(r) {
          return Sk(e) && t && typeof t == "object" ? Object.keys(e.args[0]).length === Object.keys(t).length && r : r;
        }).catch(function() {
          return !1;
        });
      };
    }
  }
};
function Sk(n) {
  return n && n.name === "schema" && n.args.length > 0 && typeof n.args[0] == "object";
}
function ZC(n) {
  return typeof n == "string" ? n.split("") : n;
}
var hO = {
  // Value
  equal: function(n) {
    return function(e) {
      return e == n;
    };
  },
  exact: function(n) {
    return function(e) {
      return e === n;
    };
  },
  // Types
  number: function(n) {
    return n === void 0 && (n = !0), function(e) {
      return typeof e == "number" && (n || isFinite(e));
    };
  },
  integer: function() {
    return function(n) {
      var e = Number.isInteger || bK;
      return e(n);
    };
  },
  numeric: function() {
    return function(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    };
  },
  string: function() {
    return _E("string");
  },
  boolean: function() {
    return _E("boolean");
  },
  undefined: function() {
    return _E("undefined");
  },
  null: function() {
    return _E("null");
  },
  array: function() {
    return _E("array");
  },
  object: function() {
    return _E("object");
  },
  instanceOf: function(n) {
    return function(e) {
      return e instanceof n;
    };
  },
  // Pattern
  pattern: function(n) {
    return function(e) {
      return n.test(e);
    };
  },
  lowercase: function() {
    return function(n) {
      return typeof n == "boolean" || n === n.toLowerCase() && n.trim() !== "";
    };
  },
  uppercase: function() {
    return function(n) {
      return n === n.toUpperCase() && n.trim() !== "";
    };
  },
  vowel: function() {
    return function(n) {
      return /^[aeiou]+$/i.test(n);
    };
  },
  consonant: function() {
    return function(n) {
      return /^(?=[^aeiou])([a-z]+)$/i.test(n);
    };
  },
  // Value at
  first: function(n) {
    return function(e) {
      return e[0] == n;
    };
  },
  last: function(n) {
    return function(e) {
      return e[e.length - 1] == n;
    };
  },
  // Length
  empty: function() {
    return function(n) {
      return n.length === 0;
    };
  },
  length: function(n, e) {
    return function(t) {
      return t.length >= n && t.length <= (e || n);
    };
  },
  minLength: function(n) {
    return function(e) {
      return e.length >= n;
    };
  },
  maxLength: function(n) {
    return function(e) {
      return e.length <= n;
    };
  },
  // Range
  negative: function() {
    return function(n) {
      return n < 0;
    };
  },
  positive: function() {
    return function(n) {
      return n >= 0;
    };
  },
  between: function(n, e) {
    return function(t) {
      return t >= n && t <= e;
    };
  },
  range: function(n, e) {
    return function(t) {
      return t >= n && t <= e;
    };
  },
  lessThan: function(n) {
    return function(e) {
      return e < n;
    };
  },
  lessThanOrEqual: function(n) {
    return function(e) {
      return e <= n;
    };
  },
  greaterThan: function(n) {
    return function(e) {
      return e > n;
    };
  },
  greaterThanOrEqual: function(n) {
    return function(e) {
      return e >= n;
    };
  },
  // Divisible
  even: function() {
    return function(n) {
      return n % 2 === 0;
    };
  },
  odd: function() {
    return function(n) {
      return n % 2 !== 0;
    };
  },
  includes: function(n) {
    return function(e) {
      return ~e.indexOf(n);
    };
  },
  schema: function(n) {
    return TK(n);
  },
  // branching
  passesAnyOf: function() {
    for (var n = [], e = arguments.length; e--; )
      n[e] = arguments[e];
    return function(t) {
      return n.some(function(r) {
        return r.test(t);
      });
    };
  },
  optional: EK
};
function _E(n) {
  return function(e) {
    return Array.isArray(e) && n === "array" || e === null && n === "null" || typeof e === n;
  };
}
function bK(n) {
  return typeof n == "number" && isFinite(n) && Math.floor(n) === n;
}
function TK(n) {
  return {
    simple: function(e) {
      var t = [];
      if (Object.keys(n).forEach(function(r) {
        var a = n[r];
        try {
          a.check((e || {})[r]);
        } catch (s) {
          s.target = r, t.push(s);
        }
      }), t.length > 0)
        throw t;
      return !0;
    },
    async: function(e) {
      var t = [], r = Object.keys(n).map(function(a) {
        var s = n[a];
        return s.testAsync((e || {})[a]).catch(function(u) {
          u.target = a, t.push(u);
        });
      });
      return Promise.all(r).then(function() {
        if (t.length > 0)
          throw t;
        return !0;
      });
    }
  };
}
var Qa = "colors", Sf = "sizes", jn = "space", MK = { gap: jn, gridGap: jn, columnGap: jn, gridColumnGap: jn, rowGap: jn, gridRowGap: jn, inset: jn, insetBlock: jn, insetBlockEnd: jn, insetBlockStart: jn, insetInline: jn, insetInlineEnd: jn, insetInlineStart: jn, margin: jn, marginTop: jn, marginRight: jn, marginBottom: jn, marginLeft: jn, marginBlock: jn, marginBlockEnd: jn, marginBlockStart: jn, marginInline: jn, marginInlineEnd: jn, marginInlineStart: jn, padding: jn, paddingTop: jn, paddingRight: jn, paddingBottom: jn, paddingLeft: jn, paddingBlock: jn, paddingBlockEnd: jn, paddingBlockStart: jn, paddingInline: jn, paddingInlineEnd: jn, paddingInlineStart: jn, top: jn, right: jn, bottom: jn, left: jn, scrollMargin: jn, scrollMarginTop: jn, scrollMarginRight: jn, scrollMarginBottom: jn, scrollMarginLeft: jn, scrollMarginX: jn, scrollMarginY: jn, scrollMarginBlock: jn, scrollMarginBlockEnd: jn, scrollMarginBlockStart: jn, scrollMarginInline: jn, scrollMarginInlineEnd: jn, scrollMarginInlineStart: jn, scrollPadding: jn, scrollPaddingTop: jn, scrollPaddingRight: jn, scrollPaddingBottom: jn, scrollPaddingLeft: jn, scrollPaddingX: jn, scrollPaddingY: jn, scrollPaddingBlock: jn, scrollPaddingBlockEnd: jn, scrollPaddingBlockStart: jn, scrollPaddingInline: jn, scrollPaddingInlineEnd: jn, scrollPaddingInlineStart: jn, fontSize: "fontSizes", background: Qa, backgroundColor: Qa, backgroundImage: Qa, borderImage: Qa, border: Qa, borderBlock: Qa, borderBlockEnd: Qa, borderBlockStart: Qa, borderBottom: Qa, borderBottomColor: Qa, borderColor: Qa, borderInline: Qa, borderInlineEnd: Qa, borderInlineStart: Qa, borderLeft: Qa, borderLeftColor: Qa, borderRight: Qa, borderRightColor: Qa, borderTop: Qa, borderTopColor: Qa, caretColor: Qa, color: Qa, columnRuleColor: Qa, fill: Qa, outline: Qa, outlineColor: Qa, stroke: Qa, textDecorationColor: Qa, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: Sf, minBlockSize: Sf, maxBlockSize: Sf, inlineSize: Sf, minInlineSize: Sf, maxInlineSize: Sf, width: Sf, minWidth: Sf, maxWidth: Sf, height: Sf, minHeight: Sf, maxHeight: Sf, flexBasis: Sf, gridTemplateColumns: Sf, gridTemplateRows: Sf, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" }, wK = (n, e) => typeof e == "function" ? { "()": Function.prototype.toString.call(e) } : e, QE = () => {
  const n = /* @__PURE__ */ Object.create(null);
  return (e, t, ...r) => {
    const a = ((s) => JSON.stringify(s, wK))(e);
    return a in n ? n[a] : n[a] = t(e, ...r);
  };
}, ax = Symbol.for("sxs.internal"), PP = (n, e) => Object.defineProperties(n, Object.getOwnPropertyDescriptors(e)), xk = (n) => {
  for (const e in n)
    return !0;
  return !1;
}, { hasOwnProperty: CK } = Object.prototype, pO = (n) => n.includes("-") ? n : n.replace(/[A-Z]/g, (e) => "-" + e.toLowerCase()), RK = /\s+(?![^()]*\))/, EE = (n) => (e) => n(...typeof e == "string" ? String(e).split(RK) : [e]), _k = { appearance: (n) => ({ WebkitAppearance: n, appearance: n }), backfaceVisibility: (n) => ({ WebkitBackfaceVisibility: n, backfaceVisibility: n }), backdropFilter: (n) => ({ WebkitBackdropFilter: n, backdropFilter: n }), backgroundClip: (n) => ({ WebkitBackgroundClip: n, backgroundClip: n }), boxDecorationBreak: (n) => ({ WebkitBoxDecorationBreak: n, boxDecorationBreak: n }), clipPath: (n) => ({ WebkitClipPath: n, clipPath: n }), content: (n) => ({ content: n.includes('"') || n.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(n) ? n : `"${n}"` }), hyphens: (n) => ({ WebkitHyphens: n, hyphens: n }), maskImage: (n) => ({ WebkitMaskImage: n, maskImage: n }), maskSize: (n) => ({ WebkitMaskSize: n, maskSize: n }), tabSize: (n) => ({ MozTabSize: n, tabSize: n }), textSizeAdjust: (n) => ({ WebkitTextSizeAdjust: n, textSizeAdjust: n }), userSelect: (n) => ({ WebkitUserSelect: n, userSelect: n }), marginBlock: EE((n, e) => ({ marginBlockStart: n, marginBlockEnd: e || n })), marginInline: EE((n, e) => ({ marginInlineStart: n, marginInlineEnd: e || n })), maxSize: EE((n, e) => ({ maxBlockSize: n, maxInlineSize: e || n })), minSize: EE((n, e) => ({ minBlockSize: n, minInlineSize: e || n })), paddingBlock: EE((n, e) => ({ paddingBlockStart: n, paddingBlockEnd: e || n })), paddingInline: EE((n, e) => ({ paddingInlineStart: n, paddingInlineEnd: e || n })) }, iL = /([\d.]+)([^]*)/, AK = (n, e) => n.length ? n.reduce((t, r) => (t.push(...e.map((a) => a.includes("&") ? a.replace(/&/g, /[ +>|~]/.test(r) && /&.*&/.test(a) ? `:is(${r})` : r) : r + " " + a)), t), []) : e, DK = (n, e) => n in LK && typeof e == "string" ? e.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (t, r, a, s) => r + (a === "stretch" ? `-moz-available${s};${pO(n)}:${r}-webkit-fill-available` : `-moz-fit-content${s};${pO(n)}:${r}fit-content`) + s) : String(e), LK = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 }, Hg = (n) => n ? n + "-" : "", mH = (n, e, t) => n.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (r, a, s, u, h) => u == "$" == !!s ? r : (a || u == "--" ? "calc(" : "") + "var(--" + (u === "$" ? Hg(e) + (h.includes("$") ? "" : Hg(t)) + h.replace(/\$/g, "-") : h) + ")" + (a || u == "--" ? "*" + (a || "") + (s || "1") + ")" : "")), OK = /\s*,\s*(?![^()]*\))/, PK = Object.prototype.toString, DE = (n, e, t, r, a) => {
  let s, u, h;
  const v = (y, _, b) => {
    let M, C;
    const D = (U) => {
      for (M in U) {
        const I = M.charCodeAt(0) === 64, k = I && Array.isArray(U[M]) ? U[M] : [U[M]];
        for (C of k) {
          const G = /[A-Z]/.test(O = M) ? O : O.replace(/-[^]/g, (Y) => Y[1].toUpperCase()), j = typeof C == "object" && C && C.toString === PK && (!r.utils[G] || !_.length);
          if (G in r.utils && !j) {
            const Y = r.utils[G];
            if (Y !== u) {
              u = Y, D(Y(C)), u = null;
              continue;
            }
          } else if (G in _k) {
            const Y = _k[G];
            if (Y !== h) {
              h = Y, D(Y(C)), h = null;
              continue;
            }
          }
          if (I && (N = M.slice(1) in r.media ? "@media " + r.media[M.slice(1)] : M, M = N.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (Y, Z, te, J, q, oe) => {
            const ye = iL.test(Z), de = 0.0625 * (ye ? -1 : 1), [xe, Re] = ye ? [J, Z] : [Z, J];
            return "(" + (te[0] === "=" ? "" : te[0] === ">" === ye ? "max-" : "min-") + xe + ":" + (te[0] !== "=" && te.length === 1 ? Re.replace(iL, (Pe, Te, ue) => Number(Te) + de * (te === ">" ? 1 : -1) + ue) : Re) + (q ? ") and (" + (q[0] === ">" ? "min-" : "max-") + xe + ":" + (q.length === 1 ? oe.replace(iL, (Pe, Te, ue) => Number(Te) + de * (q === ">" ? -1 : 1) + ue) : oe) : "") + ")";
          })), j) {
            const Y = I ? b.concat(M) : [...b], Z = I ? [..._] : AK(_, M.split(OK));
            s !== void 0 && a(Ek(...s)), s = void 0, v(C, Z, Y);
          } else
            s === void 0 && (s = [[], _, b]), M = I || M.charCodeAt(0) !== 36 ? M : `--${Hg(r.prefix)}${M.slice(1).replace(/\$/g, "-")}`, C = j ? C : typeof C == "number" ? C && G in NK ? String(C) + "px" : String(C) : mH(DK(G, C ?? ""), r.prefix, r.themeMap[G]), s[0].push(`${I ? `${M} ` : `${pO(M)}:`}${C}`);
        }
      }
      var N, O;
    };
    D(y), s !== void 0 && a(Ek(...s)), s = void 0;
  };
  v(n, e, t);
}, Ek = (n, e, t) => `${t.map((r) => `${r}{`).join("")}${e.length ? `${e.join(",")}{` : ""}${n.join(";")}${e.length ? "}" : ""}${Array(t.length ? t.length + 1 : 0).join("}")}`, NK = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 }, bk = (n) => String.fromCharCode(n + (n > 25 ? 39 : 97)), ox = (n) => ((e) => {
  let t, r = "";
  for (t = Math.abs(e); t > 52; t = t / 52 | 0)
    r = bk(t % 52) + r;
  return bk(t % 52) + r;
})(((e, t) => {
  let r = t.length;
  for (; r; )
    e = 33 * e ^ t.charCodeAt(--r);
  return e;
})(5381, JSON.stringify(n)) >>> 0), dT = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"], UK = (n) => {
  if (n.href && !n.href.startsWith(location.origin))
    return !1;
  try {
    return !!n.cssRules;
  } catch {
    return !1;
  }
}, zK = (n) => {
  let e;
  const t = () => {
    const { cssRules: a } = e.sheet;
    return [].map.call(a, (s, u) => {
      const { cssText: h } = s;
      let v = "";
      if (h.startsWith("--sxs"))
        return "";
      if (a[u - 1] && (v = a[u - 1].cssText).startsWith("--sxs")) {
        if (!s.cssRules.length)
          return "";
        for (const y in e.rules)
          if (e.rules[y].group === s)
            return `--sxs{--sxs:${[...e.rules[y].cache].join(" ")}}${h}`;
        return s.cssRules.length ? `${v}${h}` : "";
      }
      return h;
    }).join("");
  }, r = () => {
    if (e) {
      const { rules: h, sheet: v } = e;
      if (!v.deleteRule) {
        for (; Object(Object(v.cssRules)[0]).type === 3; )
          v.cssRules.splice(0, 1);
        v.cssRules = [];
      }
      for (const y in h)
        delete h[y];
    }
    const a = Object(n).styleSheets || [];
    for (const h of a)
      if (UK(h)) {
        for (let v = 0, y = h.cssRules; y[v]; ++v) {
          const _ = Object(y[v]);
          if (_.type !== 1)
            continue;
          const b = Object(y[v + 1]);
          if (b.type !== 4)
            continue;
          ++v;
          const { cssText: M } = _;
          if (!M.startsWith("--sxs"))
            continue;
          const C = M.slice(14, -3).trim().split(/\s+/), D = dT[C[0]];
          D && (e || (e = { sheet: h, reset: r, rules: {}, toString: t }), e.rules[D] = { group: b, index: v, cache: new Set(C) });
        }
        if (e)
          break;
      }
    if (!e) {
      const h = (v, y) => ({ type: y, cssRules: [], insertRule(_, b) {
        this.cssRules.splice(b, 0, h(_, { import: 3, undefined: 1 }[(_.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return v === "@media{}" ? `@media{${[].map.call(this.cssRules, (_) => _.cssText).join("")}}` : v;
      } });
      e = { sheet: n ? (n.head || n).appendChild(document.createElement("style")).sheet : h("", "text/css"), rules: {}, reset: r, toString: t };
    }
    const { sheet: s, rules: u } = e;
    for (let h = dT.length - 1; h >= 0; --h) {
      const v = dT[h];
      if (!u[v]) {
        const y = dT[h + 1], _ = u[y] ? u[y].index : s.cssRules.length;
        s.insertRule("@media{}", _), s.insertRule(`--sxs{--sxs:${h}}`, _), u[v] = { group: s.cssRules[_ + 1], index: _, cache: /* @__PURE__ */ new Set([h]) };
      }
      kK(u[v]);
    }
  };
  return r(), e;
}, kK = (n) => {
  const e = n.group;
  let t = e.cssRules.length;
  n.apply = (r) => {
    try {
      e.insertRule(r, t), ++t;
    } catch {
    }
  };
}, oT = Symbol(), IK = QE(), Tk = (n, e) => IK(n, () => (...t) => {
  let r = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const a of t)
    if (a != null)
      if (a[ax]) {
        r.type == null && (r.type = a[ax].type);
        for (const s of a[ax].composers)
          r.composers.add(s);
      } else
        a.constructor !== Object || a.$$typeof ? r.type == null && (r.type = a) : r.composers.add(FK(a, n));
  return r.type == null && (r.type = "span"), r.composers.size || r.composers.add(["PJLV", {}, [], [], {}, []]), BK(n, r, e);
}), FK = ({ variants: n, compoundVariants: e, defaultVariants: t, ...r }, a) => {
  const s = `${Hg(a.prefix)}c-${ox(r)}`, u = [], h = [], v = /* @__PURE__ */ Object.create(null), y = [];
  for (const M in t)
    v[M] = String(t[M]);
  if (typeof n == "object" && n)
    for (const M in n) {
      _ = v, b = M, CK.call(_, b) || (v[M] = "undefined");
      const C = n[M];
      for (const D in C) {
        const U = { [M]: String(D) };
        String(D) === "undefined" && y.push(M);
        const N = C[D], O = [U, N, !xk(N)];
        u.push(O);
      }
    }
  var _, b;
  if (typeof e == "object" && e)
    for (const M of e) {
      let { css: C, ...D } = M;
      C = typeof C == "object" && C || {};
      for (const N in D)
        D[N] = String(D[N]);
      const U = [D, C, !xk(C)];
      h.push(U);
    }
  return [s, r, u, h, v, y];
}, BK = (n, e, t) => {
  const [r, a, s, u] = HK(e.composers), h = typeof e.type == "function" || e.type.$$typeof ? ((b) => {
    function M() {
      for (let C = 0; C < M[oT].length; C++) {
        const [D, U] = M[oT][C];
        b.rules[D].apply(U);
      }
      return M[oT] = [], null;
    }
    return M[oT] = [], M.rules = {}, dT.forEach((C) => M.rules[C] = { apply: (D) => M[oT].push([C, D]) }), M;
  })(t) : null, v = (h || t).rules, y = `.${r}${a.length > 1 ? `:where(.${a.slice(1).join(".")})` : ""}`, _ = (b) => {
    b = typeof b == "object" && b || VK;
    const { css: M, ...C } = b, D = {};
    for (const O in s)
      if (delete C[O], O in b) {
        let I = b[O];
        typeof I == "object" && I ? D[O] = { "@initial": s[O], ...I } : (I = String(I), D[O] = I !== "undefined" || u.has(O) ? I : s[O]);
      } else
        D[O] = s[O];
    const U = /* @__PURE__ */ new Set([...a]);
    for (const [O, I, k, G] of e.composers) {
      t.rules.styled.cache.has(O) || (t.rules.styled.cache.add(O), DE(I, [`.${O}`], [], n, (Z) => {
        v.styled.apply(Z);
      }));
      const j = Mk(k, D, n.media), Y = Mk(G, D, n.media, !0);
      for (const Z of j)
        if (Z !== void 0)
          for (const [te, J, q] of Z) {
            const oe = `${O}-${ox(J)}-${te}`;
            U.add(oe);
            const ye = (q ? t.rules.resonevar : t.rules.onevar).cache, de = q ? v.resonevar : v.onevar;
            ye.has(oe) || (ye.add(oe), DE(J, [`.${oe}`], [], n, (xe) => {
              de.apply(xe);
            }));
          }
      for (const Z of Y)
        if (Z !== void 0)
          for (const [te, J] of Z) {
            const q = `${O}-${ox(J)}-${te}`;
            U.add(q), t.rules.allvar.cache.has(q) || (t.rules.allvar.cache.add(q), DE(J, [`.${q}`], [], n, (oe) => {
              v.allvar.apply(oe);
            }));
          }
    }
    if (typeof M == "object" && M) {
      const O = `${r}-i${ox(M)}-css`;
      U.add(O), t.rules.inline.cache.has(O) || (t.rules.inline.cache.add(O), DE(M, [`.${O}`], [], n, (I) => {
        v.inline.apply(I);
      }));
    }
    for (const O of String(b.className || "").trim().split(/\s+/))
      O && U.add(O);
    const N = C.className = [...U].join(" ");
    return { type: e.type, className: N, selector: y, props: C, toString: () => N, deferredInjector: h };
  };
  return PP(_, { className: r, selector: y, [ax]: e, toString: () => (t.rules.styled.cache.has(r) || _(), r) });
}, HK = (n) => {
  let e = "";
  const t = [], r = {}, a = [];
  for (const [s, , , , u, h] of n) {
    e === "" && (e = s), t.push(s), a.push(...h);
    for (const v in u) {
      const y = u[v];
      (r[v] === void 0 || y !== "undefined" || h.includes(y)) && (r[v] = y);
    }
  }
  return [e, t, r, new Set(a)];
}, Mk = (n, e, t, r) => {
  const a = [];
  e:
    for (let [s, u, h] of n) {
      if (h)
        continue;
      let v, y = 0, _ = !1;
      for (v in s) {
        const b = s[v];
        let M = e[v];
        if (M !== b) {
          if (typeof M != "object" || !M)
            continue e;
          {
            let C, D, U = 0;
            for (const N in M) {
              if (b === String(M[N])) {
                if (N !== "@initial") {
                  const O = N.slice(1);
                  (D = D || []).push(O in t ? t[O] : N.replace(/^@media ?/, "")), _ = !0;
                }
                y += U, C = !0;
              }
              ++U;
            }
            if (D && D.length && (u = { ["@media " + D.join(", ")]: u }), !C)
              continue e;
          }
        }
      }
      (a[y] = a[y] || []).push([r ? "cv" : `${v}-${s[v]}`, u, _]);
    }
  return a;
}, VK = {}, GK = QE(), WK = (n, e) => GK(n, () => (...t) => {
  const r = () => {
    for (let a of t) {
      a = typeof a == "object" && a || {};
      let s = ox(a);
      if (!e.rules.global.cache.has(s)) {
        if (e.rules.global.cache.add(s), "@import" in a) {
          let u = [].indexOf.call(e.sheet.cssRules, e.rules.themed.group) - 1;
          for (let h of [].concat(a["@import"]))
            h = h.includes('"') || h.includes("'") ? h : `"${h}"`, e.sheet.insertRule(`@import ${h};`, u++);
          delete a["@import"];
        }
        DE(a, [], [], n, (u) => {
          e.rules.global.apply(u);
        });
      }
    }
    return "";
  };
  return PP(r, { toString: r });
}), jK = QE(), $K = (n, e) => jK(n, () => (t) => {
  const r = `${Hg(n.prefix)}k-${ox(t)}`, a = () => {
    if (!e.rules.global.cache.has(r)) {
      e.rules.global.cache.add(r);
      const s = [];
      DE(t, [], [], n, (h) => s.push(h));
      const u = `@keyframes ${r}{${s.join("")}}`;
      e.rules.global.apply(u);
    }
    return r;
  };
  return PP(a, { get name() {
    return a();
  }, toString: a });
}), YK = class {
  constructor(n, e, t, r) {
    this.token = n == null ? "" : String(n), this.value = e == null ? "" : String(e), this.scale = t == null ? "" : String(t), this.prefix = r == null ? "" : String(r);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + Hg(this.prefix) + Hg(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
}, XK = QE(), qK = (n, e) => XK(n, () => (t, r) => {
  r = typeof t == "object" && t || Object(r);
  const a = `.${t = (t = typeof t == "string" ? t : "") || `${Hg(n.prefix)}t-${ox(r)}`}`, s = {}, u = [];
  for (const v in r) {
    s[v] = {};
    for (const y in r[v]) {
      const _ = `--${Hg(n.prefix)}${v}-${y}`, b = mH(String(r[v][y]), n.prefix, v);
      s[v][y] = new YK(y, b, v, n.prefix), u.push(`${_}:${b}`);
    }
  }
  const h = () => {
    if (u.length && !e.rules.themed.cache.has(t)) {
      e.rules.themed.cache.add(t);
      const v = `${r === n.theme ? ":root," : ""}.${t}{${u.join(";")}}`;
      e.rules.themed.apply(v);
    }
    return t;
  };
  return { ...s, get className() {
    return h();
  }, selector: a, toString: h };
}), KK = QE(), QK = QE(), ZK = (n) => {
  const e = ((t) => {
    let r = !1;
    const a = KK(t, (s) => {
      r = !0;
      const u = "prefix" in (s = typeof s == "object" && s || {}) ? String(s.prefix) : "", h = typeof s.media == "object" && s.media || {}, v = typeof s.root == "object" ? s.root || null : globalThis.document || null, y = typeof s.theme == "object" && s.theme || {}, _ = { prefix: u, media: h, theme: y, themeMap: typeof s.themeMap == "object" && s.themeMap || { ...MK }, utils: typeof s.utils == "object" && s.utils || {} }, b = zK(v), M = { css: Tk(_, b), globalCss: WK(_, b), keyframes: $K(_, b), createTheme: qK(_, b), reset() {
        b.reset(), M.theme.toString();
      }, theme: {}, sheet: b, config: _, prefix: u, getCssText: b.toString, toString: b.toString };
      return String(M.theme = M.createTheme(y)), M;
    });
    return r || a.reset(), a;
  })(n);
  return e.styled = (({ config: t, sheet: r }) => QK(t, () => {
    const a = Tk(t, r);
    return (...s) => {
      const u = a(...s), h = u[ax].type, v = Ne.forwardRef((y, _) => {
        const b = y && y.as || h, { props: M, deferredInjector: C } = u(y);
        return delete M.as, M.ref = _, C ? Ne.createElement(Ne.Fragment, null, Ne.createElement(b, M), Ne.createElement(C, null)) : Ne.createElement(b, M);
      });
      return v.className = u.className, v.displayName = `Styled.${h.displayName || h.name || h}`, v.selector = u.selector, v.toString = () => u.selector, v[ax] = u[ax], v;
    };
  }))(e), e;
};
function Og(n, e, { checkForDefaultPrevented: t = !0 } = {}) {
  return function(a) {
    if (n == null || n(a), t === !1 || !a.defaultPrevented)
      return e == null ? void 0 : e(a);
  };
}
function vH(n, e = []) {
  let t = [];
  function r(s, u) {
    const h = le.createContext(u), v = t.length;
    t = [...t, u];
    function y(b) {
      const { scope: M, children: C, ...D } = b, U = (M == null ? void 0 : M[n][v]) || h, N = le.useMemo(() => D, Object.values(D));
      return /* @__PURE__ */ Or.jsx(U.Provider, { value: N, children: C });
    }
    function _(b, M) {
      const C = (M == null ? void 0 : M[n][v]) || h, D = le.useContext(C);
      if (D)
        return D;
      if (u !== void 0)
        return u;
      throw new Error(`\`${b}\` must be used within \`${s}\``);
    }
    return y.displayName = s + "Provider", [y, _];
  }
  const a = () => {
    const s = t.map((u) => le.createContext(u));
    return function(h) {
      const v = (h == null ? void 0 : h[n]) || s;
      return le.useMemo(
        () => ({ [`__scope${n}`]: { ...h, [n]: v } }),
        [h, v]
      );
    };
  };
  return a.scopeName = n, [r, JK(a, ...e)];
}
function JK(...n) {
  const e = n[0];
  if (n.length === 1)
    return e;
  const t = () => {
    const r = n.map((a) => ({
      useScope: a(),
      scopeName: a.scopeName
    }));
    return function(s) {
      const u = r.reduce((h, { useScope: v, scopeName: y }) => {
        const b = v(s)[`__scope${y}`];
        return { ...h, ...b };
      }, {});
      return le.useMemo(() => ({ [`__scope${e.scopeName}`]: u }), [u]);
    };
  };
  return t.scopeName = e.scopeName, t;
}
function ZE(n) {
  const e = le.useRef(n);
  return le.useEffect(() => {
    e.current = n;
  }), le.useMemo(() => (...t) => {
    var r;
    return (r = e.current) == null ? void 0 : r.call(e, ...t);
  }, []);
}
function eQ(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = ZE(n);
  le.useEffect(() => {
    const r = (a) => {
      a.key === "Escape" && t(a);
    };
    return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 });
  }, [t, e]);
}
var tQ = "DismissableLayer", mO = "dismissableLayer.update", nQ = "dismissableLayer.pointerDownOutside", rQ = "dismissableLayer.focusOutside", wk, gH = le.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), yH = le.forwardRef(
  (n, e) => {
    const {
      disableOutsidePointerEvents: t = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: a,
      onFocusOutside: s,
      onInteractOutside: u,
      onDismiss: h,
      ...v
    } = n, y = le.useContext(gH), [_, b] = le.useState(null), M = (_ == null ? void 0 : _.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, C] = le.useState({}), D = Sx(e, (Z) => b(Z)), U = Array.from(y.layers), [N] = [...y.layersWithOutsidePointerEventsDisabled].slice(-1), O = U.indexOf(N), I = _ ? U.indexOf(_) : -1, k = y.layersWithOutsidePointerEventsDisabled.size > 0, G = I >= O, j = oQ((Z) => {
      const te = Z.target, J = [...y.branches].some((q) => q.contains(te));
      !G || J || (a == null || a(Z), u == null || u(Z), Z.defaultPrevented || h == null || h());
    }, M), Y = sQ((Z) => {
      const te = Z.target;
      [...y.branches].some((q) => q.contains(te)) || (s == null || s(Z), u == null || u(Z), Z.defaultPrevented || h == null || h());
    }, M);
    return eQ((Z) => {
      I === y.layers.size - 1 && (r == null || r(Z), !Z.defaultPrevented && h && (Z.preventDefault(), h()));
    }, M), le.useEffect(() => {
      if (_)
        return t && (y.layersWithOutsidePointerEventsDisabled.size === 0 && (wk = M.body.style.pointerEvents, M.body.style.pointerEvents = "none"), y.layersWithOutsidePointerEventsDisabled.add(_)), y.layers.add(_), Ck(), () => {
          t && y.layersWithOutsidePointerEventsDisabled.size === 1 && (M.body.style.pointerEvents = wk);
        };
    }, [_, M, t, y]), le.useEffect(() => () => {
      _ && (y.layers.delete(_), y.layersWithOutsidePointerEventsDisabled.delete(_), Ck());
    }, [_, y]), le.useEffect(() => {
      const Z = () => C({});
      return document.addEventListener(mO, Z), () => document.removeEventListener(mO, Z);
    }, []), /* @__PURE__ */ Or.jsx(
      b0.div,
      {
        ...v,
        ref: D,
        style: {
          pointerEvents: k ? G ? "auto" : "none" : void 0,
          ...n.style
        },
        onFocusCapture: Og(n.onFocusCapture, Y.onFocusCapture),
        onBlurCapture: Og(n.onBlurCapture, Y.onBlurCapture),
        onPointerDownCapture: Og(
          n.onPointerDownCapture,
          j.onPointerDownCapture
        )
      }
    );
  }
);
yH.displayName = tQ;
var iQ = "DismissableLayerBranch", aQ = le.forwardRef((n, e) => {
  const t = le.useContext(gH), r = le.useRef(null), a = Sx(e, r);
  return le.useEffect(() => {
    const s = r.current;
    if (s)
      return t.branches.add(s), () => {
        t.branches.delete(s);
      };
  }, [t.branches]), /* @__PURE__ */ Or.jsx(b0.div, { ...n, ref: a });
});
aQ.displayName = iQ;
function oQ(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = ZE(n), r = le.useRef(!1), a = le.useRef(() => {
  });
  return le.useEffect(() => {
    const s = (h) => {
      if (h.target && !r.current) {
        let v = function() {
          SH(
            nQ,
            t,
            y,
            { discrete: !0 }
          );
        };
        const y = { originalEvent: h };
        h.pointerType === "touch" ? (e.removeEventListener("click", a.current), a.current = v, e.addEventListener("click", a.current, { once: !0 })) : v();
      } else
        e.removeEventListener("click", a.current);
      r.current = !1;
    }, u = window.setTimeout(() => {
      e.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(u), e.removeEventListener("pointerdown", s), e.removeEventListener("click", a.current);
    };
  }, [e, t]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function sQ(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = ZE(n), r = le.useRef(!1);
  return le.useEffect(() => {
    const a = (s) => {
      s.target && !r.current && SH(rQ, t, { originalEvent: s }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", a), () => e.removeEventListener("focusin", a);
  }, [e, t]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function Ck() {
  const n = new CustomEvent(mO);
  document.dispatchEvent(n);
}
function SH(n, e, t, { discrete: r }) {
  const a = t.originalEvent.target, s = new CustomEvent(n, { bubbles: !1, cancelable: !0, detail: t });
  e && a.addEventListener(n, e, { once: !0 }), r ? yK(a, s) : a.dispatchEvent(s);
}
var lQ = s6.useId || (() => {
}), uQ = 0;
function cQ(n) {
  const [e, t] = le.useState(lQ());
  return fx(() => {
    n || t((r) => r ?? String(uQ++));
  }, [n]), n || (e ? `radix-${e}` : "");
}
const fQ = ["top", "right", "bottom", "left"], yv = Math.min, ah = Math.max, TR = Math.round, JC = Math.floor, m0 = (n) => ({
  x: n,
  y: n
}), dQ = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, hQ = {
  start: "end",
  end: "start"
};
function vO(n, e, t) {
  return ah(n, yv(e, t));
}
function Vg(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function Gg(n) {
  return n.split("-")[0];
}
function JE(n) {
  return n.split("-")[1];
}
function NP(n) {
  return n === "x" ? "y" : "x";
}
function UP(n) {
  return n === "y" ? "height" : "width";
}
function v0(n) {
  return ["top", "bottom"].includes(Gg(n)) ? "y" : "x";
}
function zP(n) {
  return NP(v0(n));
}
function pQ(n, e, t) {
  t === void 0 && (t = !1);
  const r = JE(n), a = zP(n), s = UP(a);
  let u = a === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (u = MR(u)), [u, MR(u)];
}
function mQ(n) {
  const e = MR(n);
  return [gO(n), e, gO(e)];
}
function gO(n) {
  return n.replace(/start|end/g, (e) => hQ[e]);
}
function vQ(n, e, t) {
  const r = ["left", "right"], a = ["right", "left"], s = ["top", "bottom"], u = ["bottom", "top"];
  switch (n) {
    case "top":
    case "bottom":
      return t ? e ? a : r : e ? r : a;
    case "left":
    case "right":
      return e ? s : u;
    default:
      return [];
  }
}
function gQ(n, e, t, r) {
  const a = JE(n);
  let s = vQ(Gg(n), t === "start", r);
  return a && (s = s.map((u) => u + "-" + a), e && (s = s.concat(s.map(gO)))), s;
}
function MR(n) {
  return n.replace(/left|right|bottom|top/g, (e) => dQ[e]);
}
function yQ(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function xH(n) {
  return typeof n != "number" ? yQ(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function wR(n) {
  const {
    x: e,
    y: t,
    width: r,
    height: a
  } = n;
  return {
    width: r,
    height: a,
    top: t,
    left: e,
    right: e + r,
    bottom: t + a,
    x: e,
    y: t
  };
}
function Rk(n, e, t) {
  let {
    reference: r,
    floating: a
  } = n;
  const s = v0(e), u = zP(e), h = UP(u), v = Gg(e), y = s === "y", _ = r.x + r.width / 2 - a.width / 2, b = r.y + r.height / 2 - a.height / 2, M = r[h] / 2 - a[h] / 2;
  let C;
  switch (v) {
    case "top":
      C = {
        x: _,
        y: r.y - a.height
      };
      break;
    case "bottom":
      C = {
        x: _,
        y: r.y + r.height
      };
      break;
    case "right":
      C = {
        x: r.x + r.width,
        y: b
      };
      break;
    case "left":
      C = {
        x: r.x - a.width,
        y: b
      };
      break;
    default:
      C = {
        x: r.x,
        y: r.y
      };
  }
  switch (JE(e)) {
    case "start":
      C[u] -= M * (t && y ? -1 : 1);
      break;
    case "end":
      C[u] += M * (t && y ? -1 : 1);
      break;
  }
  return C;
}
const SQ = async (n, e, t) => {
  const {
    placement: r = "bottom",
    strategy: a = "absolute",
    middleware: s = [],
    platform: u
  } = t, h = s.filter(Boolean), v = await (u.isRTL == null ? void 0 : u.isRTL(e));
  let y = await u.getElementRects({
    reference: n,
    floating: e,
    strategy: a
  }), {
    x: _,
    y: b
  } = Rk(y, r, v), M = r, C = {}, D = 0;
  for (let U = 0; U < h.length; U++) {
    const {
      name: N,
      fn: O
    } = h[U], {
      x: I,
      y: k,
      data: G,
      reset: j
    } = await O({
      x: _,
      y: b,
      initialPlacement: r,
      placement: M,
      strategy: a,
      middlewareData: C,
      rects: y,
      platform: u,
      elements: {
        reference: n,
        floating: e
      }
    });
    _ = I ?? _, b = k ?? b, C = {
      ...C,
      [N]: {
        ...C[N],
        ...G
      }
    }, j && D <= 50 && (D++, typeof j == "object" && (j.placement && (M = j.placement), j.rects && (y = j.rects === !0 ? await u.getElementRects({
      reference: n,
      floating: e,
      strategy: a
    }) : j.rects), {
      x: _,
      y: b
    } = Rk(y, M, v)), U = -1);
  }
  return {
    x: _,
    y: b,
    placement: M,
    strategy: a,
    middlewareData: C
  };
};
async function WT(n, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: r,
    y: a,
    platform: s,
    rects: u,
    elements: h,
    strategy: v
  } = n, {
    boundary: y = "clippingAncestors",
    rootBoundary: _ = "viewport",
    elementContext: b = "floating",
    altBoundary: M = !1,
    padding: C = 0
  } = Vg(e, n), D = xH(C), N = h[M ? b === "floating" ? "reference" : "floating" : b], O = wR(await s.getClippingRect({
    element: (t = await (s.isElement == null ? void 0 : s.isElement(N))) == null || t ? N : N.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(h.floating)),
    boundary: y,
    rootBoundary: _,
    strategy: v
  })), I = b === "floating" ? {
    x: r,
    y: a,
    width: u.floating.width,
    height: u.floating.height
  } : u.reference, k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(h.floating)), G = await (s.isElement == null ? void 0 : s.isElement(k)) ? await (s.getScale == null ? void 0 : s.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, j = wR(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: h,
    rect: I,
    offsetParent: k,
    strategy: v
  }) : I);
  return {
    top: (O.top - j.top + D.top) / G.y,
    bottom: (j.bottom - O.bottom + D.bottom) / G.y,
    left: (O.left - j.left + D.left) / G.x,
    right: (j.right - O.right + D.right) / G.x
  };
}
const xQ = (n) => ({
  name: "arrow",
  options: n,
  async fn(e) {
    const {
      x: t,
      y: r,
      placement: a,
      rects: s,
      platform: u,
      elements: h,
      middlewareData: v
    } = e, {
      element: y,
      padding: _ = 0
    } = Vg(n, e) || {};
    if (y == null)
      return {};
    const b = xH(_), M = {
      x: t,
      y: r
    }, C = zP(a), D = UP(C), U = await u.getDimensions(y), N = C === "y", O = N ? "top" : "left", I = N ? "bottom" : "right", k = N ? "clientHeight" : "clientWidth", G = s.reference[D] + s.reference[C] - M[C] - s.floating[D], j = M[C] - s.reference[C], Y = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(y));
    let Z = Y ? Y[k] : 0;
    (!Z || !await (u.isElement == null ? void 0 : u.isElement(Y))) && (Z = h.floating[k] || s.floating[D]);
    const te = G / 2 - j / 2, J = Z / 2 - U[D] / 2 - 1, q = yv(b[O], J), oe = yv(b[I], J), ye = q, de = Z - U[D] - oe, xe = Z / 2 - U[D] / 2 + te, Re = vO(ye, xe, de), Pe = !v.arrow && JE(a) != null && xe !== Re && s.reference[D] / 2 - (xe < ye ? q : oe) - U[D] / 2 < 0, Te = Pe ? xe < ye ? xe - ye : xe - de : 0;
    return {
      [C]: M[C] + Te,
      data: {
        [C]: Re,
        centerOffset: xe - Re - Te,
        ...Pe && {
          alignmentOffset: Te
        }
      },
      reset: Pe
    };
  }
}), _Q = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: a,
        middlewareData: s,
        rects: u,
        initialPlacement: h,
        platform: v,
        elements: y
      } = e, {
        mainAxis: _ = !0,
        crossAxis: b = !0,
        fallbackPlacements: M,
        fallbackStrategy: C = "bestFit",
        fallbackAxisSideDirection: D = "none",
        flipAlignment: U = !0,
        ...N
      } = Vg(n, e);
      if ((t = s.arrow) != null && t.alignmentOffset)
        return {};
      const O = Gg(a), I = v0(h), k = Gg(h) === h, G = await (v.isRTL == null ? void 0 : v.isRTL(y.floating)), j = M || (k || !U ? [MR(h)] : mQ(h)), Y = D !== "none";
      !M && Y && j.push(...gQ(h, U, D, G));
      const Z = [h, ...j], te = await WT(e, N), J = [];
      let q = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (_ && J.push(te[O]), b) {
        const xe = pQ(a, u, G);
        J.push(te[xe[0]], te[xe[1]]);
      }
      if (q = [...q, {
        placement: a,
        overflows: J
      }], !J.every((xe) => xe <= 0)) {
        var oe, ye;
        const xe = (((oe = s.flip) == null ? void 0 : oe.index) || 0) + 1, Re = Z[xe];
        if (Re)
          return {
            data: {
              index: xe,
              overflows: q
            },
            reset: {
              placement: Re
            }
          };
        let Pe = (ye = q.filter((Te) => Te.overflows[0] <= 0).sort((Te, ue) => Te.overflows[1] - ue.overflows[1])[0]) == null ? void 0 : ye.placement;
        if (!Pe)
          switch (C) {
            case "bestFit": {
              var de;
              const Te = (de = q.filter((ue) => {
                if (Y) {
                  const we = v0(ue.placement);
                  return we === I || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  we === "y";
                }
                return !0;
              }).map((ue) => [ue.placement, ue.overflows.filter((we) => we > 0).reduce((we, X) => we + X, 0)]).sort((ue, we) => ue[1] - we[1])[0]) == null ? void 0 : de[0];
              Te && (Pe = Te);
              break;
            }
            case "initialPlacement":
              Pe = h;
              break;
          }
        if (a !== Pe)
          return {
            reset: {
              placement: Pe
            }
          };
      }
      return {};
    }
  };
};
function Ak(n, e) {
  return {
    top: n.top - e.height,
    right: n.right - e.width,
    bottom: n.bottom - e.height,
    left: n.left - e.width
  };
}
function Dk(n) {
  return fQ.some((e) => n[e] >= 0);
}
const EQ = function(n) {
  return n === void 0 && (n = {}), {
    name: "hide",
    options: n,
    async fn(e) {
      const {
        rects: t
      } = e, {
        strategy: r = "referenceHidden",
        ...a
      } = Vg(n, e);
      switch (r) {
        case "referenceHidden": {
          const s = await WT(e, {
            ...a,
            elementContext: "reference"
          }), u = Ak(s, t.reference);
          return {
            data: {
              referenceHiddenOffsets: u,
              referenceHidden: Dk(u)
            }
          };
        }
        case "escaped": {
          const s = await WT(e, {
            ...a,
            altBoundary: !0
          }), u = Ak(s, t.floating);
          return {
            data: {
              escapedOffsets: u,
              escaped: Dk(u)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function bQ(n, e) {
  const {
    placement: t,
    platform: r,
    elements: a
  } = n, s = await (r.isRTL == null ? void 0 : r.isRTL(a.floating)), u = Gg(t), h = JE(t), v = v0(t) === "y", y = ["left", "top"].includes(u) ? -1 : 1, _ = s && v ? -1 : 1, b = Vg(e, n);
  let {
    mainAxis: M,
    crossAxis: C,
    alignmentAxis: D
  } = typeof b == "number" ? {
    mainAxis: b,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...b
  };
  return h && typeof D == "number" && (C = h === "end" ? D * -1 : D), v ? {
    x: C * _,
    y: M * y
  } : {
    x: M * y,
    y: C * _
  };
}
const TQ = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(e) {
      var t, r;
      const {
        x: a,
        y: s,
        placement: u,
        middlewareData: h
      } = e, v = await bQ(e, n);
      return u === ((t = h.offset) == null ? void 0 : t.placement) && (r = h.arrow) != null && r.alignmentOffset ? {} : {
        x: a + v.x,
        y: s + v.y,
        data: {
          ...v,
          placement: u
        }
      };
    }
  };
}, MQ = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(e) {
      const {
        x: t,
        y: r,
        placement: a
      } = e, {
        mainAxis: s = !0,
        crossAxis: u = !1,
        limiter: h = {
          fn: (N) => {
            let {
              x: O,
              y: I
            } = N;
            return {
              x: O,
              y: I
            };
          }
        },
        ...v
      } = Vg(n, e), y = {
        x: t,
        y: r
      }, _ = await WT(e, v), b = v0(Gg(a)), M = NP(b);
      let C = y[M], D = y[b];
      if (s) {
        const N = M === "y" ? "top" : "left", O = M === "y" ? "bottom" : "right", I = C + _[N], k = C - _[O];
        C = vO(I, C, k);
      }
      if (u) {
        const N = b === "y" ? "top" : "left", O = b === "y" ? "bottom" : "right", I = D + _[N], k = D - _[O];
        D = vO(I, D, k);
      }
      const U = h.fn({
        ...e,
        [M]: C,
        [b]: D
      });
      return {
        ...U,
        data: {
          x: U.x - t,
          y: U.y - r
        }
      };
    }
  };
}, wQ = function(n) {
  return n === void 0 && (n = {}), {
    options: n,
    fn(e) {
      const {
        x: t,
        y: r,
        placement: a,
        rects: s,
        middlewareData: u
      } = e, {
        offset: h = 0,
        mainAxis: v = !0,
        crossAxis: y = !0
      } = Vg(n, e), _ = {
        x: t,
        y: r
      }, b = v0(a), M = NP(b);
      let C = _[M], D = _[b];
      const U = Vg(h, e), N = typeof U == "number" ? {
        mainAxis: U,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...U
      };
      if (v) {
        const k = M === "y" ? "height" : "width", G = s.reference[M] - s.floating[k] + N.mainAxis, j = s.reference[M] + s.reference[k] - N.mainAxis;
        C < G ? C = G : C > j && (C = j);
      }
      if (y) {
        var O, I;
        const k = M === "y" ? "width" : "height", G = ["top", "left"].includes(Gg(a)), j = s.reference[b] - s.floating[k] + (G && ((O = u.offset) == null ? void 0 : O[b]) || 0) + (G ? 0 : N.crossAxis), Y = s.reference[b] + s.reference[k] + (G ? 0 : ((I = u.offset) == null ? void 0 : I[b]) || 0) - (G ? N.crossAxis : 0);
        D < j ? D = j : D > Y && (D = Y);
      }
      return {
        [M]: C,
        [b]: D
      };
    }
  };
}, CQ = function(n) {
  return n === void 0 && (n = {}), {
    name: "size",
    options: n,
    async fn(e) {
      const {
        placement: t,
        rects: r,
        platform: a,
        elements: s
      } = e, {
        apply: u = () => {
        },
        ...h
      } = Vg(n, e), v = await WT(e, h), y = Gg(t), _ = JE(t), b = v0(t) === "y", {
        width: M,
        height: C
      } = r.floating;
      let D, U;
      y === "top" || y === "bottom" ? (D = y, U = _ === (await (a.isRTL == null ? void 0 : a.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (U = y, D = _ === "end" ? "top" : "bottom");
      const N = C - v.top - v.bottom, O = M - v.left - v.right, I = yv(C - v[D], N), k = yv(M - v[U], O), G = !e.middlewareData.shift;
      let j = I, Y = k;
      if (b ? Y = _ || G ? yv(k, O) : O : j = _ || G ? yv(I, N) : N, G && !_) {
        const te = ah(v.left, 0), J = ah(v.right, 0), q = ah(v.top, 0), oe = ah(v.bottom, 0);
        b ? Y = M - 2 * (te !== 0 || J !== 0 ? te + J : ah(v.left, v.right)) : j = C - 2 * (q !== 0 || oe !== 0 ? q + oe : ah(v.top, v.bottom));
      }
      await u({
        ...e,
        availableWidth: Y,
        availableHeight: j
      });
      const Z = await a.getDimensions(s.floating);
      return M !== Z.width || C !== Z.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function eb(n) {
  return _H(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function lh(n) {
  var e;
  return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function jg(n) {
  var e;
  return (e = (_H(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement;
}
function _H(n) {
  return n instanceof Node || n instanceof lh(n).Node;
}
function im(n) {
  return n instanceof Element || n instanceof lh(n).Element;
}
function bv(n) {
  return n instanceof HTMLElement || n instanceof lh(n).HTMLElement;
}
function Lk(n) {
  return typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof lh(n).ShadowRoot;
}
function pM(n) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: r,
    display: a
  } = am(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !["inline", "contents"].includes(a);
}
function RQ(n) {
  return ["table", "td", "th"].includes(eb(n));
}
function nA(n) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
function kP(n) {
  const e = IP(), t = im(n) ? am(n) : n;
  return t.transform !== "none" || t.perspective !== "none" || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (t.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (t.contain || "").includes(r));
}
function AQ(n) {
  let e = g0(n);
  for (; bv(e) && !BE(e); ) {
    if (kP(e))
      return e;
    if (nA(e))
      return null;
    e = g0(e);
  }
  return null;
}
function IP() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function BE(n) {
  return ["html", "body", "#document"].includes(eb(n));
}
function am(n) {
  return lh(n).getComputedStyle(n);
}
function rA(n) {
  return im(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
function g0(n) {
  if (eb(n) === "html")
    return n;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    Lk(n) && n.host || // Fallback.
    jg(n)
  );
  return Lk(e) ? e.host : e;
}
function EH(n) {
  const e = g0(n);
  return BE(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : bv(e) && pM(e) ? e : EH(e);
}
function jT(n, e, t) {
  var r;
  e === void 0 && (e = []), t === void 0 && (t = !0);
  const a = EH(n), s = a === ((r = n.ownerDocument) == null ? void 0 : r.body), u = lh(a);
  if (s) {
    const h = yO(u);
    return e.concat(u, u.visualViewport || [], pM(a) ? a : [], h && t ? jT(h) : []);
  }
  return e.concat(a, jT(a, [], t));
}
function yO(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function bH(n) {
  const e = am(n);
  let t = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const a = bv(n), s = a ? n.offsetWidth : t, u = a ? n.offsetHeight : r, h = TR(t) !== s || TR(r) !== u;
  return h && (t = s, r = u), {
    width: t,
    height: r,
    $: h
  };
}
function FP(n) {
  return im(n) ? n : n.contextElement;
}
function NE(n) {
  const e = FP(n);
  if (!bv(e))
    return m0(1);
  const t = e.getBoundingClientRect(), {
    width: r,
    height: a,
    $: s
  } = bH(e);
  let u = (s ? TR(t.width) : t.width) / r, h = (s ? TR(t.height) : t.height) / a;
  return (!u || !Number.isFinite(u)) && (u = 1), (!h || !Number.isFinite(h)) && (h = 1), {
    x: u,
    y: h
  };
}
const DQ = /* @__PURE__ */ m0(0);
function TH(n) {
  const e = lh(n);
  return !IP() || !e.visualViewport ? DQ : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function LQ(n, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== lh(n) ? !1 : e;
}
function dx(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const a = n.getBoundingClientRect(), s = FP(n);
  let u = m0(1);
  e && (r ? im(r) && (u = NE(r)) : u = NE(n));
  const h = LQ(s, t, r) ? TH(s) : m0(0);
  let v = (a.left + h.x) / u.x, y = (a.top + h.y) / u.y, _ = a.width / u.x, b = a.height / u.y;
  if (s) {
    const M = lh(s), C = r && im(r) ? lh(r) : r;
    let D = M, U = yO(D);
    for (; U && r && C !== D; ) {
      const N = NE(U), O = U.getBoundingClientRect(), I = am(U), k = O.left + (U.clientLeft + parseFloat(I.paddingLeft)) * N.x, G = O.top + (U.clientTop + parseFloat(I.paddingTop)) * N.y;
      v *= N.x, y *= N.y, _ *= N.x, b *= N.y, v += k, y += G, D = lh(U), U = yO(D);
    }
  }
  return wR({
    width: _,
    height: b,
    x: v,
    y
  });
}
function OQ(n) {
  let {
    elements: e,
    rect: t,
    offsetParent: r,
    strategy: a
  } = n;
  const s = a === "fixed", u = jg(r), h = e ? nA(e.floating) : !1;
  if (r === u || h && s)
    return t;
  let v = {
    scrollLeft: 0,
    scrollTop: 0
  }, y = m0(1);
  const _ = m0(0), b = bv(r);
  if ((b || !b && !s) && ((eb(r) !== "body" || pM(u)) && (v = rA(r)), bv(r))) {
    const M = dx(r);
    y = NE(r), _.x = M.x + r.clientLeft, _.y = M.y + r.clientTop;
  }
  return {
    width: t.width * y.x,
    height: t.height * y.y,
    x: t.x * y.x - v.scrollLeft * y.x + _.x,
    y: t.y * y.y - v.scrollTop * y.y + _.y
  };
}
function PQ(n) {
  return Array.from(n.getClientRects());
}
function MH(n) {
  return dx(jg(n)).left + rA(n).scrollLeft;
}
function NQ(n) {
  const e = jg(n), t = rA(n), r = n.ownerDocument.body, a = ah(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = ah(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let u = -t.scrollLeft + MH(n);
  const h = -t.scrollTop;
  return am(r).direction === "rtl" && (u += ah(e.clientWidth, r.clientWidth) - a), {
    width: a,
    height: s,
    x: u,
    y: h
  };
}
function UQ(n, e) {
  const t = lh(n), r = jg(n), a = t.visualViewport;
  let s = r.clientWidth, u = r.clientHeight, h = 0, v = 0;
  if (a) {
    s = a.width, u = a.height;
    const y = IP();
    (!y || y && e === "fixed") && (h = a.offsetLeft, v = a.offsetTop);
  }
  return {
    width: s,
    height: u,
    x: h,
    y: v
  };
}
function zQ(n, e) {
  const t = dx(n, !0, e === "fixed"), r = t.top + n.clientTop, a = t.left + n.clientLeft, s = bv(n) ? NE(n) : m0(1), u = n.clientWidth * s.x, h = n.clientHeight * s.y, v = a * s.x, y = r * s.y;
  return {
    width: u,
    height: h,
    x: v,
    y
  };
}
function Ok(n, e, t) {
  let r;
  if (e === "viewport")
    r = UQ(n, t);
  else if (e === "document")
    r = NQ(jg(n));
  else if (im(e))
    r = zQ(e, t);
  else {
    const a = TH(n);
    r = {
      ...e,
      x: e.x - a.x,
      y: e.y - a.y
    };
  }
  return wR(r);
}
function wH(n, e) {
  const t = g0(n);
  return t === e || !im(t) || BE(t) ? !1 : am(t).position === "fixed" || wH(t, e);
}
function kQ(n, e) {
  const t = e.get(n);
  if (t)
    return t;
  let r = jT(n, [], !1).filter((h) => im(h) && eb(h) !== "body"), a = null;
  const s = am(n).position === "fixed";
  let u = s ? g0(n) : n;
  for (; im(u) && !BE(u); ) {
    const h = am(u), v = kP(u);
    !v && h.position === "fixed" && (a = null), (s ? !v && !a : !v && h.position === "static" && !!a && ["absolute", "fixed"].includes(a.position) || pM(u) && !v && wH(n, u)) ? r = r.filter((_) => _ !== u) : a = h, u = g0(u);
  }
  return e.set(n, r), r;
}
function IQ(n) {
  let {
    element: e,
    boundary: t,
    rootBoundary: r,
    strategy: a
  } = n;
  const u = [...t === "clippingAncestors" ? nA(e) ? [] : kQ(e, this._c) : [].concat(t), r], h = u[0], v = u.reduce((y, _) => {
    const b = Ok(e, _, a);
    return y.top = ah(b.top, y.top), y.right = yv(b.right, y.right), y.bottom = yv(b.bottom, y.bottom), y.left = ah(b.left, y.left), y;
  }, Ok(e, h, a));
  return {
    width: v.right - v.left,
    height: v.bottom - v.top,
    x: v.left,
    y: v.top
  };
}
function FQ(n) {
  const {
    width: e,
    height: t
  } = bH(n);
  return {
    width: e,
    height: t
  };
}
function BQ(n, e, t) {
  const r = bv(e), a = jg(e), s = t === "fixed", u = dx(n, !0, s, e);
  let h = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const v = m0(0);
  if (r || !r && !s)
    if ((eb(e) !== "body" || pM(a)) && (h = rA(e)), r) {
      const b = dx(e, !0, s, e);
      v.x = b.x + e.clientLeft, v.y = b.y + e.clientTop;
    } else
      a && (v.x = MH(a));
  const y = u.left + h.scrollLeft - v.x, _ = u.top + h.scrollTop - v.y;
  return {
    x: y,
    y: _,
    width: u.width,
    height: u.height
  };
}
function aL(n) {
  return am(n).position === "static";
}
function Pk(n, e) {
  return !bv(n) || am(n).position === "fixed" ? null : e ? e(n) : n.offsetParent;
}
function CH(n, e) {
  const t = lh(n);
  if (nA(n))
    return t;
  if (!bv(n)) {
    let a = g0(n);
    for (; a && !BE(a); ) {
      if (im(a) && !aL(a))
        return a;
      a = g0(a);
    }
    return t;
  }
  let r = Pk(n, e);
  for (; r && RQ(r) && aL(r); )
    r = Pk(r, e);
  return r && BE(r) && aL(r) && !kP(r) ? t : r || AQ(n) || t;
}
const HQ = async function(n) {
  const e = this.getOffsetParent || CH, t = this.getDimensions, r = await t(n.floating);
  return {
    reference: BQ(n.reference, await e(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function VQ(n) {
  return am(n).direction === "rtl";
}
const GQ = {
  convertOffsetParentRelativeRectToViewportRelativeRect: OQ,
  getDocumentElement: jg,
  getClippingRect: IQ,
  getOffsetParent: CH,
  getElementRects: HQ,
  getClientRects: PQ,
  getDimensions: FQ,
  getScale: NE,
  isElement: im,
  isRTL: VQ
};
function WQ(n, e) {
  let t = null, r;
  const a = jg(n);
  function s() {
    var h;
    clearTimeout(r), (h = t) == null || h.disconnect(), t = null;
  }
  function u(h, v) {
    h === void 0 && (h = !1), v === void 0 && (v = 1), s();
    const {
      left: y,
      top: _,
      width: b,
      height: M
    } = n.getBoundingClientRect();
    if (h || e(), !b || !M)
      return;
    const C = JC(_), D = JC(a.clientWidth - (y + b)), U = JC(a.clientHeight - (_ + M)), N = JC(y), I = {
      rootMargin: -C + "px " + -D + "px " + -U + "px " + -N + "px",
      threshold: ah(0, yv(1, v)) || 1
    };
    let k = !0;
    function G(j) {
      const Y = j[0].intersectionRatio;
      if (Y !== v) {
        if (!k)
          return u();
        Y ? u(!1, Y) : r = setTimeout(() => {
          u(!1, 1e-7);
        }, 1e3);
      }
      k = !1;
    }
    try {
      t = new IntersectionObserver(G, {
        ...I,
        // Handle <iframe>s
        root: a.ownerDocument
      });
    } catch {
      t = new IntersectionObserver(G, I);
    }
    t.observe(n);
  }
  return u(!0), s;
}
function jQ(n, e, t, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: a = !0,
    ancestorResize: s = !0,
    elementResize: u = typeof ResizeObserver == "function",
    layoutShift: h = typeof IntersectionObserver == "function",
    animationFrame: v = !1
  } = r, y = FP(n), _ = a || s ? [...y ? jT(y) : [], ...jT(e)] : [];
  _.forEach((O) => {
    a && O.addEventListener("scroll", t, {
      passive: !0
    }), s && O.addEventListener("resize", t);
  });
  const b = y && h ? WQ(y, t) : null;
  let M = -1, C = null;
  u && (C = new ResizeObserver((O) => {
    let [I] = O;
    I && I.target === y && C && (C.unobserve(e), cancelAnimationFrame(M), M = requestAnimationFrame(() => {
      var k;
      (k = C) == null || k.observe(e);
    })), t();
  }), y && !v && C.observe(y), C.observe(e));
  let D, U = v ? dx(n) : null;
  v && N();
  function N() {
    const O = dx(n);
    U && (O.x !== U.x || O.y !== U.y || O.width !== U.width || O.height !== U.height) && t(), U = O, D = requestAnimationFrame(N);
  }
  return t(), () => {
    var O;
    _.forEach((I) => {
      a && I.removeEventListener("scroll", t), s && I.removeEventListener("resize", t);
    }), b == null || b(), (O = C) == null || O.disconnect(), C = null, v && cancelAnimationFrame(D);
  };
}
const $Q = TQ, YQ = MQ, XQ = _Q, qQ = CQ, KQ = EQ, Nk = xQ, QQ = wQ, ZQ = (n, e, t) => {
  const r = /* @__PURE__ */ new Map(), a = {
    platform: GQ,
    ...t
  }, s = {
    ...a.platform,
    _c: r
  };
  return SQ(n, e, {
    ...a,
    platform: s
  });
};
var pR = typeof document < "u" ? le.useLayoutEffect : le.useEffect;
function CR(n, e) {
  if (n === e)
    return !0;
  if (typeof n != typeof e)
    return !1;
  if (typeof n == "function" && n.toString() === e.toString())
    return !0;
  let t, r, a;
  if (n && e && typeof n == "object") {
    if (Array.isArray(n)) {
      if (t = n.length, t !== e.length)
        return !1;
      for (r = t; r-- !== 0; )
        if (!CR(n[r], e[r]))
          return !1;
      return !0;
    }
    if (a = Object.keys(n), t = a.length, t !== Object.keys(e).length)
      return !1;
    for (r = t; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, a[r]))
        return !1;
    for (r = t; r-- !== 0; ) {
      const s = a[r];
      if (!(s === "_owner" && n.$$typeof) && !CR(n[s], e[s]))
        return !1;
    }
    return !0;
  }
  return n !== n && e !== e;
}
function RH(n) {
  return typeof window > "u" ? 1 : (n.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Uk(n, e) {
  const t = RH(n);
  return Math.round(e * t) / t;
}
function zk(n) {
  const e = le.useRef(n);
  return pR(() => {
    e.current = n;
  }), e;
}
function JQ(n) {
  n === void 0 && (n = {});
  const {
    placement: e = "bottom",
    strategy: t = "absolute",
    middleware: r = [],
    platform: a,
    elements: {
      reference: s,
      floating: u
    } = {},
    transform: h = !0,
    whileElementsMounted: v,
    open: y
  } = n, [_, b] = le.useState({
    x: 0,
    y: 0,
    strategy: t,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [M, C] = le.useState(r);
  CR(M, r) || C(r);
  const [D, U] = le.useState(null), [N, O] = le.useState(null), I = le.useCallback((Te) => {
    Te !== Y.current && (Y.current = Te, U(Te));
  }, []), k = le.useCallback((Te) => {
    Te !== Z.current && (Z.current = Te, O(Te));
  }, []), G = s || D, j = u || N, Y = le.useRef(null), Z = le.useRef(null), te = le.useRef(_), J = v != null, q = zk(v), oe = zk(a), ye = le.useCallback(() => {
    if (!Y.current || !Z.current)
      return;
    const Te = {
      placement: e,
      strategy: t,
      middleware: M
    };
    oe.current && (Te.platform = oe.current), ZQ(Y.current, Z.current, Te).then((ue) => {
      const we = {
        ...ue,
        isPositioned: !0
      };
      de.current && !CR(te.current, we) && (te.current = we, $T.flushSync(() => {
        b(we);
      }));
    });
  }, [M, e, t, oe]);
  pR(() => {
    y === !1 && te.current.isPositioned && (te.current.isPositioned = !1, b((Te) => ({
      ...Te,
      isPositioned: !1
    })));
  }, [y]);
  const de = le.useRef(!1);
  pR(() => (de.current = !0, () => {
    de.current = !1;
  }), []), pR(() => {
    if (G && (Y.current = G), j && (Z.current = j), G && j) {
      if (q.current)
        return q.current(G, j, ye);
      ye();
    }
  }, [G, j, ye, q, J]);
  const xe = le.useMemo(() => ({
    reference: Y,
    floating: Z,
    setReference: I,
    setFloating: k
  }), [I, k]), Re = le.useMemo(() => ({
    reference: G,
    floating: j
  }), [G, j]), Pe = le.useMemo(() => {
    const Te = {
      position: t,
      left: 0,
      top: 0
    };
    if (!Re.floating)
      return Te;
    const ue = Uk(Re.floating, _.x), we = Uk(Re.floating, _.y);
    return h ? {
      ...Te,
      transform: "translate(" + ue + "px, " + we + "px)",
      ...RH(Re.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: t,
      left: ue,
      top: we
    };
  }, [t, h, Re.floating, _.x, _.y]);
  return le.useMemo(() => ({
    ..._,
    update: ye,
    refs: xe,
    elements: Re,
    floatingStyles: Pe
  }), [_, ye, xe, Re, Pe]);
}
const eZ = (n) => {
  function e(t) {
    return {}.hasOwnProperty.call(t, "current");
  }
  return {
    name: "arrow",
    options: n,
    fn(t) {
      const {
        element: r,
        padding: a
      } = typeof n == "function" ? n(t) : n;
      return r && e(r) ? r.current != null ? Nk({
        element: r.current,
        padding: a
      }).fn(t) : {} : r ? Nk({
        element: r,
        padding: a
      }).fn(t) : {};
    }
  };
}, tZ = (n, e) => ({
  ...$Q(n),
  options: [n, e]
}), nZ = (n, e) => ({
  ...YQ(n),
  options: [n, e]
}), rZ = (n, e) => ({
  ...QQ(n),
  options: [n, e]
}), iZ = (n, e) => ({
  ...XQ(n),
  options: [n, e]
}), aZ = (n, e) => ({
  ...qQ(n),
  options: [n, e]
}), oZ = (n, e) => ({
  ...KQ(n),
  options: [n, e]
}), sZ = (n, e) => ({
  ...eZ(n),
  options: [n, e]
});
var lZ = "Arrow", AH = le.forwardRef((n, e) => {
  const { children: t, width: r = 10, height: a = 5, ...s } = n;
  return /* @__PURE__ */ Or.jsx(
    b0.svg,
    {
      ...s,
      ref: e,
      width: r,
      height: a,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: n.asChild ? t : /* @__PURE__ */ Or.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
AH.displayName = lZ;
var uZ = AH;
function cZ(n) {
  const [e, t] = le.useState(void 0);
  return fx(() => {
    if (n) {
      t({ width: n.offsetWidth, height: n.offsetHeight });
      const r = new ResizeObserver((a) => {
        if (!Array.isArray(a) || !a.length)
          return;
        const s = a[0];
        let u, h;
        if ("borderBoxSize" in s) {
          const v = s.borderBoxSize, y = Array.isArray(v) ? v[0] : v;
          u = y.inlineSize, h = y.blockSize;
        } else
          u = n.offsetWidth, h = n.offsetHeight;
        t({ width: u, height: h });
      });
      return r.observe(n, { box: "border-box" }), () => r.unobserve(n);
    } else
      t(void 0);
  }, [n]), e;
}
var BP = "Popper", [DH, LH] = vH(BP), [fZ, OH] = DH(BP), PH = (n) => {
  const { __scopePopper: e, children: t } = n, [r, a] = le.useState(null);
  return /* @__PURE__ */ Or.jsx(fZ, { scope: e, anchor: r, onAnchorChange: a, children: t });
};
PH.displayName = BP;
var NH = "PopperAnchor", UH = le.forwardRef(
  (n, e) => {
    const { __scopePopper: t, virtualRef: r, ...a } = n, s = OH(NH, t), u = le.useRef(null), h = Sx(e, u);
    return le.useEffect(() => {
      s.onAnchorChange((r == null ? void 0 : r.current) || u.current);
    }), r ? null : /* @__PURE__ */ Or.jsx(b0.div, { ...a, ref: h });
  }
);
UH.displayName = NH;
var HP = "PopperContent", [dZ, hZ] = DH(HP), zH = le.forwardRef(
  (n, e) => {
    var Je, at, xt, $t, Ht, he;
    const {
      __scopePopper: t,
      side: r = "bottom",
      sideOffset: a = 0,
      align: s = "center",
      alignOffset: u = 0,
      arrowPadding: h = 0,
      avoidCollisions: v = !0,
      collisionBoundary: y = [],
      collisionPadding: _ = 0,
      sticky: b = "partial",
      hideWhenDetached: M = !1,
      updatePositionStrategy: C = "optimized",
      onPlaced: D,
      ...U
    } = n, N = OH(HP, t), [O, I] = le.useState(null), k = Sx(e, (nt) => I(nt)), [G, j] = le.useState(null), Y = cZ(G), Z = (Y == null ? void 0 : Y.width) ?? 0, te = (Y == null ? void 0 : Y.height) ?? 0, J = r + (s !== "center" ? "-" + s : ""), q = typeof _ == "number" ? _ : { top: 0, right: 0, bottom: 0, left: 0, ..._ }, oe = Array.isArray(y) ? y : [y], ye = oe.length > 0, de = {
      padding: q,
      boundary: oe.filter(mZ),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: ye
    }, { refs: xe, floatingStyles: Re, placement: Pe, isPositioned: Te, middlewareData: ue } = JQ({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: J,
      whileElementsMounted: (...nt) => jQ(...nt, {
        animationFrame: C === "always"
      }),
      elements: {
        reference: N.anchor
      },
      middleware: [
        tZ({ mainAxis: a + te, alignmentAxis: u }),
        v && nZ({
          mainAxis: !0,
          crossAxis: !1,
          limiter: b === "partial" ? rZ() : void 0,
          ...de
        }),
        v && iZ({ ...de }),
        aZ({
          ...de,
          apply: ({ elements: nt, rects: et, availableWidth: Rt, availableHeight: gt }) => {
            const { width: Jt, height: Kt } = et.reference, qt = nt.floating.style;
            qt.setProperty("--radix-popper-available-width", `${Rt}px`), qt.setProperty("--radix-popper-available-height", `${gt}px`), qt.setProperty("--radix-popper-anchor-width", `${Jt}px`), qt.setProperty("--radix-popper-anchor-height", `${Kt}px`);
          }
        }),
        G && sZ({ element: G, padding: h }),
        vZ({ arrowWidth: Z, arrowHeight: te }),
        M && oZ({ strategy: "referenceHidden", ...de })
      ]
    }), [we, X] = FH(Pe), me = ZE(D);
    fx(() => {
      Te && (me == null || me());
    }, [Te, me]);
    const ce = (Je = ue.arrow) == null ? void 0 : Je.x, Ue = (at = ue.arrow) == null ? void 0 : at.y, Oe = ((xt = ue.arrow) == null ? void 0 : xt.centerOffset) !== 0, [Ze, je] = le.useState();
    return fx(() => {
      O && je(window.getComputedStyle(O).zIndex);
    }, [O]), /* @__PURE__ */ Or.jsx(
      "div",
      {
        ref: xe.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...Re,
          transform: Te ? Re.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Ze,
          "--radix-popper-transform-origin": [
            ($t = ue.transformOrigin) == null ? void 0 : $t.x,
            (Ht = ue.transformOrigin) == null ? void 0 : Ht.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((he = ue.hide) == null ? void 0 : he.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: n.dir,
        children: /* @__PURE__ */ Or.jsx(
          dZ,
          {
            scope: t,
            placedSide: we,
            onArrowChange: j,
            arrowX: ce,
            arrowY: Ue,
            shouldHideArrow: Oe,
            children: /* @__PURE__ */ Or.jsx(
              b0.div,
              {
                "data-side": we,
                "data-align": X,
                ...U,
                ref: k,
                style: {
                  ...U.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: Te ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
zH.displayName = HP;
var kH = "PopperArrow", pZ = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, IH = le.forwardRef(function(e, t) {
  const { __scopePopper: r, ...a } = e, s = hZ(kH, r), u = pZ[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ Or.jsx(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [u]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ Or.jsx(
          uZ,
          {
            ...a,
            ref: t,
            style: {
              ...a.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
IH.displayName = kH;
function mZ(n) {
  return n !== null;
}
var vZ = (n) => ({
  name: "transformOrigin",
  options: n,
  fn(e) {
    var N, O, I;
    const { placement: t, rects: r, middlewareData: a } = e, u = ((N = a.arrow) == null ? void 0 : N.centerOffset) !== 0, h = u ? 0 : n.arrowWidth, v = u ? 0 : n.arrowHeight, [y, _] = FH(t), b = { start: "0%", center: "50%", end: "100%" }[_], M = (((O = a.arrow) == null ? void 0 : O.x) ?? 0) + h / 2, C = (((I = a.arrow) == null ? void 0 : I.y) ?? 0) + v / 2;
    let D = "", U = "";
    return y === "bottom" ? (D = u ? b : `${M}px`, U = `${-v}px`) : y === "top" ? (D = u ? b : `${M}px`, U = `${r.floating.height + v}px`) : y === "right" ? (D = `${-v}px`, U = u ? b : `${C}px`) : y === "left" && (D = `${r.floating.width + v}px`, U = u ? b : `${C}px`), { data: { x: D, y: U } };
  }
});
function FH(n) {
  const [e, t = "center"] = n.split("-");
  return [e, t];
}
var gZ = PH, yZ = UH, SZ = zH, xZ = IH;
function _Z(n, e) {
  return le.useReducer((t, r) => e[t][r] ?? t, n);
}
var BH = (n) => {
  const { present: e, children: t } = n, r = EZ(e), a = typeof t == "function" ? t({ present: r.isPresent }) : le.Children.only(t), s = Sx(r.ref, bZ(a));
  return typeof t == "function" || r.isPresent ? le.cloneElement(a, { ref: s }) : null;
};
BH.displayName = "Presence";
function EZ(n) {
  const [e, t] = le.useState(), r = le.useRef({}), a = le.useRef(n), s = le.useRef("none"), u = n ? "mounted" : "unmounted", [h, v] = _Z(u, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return le.useEffect(() => {
    const y = eR(r.current);
    s.current = h === "mounted" ? y : "none";
  }, [h]), fx(() => {
    const y = r.current, _ = a.current;
    if (_ !== n) {
      const M = s.current, C = eR(y);
      n ? v("MOUNT") : C === "none" || (y == null ? void 0 : y.display) === "none" ? v("UNMOUNT") : v(_ && M !== C ? "ANIMATION_OUT" : "UNMOUNT"), a.current = n;
    }
  }, [n, v]), fx(() => {
    if (e) {
      const y = (b) => {
        const C = eR(r.current).includes(b.animationName);
        b.target === e && C && $T.flushSync(() => v("ANIMATION_END"));
      }, _ = (b) => {
        b.target === e && (s.current = eR(r.current));
      };
      return e.addEventListener("animationstart", _), e.addEventListener("animationcancel", y), e.addEventListener("animationend", y), () => {
        e.removeEventListener("animationstart", _), e.removeEventListener("animationcancel", y), e.removeEventListener("animationend", y);
      };
    } else
      v("ANIMATION_END");
  }, [e, v]), {
    isPresent: ["mounted", "unmountSuspended"].includes(h),
    ref: le.useCallback((y) => {
      y && (r.current = getComputedStyle(y)), t(y);
    }, [])
  };
}
function eR(n) {
  return (n == null ? void 0 : n.animationName) || "none";
}
function bZ(n) {
  var r, a;
  let e = (r = Object.getOwnPropertyDescriptor(n.props, "ref")) == null ? void 0 : r.get, t = e && "isReactWarning" in e && e.isReactWarning;
  return t ? n.ref : (e = (a = Object.getOwnPropertyDescriptor(n, "ref")) == null ? void 0 : a.get, t = e && "isReactWarning" in e && e.isReactWarning, t ? n.props.ref : n.props.ref || n.ref);
}
function TZ({
  prop: n,
  defaultProp: e,
  onChange: t = () => {
  }
}) {
  const [r, a] = MZ({ defaultProp: e, onChange: t }), s = n !== void 0, u = s ? n : r, h = ZE(t), v = le.useCallback(
    (y) => {
      if (s) {
        const b = typeof y == "function" ? y(n) : y;
        b !== n && h(b);
      } else
        a(y);
    },
    [s, n, a, h]
  );
  return [u, v];
}
function MZ({
  defaultProp: n,
  onChange: e
}) {
  const t = le.useState(n), [r] = t, a = le.useRef(r), s = ZE(e);
  return le.useEffect(() => {
    a.current !== r && (s(r), a.current = r);
  }, [r, a, s]), t;
}
var wZ = "VisuallyHidden", HH = le.forwardRef(
  (n, e) => /* @__PURE__ */ Or.jsx(
    b0.span,
    {
      ...n,
      ref: e,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...n.style
      }
    }
  )
);
HH.displayName = wZ;
var CZ = HH, [iA, hie] = vH("Tooltip", [
  LH
]), aA = LH(), RZ = "TooltipProvider", SO = "tooltip.open", [pie, VP] = iA(RZ), oA = "Tooltip", [AZ, sA] = iA(oA), VH = (n) => {
  const {
    __scopeTooltip: e,
    children: t,
    open: r,
    defaultOpen: a = !1,
    onOpenChange: s,
    disableHoverableContent: u,
    delayDuration: h
  } = n, v = VP(oA, n.__scopeTooltip), y = aA(e), [_, b] = le.useState(null), M = cQ(), C = le.useRef(0), D = u ?? v.disableHoverableContent, U = h ?? v.delayDuration, N = le.useRef(!1), [O = !1, I] = TZ({
    prop: r,
    defaultProp: a,
    onChange: (Z) => {
      Z ? (v.onOpen(), document.dispatchEvent(new CustomEvent(SO))) : v.onClose(), s == null || s(Z);
    }
  }), k = le.useMemo(() => O ? N.current ? "delayed-open" : "instant-open" : "closed", [O]), G = le.useCallback(() => {
    window.clearTimeout(C.current), N.current = !1, I(!0);
  }, [I]), j = le.useCallback(() => {
    window.clearTimeout(C.current), I(!1);
  }, [I]), Y = le.useCallback(() => {
    window.clearTimeout(C.current), C.current = window.setTimeout(() => {
      N.current = !0, I(!0);
    }, U);
  }, [U, I]);
  return le.useEffect(() => () => window.clearTimeout(C.current), []), /* @__PURE__ */ Or.jsx(gZ, { ...y, children: /* @__PURE__ */ Or.jsx(
    AZ,
    {
      scope: e,
      contentId: M,
      open: O,
      stateAttribute: k,
      trigger: _,
      onTriggerChange: b,
      onTriggerEnter: le.useCallback(() => {
        v.isOpenDelayed ? Y() : G();
      }, [v.isOpenDelayed, Y, G]),
      onTriggerLeave: le.useCallback(() => {
        D ? j() : window.clearTimeout(C.current);
      }, [j, D]),
      onOpen: G,
      onClose: j,
      disableHoverableContent: D,
      children: t
    }
  ) });
};
VH.displayName = oA;
var xO = "TooltipTrigger", GH = le.forwardRef(
  (n, e) => {
    const { __scopeTooltip: t, ...r } = n, a = sA(xO, t), s = VP(xO, t), u = aA(t), h = le.useRef(null), v = Sx(e, h, a.onTriggerChange), y = le.useRef(!1), _ = le.useRef(!1), b = le.useCallback(() => y.current = !1, []);
    return le.useEffect(() => () => document.removeEventListener("pointerup", b), [b]), /* @__PURE__ */ Or.jsx(yZ, { asChild: !0, ...u, children: /* @__PURE__ */ Or.jsx(
      b0.button,
      {
        "aria-describedby": a.open ? a.contentId : void 0,
        "data-state": a.stateAttribute,
        ...r,
        ref: v,
        onPointerMove: Og(n.onPointerMove, (M) => {
          M.pointerType !== "touch" && !_.current && !s.isPointerInTransitRef.current && (a.onTriggerEnter(), _.current = !0);
        }),
        onPointerLeave: Og(n.onPointerLeave, () => {
          a.onTriggerLeave(), _.current = !1;
        }),
        onPointerDown: Og(n.onPointerDown, () => {
          y.current = !0, document.addEventListener("pointerup", b, { once: !0 });
        }),
        onFocus: Og(n.onFocus, () => {
          y.current || a.onOpen();
        }),
        onBlur: Og(n.onBlur, a.onClose),
        onClick: Og(n.onClick, a.onClose)
      }
    ) });
  }
);
GH.displayName = xO;
var DZ = "TooltipPortal", [mie, LZ] = iA(DZ, {
  forceMount: void 0
}), HE = "TooltipContent", WH = le.forwardRef(
  (n, e) => {
    const t = LZ(HE, n.__scopeTooltip), { forceMount: r = t.forceMount, side: a = "top", ...s } = n, u = sA(HE, n.__scopeTooltip);
    return /* @__PURE__ */ Or.jsx(BH, { present: r || u.open, children: u.disableHoverableContent ? /* @__PURE__ */ Or.jsx(jH, { side: a, ...s, ref: e }) : /* @__PURE__ */ Or.jsx(OZ, { side: a, ...s, ref: e }) });
  }
), OZ = le.forwardRef((n, e) => {
  const t = sA(HE, n.__scopeTooltip), r = VP(HE, n.__scopeTooltip), a = le.useRef(null), s = Sx(e, a), [u, h] = le.useState(null), { trigger: v, onClose: y } = t, _ = a.current, { onPointerInTransitChange: b } = r, M = le.useCallback(() => {
    h(null), b(!1);
  }, [b]), C = le.useCallback(
    (D, U) => {
      const N = D.currentTarget, O = { x: D.clientX, y: D.clientY }, I = UZ(O, N.getBoundingClientRect()), k = zZ(O, I), G = kZ(U.getBoundingClientRect()), j = FZ([...k, ...G]);
      h(j), b(!0);
    },
    [b]
  );
  return le.useEffect(() => () => M(), [M]), le.useEffect(() => {
    if (v && _) {
      const D = (N) => C(N, _), U = (N) => C(N, v);
      return v.addEventListener("pointerleave", D), _.addEventListener("pointerleave", U), () => {
        v.removeEventListener("pointerleave", D), _.removeEventListener("pointerleave", U);
      };
    }
  }, [v, _, C, M]), le.useEffect(() => {
    if (u) {
      const D = (U) => {
        const N = U.target, O = { x: U.clientX, y: U.clientY }, I = (v == null ? void 0 : v.contains(N)) || (_ == null ? void 0 : _.contains(N)), k = !IZ(O, u);
        I ? M() : k && (M(), y());
      };
      return document.addEventListener("pointermove", D), () => document.removeEventListener("pointermove", D);
    }
  }, [v, _, u, y, M]), /* @__PURE__ */ Or.jsx(jH, { ...n, ref: s });
}), [PZ, NZ] = iA(oA, { isInside: !1 }), jH = le.forwardRef(
  (n, e) => {
    const {
      __scopeTooltip: t,
      children: r,
      "aria-label": a,
      onEscapeKeyDown: s,
      onPointerDownOutside: u,
      ...h
    } = n, v = sA(HE, t), y = aA(t), { onClose: _ } = v;
    return le.useEffect(() => (document.addEventListener(SO, _), () => document.removeEventListener(SO, _)), [_]), le.useEffect(() => {
      if (v.trigger) {
        const b = (M) => {
          const C = M.target;
          C != null && C.contains(v.trigger) && _();
        };
        return window.addEventListener("scroll", b, { capture: !0 }), () => window.removeEventListener("scroll", b, { capture: !0 });
      }
    }, [v.trigger, _]), /* @__PURE__ */ Or.jsx(
      yH,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: s,
        onPointerDownOutside: u,
        onFocusOutside: (b) => b.preventDefault(),
        onDismiss: _,
        children: /* @__PURE__ */ Or.jsxs(
          SZ,
          {
            "data-state": v.stateAttribute,
            ...y,
            ...h,
            ref: e,
            style: {
              ...h.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ Or.jsx(uH, { children: r }),
              /* @__PURE__ */ Or.jsx(PZ, { scope: t, isInside: !0, children: /* @__PURE__ */ Or.jsx(CZ, { id: v.contentId, role: "tooltip", children: a || r }) })
            ]
          }
        )
      }
    );
  }
);
WH.displayName = HE;
var $H = "TooltipArrow", YH = le.forwardRef(
  (n, e) => {
    const { __scopeTooltip: t, ...r } = n, a = aA(t);
    return NZ(
      $H,
      t
    ).isInside ? null : /* @__PURE__ */ Or.jsx(xZ, { ...a, ...r, ref: e });
  }
);
YH.displayName = $H;
function UZ(n, e) {
  const t = Math.abs(e.top - n.y), r = Math.abs(e.bottom - n.y), a = Math.abs(e.right - n.x), s = Math.abs(e.left - n.x);
  switch (Math.min(t, r, a, s)) {
    case s:
      return "left";
    case a:
      return "right";
    case t:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function zZ(n, e, t = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push(
        { x: n.x - t, y: n.y + t },
        { x: n.x + t, y: n.y + t }
      );
      break;
    case "bottom":
      r.push(
        { x: n.x - t, y: n.y - t },
        { x: n.x + t, y: n.y - t }
      );
      break;
    case "left":
      r.push(
        { x: n.x + t, y: n.y - t },
        { x: n.x + t, y: n.y + t }
      );
      break;
    case "right":
      r.push(
        { x: n.x - t, y: n.y - t },
        { x: n.x - t, y: n.y + t }
      );
      break;
  }
  return r;
}
function kZ(n) {
  const { top: e, right: t, bottom: r, left: a } = n;
  return [
    { x: a, y: e },
    { x: t, y: e },
    { x: t, y: r },
    { x: a, y: r }
  ];
}
function IZ(n, e) {
  const { x: t, y: r } = n;
  let a = !1;
  for (let s = 0, u = e.length - 1; s < e.length; u = s++) {
    const h = e[s].x, v = e[s].y, y = e[u].x, _ = e[u].y;
    v > r != _ > r && t < (y - h) * (r - v) / (_ - v) + h && (a = !a);
  }
  return a;
}
function FZ(n) {
  const e = n.slice();
  return e.sort((t, r) => t.x < r.x ? -1 : t.x > r.x ? 1 : t.y < r.y ? -1 : t.y > r.y ? 1 : 0), BZ(e);
}
function BZ(n) {
  if (n.length <= 1)
    return n.slice();
  const e = [];
  for (let r = 0; r < n.length; r++) {
    const a = n[r];
    for (; e.length >= 2; ) {
      const s = e[e.length - 1], u = e[e.length - 2];
      if ((s.x - u.x) * (a.y - u.y) >= (s.y - u.y) * (a.x - u.x))
        e.pop();
      else
        break;
    }
    e.push(a);
  }
  e.pop();
  const t = [];
  for (let r = n.length - 1; r >= 0; r--) {
    const a = n[r];
    for (; t.length >= 2; ) {
      const s = t[t.length - 1], u = t[t.length - 2];
      if ((s.x - u.x) * (a.y - u.y) >= (s.y - u.y) * (a.x - u.x))
        t.pop();
      else
        break;
    }
    t.push(a);
  }
  return t.pop(), e.length === 1 && t.length === 1 && e[0].x === t[0].x && e[0].y === t[0].y ? e : e.concat(t);
}
var HZ = VH, VZ = GH, GZ = WH, WZ = YH;
function jZ(n, e) {
  if (n == null)
    return {};
  var t = {}, r = Object.keys(n), a, s;
  for (s = 0; s < r.length; s++)
    a = r[s], !(e.indexOf(a) >= 0) && (t[a] = n[a]);
  return t;
}
function Za(n, e) {
  if (n == null)
    return {};
  var t = jZ(n, e), r, a;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (a = 0; a < s.length; a++)
      r = s[a], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]);
  }
  return t;
}
let is;
(function(n) {
  n[n.UNSUPPORTED_INPUT = 0] = "UNSUPPORTED_INPUT", n[n.NO_COMPONENT_FOR_TYPE = 1] = "NO_COMPONENT_FOR_TYPE", n[n.UNKNOWN_INPUT = 2] = "UNKNOWN_INPUT", n[n.DUPLICATE_KEYS = 3] = "DUPLICATE_KEYS", n[n.ALREADY_REGISTERED_TYPE = 4] = "ALREADY_REGISTERED_TYPE", n[n.CLIPBOARD_ERROR = 5] = "CLIPBOARD_ERROR", n[n.THEME_ERROR = 6] = "THEME_ERROR", n[n.PATH_DOESNT_EXIST = 7] = "PATH_DOESNT_EXIST", n[n.INPUT_TYPE_OVERRIDE = 8] = "INPUT_TYPE_OVERRIDE", n[n.EMPTY_KEY = 9] = "EMPTY_KEY";
})(is || (is = {}));
const $Z = {
  [is.UNSUPPORTED_INPUT]: (n, e) => [`An input with type \`${n}\` input was found at path \`${e}\` but it's not supported yet.`],
  [is.NO_COMPONENT_FOR_TYPE]: (n, e) => [`Type \`${n}\` found at path \`${e}\` can't be displayed in panel because no component supports it yet.`],
  [is.UNKNOWN_INPUT]: (n, e) => [`input at path \`${n}\` is not recognized.`, e],
  [is.DUPLICATE_KEYS]: (n, e, t) => [`Key \`${n}\` of path \`${e}\` already exists at path \`${t}\`. Even nested keys need to be unique. Rename one of the keys.`],
  [is.ALREADY_REGISTERED_TYPE]: (n) => [`Type ${n} has already been registered. You can't register a component with the same type.`],
  [is.CLIPBOARD_ERROR]: (n) => ["Error copying the value", n],
  [is.THEME_ERROR]: (n, e) => [`Error accessing the theme \`${n}.${e}\` value.`],
  [is.PATH_DOESNT_EXIST]: (n) => [`Error getting the value at path \`${n}\`. There is probably an error in your \`render\` function.`],
  [is.PATH_DOESNT_EXIST]: (n) => [`Error accessing the value at path \`${n}\``],
  [is.INPUT_TYPE_OVERRIDE]: (n, e, t) => [`Input at path \`${n}\` already exists with type: \`${e}\`. Its type cannot be overridden with type \`${t}\`.`],
  [is.EMPTY_KEY]: () => ["Keys can not be empty, if you want to hide a label use whitespace."]
};
function XH(n, e, ...t) {
  const [r, ...a] = $Z[e](...t);
  console[n]("LEVA: " + r, ...a);
}
const Ng = XH.bind(null, "warn"), YZ = XH.bind(null, "log"), XZ = ["value"], qZ = ["schema"], KZ = ["value"], qH = [], hx = {};
function kk(n) {
  let {
    value: e
  } = n, t = Za(n, XZ);
  for (let r of qH) {
    const a = r(e, t);
    if (a)
      return a;
  }
}
function $g(n, e) {
  let {
    schema: t
  } = e, r = Za(e, qZ);
  if (n in hx) {
    Ng(is.ALREADY_REGISTERED_TYPE, n);
    return;
  }
  qH.push((a, s) => t(a, s) && n), hx[n] = r;
}
function oL(n, e, t, r) {
  const {
    normalize: a
  } = hx[n];
  if (a)
    return a(e, t, r);
  if (typeof e != "object" || !("value" in e))
    return {
      value: e
    };
  const {
    value: s
  } = e, u = Za(e, KZ);
  return {
    value: s,
    settings: u
  };
}
function QZ(n, e, t, r, a, s) {
  const {
    sanitize: u
  } = hx[n];
  return u ? u(e, t, r, a, s) : e;
}
function Ik(n, e, t) {
  const {
    format: r
  } = hx[n];
  return r ? r(e, t) : e;
}
function ZZ(n, e, t) {
  return e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Fk(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(n, a).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function Lr(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Fk(Object(t), !0).forEach(function(r) {
      ZZ(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Fk(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
const y0 = (n, e, t) => n > t ? t : n < e ? e : n, JZ = (n) => {
  if (n === "" || typeof n == "number")
    return n;
  try {
    const e = o0(n);
    if (!isNaN(e))
      return e;
  } catch {
  }
  return parseFloat(n);
}, eJ = Math.log(10);
function Bk(n) {
  let e = Math.abs(+String(n).replace(".", ""));
  if (e === 0)
    return 0.01;
  for (; e !== 0 && e % 10 === 0; )
    e /= 10;
  const t = Math.floor(Math.log(e) / eJ) + 1, r = Math.floor(Math.log10(Math.abs(n))), a = Math.pow(10, r - t);
  return Math.max(a, 1e-3);
}
const RR = (n, e, t) => t === e ? 0 : (y0(n, e, t) - e) / (t - e), AR = (n, e, t) => n * (t - e) + e, tJ = () => "_" + Math.random().toString(36).substr(2, 9), Hk = /\(([0-9+\-*/^ .]+)\)/, Vk = /(\d+(?:\.\d+)?) ?\^ ?(\d+(?:\.\d+)?)/, Gk = /(\d+(?:\.\d+)?) ?\* ?(\d+(?:\.\d+)?)/, Wk = /(\d+(?:\.\d+)?) ?\/ ?(\d+(?:\.\d+)?)/, jk = /(\d+(?:\.\d+)?) ?\+ ?(\d+(?:\.\d+)?)/, $k = /(\d+(?:\.\d+)?) ?- ?(\d+(?:\.\d+)?)/;
function o0(n) {
  if (isNaN(Number(n)))
    if (Hk.test(n)) {
      const e = n.replace(Hk, (t, r) => String(o0(r)));
      return o0(e);
    } else if (Vk.test(n)) {
      const e = n.replace(Vk, (t, r, a) => String(Math.pow(Number(r), Number(a))));
      return o0(e);
    } else if (Gk.test(n)) {
      const e = n.replace(Gk, (t, r, a) => String(Number(r) * Number(a)));
      return o0(e);
    } else if (Wk.test(n)) {
      const e = n.replace(Wk, (t, r, a) => {
        if (a != 0)
          return String(Number(r) / Number(a));
        throw new Error("Division by zero");
      });
      return o0(e);
    } else if (jk.test(n)) {
      const e = n.replace(jk, (t, r, a) => String(Number(r) + Number(a)));
      return o0(e);
    } else if ($k.test(n)) {
      const e = n.replace($k, (t, r, a) => String(Number(r) - Number(a)));
      return o0(e);
    } else
      return Number(n);
  return Number(n);
}
function nJ(n, e) {
  return e.reduce((t, r) => (n && n.hasOwnProperty(r) && (t[r] = n[r]), t), {});
}
function rJ(n, e) {
  const t = Lr({}, n);
  return e.forEach((r) => r in n && delete t[r]), t;
}
function iJ(n, e) {
  return n.reduce((t, r, a) => Object.assign(t, {
    [e[a]]: r
  }), {});
}
function KH(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
const aJ = (n) => KH(n) && Object.keys(n).length === 0;
let tm;
(function(n) {
  n.BUTTON = "BUTTON", n.BUTTON_GROUP = "BUTTON_GROUP", n.MONITOR = "MONITOR", n.FOLDER = "FOLDER";
})(tm || (tm = {}));
let om;
(function(n) {
  n.SELECT = "SELECT", n.IMAGE = "IMAGE", n.NUMBER = "NUMBER", n.COLOR = "COLOR", n.STRING = "STRING", n.BOOLEAN = "BOOLEAN", n.INTERVAL = "INTERVAL", n.VECTOR3D = "VECTOR3D", n.VECTOR2D = "VECTOR2D";
})(om || (om = {}));
const oJ = ["type", "__customInput"], sJ = ["render", "label", "optional", "order", "disabled", "hint", "onChange", "onEditStart", "onEditEnd", "transient"], lJ = ["type"];
function QH(n, e, t = {}, r) {
  var a, s;
  if (typeof n != "object" || Array.isArray(n))
    return {
      type: r,
      input: n,
      options: Lr({
        key: e,
        label: e,
        optional: !1,
        disabled: !1,
        order: 0
      }, t)
    };
  if ("__customInput" in n) {
    const {
      type: j,
      __customInput: Y
    } = n, Z = Za(n, oJ);
    return QH(Y, e, Z, j);
  }
  const {
    render: u,
    label: h,
    optional: v,
    order: y = 0,
    disabled: _,
    hint: b,
    onChange: M,
    onEditStart: C,
    onEditEnd: D,
    transient: U
  } = n, N = Za(n, sJ), O = Lr({
    render: u,
    key: e,
    label: h ?? e,
    hint: b,
    transient: U ?? !!M,
    onEditStart: C,
    onEditEnd: D,
    disabled: _,
    optional: v,
    order: y
  }, t);
  let {
    type: I
  } = N, k = Za(N, lJ);
  if (I = r ?? I, I in tm)
    return {
      type: I,
      input: k,
      options: O
    };
  let G;
  return r && KH(k) && "value" in k ? G = k.value : G = aJ(k) ? void 0 : k, {
    type: I,
    input: G,
    options: Lr(Lr({}, O), {}, {
      onChange: M,
      optional: (a = O.optional) !== null && a !== void 0 ? a : !1,
      disabled: (s = O.disabled) !== null && s !== void 0 ? s : !1
    })
  };
}
function uJ(n, e, t, r) {
  const a = QH(n, e), {
    type: s,
    input: u,
    options: h
  } = a;
  if (s)
    return s in tm ? a : {
      type: s,
      input: oL(s, u, t, r),
      options: h
    };
  let v = kk(u);
  return v ? {
    type: v,
    input: oL(v, u, t, r),
    options: h
  } : (v = kk({
    value: u
  }), v ? {
    type: v,
    input: oL(v, {
      value: u
    }, t, r),
    options: h
  } : !1);
}
function Yk(n, e, t, r, a) {
  const {
    value: s,
    type: u,
    settings: h
  } = n;
  n.value = ZH({
    type: u,
    value: s,
    settings: h
  }, e, t, r), n.fromPanel = a;
}
const cJ = function(e, t, r) {
  this.type = "LEVA_ERROR", this.message = "LEVA: " + e, this.previousValue = t, this.error = r;
};
function ZH({
  type: n,
  value: e,
  settings: t
}, r, a, s) {
  const u = n !== "SELECT" && typeof r == "function" ? r(e) : r;
  let h;
  try {
    h = QZ(n, u, t, e, a, s);
  } catch (v) {
    throw new cJ(`The value \`${r}\` did not result in a correct value.`, e, v);
  }
  return VT(h, e) ? e : h;
}
const JH = (n, e, t = !1) => {
  let r = 0;
  return function() {
    const a = arguments, s = t && !r, u = () => n.apply(this, a);
    window.clearTimeout(r), r = window.setTimeout(u, e), s && u();
  };
}, e4 = (n) => n.shiftKey ? 5 : n.altKey ? 1 / 5 : 1;
function fJ(n, e) {
  const t = console.error;
  console.error = () => {
  }, AI.render(n, e), console.error = t;
}
const dJ = ["value"], hJ = ["min", "max"], pJ = (n) => {
  if (typeof n == "number")
    return !0;
  if (typeof n == "string") {
    const e = parseFloat(n);
    return isNaN(e) ? !1 : n.substring(("" + e).length).trim().length < 4;
  }
  return !1;
}, t4 = (n, {
  min: e = -1 / 0,
  max: t = 1 / 0,
  suffix: r
}) => {
  const a = parseFloat(n);
  if (n === "" || isNaN(a))
    throw Error("Invalid number");
  const s = y0(a, e, t);
  return r ? s + r : s;
}, mJ = (n, {
  pad: e = 0,
  suffix: t
}) => {
  const r = parseFloat(n).toFixed(e);
  return t ? r + t : r;
}, n4 = (n) => {
  let {
    value: e
  } = n, t = Za(n, dJ);
  const {
    min: r = -1 / 0,
    max: a = 1 / 0
  } = t, s = Za(t, hJ);
  let u = parseFloat(e);
  const h = typeof e == "string" ? e.substring(("" + u).length) : void 0;
  u = y0(u, r, a);
  let v = t.step;
  v || (Number.isFinite(r) ? Number.isFinite(a) ? v = +(Math.abs(a - r) / 100).toPrecision(1) : v = +(Math.abs(u - r) / 100).toPrecision(1) : Number.isFinite(a) && (v = +(Math.abs(a - u) / 100).toPrecision(1)));
  const y = v ? Bk(v) * 10 : Bk(u);
  v = v || y / 10;
  const _ = Math.round(y0(Math.log10(1 / y), 0, 2));
  return {
    value: h ? u + h : u,
    settings: Lr({
      initialValue: u,
      step: v,
      pad: _,
      min: r,
      max: a,
      suffix: h
    }, s)
  };
}, r4 = (n, {
  step: e,
  initialValue: t
}) => {
  const r = Math.round((n - t) / e);
  return t + r * e;
};
var i4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: pJ,
  sanitize: t4,
  format: mJ,
  normalize: n4,
  sanitizeStep: r4
});
function As() {
  return As = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, As.apply(this, arguments);
}
const a4 = le.createContext({});
function Pc() {
  return le.useContext(a4);
}
const GP = le.createContext(null), o4 = le.createContext(null), s4 = le.createContext(null);
function mM() {
  return le.useContext(o4);
}
function vJ() {
  return le.useContext(s4);
}
const l4 = () => ({
  colors: {
    elevation1: "#292d39",
    elevation2: "#181c20",
    elevation3: "#373c4b",
    accent1: "#0066dc",
    accent2: "#007bff",
    accent3: "#3c93ff",
    highlight1: "#535760",
    highlight2: "#8c92a4",
    highlight3: "#fefefe",
    vivid1: "#ffcc00",
    folderWidgetColor: "$highlight2",
    folderTextColor: "$highlight3",
    toolTipBackground: "$highlight3",
    toolTipText: "$elevation2"
  },
  radii: {
    xs: "2px",
    sm: "3px",
    lg: "10px"
  },
  space: {
    xs: "3px",
    sm: "6px",
    md: "10px",
    rowGap: "7px",
    colGap: "7px"
  },
  fonts: {
    mono: "ui-monospace, SFMono-Regular, Menlo, 'Roboto Mono', monospace",
    sans: "system-ui, sans-serif"
  },
  fontSizes: {
    root: "11px",
    toolTip: "$root"
  },
  sizes: {
    rootWidth: "280px",
    controlWidth: "160px",
    numberInputMinWidth: "38px",
    scrubberWidth: "8px",
    scrubberHeight: "16px",
    rowHeight: "24px",
    folderTitleHeight: "20px",
    checkboxSize: "16px",
    joystickWidth: "100px",
    joystickHeight: "100px",
    colorPickerWidth: "$controlWidth",
    colorPickerHeight: "100px",
    imagePreviewWidth: "$controlWidth",
    imagePreviewHeight: "100px",
    monitorHeight: "60px",
    titleBarHeight: "39px"
  },
  shadows: {
    level1: "0 0 9px 0 #00000088",
    level2: "0 4px 14px #00000033"
  },
  borderWidths: {
    root: "0px",
    input: "1px",
    focus: "1px",
    hover: "1px",
    active: "1px",
    folder: "1px"
  },
  fontWeights: {
    label: "normal",
    folder: "normal",
    button: "normal"
  }
});
function tR(n, e) {
  const [t, r] = n.split(" "), a = {};
  return t !== "none" && (a.boxShadow = `${e.inset ? "inset " : ""}0 0 0 $borderWidths${[e.key]} $colors${t !== "default" && t || e.borderColor}`), r && (a.backgroundColor = r), a;
}
const sT = {
  $inputStyle: () => (n) => tR(n, {
    key: "$input",
    borderColor: "$highlight1",
    inset: !0
  }),
  $focusStyle: () => (n) => tR(n, {
    key: "$focus",
    borderColor: "$accent2"
  }),
  $hoverStyle: () => (n) => tR(n, {
    key: "$hover",
    borderColor: "$accent1",
    inset: !0
  }),
  $activeStyle: () => (n) => tR(n, {
    key: "$active",
    borderColor: "$accent1",
    inset: !0
  })
}, {
  styled: Er,
  css: vie,
  createTheme: gJ,
  globalCss: yJ,
  keyframes: gie
} = ZK({
  prefix: "leva",
  theme: l4(),
  utils: Lr(Lr({}, sT), {}, {
    $flex: () => ({
      display: "flex",
      alignItems: "center"
    }),
    $flexCenter: () => ({
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }),
    $reset: () => ({
      outline: "none",
      fontSize: "inherit",
      fontWeight: "inherit",
      color: "inherit",
      fontFamily: "inherit",
      border: "none",
      backgroundColor: "transparent",
      appearance: "none"
    }),
    $draggable: () => ({
      touchAction: "none",
      WebkitUserDrag: "none",
      userSelect: "none"
    }),
    $focus: (n) => ({
      "&:focus": sT.$focusStyle()(n)
    }),
    $focusWithin: (n) => ({
      "&:focus-within": sT.$focusStyle()(n)
    }),
    $hover: (n) => ({
      "&:hover": sT.$hoverStyle()(n)
    }),
    $active: (n) => ({
      "&:active": sT.$activeStyle()(n)
    })
  })
}), SJ = yJ({
  ".leva__panel__dragged": {
    WebkitUserDrag: "none",
    userSelect: "none",
    input: {
      userSelect: "none"
    },
    "*": {
      cursor: "ew-resize !important"
    }
  }
});
function xJ(n) {
  const e = l4();
  if (!n)
    return {
      theme: e,
      className: ""
    };
  Object.keys(n).forEach((r) => {
    Object.assign(e[r], n[r]);
  });
  const t = gJ(e);
  return {
    theme: e,
    className: t.className
  };
}
function Ig(n, e) {
  const {
    theme: t
  } = le.useContext(GP);
  if (!(n in t) || !(e in t[n]))
    return Ng(is.THEME_ERROR, n, e), "";
  let r = e;
  for (; ; ) {
    let a = t[n][r];
    if (typeof a == "string" && a.charAt(0) === "$")
      r = a.substr(1);
    else
      return a;
  }
}
const u4 = Er("input", {
  $reset: "",
  padding: "0 $sm",
  width: 0,
  minWidth: 0,
  flex: 1,
  height: "100%",
  variants: {
    levaType: {
      number: {
        textAlign: "right"
      }
    },
    as: {
      textarea: {
        padding: "$sm"
      }
    }
  }
}), c4 = Er("div", {
  $draggable: "",
  height: "100%",
  $flexCenter: "",
  position: "relative",
  padding: "0 $xs",
  fontSize: "0.8em",
  opacity: 0.8,
  cursor: "default",
  touchAction: "none",
  [`& + ${u4}`]: {
    paddingLeft: 0
  }
}), _J = Er(c4, {
  cursor: "ew-resize",
  marginRight: "-$xs",
  textTransform: "uppercase",
  opacity: 0.3,
  "&:hover": {
    opacity: 1
  },
  variants: {
    dragging: {
      true: {
        backgroundColor: "$accent2",
        opacity: 1
      }
    }
  }
}), EJ = Er("div", {
  $flex: "",
  position: "relative",
  borderRadius: "$sm",
  overflow: "hidden",
  color: "inherit",
  height: "$rowHeight",
  backgroundColor: "$elevation3",
  $inputStyle: "$elevation1",
  $hover: "",
  $focusWithin: "",
  variants: {
    textArea: {
      true: {
        height: "auto"
      }
    }
  }
}), bJ = ["innerLabel", "value", "onUpdate", "onChange", "onKeyDown", "type", "id", "inputType", "rows"], TJ = ["onUpdate"];
function WP(n) {
  let {
    innerLabel: e,
    value: t,
    onUpdate: r,
    onChange: a,
    onKeyDown: s,
    type: u,
    id: h,
    inputType: v = "text",
    rows: y = 0
  } = n, _ = Za(n, bJ);
  const {
    id: b,
    emitOnEditStart: M,
    emitOnEditEnd: C,
    disabled: D
  } = Pc(), U = h || b, N = le.useRef(null), O = y > 0, I = O ? "textarea" : "input", k = le.useCallback((Y) => (Z) => {
    const te = Z.currentTarget.value;
    Y(te);
  }, []);
  Ne.useEffect(() => {
    const Y = N.current, Z = k((te) => {
      r(te), C();
    });
    return Y == null || Y.addEventListener("blur", Z), () => Y == null ? void 0 : Y.removeEventListener("blur", Z);
  }, [k, r, C]);
  const G = le.useCallback((Y) => {
    Y.key === "Enter" && k(r)(Y);
  }, [k, r]), j = Object.assign({
    as: I
  }, O ? {
    rows: y
  } : {}, _);
  return Ne.createElement(EJ, {
    textArea: O
  }, e && typeof e == "string" ? Ne.createElement(c4, null, e) : e, Ne.createElement(u4, As({
    levaType: u,
    ref: N,
    id: U,
    type: v,
    autoComplete: "off",
    spellCheck: "false",
    value: t,
    onChange: k(a),
    onFocus: () => M(),
    onKeyPress: G,
    onKeyDown: s,
    disabled: D
  }, j)));
}
function MJ(n) {
  let {
    onUpdate: e
  } = n, t = Za(n, TJ);
  const r = le.useCallback((s) => e(JZ(s)), [e]), a = le.useCallback((s) => {
    const u = s.key === "ArrowUp" ? 1 : s.key === "ArrowDown" ? -1 : 0;
    if (u) {
      s.preventDefault();
      const h = s.altKey ? 0.1 : s.shiftKey ? 10 : 1;
      e((v) => parseFloat(v) + u * h);
    }
  }, [e]);
  return Ne.createElement(WP, As({}, t, {
    onUpdate: r,
    onKeyDown: a,
    type: "number"
  }));
}
const DR = Er("div", {}), _O = Er("div", {
  position: "relative",
  background: "$elevation2",
  transition: "height 300ms ease",
  variants: {
    fill: {
      true: {},
      false: {}
    },
    flat: {
      false: {},
      true: {}
    },
    isRoot: {
      true: {},
      false: {
        paddingLeft: "$md",
        "&::after": {
          content: '""',
          position: "absolute",
          left: 0,
          top: 0,
          width: "$borderWidths$folder",
          height: "100%",
          backgroundColor: "$folderWidgetColor",
          opacity: 0.4,
          transform: "translateX(-50%)"
        }
      }
    }
  },
  compoundVariants: [{
    isRoot: !0,
    fill: !1,
    css: {
      overflowY: "auto",
      maxHeight: "calc(100vh - 20px - $$titleBarHeight)"
    }
  }, {
    isRoot: !0,
    flat: !1,
    css: {
      borderRadius: "$lg"
    }
  }]
}), wJ = Er("div", {
  $flex: "",
  color: "$folderTextColor",
  userSelect: "none",
  cursor: "pointer",
  height: "$folderTitleHeight",
  fontWeight: "$folder",
  "> svg": {
    marginLeft: -4,
    marginRight: 4,
    cursor: "pointer",
    fill: "$folderWidgetColor",
    opacity: 0.6
  },
  "&:hover > svg": {
    fill: "$folderWidgetColor"
  },
  [`&:hover + ${_O}::after`]: {
    opacity: 0.6
  },
  [`${DR}:hover > & + ${_O}::after`]: {
    opacity: 0.6
  },
  [`${DR}:hover > & > svg`]: {
    opacity: 1
  }
}), f4 = Er("div", {
  position: "relative",
  display: "grid",
  gridTemplateColumns: "100%",
  rowGap: "$rowGap",
  transition: "opacity 250ms ease",
  variants: {
    toggled: {
      true: {
        opacity: 1,
        transitionDelay: "250ms"
      },
      false: {
        opacity: 0,
        transitionDelay: "0ms",
        pointerEvents: "none"
      }
    },
    isRoot: {
      true: {
        "& > div": {
          paddingLeft: "$md",
          paddingRight: "$md"
        },
        "& > div:first-of-type": {
          paddingTop: "$sm"
        },
        "& > div:last-of-type": {
          paddingBottom: "$sm"
        },
        [`> ${DR}:not(:first-of-type)`]: {
          paddingTop: "$sm",
          marginTop: "$md",
          borderTop: "$borderWidths$folder solid $colors$elevation1"
        }
      }
    }
  }
}), d4 = Er("div", {
  position: "relative",
  zIndex: 100,
  display: "grid",
  rowGap: "$rowGap",
  gridTemplateRows: "minmax($sizes$rowHeight, max-content)",
  alignItems: "center",
  color: "$highlight2",
  [`${f4} > &`]: {
    "&:first-of-type": {
      marginTop: "$rowGap"
    },
    "&:last-of-type": {
      marginBottom: "$rowGap"
    }
  },
  variants: {
    disabled: {
      true: {
        pointerEvents: "none"
      },
      false: {
        "&:hover,&:focus-within": {
          color: "$highlight3"
        }
      }
    }
  }
}), h4 = Er(d4, {
  gridTemplateColumns: "auto $sizes$controlWidth",
  columnGap: "$colGap"
}), CJ = Er("div", {
  $flex: "",
  height: "100%",
  position: "relative",
  overflow: "hidden",
  "& > div": {
    marginLeft: "$colGap",
    padding: "0 $xs",
    opacity: 0.4
  },
  "& > div:hover": {
    opacity: 0.8
  },
  "& > div > svg": {
    display: "none",
    cursor: "pointer",
    width: 13,
    minWidth: 13,
    height: 13,
    backgroundColor: "$elevation2"
  },
  "&:hover > div > svg": {
    display: "block"
  },
  variants: {
    align: {
      top: {
        height: "100%",
        alignItems: "flex-start",
        paddingTop: "$sm"
      }
    }
  }
}), RJ = Er("input", {
  $reset: "",
  height: 0,
  width: 0,
  opacity: 0,
  margin: 0,
  "& + label": {
    position: "relative",
    $flexCenter: "",
    height: "100%",
    userSelect: "none",
    cursor: "pointer",
    paddingLeft: 2,
    paddingRight: "$sm",
    pointerEvents: "auto"
  },
  "& + label:after": {
    content: '""',
    width: 6,
    height: 6,
    backgroundColor: "$elevation3",
    borderRadius: "50%",
    $activeStyle: ""
  },
  "&:focus + label:after": {
    $focusStyle: ""
  },
  "& + label:active:after": {
    backgroundColor: "$accent1",
    $focusStyle: ""
  },
  "&:checked + label:after": {
    backgroundColor: "$accent1"
  }
}), EO = Er("label", {
  fontWeight: "$label",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
  "& > svg": {
    display: "block"
  }
}), AJ = Er("div", {
  opacity: 1,
  variants: {
    disabled: {
      true: {
        opacity: 0.6,
        pointerEvents: "none",
        [`& ${EO}`]: {
          pointerEvents: "auto"
        }
      }
    }
  }
}), p4 = Er("div", {
  position: "fixed",
  top: 0,
  bottom: 0,
  right: 0,
  left: 0,
  zIndex: 1e3,
  userSelect: "none"
}), DJ = Er("div", {
  background: "$toolTipBackground",
  fontFamily: "$sans",
  fontSize: "$toolTip",
  padding: "$xs $sm",
  color: "$toolTipText",
  borderRadius: "$xs",
  boxShadow: "$level2",
  maxWidth: 260
}), LJ = Er(WZ, {
  fill: "$toolTipBackground"
});
function jP({
  children: n
}) {
  const {
    className: e
  } = le.useContext(GP);
  return Ne.createElement(xK, {
    className: e
  }, n);
}
const OJ = ["align"];
function PJ() {
  const {
    id: n,
    disable: e,
    disabled: t
  } = Pc();
  return Ne.createElement(Ne.Fragment, null, Ne.createElement(RJ, {
    id: n + "__disable",
    type: "checkbox",
    checked: !t,
    onChange: () => e(!t)
  }), Ne.createElement("label", {
    htmlFor: n + "__disable"
  }));
}
function NJ(n) {
  const {
    id: e,
    optional: t,
    hint: r
  } = Pc(), a = n.htmlFor || (e ? {
    htmlFor: e
  } : null), s = !r && typeof n.children == "string" ? {
    title: n.children
  } : null;
  return Ne.createElement(Ne.Fragment, null, t && Ne.createElement(PJ, null), r !== void 0 ? Ne.createElement(HZ, null, Ne.createElement(VZ, {
    asChild: !0
  }, Ne.createElement(EO, As({}, a, n))), Ne.createElement(GZ, {
    side: "top",
    sideOffset: 2
  }, Ne.createElement(DJ, null, r, Ne.createElement(LJ, null)))) : Ne.createElement(EO, As({}, a, s, n)));
}
function cm(n) {
  let {
    align: e
  } = n, t = Za(n, OJ);
  const {
    value: r,
    label: a,
    key: s,
    disabled: u
  } = Pc(), {
    hideCopyButton: h
  } = vJ(), v = !h && s !== void 0, [y, _] = le.useState(!1), b = async () => {
    try {
      await navigator.clipboard.writeText(JSON.stringify({
        [s]: r ?? ""
      })), _(!0);
    } catch {
      Ng(is.CLIPBOARD_ERROR, {
        [s]: r
      });
    }
  };
  return Ne.createElement(CJ, {
    align: e,
    onPointerLeave: () => _(!1)
  }, Ne.createElement(NJ, t), v && !u && Ne.createElement("div", {
    title: `Click to copy ${typeof a == "string" ? a : s} value`
  }, y ? Ne.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, Ne.createElement("path", {
    d: "M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"
  }), Ne.createElement("path", {
    fillRule: "evenodd",
    d: "M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm9.707 5.707a1 1 0 00-1.414-1.414L9 12.586l-1.293-1.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z",
    clipRule: "evenodd"
  })) : Ne.createElement("svg", {
    onClick: b,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, Ne.createElement("path", {
    d: "M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"
  }), Ne.createElement("path", {
    d: "M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"
  }))));
}
const UJ = ["toggled"], zJ = Er("svg", {
  fill: "currentColor",
  transition: "transform 350ms ease, fill 250ms ease"
});
function $P(n) {
  let {
    toggled: e
  } = n, t = Za(n, UJ);
  return Ne.createElement(zJ, As({
    width: "9",
    height: "5",
    viewBox: "0 0 9 5",
    xmlns: "http://www.w3.org/2000/svg",
    style: {
      transform: `rotate(${e ? 0 : -90}deg)`
    }
  }, t), Ne.createElement("path", {
    d: "M3.8 4.4c.4.3 1 .3 1.4 0L8 1.7A1 1 0 007.4 0H1.6a1 1 0 00-.7 1.7l3 2.7z"
  }));
}
const kJ = ["input"];
function ap(n) {
  let {
    input: e
  } = n, t = Za(n, kJ);
  return e ? Ne.createElement(h4, t) : Ne.createElement(d4, t);
}
function m4({
  value: n,
  type: e,
  settings: t,
  setValue: r
}) {
  const [a, s] = le.useState(Ik(e, n, t)), u = le.useRef(n), h = le.useRef(t);
  h.current = t;
  const v = le.useCallback((_) => s(Ik(e, _, h.current)), [e]), y = le.useCallback((_) => {
    try {
      r(_);
    } catch (b) {
      const {
        type: M,
        previousValue: C
      } = b;
      if (M !== "LEVA_ERROR")
        throw b;
      v(C);
    }
  }, [v, r]);
  return le.useEffect(() => {
    VT(n, u.current) || v(n), u.current = n;
  }, [n, v]), {
    displayValue: a,
    onChange: s,
    onUpdate: y
  };
}
function vM(n, e) {
  const {
    emitOnEditStart: t,
    emitOnEditEnd: r
  } = Pc();
  return Xq((a) => {
    a.first && (document.body.classList.add("leva__panel__dragged"), t == null || t());
    const s = n(a);
    return a.last && (document.body.classList.remove("leva__panel__dragged"), r == null || r()), s;
  }, e);
}
function IJ(n) {
  const e = le.useRef(null), t = le.useRef(null), r = le.useRef(!1);
  return le.useEffect(() => {
    const a = JH(() => {
      e.current.width = e.current.offsetWidth * window.devicePixelRatio, e.current.height = e.current.offsetHeight * window.devicePixelRatio, n(e.current, t.current);
    }, 250);
    return window.addEventListener("resize", a), r.current || (a(), r.current = !0), () => window.removeEventListener("resize", a);
  }, [n]), le.useEffect(() => {
    t.current = e.current.getContext("2d");
  }, []), [e, t];
}
function v4() {
  const n = le.useRef(null), e = le.useRef({
    x: 0,
    y: 0
  }), t = le.useCallback((r) => {
    Object.assign(e.current, r), n.current && (n.current.style.transform = `translate3d(${e.current.x}px, ${e.current.y}px, 0)`);
  }, []);
  return [n, t];
}
const FJ = ["__refCount"], sL = (n, e) => {
  if (!n[e])
    return null;
  const t = n[e];
  return Za(t, FJ);
};
function BJ(n) {
  const e = mM(), [t, r] = le.useState(sL(e.getData(), n)), a = le.useCallback((y) => e.setValueAtPath(n, y, !0), [n, e]), s = le.useCallback((y) => e.setSettingsAtPath(n, y), [n, e]), u = le.useCallback((y) => e.disableInputAtPath(n, y), [n, e]), h = le.useCallback(() => e.emitOnEditStart(n), [n, e]), v = le.useCallback(() => e.emitOnEditEnd(n), [n, e]);
  return le.useEffect(() => {
    r(sL(e.getData(), n));
    const y = e.useStore.subscribe((_) => sL(_.data, n), r, {
      equalityFn: hM
    });
    return () => y();
  }, [e, n]), [t, {
    set: a,
    setSettings: s,
    disable: u,
    storeId: e.storeId,
    emitOnEditStart: h,
    emitOnEditEnd: v
  }];
}
const HJ = Er("div", {
  variants: {
    hasRange: {
      true: {
        position: "relative",
        display: "grid",
        gridTemplateColumns: "auto $sizes$numberInputMinWidth",
        columnGap: "$colGap",
        alignItems: "center"
      }
    }
  }
}), g4 = Er("div", {
  position: "relative",
  width: "100%",
  height: 2,
  borderRadius: "$xs",
  backgroundColor: "$elevation1"
}), bO = Er("div", {
  position: "absolute",
  width: "$scrubberWidth",
  height: "$scrubberHeight",
  borderRadius: "$xs",
  boxShadow: "0 0 0 2px $colors$elevation2",
  backgroundColor: "$accent2",
  cursor: "pointer",
  $active: "none $accent1",
  $hover: "none $accent3",
  variants: {
    position: {
      left: {
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0,
        transform: "translateX(calc(-0.5 * ($sizes$scrubberWidth + 4px)))"
      },
      right: {
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0,
        transform: "translateX(calc(0.5 * ($sizes$scrubberWidth + 4px)))"
      }
    }
  }
}), y4 = Er("div", {
  position: "relative",
  $flex: "",
  height: "100%",
  cursor: "pointer",
  touchAction: "none"
}), S4 = Er("div", {
  position: "absolute",
  height: "100%",
  backgroundColor: "$accent2"
});
function VJ({
  value: n,
  min: e,
  max: t,
  onDrag: r,
  step: a,
  initialValue: s
}) {
  const u = le.useRef(null), h = le.useRef(null), v = le.useRef(0), y = Ig("sizes", "scrubberWidth"), _ = vM(({
    event: M,
    first: C,
    xy: [D],
    movement: [U],
    memo: N
  }) => {
    if (C) {
      const {
        width: I,
        left: k
      } = u.current.getBoundingClientRect();
      v.current = I - parseFloat(y), N = (M == null ? void 0 : M.target) === h.current ? n : AR((D - k) / I, e, t);
    }
    const O = N + AR(U / v.current, 0, t - e);
    return r(r4(O, {
      step: a,
      initialValue: s
    })), N;
  }), b = RR(n, e, t);
  return Ne.createElement(y4, As({
    ref: u
  }, _()), Ne.createElement(g4, null, Ne.createElement(S4, {
    style: {
      left: 0,
      right: `${(1 - b) * 100}%`
    }
  })), Ne.createElement(bO, {
    ref: h,
    style: {
      left: `calc(${b} * (100% - ${y}))`
    }
  }));
}
const GJ = Ne.memo(({
  label: n,
  onUpdate: e,
  step: t,
  innerLabelTrim: r
}) => {
  const [a, s] = le.useState(!1), u = vM(({
    active: h,
    delta: [v],
    event: y,
    memo: _ = 0
  }) => (s(h), _ += v / 2, Math.abs(_) >= 1 && (e((b) => parseFloat(b) + Math.floor(_) * t * e4(y)), _ = 0), _));
  return Ne.createElement(_J, As({
    dragging: a,
    title: n.length > 1 ? n : ""
  }, u()), n.slice(0, r));
});
function x4({
  label: n,
  id: e,
  displayValue: t,
  onUpdate: r,
  onChange: a,
  settings: s,
  innerLabelTrim: u = 1
}) {
  const h = u > 0 && Ne.createElement(GJ, {
    label: n,
    step: s.step,
    onUpdate: r,
    innerLabelTrim: u
  });
  return Ne.createElement(MJ, {
    id: e,
    value: String(t),
    onUpdate: r,
    onChange: a,
    innerLabel: h
  });
}
function WJ() {
  const n = Pc(), {
    label: e,
    value: t,
    onUpdate: r,
    settings: a,
    id: s
  } = n, {
    min: u,
    max: h
  } = a, v = h !== 1 / 0 && u !== -1 / 0;
  return Ne.createElement(ap, {
    input: !0
  }, Ne.createElement(cm, null, e), Ne.createElement(HJ, {
    hasRange: v
  }, v && Ne.createElement(VJ, As({
    value: parseFloat(t),
    onDrag: r
  }, a)), Ne.createElement(x4, As({}, n, {
    id: s,
    label: "value",
    innerLabelTrim: v ? 0 : 1
  }))));
}
const {
  sanitizeStep: jJ
} = i4, $J = Za(i4, ["sanitizeStep"]);
var YJ = Lr({
  component: WJ
}, $J);
const XJ = (n, e) => hd().schema({
  options: hd().passesAnyOf(hd().object(), hd().array())
}).test(e), qJ = (n, {
  values: e
}) => {
  if (e.indexOf(n) < 0)
    throw Error("Selected value doesn't match Select options");
  return n;
}, KJ = (n, {
  values: e
}) => e.indexOf(n), QJ = (n) => {
  let {
    value: e,
    options: t
  } = n, r, a;
  return Array.isArray(t) ? (a = t, r = t.map((s) => String(s))) : (a = Object.values(t), r = Object.keys(t)), "value" in n ? a.includes(e) || (r.unshift(String(e)), a.unshift(e)) : e = a[0], Object.values(t).includes(e) || (t[String(e)] = e), {
    value: e,
    settings: {
      keys: r,
      values: a
    }
  };
};
var ZJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: XJ,
  sanitize: qJ,
  format: KJ,
  normalize: QJ
});
const JJ = Er("div", {
  $flexCenter: "",
  position: "relative",
  "> svg": {
    pointerEvents: "none",
    position: "absolute",
    right: "$md"
  }
}), TO = Er("select", {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%",
  opacity: 0
}), eee = Er("div", {
  display: "flex",
  alignItems: "center",
  width: "100%",
  height: "$rowHeight",
  backgroundColor: "$elevation3",
  borderRadius: "$sm",
  padding: "0 $sm",
  cursor: "pointer",
  [`${TO}:focus + &`]: {
    $focusStyle: ""
  },
  [`${TO}:hover + &`]: {
    $hoverStyle: ""
  }
});
function tee({
  displayValue: n,
  value: e,
  onUpdate: t,
  id: r,
  settings: a,
  disabled: s
}) {
  const {
    keys: u,
    values: h
  } = a, v = le.useRef();
  return e === h[n] && (v.current = u[n]), Ne.createElement(JJ, null, Ne.createElement(TO, {
    id: r,
    value: n,
    onChange: (y) => t(h[Number(y.currentTarget.value)]),
    disabled: s
  }, u.map((y, _) => Ne.createElement("option", {
    key: y,
    value: _
  }, y))), Ne.createElement(eee, null, v.current), Ne.createElement($P, {
    toggled: !0
  }));
}
function nee() {
  const {
    label: n,
    value: e,
    displayValue: t,
    onUpdate: r,
    id: a,
    disabled: s,
    settings: u
  } = Pc();
  return Ne.createElement(ap, {
    input: !0
  }, Ne.createElement(cm, null, n), Ne.createElement(tee, {
    id: a,
    value: e,
    displayValue: t,
    onUpdate: r,
    settings: u,
    disabled: s
  }));
}
var ree = Lr({
  component: nee
}, ZJ);
const iee = (n) => hd().string().test(n), aee = (n) => {
  if (typeof n != "string")
    throw Error("Invalid string");
  return n;
}, oee = ({
  value: n,
  editable: e = !0,
  rows: t = !1
}) => ({
  value: n,
  settings: {
    editable: e,
    rows: typeof t == "number" ? t : t ? 5 : 0
  }
});
var see = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: iee,
  sanitize: aee,
  normalize: oee
});
const lee = ["displayValue", "onUpdate", "onChange", "editable"], uee = Er("div", {
  whiteSpace: "pre-wrap"
});
function cee(n) {
  let {
    displayValue: e,
    onUpdate: t,
    onChange: r,
    editable: a = !0
  } = n, s = Za(n, lee);
  return a ? Ne.createElement(WP, As({
    value: e,
    onUpdate: t,
    onChange: r
  }, s)) : Ne.createElement(uee, null, e);
}
function fee() {
  const {
    label: n,
    settings: e,
    displayValue: t,
    onUpdate: r,
    onChange: a
  } = Pc();
  return Ne.createElement(ap, {
    input: !0
  }, Ne.createElement(cm, null, n), Ne.createElement(cee, As({
    displayValue: t,
    onUpdate: r,
    onChange: a
  }, e)));
}
var dee = Lr({
  component: fee
}, see);
const hee = (n) => hd().boolean().test(n), pee = (n) => {
  if (typeof n != "boolean")
    throw Error("Invalid boolean");
  return n;
};
var mee = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: hee,
  sanitize: pee
});
const vee = Er("div", {
  position: "relative",
  $flex: "",
  height: "$rowHeight",
  input: {
    $reset: "",
    height: 0,
    width: 0,
    opacity: 0,
    margin: 0
  },
  label: {
    position: "relative",
    $flexCenter: "",
    userSelect: "none",
    cursor: "pointer",
    height: "$checkboxSize",
    width: "$checkboxSize",
    backgroundColor: "$elevation3",
    borderRadius: "$sm",
    $hover: ""
  },
  "input:focus + label": {
    $focusStyle: ""
  },
  "input:focus:checked + label, input:checked + label:hover": {
    $hoverStyle: "$accent3"
  },
  "input + label:active": {
    backgroundColor: "$accent1"
  },
  "input:checked + label:active": {
    backgroundColor: "$accent1"
  },
  "label > svg": {
    display: "none",
    width: "90%",
    height: "90%",
    stroke: "$highlight3"
  },
  "input:checked + label": {
    backgroundColor: "$accent2"
  },
  "input:checked + label > svg": {
    display: "block"
  }
});
function gee({
  value: n,
  onUpdate: e,
  id: t,
  disabled: r
}) {
  return Ne.createElement(vee, null, Ne.createElement("input", {
    id: t,
    type: "checkbox",
    checked: n,
    onChange: (a) => e(a.currentTarget.checked),
    disabled: r
  }), Ne.createElement("label", {
    htmlFor: t
  }, Ne.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24"
  }, Ne.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    d: "M5 13l4 4L19 7"
  }))));
}
function yee() {
  const {
    label: n,
    value: e,
    onUpdate: t,
    disabled: r,
    id: a
  } = Pc();
  return Ne.createElement(ap, {
    input: !0
  }, Ne.createElement(cm, null, n), Ne.createElement(gee, {
    value: e,
    onUpdate: t,
    id: a,
    disabled: r
  }));
}
var See = Lr({
  component: yee
}, mee);
const xee = ["locked"];
function _ee({
  value: n,
  id: e,
  valueKey: t,
  settings: r,
  onUpdate: a,
  innerLabelTrim: s
}) {
  const u = le.useRef(n[t]);
  u.current = n[t];
  const h = le.useCallback((y) => a({
    [t]: ZH({
      type: "NUMBER",
      value: u.current,
      settings: r
    }, y)
  }), [a, r, t]), v = m4({
    type: "NUMBER",
    value: n[t],
    settings: r,
    setValue: h
  });
  return Ne.createElement(x4, {
    id: e,
    label: t,
    value: n[t],
    displayValue: v.displayValue,
    onUpdate: v.onUpdate,
    onChange: v.onChange,
    settings: r,
    innerLabelTrim: s
  });
}
const Eee = Er("div", {
  display: "grid",
  columnGap: "$colGap",
  gridAutoFlow: "column dense",
  alignItems: "center",
  variants: {
    withLock: {
      true: {
        gridTemplateColumns: "10px auto",
        "> svg": {
          cursor: "pointer"
        }
      }
    }
  }
});
function bee(n) {
  let {
    locked: e
  } = n, t = Za(n, xee);
  return Ne.createElement("svg", As({
    width: "10",
    height: "10",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, t), e ? Ne.createElement("path", {
    d: "M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }) : Ne.createElement("path", {
    d: "M9 3.63601C9 2.76044 9.24207 2.11211 9.64154 1.68623C10.0366 1.26502 10.6432 1 11.5014 1C12.4485 1 13.0839 1.30552 13.4722 1.80636C13.8031 2.23312 14 2.84313 14 3.63325H15C15 2.68242 14.7626 1.83856 14.2625 1.19361C13.6389 0.38943 12.6743 0 11.5014 0C10.4294 0 9.53523 0.337871 8.91218 1.0021C8.29351 1.66167 8 2.58135 8 3.63601V6H1C0.447715 6 0 6.44772 0 7V13C0 13.5523 0.447715 14 1 14H10C10.5523 14 11 13.5523 11 13V7C11 6.44772 10.5523 6 10 6H9V3.63601ZM1 7H10V13H1V7Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}
function YP({
  value: n,
  onUpdate: e,
  settings: t,
  innerLabelTrim: r
}) {
  const {
    id: a,
    setSettings: s
  } = Pc(), {
    lock: u,
    locked: h
  } = t;
  return Ne.createElement(Eee, {
    withLock: u
  }, u && Ne.createElement(bee, {
    locked: h,
    onClick: () => s({
      locked: !h
    })
  }), Object.keys(n).map((v, y) => Ne.createElement(_ee, {
    id: y === 0 ? a : `${a}.${v}`,
    key: v,
    valueKey: v,
    value: n,
    settings: t[v],
    onUpdate: e,
    innerLabelTrim: r
  })));
}
const _4 = (n, e) => {
  const t = {};
  let r = 0, a = 1 / 0;
  Object.entries(n).forEach(([s, u]) => {
    t[s] = n4(Lr({
      value: u
    }, e[s])).settings, r = Math.max(r, t[s].step), a = Math.min(a, t[s].pad);
  });
  for (let s in t) {
    const {
      step: u,
      min: h,
      max: v
    } = e[s] || {};
    !isFinite(u) && (!isFinite(h) || !isFinite(v)) && (t[s].step = r, t[s].pad = a);
  }
  return t;
}, Tee = ["lock"], Mee = ["value"];
function wee(n) {
  const e = hd().array().length(n).every.number(), t = (r) => {
    if (!r || typeof r != "object")
      return !1;
    const a = Object.values(r);
    return a.length === n && a.every((s) => isFinite(s));
  };
  return (r) => e.test(r) || t(r);
}
function Cee(n) {
  return Array.isArray(n) ? "array" : "object";
}
function xT(n, e, t) {
  return Cee(n) === e ? n : e === "array" ? Object.values(n) : iJ(n, t);
}
const Ree = (n, e, t) => {
  const r = xT(n, "object", e.keys);
  for (let u in r)
    r[u] = t4(r[u], e[u]);
  const a = Object.keys(r);
  let s = {};
  if (a.length === e.keys.length)
    s = r;
  else {
    const u = xT(t, "object", e.keys);
    if (a.length === 1 && e.locked) {
      const h = a[0], v = r[h], y = u[h], _ = y !== 0 ? v / y : 1;
      for (let b in u)
        b === h ? s[h] = v : s[b] = u[b] * _;
    } else
      s = Lr(Lr({}, u), r);
  }
  return xT(s, e.format, e.keys);
}, Aee = (n, e) => xT(n, "object", e.keys), Dee = (n) => !!n && ("step" in n || "min" in n || "max" in n);
function Lee(n, e, t = []) {
  const {
    lock: r = !1
  } = e, a = Za(e, Tee), s = Array.isArray(n) ? "array" : "object", u = s === "object" ? Object.keys(n) : t, h = xT(n, "object", u), v = Dee(a) ? u.reduce((_, b) => Object.assign(_, {
    [b]: a
  }), {}) : a, y = _4(h, v);
  return {
    value: s === "array" ? n : h,
    settings: Lr(Lr({}, y), {}, {
      format: s,
      keys: u,
      lock: r,
      locked: !1
    })
  };
}
function E4(n) {
  return {
    schema: wee(n.length),
    normalize: (e) => {
      let {
        value: t
      } = e, r = Za(e, Mee);
      return Lee(t, r, n);
    },
    format: (e, t) => Aee(e, t),
    sanitize: (e, t, r) => Ree(e, t, r)
  };
}
var Oee = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, Lg = function(n) {
  return typeof n == "string" ? n.length > 0 : typeof n == "number";
}, _u = function(n, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = Math.pow(10, e)), Math.round(t * n) / t + 0;
}, ip = function(n, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = 1), n > t ? t : n > e ? n : e;
}, b4 = function(n) {
  return (n = isFinite(n) ? n % 360 : 0) > 0 ? n : n + 360;
}, Xk = function(n) {
  return { r: ip(n.r, 0, 255), g: ip(n.g, 0, 255), b: ip(n.b, 0, 255), a: ip(n.a) };
}, lL = function(n) {
  return { r: _u(n.r), g: _u(n.g), b: _u(n.b), a: _u(n.a, 3) };
}, Pee = /^#([0-9a-f]{3,8})$/i, nR = function(n) {
  var e = n.toString(16);
  return e.length < 2 ? "0" + e : e;
}, T4 = function(n) {
  var e = n.r, t = n.g, r = n.b, a = n.a, s = Math.max(e, t, r), u = s - Math.min(e, t, r), h = u ? s === e ? (t - r) / u : s === t ? 2 + (r - e) / u : 4 + (e - t) / u : 0;
  return { h: 60 * (h < 0 ? h + 6 : h), s: s ? u / s * 100 : 0, v: s / 255 * 100, a };
}, M4 = function(n) {
  var e = n.h, t = n.s, r = n.v, a = n.a;
  e = e / 360 * 6, t /= 100, r /= 100;
  var s = Math.floor(e), u = r * (1 - t), h = r * (1 - (e - s) * t), v = r * (1 - (1 - e + s) * t), y = s % 6;
  return { r: 255 * [r, h, u, u, v, r][y], g: 255 * [v, r, r, h, u, u][y], b: 255 * [u, u, v, r, r, h][y], a };
}, qk = function(n) {
  return { h: b4(n.h), s: ip(n.s, 0, 100), l: ip(n.l, 0, 100), a: ip(n.a) };
}, Kk = function(n) {
  return { h: _u(n.h), s: _u(n.s), l: _u(n.l), a: _u(n.a, 3) };
}, Qk = function(n) {
  return M4((t = (e = n).s, { h: e.h, s: (t *= ((r = e.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * t / (r + t) * 100 : 0, v: r + t, a: e.a }));
  var e, t, r;
}, _T = function(n) {
  return { h: (e = T4(n)).h, s: (a = (200 - (t = e.s)) * (r = e.v) / 100) > 0 && a < 200 ? t * r / 100 / (a <= 100 ? a : 200 - a) * 100 : 0, l: a / 2, a: e.a };
  var e, t, r, a;
}, Nee = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Uee = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, zee = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, kee = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, MO = { string: [[function(n) {
  var e = Pee.exec(n);
  return e ? (n = e[1]).length <= 4 ? { r: parseInt(n[0] + n[0], 16), g: parseInt(n[1] + n[1], 16), b: parseInt(n[2] + n[2], 16), a: n.length === 4 ? _u(parseInt(n[3] + n[3], 16) / 255, 2) : 1 } : n.length === 6 || n.length === 8 ? { r: parseInt(n.substr(0, 2), 16), g: parseInt(n.substr(2, 2), 16), b: parseInt(n.substr(4, 2), 16), a: n.length === 8 ? _u(parseInt(n.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(n) {
  var e = zee.exec(n) || kee.exec(n);
  return e ? e[2] !== e[4] || e[4] !== e[6] ? null : Xk({ r: Number(e[1]) / (e[2] ? 100 / 255 : 1), g: Number(e[3]) / (e[4] ? 100 / 255 : 1), b: Number(e[5]) / (e[6] ? 100 / 255 : 1), a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1) }) : null;
}, "rgb"], [function(n) {
  var e = Nee.exec(n) || Uee.exec(n);
  if (!e)
    return null;
  var t, r, a = qk({ h: (t = e[1], r = e[2], r === void 0 && (r = "deg"), Number(t) * (Oee[r] || 1)), s: Number(e[3]), l: Number(e[4]), a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1) });
  return Qk(a);
}, "hsl"]], object: [[function(n) {
  var e = n.r, t = n.g, r = n.b, a = n.a, s = a === void 0 ? 1 : a;
  return Lg(e) && Lg(t) && Lg(r) ? Xk({ r: Number(e), g: Number(t), b: Number(r), a: Number(s) }) : null;
}, "rgb"], [function(n) {
  var e = n.h, t = n.s, r = n.l, a = n.a, s = a === void 0 ? 1 : a;
  if (!Lg(e) || !Lg(t) || !Lg(r))
    return null;
  var u = qk({ h: Number(e), s: Number(t), l: Number(r), a: Number(s) });
  return Qk(u);
}, "hsl"], [function(n) {
  var e = n.h, t = n.s, r = n.v, a = n.a, s = a === void 0 ? 1 : a;
  if (!Lg(e) || !Lg(t) || !Lg(r))
    return null;
  var u = function(h) {
    return { h: b4(h.h), s: ip(h.s, 0, 100), v: ip(h.v, 0, 100), a: ip(h.a) };
  }({ h: Number(e), s: Number(t), v: Number(r), a: Number(s) });
  return M4(u);
}, "hsv"]] }, Zk = function(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t][0](n);
    if (r)
      return [r, e[t][1]];
  }
  return [null, void 0];
}, w4 = function(n) {
  return typeof n == "string" ? Zk(n.trim(), MO.string) : typeof n == "object" && n !== null ? Zk(n, MO.object) : [null, void 0];
}, Iee = function(n) {
  return w4(n)[1];
}, uL = function(n, e) {
  var t = _T(n);
  return { h: t.h, s: ip(t.s + 100 * e, 0, 100), l: t.l, a: t.a };
}, cL = function(n) {
  return (299 * n.r + 587 * n.g + 114 * n.b) / 1e3 / 255;
}, Jk = function(n, e) {
  var t = _T(n);
  return { h: t.h, s: t.s, l: ip(t.l + 100 * e, 0, 100), a: t.a };
}, wO = function() {
  function n(e) {
    this.parsed = w4(e)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return n.prototype.isValid = function() {
    return this.parsed !== null;
  }, n.prototype.brightness = function() {
    return _u(cL(this.rgba), 2);
  }, n.prototype.isDark = function() {
    return cL(this.rgba) < 0.5;
  }, n.prototype.isLight = function() {
    return cL(this.rgba) >= 0.5;
  }, n.prototype.toHex = function() {
    return e = lL(this.rgba), t = e.r, r = e.g, a = e.b, u = (s = e.a) < 1 ? nR(_u(255 * s)) : "", "#" + nR(t) + nR(r) + nR(a) + u;
    var e, t, r, a, s, u;
  }, n.prototype.toRgb = function() {
    return lL(this.rgba);
  }, n.prototype.toRgbString = function() {
    return e = lL(this.rgba), t = e.r, r = e.g, a = e.b, (s = e.a) < 1 ? "rgba(" + t + ", " + r + ", " + a + ", " + s + ")" : "rgb(" + t + ", " + r + ", " + a + ")";
    var e, t, r, a, s;
  }, n.prototype.toHsl = function() {
    return Kk(_T(this.rgba));
  }, n.prototype.toHslString = function() {
    return e = Kk(_T(this.rgba)), t = e.h, r = e.s, a = e.l, (s = e.a) < 1 ? "hsla(" + t + ", " + r + "%, " + a + "%, " + s + ")" : "hsl(" + t + ", " + r + "%, " + a + "%)";
    var e, t, r, a, s;
  }, n.prototype.toHsv = function() {
    return e = T4(this.rgba), { h: _u(e.h), s: _u(e.s), v: _u(e.v), a: _u(e.a, 3) };
    var e;
  }, n.prototype.invert = function() {
    return _f({ r: 255 - (e = this.rgba).r, g: 255 - e.g, b: 255 - e.b, a: e.a });
    var e;
  }, n.prototype.saturate = function(e) {
    return e === void 0 && (e = 0.1), _f(uL(this.rgba, e));
  }, n.prototype.desaturate = function(e) {
    return e === void 0 && (e = 0.1), _f(uL(this.rgba, -e));
  }, n.prototype.grayscale = function() {
    return _f(uL(this.rgba, -1));
  }, n.prototype.lighten = function(e) {
    return e === void 0 && (e = 0.1), _f(Jk(this.rgba, e));
  }, n.prototype.darken = function(e) {
    return e === void 0 && (e = 0.1), _f(Jk(this.rgba, -e));
  }, n.prototype.rotate = function(e) {
    return e === void 0 && (e = 15), this.hue(this.hue() + e);
  }, n.prototype.alpha = function(e) {
    return typeof e == "number" ? _f({ r: (t = this.rgba).r, g: t.g, b: t.b, a: e }) : _u(this.rgba.a, 3);
    var t;
  }, n.prototype.hue = function(e) {
    var t = _T(this.rgba);
    return typeof e == "number" ? _f({ h: e, s: t.s, l: t.l, a: t.a }) : _u(t.h);
  }, n.prototype.isEqual = function(e) {
    return this.toHex() === _f(e).toHex();
  }, n;
}(), _f = function(n) {
  return n instanceof wO ? n : new wO(n);
}, eI = [], Fee = function(n) {
  n.forEach(function(e) {
    eI.indexOf(e) < 0 && (e(wO, MO), eI.push(e));
  });
};
function Bee(n, e) {
  var t = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r = {};
  for (var a in t)
    r[t[a]] = a;
  var s = {};
  n.prototype.toName = function(u) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var h, v, y = r[this.toHex()];
    if (y)
      return y;
    if (u != null && u.closest) {
      var _ = this.toRgb(), b = 1 / 0, M = "black";
      if (!s.length)
        for (var C in t)
          s[C] = new n(t[C]).toRgb();
      for (var D in t) {
        var U = (h = _, v = s[D], Math.pow(h.r - v.r, 2) + Math.pow(h.g - v.g, 2) + Math.pow(h.b - v.b, 2));
        U < b && (b = U, M = D);
      }
      return M;
    }
  }, e.string.push([function(u) {
    var h = u.toLowerCase(), v = h === "transparent" ? "#0000" : t[h];
    return v ? new n(v).toRgb() : null;
  }, "name"]);
}
function tb() {
  return (tb = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }).apply(this, arguments);
}
function XP(n, e) {
  if (n == null)
    return {};
  var t, r, a = {}, s = Object.keys(n);
  for (r = 0; r < s.length; r++)
    e.indexOf(t = s[r]) >= 0 || (a[t] = n[t]);
  return a;
}
function CO(n) {
  var e = le.useRef(n), t = le.useRef(function(r) {
    e.current && e.current(r);
  });
  return e.current = n, t.current;
}
var VE = function(n, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = 1), n > t ? t : n < e ? e : n;
}, ET = function(n) {
  return "touches" in n;
}, RO = function(n) {
  return n && n.ownerDocument.defaultView || self;
}, tI = function(n, e, t) {
  var r = n.getBoundingClientRect(), a = ET(e) ? function(s, u) {
    for (var h = 0; h < s.length; h++)
      if (s[h].identifier === u)
        return s[h];
    return s[0];
  }(e.touches, t) : e;
  return { left: VE((a.pageX - (r.left + RO(n).pageXOffset)) / r.width), top: VE((a.pageY - (r.top + RO(n).pageYOffset)) / r.height) };
}, nI = function(n) {
  !ET(n) && n.preventDefault();
}, qP = Ne.memo(function(n) {
  var e = n.onMove, t = n.onKey, r = XP(n, ["onMove", "onKey"]), a = le.useRef(null), s = CO(e), u = CO(t), h = le.useRef(null), v = le.useRef(!1), y = le.useMemo(function() {
    var C = function(N) {
      nI(N), (ET(N) ? N.touches.length > 0 : N.buttons > 0) && a.current ? s(tI(a.current, N, h.current)) : U(!1);
    }, D = function() {
      return U(!1);
    };
    function U(N) {
      var O = v.current, I = RO(a.current), k = N ? I.addEventListener : I.removeEventListener;
      k(O ? "touchmove" : "mousemove", C), k(O ? "touchend" : "mouseup", D);
    }
    return [function(N) {
      var O = N.nativeEvent, I = a.current;
      if (I && (nI(O), !function(G, j) {
        return j && !ET(G);
      }(O, v.current) && I)) {
        if (ET(O)) {
          v.current = !0;
          var k = O.changedTouches || [];
          k.length && (h.current = k[0].identifier);
        }
        I.focus(), s(tI(I, O, h.current)), U(!0);
      }
    }, function(N) {
      var O = N.which || N.keyCode;
      O < 37 || O > 40 || (N.preventDefault(), u({ left: O === 39 ? 0.05 : O === 37 ? -0.05 : 0, top: O === 40 ? 0.05 : O === 38 ? -0.05 : 0 }));
    }, U];
  }, [u, s]), _ = y[0], b = y[1], M = y[2];
  return le.useEffect(function() {
    return M;
  }, [M]), Ne.createElement("div", tb({}, r, { onTouchStart: _, onMouseDown: _, className: "react-colorful__interactive", ref: a, onKeyDown: b, tabIndex: 0, role: "slider" }));
}), gM = function(n) {
  return n.filter(Boolean).join(" ");
}, KP = function(n) {
  var e = n.color, t = n.left, r = n.top, a = r === void 0 ? 0.5 : r, s = gM(["react-colorful__pointer", n.className]);
  return Ne.createElement("div", { className: s, style: { top: 100 * a + "%", left: 100 * t + "%" } }, Ne.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: e } }));
}, Ef = function(n, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = Math.pow(10, e)), Math.round(t * n) / t;
}, C4 = function(n) {
  var e = n.s, t = n.v, r = n.a, a = (200 - e) * t / 100;
  return { h: Ef(n.h), s: Ef(a > 0 && a < 200 ? e * t / 100 / (a <= 100 ? a : 200 - a) * 100 : 0), l: Ef(a / 2), a: Ef(r, 2) };
}, AO = function(n) {
  var e = C4(n);
  return "hsl(" + e.h + ", " + e.s + "%, " + e.l + "%)";
}, fL = function(n) {
  var e = C4(n);
  return "hsla(" + e.h + ", " + e.s + "%, " + e.l + "%, " + e.a + ")";
}, R4 = function(n) {
  var e = n.h, t = n.s, r = n.v, a = n.a;
  e = e / 360 * 6, t /= 100, r /= 100;
  var s = Math.floor(e), u = r * (1 - t), h = r * (1 - (e - s) * t), v = r * (1 - (1 - e + s) * t), y = s % 6;
  return { r: Ef(255 * [r, h, u, u, v, r][y]), g: Ef(255 * [v, r, r, h, u, u][y]), b: Ef(255 * [u, u, v, r, r, h][y]), a: Ef(a, 2) };
}, A4 = function(n) {
  var e = n.r, t = n.g, r = n.b, a = n.a, s = Math.max(e, t, r), u = s - Math.min(e, t, r), h = u ? s === e ? (t - r) / u : s === t ? 2 + (r - e) / u : 4 + (e - t) / u : 0;
  return { h: Ef(60 * (h < 0 ? h + 6 : h)), s: Ef(s ? u / s * 100 : 0), v: Ef(s / 255 * 100), a };
}, D4 = Ne.memo(function(n) {
  var e = n.hue, t = n.onChange, r = gM(["react-colorful__hue", n.className]);
  return Ne.createElement("div", { className: r }, Ne.createElement(qP, { onMove: function(a) {
    t({ h: 360 * a.left });
  }, onKey: function(a) {
    t({ h: VE(e + 360 * a.left, 0, 360) });
  }, "aria-label": "Hue", "aria-valuenow": Ef(e), "aria-valuemax": "360", "aria-valuemin": "0" }, Ne.createElement(KP, { className: "react-colorful__hue-pointer", left: e / 360, color: AO({ h: e, s: 100, v: 100, a: 1 }) })));
}), L4 = Ne.memo(function(n) {
  var e = n.hsva, t = n.onChange, r = { backgroundColor: AO({ h: e.h, s: 100, v: 100, a: 1 }) };
  return Ne.createElement("div", { className: "react-colorful__saturation", style: r }, Ne.createElement(qP, { onMove: function(a) {
    t({ s: 100 * a.left, v: 100 - 100 * a.top });
  }, onKey: function(a) {
    t({ s: VE(e.s + 100 * a.left, 0, 100), v: VE(e.v - 100 * a.top, 0, 100) });
  }, "aria-label": "Color", "aria-valuetext": "Saturation " + Ef(e.s) + "%, Brightness " + Ef(e.v) + "%" }, Ne.createElement(KP, { className: "react-colorful__saturation-pointer", top: 1 - e.v / 100, left: e.s / 100, color: AO(e) })));
}), QP = function(n, e) {
  if (n === e)
    return !0;
  for (var t in n)
    if (n[t] !== e[t])
      return !1;
  return !0;
};
function O4(n, e, t) {
  var r = CO(t), a = le.useState(function() {
    return n.toHsva(e);
  }), s = a[0], u = a[1], h = le.useRef({ color: e, hsva: s });
  le.useEffect(function() {
    if (!n.equal(e, h.current.color)) {
      var y = n.toHsva(e);
      h.current = { hsva: y, color: e }, u(y);
    }
  }, [e, n]), le.useEffect(function() {
    var y;
    QP(s, h.current.hsva) || n.equal(y = n.fromHsva(s), h.current.color) || (h.current = { hsva: s, color: y }, r(y));
  }, [s, n, r]);
  var v = le.useCallback(function(y) {
    u(function(_) {
      return Object.assign({}, _, y);
    });
  }, []);
  return [s, v];
}
var Hee = typeof window < "u" ? le.useLayoutEffect : le.useEffect, Vee = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : void 0;
}, rI = /* @__PURE__ */ new Map(), P4 = function(n) {
  Hee(function() {
    var e = n.current ? n.current.ownerDocument : document;
    if (e !== void 0 && !rI.has(e)) {
      var t = e.createElement("style");
      t.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, rI.set(e, t);
      var r = Vee();
      r && t.setAttribute("nonce", r), e.head.appendChild(t);
    }
  }, []);
}, Gee = function(n) {
  var e = n.className, t = n.colorModel, r = n.color, a = r === void 0 ? t.defaultColor : r, s = n.onChange, u = XP(n, ["className", "colorModel", "color", "onChange"]), h = le.useRef(null);
  P4(h);
  var v = O4(t, a, s), y = v[0], _ = v[1], b = gM(["react-colorful", e]);
  return Ne.createElement("div", tb({}, u, { ref: h, className: b }), Ne.createElement(L4, { hsva: y, onChange: _ }), Ne.createElement(D4, { hue: y.h, onChange: _, className: "react-colorful__last-control" }));
}, Wee = function(n) {
  var e = n.className, t = n.hsva, r = n.onChange, a = { backgroundImage: "linear-gradient(90deg, " + fL(Object.assign({}, t, { a: 0 })) + ", " + fL(Object.assign({}, t, { a: 1 })) + ")" }, s = gM(["react-colorful__alpha", e]), u = Ef(100 * t.a);
  return Ne.createElement("div", { className: s }, Ne.createElement("div", { className: "react-colorful__alpha-gradient", style: a }), Ne.createElement(qP, { onMove: function(h) {
    r({ a: h.left });
  }, onKey: function(h) {
    r({ a: VE(t.a + h.left) });
  }, "aria-label": "Alpha", "aria-valuetext": u + "%", "aria-valuenow": u, "aria-valuemin": "0", "aria-valuemax": "100" }, Ne.createElement(KP, { className: "react-colorful__alpha-pointer", left: t.a, color: fL(t) })));
}, jee = function(n) {
  var e = n.className, t = n.colorModel, r = n.color, a = r === void 0 ? t.defaultColor : r, s = n.onChange, u = XP(n, ["className", "colorModel", "color", "onChange"]), h = le.useRef(null);
  P4(h);
  var v = O4(t, a, s), y = v[0], _ = v[1], b = gM(["react-colorful", e]);
  return Ne.createElement("div", tb({}, u, { ref: h, className: b }), Ne.createElement(L4, { hsva: y, onChange: _ }), Ne.createElement(D4, { hue: y.h, onChange: _ }), Ne.createElement(Wee, { hsva: y, onChange: _, className: "react-colorful__last-control" }));
}, $ee = { defaultColor: { r: 0, g: 0, b: 0, a: 1 }, toHsva: A4, fromHsva: R4, equal: QP }, Yee = function(n) {
  return Ne.createElement(jee, tb({}, n, { colorModel: $ee }));
}, Xee = { defaultColor: { r: 0, g: 0, b: 0 }, toHsva: function(n) {
  return A4({ r: n.r, g: n.g, b: n.b, a: 1 });
}, fromHsva: function(n) {
  return { r: (e = R4(n)).r, g: e.g, b: e.b };
  var e;
}, equal: QP }, qee = function(n) {
  return Ne.createElement(Gee, tb({}, n, { colorModel: Xee }));
};
function nb(n, e, t, r) {
  function a(s) {
    return s instanceof t ? s : new t(function(u) {
      u(s);
    });
  }
  return new (t || (t = Promise))(function(s, u) {
    function h(_) {
      try {
        y(r.next(_));
      } catch (b) {
        u(b);
      }
    }
    function v(_) {
      try {
        y(r.throw(_));
      } catch (b) {
        u(b);
      }
    }
    function y(_) {
      _.done ? s(_.value) : a(_.value).then(h, v);
    }
    y((r = r.apply(n, e || [])).next());
  });
}
function rb(n, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, a, s, u = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return u.next = h(0), u.throw = h(1), u.return = h(2), typeof Symbol == "function" && (u[Symbol.iterator] = function() {
    return this;
  }), u;
  function h(y) {
    return function(_) {
      return v([y, _]);
    };
  }
  function v(y) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; u && (u = 0, y[0] && (t = 0)), t; )
      try {
        if (r = 1, a && (s = y[0] & 2 ? a.return : y[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, y[1])).done)
          return s;
        switch (a = 0, s && (y = [y[0] & 2, s.value]), y[0]) {
          case 0:
          case 1:
            s = y;
            break;
          case 4:
            return t.label++, { value: y[1], done: !1 };
          case 5:
            t.label++, a = y[1], y = [0];
            continue;
          case 7:
            y = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (y[0] === 6 || y[0] === 2)) {
              t = 0;
              continue;
            }
            if (y[0] === 3 && (!s || y[1] > s[0] && y[1] < s[3])) {
              t.label = y[1];
              break;
            }
            if (y[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = y;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(y);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        y = e.call(n, t);
      } catch (_) {
        y = [6, _], a = 0;
      } finally {
        r = s = 0;
      }
    if (y[0] & 5)
      throw y[1];
    return { value: y[0] ? y[1] : void 0, done: !0 };
  }
}
function Kee(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var r = t.call(n), a, s = [], u;
  try {
    for (; (e === void 0 || e-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (h) {
    u = { error: h };
  } finally {
    try {
      a && !a.done && (t = r.return) && t.call(r);
    } finally {
      if (u)
        throw u.error;
    }
  }
  return s;
}
function Qee() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(Kee(arguments[e]));
  return n;
}
var Zee = /* @__PURE__ */ new Map([
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heif", "image/heif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  // Others
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function yM(n, e) {
  var t = Jee(n);
  if (typeof t.path != "string") {
    var r = n.webkitRelativePath;
    Object.defineProperty(t, "path", {
      value: typeof e == "string" ? e : typeof r == "string" && r.length > 0 ? r : n.name,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return t;
}
function Jee(n) {
  var e = n.name, t = e && e.lastIndexOf(".") !== -1;
  if (t && !n.type) {
    var r = e.split(".").pop().toLowerCase(), a = Zee.get(r);
    a && Object.defineProperty(n, "type", {
      value: a,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return n;
}
var ete = [
  // Thumbnail cache files for macOS and Windows
  ".DS_Store",
  "Thumbs.db"
  // Windows
];
function tte(n) {
  return nb(this, void 0, void 0, function() {
    return rb(this, function(e) {
      return LR(n) && nte(n) ? [2, ote(n.dataTransfer, n.type)] : rte(n) ? [2, ite(n)] : Array.isArray(n) && n.every(function(t) {
        return "getFile" in t && typeof t.getFile == "function";
      }) ? [2, ate(n)] : [2, []];
    });
  });
}
function nte(n) {
  return LR(n.dataTransfer);
}
function rte(n) {
  return LR(n) && LR(n.target);
}
function LR(n) {
  return typeof n == "object" && n !== null;
}
function ite(n) {
  return DO(n.target.files).map(function(e) {
    return yM(e);
  });
}
function ate(n) {
  return nb(this, void 0, void 0, function() {
    var e;
    return rb(this, function(t) {
      switch (t.label) {
        case 0:
          return [4, Promise.all(n.map(function(r) {
            return r.getFile();
          }))];
        case 1:
          return e = t.sent(), [2, e.map(function(r) {
            return yM(r);
          })];
      }
    });
  });
}
function ote(n, e) {
  return nb(this, void 0, void 0, function() {
    var t, r;
    return rb(this, function(a) {
      switch (a.label) {
        case 0:
          return n === null ? [2, []] : n.items ? (t = DO(n.items).filter(function(s) {
            return s.kind === "file";
          }), e !== "drop" ? [2, t] : [4, Promise.all(t.map(ste))]) : [3, 2];
        case 1:
          return r = a.sent(), [2, iI(N4(r))];
        case 2:
          return [2, iI(DO(n.files).map(function(s) {
            return yM(s);
          }))];
      }
    });
  });
}
function iI(n) {
  return n.filter(function(e) {
    return ete.indexOf(e.name) === -1;
  });
}
function DO(n) {
  if (n === null)
    return [];
  for (var e = [], t = 0; t < n.length; t++) {
    var r = n[t];
    e.push(r);
  }
  return e;
}
function ste(n) {
  if (typeof n.webkitGetAsEntry != "function")
    return aI(n);
  var e = n.webkitGetAsEntry();
  return e && e.isDirectory ? U4(e) : aI(n);
}
function N4(n) {
  return n.reduce(function(e, t) {
    return Qee(e, Array.isArray(t) ? N4(t) : [t]);
  }, []);
}
function aI(n) {
  var e = n.getAsFile();
  if (!e)
    return Promise.reject(n + " is not a File");
  var t = yM(e);
  return Promise.resolve(t);
}
function lte(n) {
  return nb(this, void 0, void 0, function() {
    return rb(this, function(e) {
      return [2, n.isDirectory ? U4(n) : ute(n)];
    });
  });
}
function U4(n) {
  var e = n.createReader();
  return new Promise(function(t, r) {
    var a = [];
    function s() {
      var u = this;
      e.readEntries(function(h) {
        return nb(u, void 0, void 0, function() {
          var v, y, _;
          return rb(this, function(b) {
            switch (b.label) {
              case 0:
                if (h.length)
                  return [3, 5];
                b.label = 1;
              case 1:
                return b.trys.push([1, 3, , 4]), [4, Promise.all(a)];
              case 2:
                return v = b.sent(), t(v), [3, 4];
              case 3:
                return y = b.sent(), r(y), [3, 4];
              case 4:
                return [3, 6];
              case 5:
                _ = Promise.all(h.map(lte)), a.push(_), s(), b.label = 6;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, function(h) {
        r(h);
      });
    }
    s();
  });
}
function ute(n) {
  return nb(this, void 0, void 0, function() {
    return rb(this, function(e) {
      return [2, new Promise(function(t, r) {
        n.file(function(a) {
          var s = yM(a, n.fullPath);
          t(s);
        }, function(a) {
          r(a);
        });
      })];
    });
  });
}
var cte = function(n, e) {
  if (n && e) {
    var t = Array.isArray(e) ? e : e.split(","), r = n.name || "", a = (n.type || "").toLowerCase(), s = a.replace(/\/.*$/, "");
    return t.some(function(u) {
      var h = u.trim().toLowerCase();
      return h.charAt(0) === "." ? r.toLowerCase().endsWith(h) : h.endsWith("/*") ? s === h.replace(/\/.*$/, "") : a === h;
    });
  }
  return !0;
};
function oI(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(n, a).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function sI(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? oI(Object(t), !0).forEach(function(r) {
      z4(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : oI(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function z4(n, e, t) {
  return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n;
}
function lI(n, e) {
  return pte(n) || hte(n, e) || dte(n, e) || fte();
}
function fte() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function dte(n, e) {
  if (n) {
    if (typeof n == "string")
      return uI(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return uI(n, e);
  }
}
function uI(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = new Array(e); t < e; t++)
    r[t] = n[t];
  return r;
}
function hte(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var r = [], a = !0, s = !1, u, h;
    try {
      for (t = t.call(n); !(a = (u = t.next()).done) && (r.push(u.value), !(e && r.length === e)); a = !0)
        ;
    } catch (v) {
      s = !0, h = v;
    } finally {
      try {
        !a && t.return != null && t.return();
      } finally {
        if (s)
          throw h;
      }
    }
    return r;
  }
}
function pte(n) {
  if (Array.isArray(n))
    return n;
}
var mte = "file-invalid-type", vte = "file-too-large", gte = "file-too-small", yte = "too-many-files", Ste = function(e) {
  e = Array.isArray(e) && e.length === 1 ? e[0] : e;
  var t = Array.isArray(e) ? "one of ".concat(e.join(", ")) : e;
  return {
    code: mte,
    message: "File type must be ".concat(t)
  };
}, cI = function(e) {
  return {
    code: vte,
    message: "File is larger than ".concat(e, " ").concat(e === 1 ? "byte" : "bytes")
  };
}, fI = function(e) {
  return {
    code: gte,
    message: "File is smaller than ".concat(e, " ").concat(e === 1 ? "byte" : "bytes")
  };
}, xte = {
  code: yte,
  message: "Too many files"
};
function k4(n, e) {
  var t = n.type === "application/x-moz-file" || cte(n, e);
  return [t, t ? null : Ste(e)];
}
function I4(n, e, t) {
  if (lT(n.size))
    if (lT(e) && lT(t)) {
      if (n.size > t)
        return [!1, cI(t)];
      if (n.size < e)
        return [!1, fI(e)];
    } else {
      if (lT(e) && n.size < e)
        return [!1, fI(e)];
      if (lT(t) && n.size > t)
        return [!1, cI(t)];
    }
  return [!0, null];
}
function lT(n) {
  return n != null;
}
function _te(n) {
  var e = n.files, t = n.accept, r = n.minSize, a = n.maxSize, s = n.multiple, u = n.maxFiles;
  return !s && e.length > 1 || s && u >= 1 && e.length > u ? !1 : e.every(function(h) {
    var v = k4(h, t), y = lI(v, 1), _ = y[0], b = I4(h, r, a), M = lI(b, 1), C = M[0];
    return _ && C;
  });
}
function OR(n) {
  return typeof n.isPropagationStopped == "function" ? n.isPropagationStopped() : typeof n.cancelBubble < "u" ? n.cancelBubble : !1;
}
function rR(n) {
  return n.dataTransfer ? Array.prototype.some.call(n.dataTransfer.types, function(e) {
    return e === "Files" || e === "application/x-moz-file";
  }) : !!n.target && !!n.target.files;
}
function dI(n) {
  n.preventDefault();
}
function Ete(n) {
  return n.indexOf("MSIE") !== -1 || n.indexOf("Trident/") !== -1;
}
function bte(n) {
  return n.indexOf("Edge/") !== -1;
}
function Tte() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return Ete(n) || bte(n);
}
function dv() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return function(r) {
    for (var a = arguments.length, s = new Array(a > 1 ? a - 1 : 0), u = 1; u < a; u++)
      s[u - 1] = arguments[u];
    return e.some(function(h) {
      return !OR(r) && h && h.apply(void 0, [r].concat(s)), OR(r);
    });
  };
}
function Mte() {
  return "showOpenFilePicker" in window;
}
function wte(n) {
  return n = typeof n == "string" ? n.split(",") : n, [{
    description: "everything",
    // TODO: Need to handle filtering more elegantly than this!
    accept: Array.isArray(n) ? (
      // Accept just MIME types as per spec
      // NOTE: accept can be https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#unique_file_type_specifiers
      n.filter(function(e) {
        return e === "audio/*" || e === "video/*" || e === "image/*" || e === "text/*" || /\w+\/[-+.\w]+/g.test(e);
      }).reduce(function(e, t) {
        return sI(sI({}, e), {}, z4({}, t, []));
      }, {})
    ) : {}
  }];
}
function Cte(n) {
  return n instanceof DOMException && (n.name === "AbortError" || n.code === n.ABORT_ERR);
}
function Rte(n) {
  return n instanceof DOMException && (n.name === "SecurityError" || n.code === n.SECURITY_ERR);
}
var Ate = ["children"], Dte = ["open"], Lte = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"], Ote = ["refKey", "onChange", "onClick"];
function Pte(n) {
  return zte(n) || Ute(n) || F4(n) || Nte();
}
function Nte() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ute(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null)
    return Array.from(n);
}
function zte(n) {
  if (Array.isArray(n))
    return LO(n);
}
function dL(n, e) {
  return Fte(n) || Ite(n, e) || F4(n, e) || kte();
}
function kte() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function F4(n, e) {
  if (n) {
    if (typeof n == "string")
      return LO(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return LO(n, e);
  }
}
function LO(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = new Array(e); t < e; t++)
    r[t] = n[t];
  return r;
}
function Ite(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var r = [], a = !0, s = !1, u, h;
    try {
      for (t = t.call(n); !(a = (u = t.next()).done) && (r.push(u.value), !(e && r.length === e)); a = !0)
        ;
    } catch (v) {
      s = !0, h = v;
    } finally {
      try {
        !a && t.return != null && t.return();
      } finally {
        if (s)
          throw h;
      }
    }
    return r;
  }
}
function Fte(n) {
  if (Array.isArray(n))
    return n;
}
function hI(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(n, a).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function rs(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? hI(Object(t), !0).forEach(function(r) {
      OO(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : hI(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function OO(n, e, t) {
  return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n;
}
function PR(n, e) {
  if (n == null)
    return {};
  var t = Bte(n, e), r, a;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (a = 0; a < s.length; a++)
      r = s[a], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]);
  }
  return t;
}
function Bte(n, e) {
  if (n == null)
    return {};
  var t = {}, r = Object.keys(n), a, s;
  for (s = 0; s < r.length; s++)
    a = r[s], !(e.indexOf(a) >= 0) && (t[a] = n[a]);
  return t;
}
var ZP = /* @__PURE__ */ le.forwardRef(function(n, e) {
  var t = n.children, r = PR(n, Ate), a = H4(r), s = a.open, u = PR(a, Dte);
  return le.useImperativeHandle(e, function() {
    return {
      open: s
    };
  }, [s]), /* @__PURE__ */ Ne.createElement(le.Fragment, null, t(rs(rs({}, u), {}, {
    open: s
  })));
});
ZP.displayName = "Dropzone";
var B4 = {
  disabled: !1,
  getFilesFromEvent: tte,
  maxSize: 1 / 0,
  minSize: 0,
  multiple: !0,
  maxFiles: 0,
  preventDropOnDocument: !0,
  noClick: !1,
  noKeyboard: !1,
  noDrag: !1,
  noDragEventsBubbling: !1,
  validator: null,
  useFsAccessApi: !0
};
ZP.defaultProps = B4;
ZP.propTypes = {
  /**
   * Render function that exposes the dropzone state and prop getter fns
   *
   * @param {object} params
   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render
   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render
   * @param {Function} params.open Open the native file selection dialog
   * @param {boolean} params.isFocused Dropzone area is in focus
   * @param {boolean} params.isFileDialogActive File dialog is opened
   * @param {boolean} params.isDragActive Active drag is in progress
   * @param {boolean} params.isDragAccept Dragged files are accepted
   * @param {boolean} params.isDragReject Some dragged files are rejected
   * @param {File[]} params.draggedFiles Files in active drag
   * @param {File[]} params.acceptedFiles Accepted files
   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected
   */
  children: xo.func,
  /**
   * Set accepted file types.
   * See https://github.com/okonet/attr-accept for more information.
   * Keep in mind that mime type determination is not reliable across platforms. CSV files,
   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
   * Windows. In some cases there might not be a mime type set at all.
   * See: https://github.com/react-dropzone/react-dropzone/issues/276
   */
  accept: xo.oneOfType([xo.string, xo.arrayOf(xo.string)]),
  /**
   * Allow drag 'n' drop (or selection from the file dialog) of multiple files
   */
  multiple: xo.bool,
  /**
   * If false, allow dropped items to take over the current browser window
   */
  preventDropOnDocument: xo.bool,
  /**
   * If true, disables click to open the native file selection dialog
   */
  noClick: xo.bool,
  /**
   * If true, disables SPACE/ENTER to open the native file selection dialog.
   * Note that it also stops tracking the focus state.
   */
  noKeyboard: xo.bool,
  /**
   * If true, disables drag 'n' drop
   */
  noDrag: xo.bool,
  /**
   * If true, stops drag event propagation to parents
   */
  noDragEventsBubbling: xo.bool,
  /**
   * Minimum file size (in bytes)
   */
  minSize: xo.number,
  /**
   * Maximum file size (in bytes)
   */
  maxSize: xo.number,
  /**
   * Maximum accepted number of files
   * The default value is 0 which means there is no limitation to how many files are accepted.
   */
  maxFiles: xo.number,
  /**
   * Enable/disable the dropzone
   */
  disabled: xo.bool,
  /**
   * Use this to provide a custom file aggregator
   *
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  getFilesFromEvent: xo.func,
  /**
   * Cb for when closing the file dialog with no selection
   */
  onFileDialogCancel: xo.func,
  /**
   * Cb for when opening the file dialog
   */
  onFileDialogOpen: xo.func,
  /**
   * Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API
   * to open the file picker instead of using an `<input type="file">` click event.
   */
  useFsAccessApi: xo.bool,
  /**
   * Cb for when the `dragenter` event occurs.
   *
   * @param {DragEvent} event
   */
  onDragEnter: xo.func,
  /**
   * Cb for when the `dragleave` event occurs
   *
   * @param {DragEvent} event
   */
  onDragLeave: xo.func,
  /**
   * Cb for when the `dragover` event occurs
   *
   * @param {DragEvent} event
   */
  onDragOver: xo.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
   *
   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
   * If `multiple` is set to false and additional files are dropped,
   * all files besides the first will be rejected.
   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
   *
   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
   *
   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
   *
   * ```js
   * function onDrop(acceptedFiles) {
   *   const req = request.post('/upload')
   *   acceptedFiles.forEach(file => {
   *     req.attach(file.name, file)
   *   })
   *   req.end(callback)
   * }
   * ```
   *
   * @param {File[]} acceptedFiles
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  onDrop: xo.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are accepted, this callback is not invoked.
   *
   * @param {File[]} files
   * @param {(DragEvent|Event)} event
   */
  onDropAccepted: xo.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are rejected, this callback is not invoked.
   *
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event
   */
  onDropRejected: xo.func,
  /**
   * Custom validation function
   * @param {File} file
   * @returns {FileError|FileError[]}
   */
  validator: xo.func
};
var PO = {
  isFocused: !1,
  isFileDialogActive: !1,
  isDragActive: !1,
  isDragAccept: !1,
  isDragReject: !1,
  draggedFiles: [],
  acceptedFiles: [],
  fileRejections: []
};
function H4() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = rs(rs({}, B4), n), t = e.accept, r = e.disabled, a = e.getFilesFromEvent, s = e.maxSize, u = e.minSize, h = e.multiple, v = e.maxFiles, y = e.onDragEnter, _ = e.onDragLeave, b = e.onDragOver, M = e.onDrop, C = e.onDropAccepted, D = e.onDropRejected, U = e.onFileDialogCancel, N = e.onFileDialogOpen, O = e.useFsAccessApi, I = e.preventDropOnDocument, k = e.noClick, G = e.noKeyboard, j = e.noDrag, Y = e.noDragEventsBubbling, Z = e.validator, te = le.useMemo(function() {
    return typeof N == "function" ? N : pI;
  }, [N]), J = le.useMemo(function() {
    return typeof U == "function" ? U : pI;
  }, [U]), q = le.useRef(null), oe = le.useRef(null), ye = le.useReducer(Hte, PO), de = dL(ye, 2), xe = de[0], Re = de[1], Pe = xe.isFocused, Te = xe.isFileDialogActive, ue = xe.draggedFiles, we = le.useRef(typeof window < "u" && window.isSecureContext && O && Mte()), X = function() {
    !we.current && Te && setTimeout(function() {
      if (oe.current) {
        var ae = oe.current.files;
        ae.length || (Re({
          type: "closeDialog"
        }), J());
      }
    }, 300);
  };
  le.useEffect(function() {
    return window.addEventListener("focus", X, !1), function() {
      window.removeEventListener("focus", X, !1);
    };
  }, [oe, Te, J, we]);
  var me = le.useRef([]), ce = function(ae) {
    q.current && q.current.contains(ae.target) || (ae.preventDefault(), me.current = []);
  };
  le.useEffect(function() {
    return I && (document.addEventListener("dragover", dI, !1), document.addEventListener("drop", ce, !1)), function() {
      I && (document.removeEventListener("dragover", dI), document.removeEventListener("drop", ce));
    };
  }, [q, I]);
  var Ue = le.useCallback(function(se) {
    se.preventDefault(), se.persist(), gt(se), me.current = [].concat(Pte(me.current), [se.target]), rR(se) && Promise.resolve(a(se)).then(function(ae) {
      OR(se) && !Y || (Re({
        draggedFiles: ae,
        isDragActive: !0,
        type: "setDraggedFiles"
      }), y && y(se));
    });
  }, [a, y, Y]), Oe = le.useCallback(function(se) {
    se.preventDefault(), se.persist(), gt(se);
    var ae = rR(se);
    if (ae && se.dataTransfer)
      try {
        se.dataTransfer.dropEffect = "copy";
      } catch {
      }
    return ae && b && b(se), !1;
  }, [b, Y]), Ze = le.useCallback(function(se) {
    se.preventDefault(), se.persist(), gt(se);
    var ae = me.current.filter(function(wt) {
      return q.current && q.current.contains(wt);
    }), Ke = ae.indexOf(se.target);
    Ke !== -1 && ae.splice(Ke, 1), me.current = ae, !(ae.length > 0) && (Re({
      isDragActive: !1,
      type: "setDraggedFiles",
      draggedFiles: []
    }), rR(se) && _ && _(se));
  }, [q, _, Y]), je = le.useCallback(function(se, ae) {
    var Ke = [], wt = [];
    se.forEach(function(_t) {
      var Vt = k4(_t, t), fn = dL(Vt, 2), Wt = fn[0], Ee = fn[1], Xe = I4(_t, u, s), St = dL(Xe, 2), Ut = St[0], Se = St[1], Ye = Z ? Z(_t) : null;
      if (Wt && Ut && !Ye)
        Ke.push(_t);
      else {
        var bt = [Ee, Se];
        Ye && (bt = bt.concat(Ye)), wt.push({
          file: _t,
          errors: bt.filter(function(Tt) {
            return Tt;
          })
        });
      }
    }), (!h && Ke.length > 1 || h && v >= 1 && Ke.length > v) && (Ke.forEach(function(_t) {
      wt.push({
        file: _t,
        errors: [xte]
      });
    }), Ke.splice(0)), Re({
      acceptedFiles: Ke,
      fileRejections: wt,
      type: "setFiles"
    }), M && M(Ke, wt, ae), wt.length > 0 && D && D(wt, ae), Ke.length > 0 && C && C(Ke, ae);
  }, [Re, h, t, u, s, v, M, C, D, Z]), Je = le.useCallback(function(se) {
    se.preventDefault(), se.persist(), gt(se), me.current = [], rR(se) && Promise.resolve(a(se)).then(function(ae) {
      OR(se) && !Y || je(ae, se);
    }), Re({
      type: "reset"
    });
  }, [a, je, Y]), at = le.useCallback(function() {
    if (we.current) {
      Re({
        type: "openDialog"
      }), te();
      var se = {
        multiple: h,
        types: wte(t)
      };
      window.showOpenFilePicker(se).then(function(ae) {
        return a(ae);
      }).then(function(ae) {
        je(ae, null), Re({
          type: "closeDialog"
        });
      }).catch(function(ae) {
        Cte(ae) ? (J(ae), Re({
          type: "closeDialog"
        })) : Rte(ae) && (we.current = !1, oe.current && (oe.current.value = null, oe.current.click()));
      });
      return;
    }
    oe.current && (Re({
      type: "openDialog"
    }), te(), oe.current.value = null, oe.current.click());
  }, [Re, te, J, O, je, t, h]), xt = le.useCallback(function(se) {
    !q.current || !q.current.isEqualNode(se.target) || (se.key === " " || se.key === "Enter" || se.keyCode === 32 || se.keyCode === 13) && (se.preventDefault(), at());
  }, [q, at]), $t = le.useCallback(function() {
    Re({
      type: "focus"
    });
  }, []), Ht = le.useCallback(function() {
    Re({
      type: "blur"
    });
  }, []), he = le.useCallback(function() {
    k || (Tte() ? setTimeout(at, 0) : at());
  }, [k, at]), nt = function(ae) {
    return r ? null : ae;
  }, et = function(ae) {
    return G ? null : nt(ae);
  }, Rt = function(ae) {
    return j ? null : nt(ae);
  }, gt = function(ae) {
    Y && ae.stopPropagation();
  }, Jt = le.useMemo(function() {
    return function() {
      var se = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ae = se.refKey, Ke = ae === void 0 ? "ref" : ae, wt = se.role, _t = se.onKeyDown, Vt = se.onFocus, fn = se.onBlur, Wt = se.onClick, Ee = se.onDragEnter, Xe = se.onDragOver, St = se.onDragLeave, Ut = se.onDrop, Se = PR(se, Lte);
      return rs(rs(OO({
        onKeyDown: et(dv(_t, xt)),
        onFocus: et(dv(Vt, $t)),
        onBlur: et(dv(fn, Ht)),
        onClick: nt(dv(Wt, he)),
        onDragEnter: Rt(dv(Ee, Ue)),
        onDragOver: Rt(dv(Xe, Oe)),
        onDragLeave: Rt(dv(St, Ze)),
        onDrop: Rt(dv(Ut, Je)),
        role: typeof wt == "string" && wt !== "" ? wt : "button"
      }, Ke, q), !r && !G ? {
        tabIndex: 0
      } : {}), Se);
    };
  }, [q, xt, $t, Ht, he, Ue, Oe, Ze, Je, G, j, r]), Kt = le.useCallback(function(se) {
    se.stopPropagation();
  }, []), qt = le.useMemo(function() {
    return function() {
      var se = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ae = se.refKey, Ke = ae === void 0 ? "ref" : ae, wt = se.onChange, _t = se.onClick, Vt = PR(se, Ote), fn = OO({
        accept: t,
        multiple: h,
        type: "file",
        style: {
          display: "none"
        },
        onChange: nt(dv(wt, Je)),
        onClick: nt(dv(_t, Kt)),
        tabIndex: -1
      }, Ke, oe);
      return rs(rs({}, fn), Vt);
    };
  }, [oe, t, h, Je, r]), hn = ue.length, Rn = hn > 0 && _te({
    files: ue,
    accept: t,
    minSize: u,
    maxSize: s,
    multiple: h,
    maxFiles: v
  }), Yn = hn > 0 && !Rn;
  return rs(rs({}, xe), {}, {
    isDragAccept: Rn,
    isDragReject: Yn,
    isFocused: Pe && !r,
    getRootProps: Jt,
    getInputProps: qt,
    rootRef: q,
    inputRef: oe,
    open: nt(at)
  });
}
function Hte(n, e) {
  switch (e.type) {
    case "focus":
      return rs(rs({}, n), {}, {
        isFocused: !0
      });
    case "blur":
      return rs(rs({}, n), {}, {
        isFocused: !1
      });
    case "openDialog":
      return rs(rs({}, PO), {}, {
        isFileDialogActive: !0
      });
    case "closeDialog":
      return rs(rs({}, n), {}, {
        isFileDialogActive: !1
      });
    case "setDraggedFiles":
      var t = e.isDragActive, r = e.draggedFiles;
      return rs(rs({}, n), {}, {
        draggedFiles: r,
        isDragActive: t
      });
    case "setFiles":
      return rs(rs({}, n), {}, {
        acceptedFiles: e.acceptedFiles,
        fileRejections: e.fileRejections
      });
    case "reset":
      return rs({}, PO);
    default:
      return n;
  }
}
function pI() {
}
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var Vte = function(e) {
  return e != null && typeof e == "object" && Array.isArray(e) === !1;
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var Gte = Vte;
function mI(n) {
  return Gte(n) === !0 && Object.prototype.toString.call(n) === "[object Object]";
}
var V4 = function(e) {
  var t, r;
  return !(mI(e) === !1 || (t = e.constructor, typeof t != "function") || (r = t.prototype, mI(r) === !1) || r.hasOwnProperty("isPrototypeOf") === !1);
};
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var Wte = V4, JP = function(e) {
  return Wte(e) || typeof e == "function" || Array.isArray(e);
};
/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var jte = function(e, t, r) {
  for (var a in e)
    if (t.call(r, e[a], a, e) === !1)
      break;
}, $te = JP, Yte = jte;
function G4(n, e) {
  for (var t = arguments.length, r = 0; ++r < t; ) {
    var a = arguments[r];
    NO(a) && Yte(a, Xte, n);
  }
  return n;
}
function Xte(n, e) {
  if (qte(e)) {
    var t = this[e];
    NO(n) && NO(t) ? G4(t, n) : this[e] = n;
  }
}
function NO(n) {
  return $te(n) && !Array.isArray(n);
}
function qte(n) {
  return n !== "__proto__" && n !== "constructor" && n !== "prototype";
}
var Kte = G4;
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var Qte = function(n, e, t, r, a) {
  if (!Zte(n) || !e)
    return n;
  if (e = iR(e), t && (e += "." + iR(t)), r && (e += "." + iR(r)), a && (e += "." + iR(a)), e in n)
    return n[e];
  for (var s = e.split("."), u = s.length, h = -1; n && ++h < u; ) {
    for (var v = s[h]; v[v.length - 1] === "\\"; )
      v = v.slice(0, -1) + "." + s[++h];
    n = n[v];
  }
  return n;
};
function Zte(n) {
  return n !== null && (typeof n == "object" || typeof n == "function");
}
function iR(n) {
  return n ? Array.isArray(n) ? n.join(".") : n : "";
}
/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var Jte = function(n, e) {
  if (n === null || typeof n > "u")
    throw new TypeError("expected first argument to be an object.");
  if (typeof e > "u" || typeof Symbol > "u" || typeof Object.getOwnPropertySymbols != "function")
    return n;
  for (var t = Object.prototype.propertyIsEnumerable, r = Object(n), a = arguments.length, s = 0; ++s < a; )
    for (var u = Object(arguments[s]), h = Object.getOwnPropertySymbols(u), v = 0; v < h.length; v++) {
      var y = h[v];
      t.call(u, y) && (r[y] = u[y]);
    }
  return r;
}, ene = JP, tne = Jte, nne = Object.assign || function(n) {
  if (n === null || typeof n > "u")
    throw new TypeError("Cannot convert undefined or null to object");
  vI(n) || (n = {});
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e];
    ine(t) && (t = ane(t)), vI(t) && (rne(n, t), tne(n, t));
  }
  return n;
};
function rne(n, e) {
  for (var t in e)
    one(e, t) && (n[t] = e[t]);
}
function ine(n) {
  return n && typeof n == "string";
}
function ane(n) {
  var e = {};
  for (var t in n)
    e[t] = n[t];
  return e;
}
function vI(n) {
  return n && typeof n == "object" || ene(n);
}
function one(n, e) {
  return Object.prototype.hasOwnProperty.call(n, e);
}
/*!
 * split-string <https://github.com/jonschlinkert/split-string>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var sne = nne, lne = function(n, e, t) {
  if (typeof n != "string")
    throw new TypeError("expected a string");
  typeof e == "function" && (t = e, e = null), typeof e == "string" && (e = { sep: e });
  var r = sne({ sep: "." }, e), a = r.quotes || ['"', "'", "`"], s;
  r.brackets === !0 ? s = {
    "<": ">",
    "(": ")",
    "[": "]",
    "{": "}"
  } : r.brackets && (s = r.brackets);
  var u = [], h = [], v = [""], y = r.sep, _ = n.length, b = -1, M;
  function C() {
    if (s && h.length)
      return s[h[h.length - 1]];
  }
  for (; ++b < _; ) {
    var D = n[b], U = n[b + 1], N = { val: D, idx: b, arr: v, str: n };
    if (u.push(N), D === "\\") {
      N.val = cne(r, n, b) === !0 ? D + U : U, N.escaped = !0, typeof t == "function" && t(N), v[v.length - 1] += N.val, b++;
      continue;
    }
    if (s && s[D]) {
      h.push(D);
      var O = C(), I = b + 1;
      if (n.indexOf(O, I + 1) !== -1)
        for (; h.length && I < _; ) {
          var k = n[++I];
          if (k === "\\") {
            k++;
            continue;
          }
          if (a.indexOf(k) !== -1) {
            I = UO(n, k, I + 1);
            continue;
          }
          if (O = C(), h.length && n.indexOf(O, I + 1) === -1)
            break;
          if (s[k]) {
            h.push(k);
            continue;
          }
          O === k && h.pop();
        }
      if (M = I, M === -1) {
        v[v.length - 1] += D;
        continue;
      }
      D = n.slice(b, M + 1), N.val = D, N.idx = b = M;
    }
    if (a.indexOf(D) !== -1) {
      if (M = UO(n, D, b + 1), M === -1) {
        v[v.length - 1] += D;
        continue;
      }
      une(D, r) === !0 ? D = n.slice(b, M + 1) : D = n.slice(b + 1, M), N.val = D, N.idx = b = M;
    }
    if (typeof t == "function" && (t(N, u), D = N.val, b = N.idx), N.val === y && N.split !== !1) {
      v.push("");
      continue;
    }
    v[v.length - 1] += N.val;
  }
  return v;
};
function UO(n, e, t, r) {
  var a = n.indexOf(e, t);
  return n.charAt(a - 1) === "\\" ? UO(n, e, a + 1) : a;
}
function une(n, e) {
  return e.keepDoubleQuotes === !0 && n === '"' || e.keepSingleQuotes === !0 && n === "'" ? !0 : e.keepQuotes;
}
function cne(n, e, t) {
  return typeof n.keepEscaping == "function" ? n.keepEscaping(e, t) : n.keepEscaping === !0 || e[t + 1] === "\\";
}
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var W4 = function(e) {
  return typeof e < "u" && e !== null && (typeof e == "object" || typeof e == "function");
}, gI = W4, fne = function(e) {
  gI(e) || (e = {});
  for (var t = arguments.length, r = 1; r < t; r++) {
    var a = arguments[r];
    gI(a) && dne(e, a);
  }
  return e;
};
function dne(n, e) {
  for (var t in e)
    hne(e, t) && (n[t] = e[t]);
}
function hne(n, e) {
  return Object.prototype.hasOwnProperty.call(n, e);
}
/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var pne = lne, mne = fne, yI = V4, SI = W4, vne = function(n, e, t) {
  if (!SI(n) || (Array.isArray(e) && (e = [].concat.apply([], e).join(".")), typeof e != "string"))
    return n;
  for (var r = pne(e, { sep: ".", brackets: !0 }).filter(gne), a = r.length, s = -1, u = n; ++s < a; ) {
    var h = r[s];
    if (s !== a - 1) {
      SI(u[h]) || (u[h] = {}), u = u[h];
      continue;
    }
    yI(u[h]) && yI(t) ? u[h] = mne({}, u[h], t) : u[h] = t;
  }
  return n;
};
function gne(n) {
  return n !== "__proto__" && n !== "constructor" && n !== "prototype";
}
var hL = JP, xI = Kte, yne = Qte, _I = vne, Sne = function(e, t, r) {
  if (!hL(e))
    throw new TypeError("expected an object");
  if (typeof t != "string" || r == null)
    return xI.apply(null, arguments);
  if (typeof r == "string")
    return _I(e, t, r), e;
  var a = yne(e, t);
  return hL(r) && hL(a) && (r = xI({}, a, r)), _I(e, t, r), e;
};
const xne = /* @__PURE__ */ GE(Sne), eN = (...n) => n.filter(Boolean).join(".");
function _ne(n) {
  const e = n.split(".");
  return [e.pop(), e.join(".") || void 0];
}
function Ene(n, e) {
  return Object.entries(nJ(n, e)).reduce(
    (t, [, {
      value: r,
      disabled: a,
      key: s
    }]) => (t[s] = a ? void 0 : r, t),
    {}
  );
}
function bne(n, e) {
  const t = le.useRef();
  return (e ? VT : hM)(n, t.current) || (t.current = n), t.current;
}
function j4(n, e) {
  return le.useMemo(n, bne(e, !0));
}
function Tne(n) {
  const e = le.useRef(null), t = le.useRef(null), r = le.useRef(!0);
  return le.useLayoutEffect(() => {
    n || (e.current.style.height = "0px", e.current.style.overflow = "hidden");
  }, []), le.useEffect(() => {
    if (r.current) {
      r.current = !1;
      return;
    }
    let a;
    const s = e.current, u = () => {
      n && (s.style.removeProperty("height"), s.style.removeProperty("overflow"), t.current.scrollIntoView({
        behavior: "smooth",
        block: "nearest"
      }));
    };
    s.addEventListener("transitionend", u, {
      once: !0
    });
    const {
      height: h
    } = t.current.getBoundingClientRect();
    return s.style.height = h + "px", n || (s.style.overflow = "hidden", a = window.setTimeout(() => s.style.height = "0px", 50)), () => {
      s.removeEventListener("transitionend", u), clearTimeout(a);
    };
  }, [n]), {
    wrapperRef: e,
    contentRef: t
  };
}
const Mne = (n) => {
  const [e, t] = le.useState(n.getVisiblePaths());
  return le.useEffect(() => {
    t(n.getVisiblePaths());
    const r = n.useStore.subscribe(n.getVisiblePaths, t, {
      equalityFn: hM
    });
    return () => r();
  }, [n]), e;
};
function wne(n, e, t) {
  return n.useStore((a) => {
    const s = Lr(Lr({}, t), a.data);
    return Ene(s, e);
  }, hM);
}
function $4(n = 3) {
  const e = le.useRef(null), t = le.useRef(null), [r, a] = le.useState(!1), s = le.useCallback(() => a(!0), []), u = le.useCallback(() => a(!1), []);
  return le.useLayoutEffect(() => {
    if (r) {
      const {
        bottom: h,
        top: v,
        left: y
      } = e.current.getBoundingClientRect(), {
        height: _
      } = t.current.getBoundingClientRect(), b = h + _ > window.innerHeight - 40 ? "up" : "down";
      t.current.style.position = "fixed", t.current.style.zIndex = "10000", t.current.style.left = y + "px", b === "down" ? t.current.style.top = h + n + "px" : t.current.style.bottom = window.innerHeight - v + n + "px";
    }
  }, [n, r]), {
    popinRef: e,
    wrapperRef: t,
    shown: r,
    show: s,
    hide: u
  };
}
Fee([Bee]);
const Cne = {
  rgb: "toRgb",
  hsl: "toHsl",
  hsv: "toHsv",
  hex: "toHex"
};
hd.extend({
  color: () => (n) => _f(n).isValid()
});
const Rne = (n) => hd().color().test(n);
function Y4(n, {
  format: e,
  hasAlpha: t,
  isString: r
}) {
  const a = Cne[e] + (r && e !== "hex" ? "String" : ""), s = n[a]();
  return typeof s == "object" && !t ? rJ(s, ["a"]) : s;
}
const X4 = (n, e) => {
  const t = _f(n);
  if (!t.isValid())
    throw Error("Invalid color");
  return Y4(t, e);
}, Ane = (n, e) => Y4(_f(n), Lr(Lr({}, e), {}, {
  isString: !0,
  format: "hex"
})), Dne = ({
  value: n
}) => {
  const e = Iee(n), t = e === "name" ? "hex" : e, r = typeof n == "object" ? "a" in n : e === "hex" && n.length === 8 || /^(rgba)|(hsla)|(hsva)/.test(n), a = {
    format: t,
    hasAlpha: r,
    isString: typeof n == "string"
  };
  return {
    value: X4(n, a),
    settings: a
  };
};
var Lne = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: Rne,
  sanitize: X4,
  format: Ane,
  normalize: Dne
});
const One = Er("div", {
  position: "relative",
  boxSizing: "border-box",
  borderRadius: "$sm",
  overflow: "hidden",
  cursor: "pointer",
  height: "$rowHeight",
  width: "$rowHeight",
  backgroundColor: "#fff",
  backgroundImage: `url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')`,
  $inputStyle: "",
  $hover: "",
  zIndex: 1,
  variants: {
    active: {
      true: {
        $inputStyle: "$accent1"
      }
    }
  },
  "&::before": {
    content: '""',
    position: "absolute",
    top: 0,
    bottom: 0,
    right: 0,
    left: 0,
    backgroundColor: "currentColor",
    zIndex: 1
  }
}), Pne = Er("div", {
  position: "relative",
  display: "grid",
  gridTemplateColumns: "$sizes$rowHeight auto",
  columnGap: "$colGap",
  alignItems: "center"
}), Nne = Er("div", {
  width: "$colorPickerWidth",
  height: "$colorPickerHeight",
  ".react-colorful": {
    width: "100%",
    height: "100%",
    boxShadow: "$level2",
    cursor: "crosshair"
  },
  ".react-colorful__saturation": {
    borderRadius: "$sm $sm 0 0"
  },
  ".react-colorful__alpha, .react-colorful__hue": {
    height: 10
  },
  ".react-colorful__last-control": {
    borderRadius: "0 0 $sm $sm"
  },
  ".react-colorful__pointer": {
    height: 12,
    width: 12
  }
});
function EI(n, e) {
  return e !== "rgb" ? _f(n).toRgb() : n;
}
function Une({
  value: n,
  displayValue: e,
  settings: t,
  onUpdate: r
}) {
  const {
    emitOnEditStart: a,
    emitOnEditEnd: s
  } = Pc(), {
    format: u,
    hasAlpha: h
  } = t, {
    popinRef: v,
    wrapperRef: y,
    shown: _,
    show: b,
    hide: M
  } = $4(), C = le.useRef(0), [D, U] = le.useState(() => EI(n, u)), N = h ? Yee : qee, O = () => {
    U(EI(n, u)), b(), a();
  }, I = () => {
    M(), s(), window.clearTimeout(C.current);
  }, k = () => {
    C.current = window.setTimeout(I, 500);
  };
  return le.useEffect(() => () => window.clearTimeout(C.current), []), Ne.createElement(Ne.Fragment, null, Ne.createElement(One, {
    ref: v,
    active: _,
    onClick: () => O(),
    style: {
      color: e
    }
  }), _ && Ne.createElement(jP, null, Ne.createElement(p4, {
    onPointerUp: I
  }), Ne.createElement(Nne, {
    ref: y,
    onMouseEnter: () => window.clearTimeout(C.current),
    onMouseLeave: (G) => G.buttons === 0 && k()
  }, Ne.createElement(N, {
    color: D,
    onChange: r
  }))));
}
function zne() {
  const {
    value: n,
    displayValue: e,
    label: t,
    onChange: r,
    onUpdate: a,
    settings: s
  } = Pc();
  return Ne.createElement(ap, {
    input: !0
  }, Ne.createElement(cm, null, t), Ne.createElement(Pne, null, Ne.createElement(Une, {
    value: n,
    displayValue: e,
    onChange: r,
    onUpdate: a,
    settings: s
  }), Ne.createElement(WP, {
    value: e,
    onChange: r,
    onUpdate: a
  })));
}
var kne = Lr({
  component: zne
}, Lne);
function Ine() {
  const {
    label: n,
    displayValue: e,
    onUpdate: t,
    settings: r
  } = Pc();
  return Ne.createElement(ap, {
    input: !0
  }, Ne.createElement(cm, null, n), Ne.createElement(YP, {
    value: e,
    settings: r,
    onUpdate: t
  }));
}
var Fne = Lr({
  component: Ine
}, E4(["x", "y", "z"]));
const Bne = Er("div", {
  $flexCenter: "",
  position: "relative",
  backgroundColor: "$elevation3",
  borderRadius: "$sm",
  cursor: "pointer",
  height: "$rowHeight",
  width: "$rowHeight",
  touchAction: "none",
  $draggable: "",
  $hover: "",
  "&:active": {
    cursor: "none"
  },
  "&::after": {
    content: '""',
    backgroundColor: "$accent2",
    height: 4,
    width: 4,
    borderRadius: 2
  }
}), Hne = Er("div", {
  $flexCenter: "",
  width: "$joystickWidth",
  height: "$joystickHeight",
  borderRadius: "$sm",
  boxShadow: "$level2",
  position: "fixed",
  zIndex: 1e4,
  overflow: "hidden",
  $draggable: "",
  transform: "translate(-50%, -50%)",
  variants: {
    isOutOfBounds: {
      true: {
        backgroundColor: "$elevation1"
      },
      false: {
        backgroundColor: "$elevation3"
      }
    }
  },
  "> div": {
    position: "absolute",
    $flexCenter: "",
    borderStyle: "solid",
    borderWidth: 1,
    borderColor: "$highlight1",
    backgroundColor: "$elevation3",
    width: "80%",
    height: "80%",
    "&::after,&::before": {
      content: '""',
      position: "absolute",
      zindex: 10,
      backgroundColor: "$highlight1"
    },
    "&::before": {
      width: "100%",
      height: 1
    },
    "&::after": {
      height: "100%",
      width: 1
    }
  },
  "> span": {
    position: "relative",
    zindex: 100,
    width: 10,
    height: 10,
    backgroundColor: "$accent2",
    borderRadius: "50%"
  }
});
function Vne({
  value: n,
  settings: e,
  onUpdate: t
}) {
  const r = le.useRef(), a = le.useRef(0), s = le.useRef(0), u = le.useRef(1), [h, v] = le.useState(!1), [y, _] = le.useState(!1), [b, M] = v4(), C = le.useRef(null), D = le.useRef(null);
  le.useLayoutEffect(() => {
    if (h) {
      const {
        top: ye,
        left: de,
        width: xe,
        height: Re
      } = C.current.getBoundingClientRect();
      D.current.style.left = de + xe / 2 + "px", D.current.style.top = ye + Re / 2 + "px";
    }
  }, [h]);
  const {
    keys: [U, N],
    joystick: O
  } = e, I = O === "invertY" ? 1 : -1, {
    [U]: {
      step: k
    },
    [N]: {
      step: G
    }
  } = e, j = Ig("sizes", "joystickWidth"), Y = Ig("sizes", "joystickHeight"), Z = parseFloat(j) * 0.8 / 2, te = parseFloat(Y) * 0.8 / 2, J = le.useCallback(() => {
    r.current || (_(!0), a.current && M({
      x: a.current * Z
    }), s.current && M({
      y: s.current * -te
    }), r.current = window.setInterval(() => {
      t((ye) => {
        const de = k * a.current * u.current, xe = I * G * s.current * u.current;
        return Array.isArray(ye) ? {
          [U]: ye[0] + de,
          [N]: ye[1] + xe
        } : {
          [U]: ye[U] + de,
          [N]: ye[N] + xe
        };
      });
    }, 16));
  }, [Z, te, t, M, k, G, U, N, I]), q = le.useCallback(() => {
    window.clearTimeout(r.current), r.current = void 0, _(!1);
  }, []);
  le.useEffect(() => {
    function ye(de) {
      u.current = e4(de);
    }
    return window.addEventListener("keydown", ye), window.addEventListener("keyup", ye), () => {
      window.clearTimeout(r.current), window.removeEventListener("keydown", ye), window.removeEventListener("keyup", ye);
    };
  }, []);
  const oe = vM(({
    first: ye,
    active: de,
    delta: [xe, Re],
    movement: [Pe, Te]
  }) => {
    ye && v(!0);
    const ue = y0(Pe, -Z, Z), we = y0(Te, -te, te);
    a.current = Math.abs(Pe) > Math.abs(ue) ? Math.sign(Pe - ue) : 0, s.current = Math.abs(Te) > Math.abs(we) ? Math.sign(we - Te) : 0;
    let X = n[U], me = n[N];
    de ? (a.current || (X += xe * k * u.current, M({
      x: ue
    })), s.current || (me -= I * Re * G * u.current, M({
      y: we
    })), a.current || s.current ? J() : q(), t({
      [U]: X,
      [N]: me
    })) : (v(!1), a.current = 0, s.current = 0, M({
      x: 0,
      y: 0
    }), q());
  });
  return Ne.createElement(Bne, As({
    ref: C
  }, oe()), h && Ne.createElement(jP, null, Ne.createElement(Hne, {
    ref: D,
    isOutOfBounds: y
  }, Ne.createElement("div", null), Ne.createElement("span", {
    ref: b
  }))));
}
const Gne = Er("div", {
  display: "grid",
  columnGap: "$colGap",
  variants: {
    withJoystick: {
      true: {
        gridTemplateColumns: "$sizes$rowHeight auto"
      },
      false: {
        gridTemplateColumns: "auto"
      }
    }
  }
});
function Wne() {
  const {
    label: n,
    displayValue: e,
    onUpdate: t,
    settings: r
  } = Pc();
  return Ne.createElement(ap, {
    input: !0
  }, Ne.createElement(cm, null, n), Ne.createElement(Gne, {
    withJoystick: !!r.joystick
  }, r.joystick && Ne.createElement(Vne, {
    value: e,
    settings: r,
    onUpdate: t
  }), Ne.createElement(YP, {
    value: e,
    settings: r,
    onUpdate: t
  })));
}
const jne = ["joystick"], q4 = E4(["x", "y"]), $ne = (n) => {
  let {
    joystick: e = !0
  } = n, t = Za(n, jne);
  const {
    value: r,
    settings: a
  } = q4.normalize(t);
  return {
    value: r,
    settings: Lr(Lr({}, a), {}, {
      joystick: e
    })
  };
};
var Yne = Lr(Lr({
  component: Wne
}, q4), {}, {
  normalize: $ne
});
const Xne = (n) => {
  if (n !== void 0) {
    if (n instanceof File)
      try {
        return URL.createObjectURL(n);
      } catch {
        return;
      }
    if (typeof n == "string" && n.indexOf("blob:") === 0)
      return n;
    throw Error("Invalid image format [undefined | blob |File].");
  }
}, qne = (n, e) => typeof e == "object" && "image" in e, Kne = ({
  image: n
}) => ({
  value: n
});
var Qne = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sanitize: Xne,
  schema: qne,
  normalize: Kne
});
const Zne = Er("div", {
  position: "relative",
  display: "grid",
  gridTemplateColumns: "$sizes$rowHeight auto 20px",
  columnGap: "$colGap",
  alignItems: "center"
}), Jne = Er("div", {
  $flexCenter: "",
  overflow: "hidden",
  height: "$rowHeight",
  background: "$elevation3",
  textAlign: "center",
  color: "inherit",
  borderRadius: "$sm",
  outline: "none",
  userSelect: "none",
  cursor: "pointer",
  $inputStyle: "",
  $hover: "",
  $focusWithin: "",
  $active: "$accent1 $elevation1",
  variants: {
    isDragAccept: {
      true: {
        $inputStyle: "$accent1",
        backgroundColor: "$elevation1"
      }
    }
  }
}), ere = Er("div", {
  boxSizing: "border-box",
  borderRadius: "$sm",
  height: "$rowHeight",
  width: "$rowHeight",
  $inputStyle: "",
  backgroundSize: "cover",
  backgroundPosition: "center",
  variants: {
    hasImage: {
      true: {
        cursor: "pointer",
        $hover: "",
        $active: ""
      }
    }
  }
}), tre = Er("div", {
  $flexCenter: "",
  width: "$imagePreviewWidth",
  height: "$imagePreviewHeight",
  borderRadius: "$sm",
  boxShadow: "$level2",
  pointerEvents: "none",
  $inputStyle: "",
  backgroundSize: "cover",
  backgroundPosition: "center"
}), nre = Er("div", {
  fontSize: "0.8em",
  height: "100%",
  padding: "$rowGap $md"
}), rre = Er("div", {
  $flexCenter: "",
  top: "0",
  right: "0",
  marginRight: "$sm",
  height: "100%",
  cursor: "pointer",
  variants: {
    disabled: {
      true: {
        color: "$elevation3",
        cursor: "default"
      }
    }
  },
  "&::after,&::before": {
    content: '""',
    position: "absolute",
    height: 2,
    width: 10,
    borderRadius: 1,
    backgroundColor: "currentColor"
  },
  "&::after": {
    transform: "rotate(45deg)"
  },
  "&::before": {
    transform: "rotate(-45deg)"
  }
});
function ire() {
  const {
    label: n,
    value: e,
    onUpdate: t,
    disabled: r
  } = Pc(), {
    popinRef: a,
    wrapperRef: s,
    shown: u,
    show: h,
    hide: v
  } = $4(), y = le.useCallback((D) => {
    D.length && t(D[0]);
  }, [t]), _ = le.useCallback((D) => {
    D.stopPropagation(), t(void 0);
  }, [t]), {
    getRootProps: b,
    getInputProps: M,
    isDragAccept: C
  } = H4({
    maxFiles: 1,
    accept: "image/*",
    onDrop: y,
    disabled: r
  });
  return Ne.createElement(ap, {
    input: !0
  }, Ne.createElement(cm, null, n), Ne.createElement(Zne, null, Ne.createElement(ere, {
    ref: a,
    hasImage: !!e,
    onPointerDown: () => !!e && h(),
    onPointerUp: v,
    style: {
      backgroundImage: e ? `url(${e})` : "none"
    }
  }), u && !!e && Ne.createElement(jP, null, Ne.createElement(p4, {
    onPointerUp: v,
    style: {
      cursor: "pointer"
    }
  }), Ne.createElement(tre, {
    ref: s,
    style: {
      backgroundImage: `url(${e})`
    }
  })), Ne.createElement(Jne, b({
    isDragAccept: C
  }), Ne.createElement("input", M()), Ne.createElement(nre, null, C ? "drop image" : "click or drop")), Ne.createElement(rre, {
    onClick: _,
    disabled: !e
  })));
}
var are = Lr({
  component: ire
}, Qne);
const bI = hd().number(), ore = (n, e) => hd().array().length(2).every.number().test(n) && hd().schema({
  min: bI,
  max: bI
}).test(e), NR = (n) => ({
  min: n[0],
  max: n[1]
}), K4 = (n, {
  bounds: [e, t]
}, r) => {
  const a = Array.isArray(n) ? NR(n) : n, s = {
    min: r[0],
    max: r[1]
  }, {
    min: u,
    max: h
  } = Lr(Lr({}, s), a);
  return [y0(Number(u), e, Math.max(e, h)), y0(Number(h), Math.min(t, u), t)];
}, sre = ({
  value: n,
  min: e,
  max: t
}) => {
  const r = {
    min: e,
    max: t
  }, a = _4(NR(n), {
    min: r,
    max: r
  }), s = [e, t], u = Lr(Lr({}, a), {}, {
    bounds: s
  });
  return {
    value: K4(NR(n), u, n),
    settings: u
  };
};
var lre = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: ore,
  format: NR,
  sanitize: K4,
  normalize: sre
});
const ure = ["value", "bounds", "onDrag"], cre = ["bounds"], fre = Er("div", {
  display: "grid",
  columnGap: "$colGap",
  gridTemplateColumns: "auto calc($sizes$numberInputMinWidth * 2 + $space$rowGap)"
});
function dre(n) {
  let {
    value: e,
    bounds: [t, r],
    onDrag: a
  } = n, s = Za(n, ure);
  const u = le.useRef(null), h = le.useRef(null), v = le.useRef(null), y = le.useRef(0), _ = Ig("sizes", "scrubberWidth"), b = vM(({
    event: D,
    first: U,
    xy: [N],
    movement: [O],
    memo: I = {}
  }) => {
    if (U) {
      const {
        width: G,
        left: j
      } = u.current.getBoundingClientRect();
      y.current = G - parseFloat(_);
      const Y = (D == null ? void 0 : D.target) === h.current || (D == null ? void 0 : D.target) === v.current;
      I.pos = AR((N - j) / G, t, r);
      const Z = Math.abs(I.pos - e.min) - Math.abs(I.pos - e.max);
      I.key = Z < 0 || Z === 0 && I.pos <= e.min ? "min" : "max", Y && (I.pos = e[I.key]);
    }
    const k = I.pos + AR(O / y.current, 0, r - t);
    return a({
      [I.key]: jJ(k, s[I.key])
    }), I;
  }), M = `calc(${RR(e.min, t, r)} * (100% - ${_} - 8px) + 4px)`, C = `calc(${1 - RR(e.max, t, r)} * (100% - ${_} - 8px) + 4px)`;
  return Ne.createElement(y4, As({
    ref: u
  }, b()), Ne.createElement(g4, null, Ne.createElement(S4, {
    style: {
      left: M,
      right: C
    }
  })), Ne.createElement(bO, {
    position: "left",
    ref: h,
    style: {
      left: M
    }
  }), Ne.createElement(bO, {
    position: "right",
    ref: v,
    style: {
      right: C
    }
  }));
}
function hre() {
  const {
    label: n,
    displayValue: e,
    onUpdate: t,
    settings: r
  } = Pc(), a = Za(r, cre);
  return Ne.createElement(Ne.Fragment, null, Ne.createElement(ap, {
    input: !0
  }, Ne.createElement(cm, null, n), Ne.createElement(fre, null, Ne.createElement(dre, As({
    value: e
  }, r, {
    onDrag: t
  })), Ne.createElement(YP, {
    value: e,
    settings: a,
    onUpdate: t,
    innerLabelTrim: 0
  }))));
}
var pre = Lr({
  component: hre
}, lre);
const mre = () => {
  const n = /* @__PURE__ */ new Map();
  return {
    on: (e, t) => {
      let r = n.get(e);
      r === void 0 && (r = /* @__PURE__ */ new Set(), n.set(e, r)), r.add(t);
    },
    off: (e, t) => {
      const r = n.get(e);
      r !== void 0 && (r.delete(t), r.size === 0 && n.delete(e));
    },
    emit: (e, ...t) => {
      const r = n.get(e);
      if (r !== void 0)
        for (const a of r)
          a(...t);
    }
  };
}, vre = ["type", "value"], gre = ["onChange", "transient", "onEditStart", "onEditEnd"], yre = function() {
  const e = UB(qq(() => ({
    data: {}
  }))), t = mre();
  this.storeId = tJ(), this.useStore = e;
  const r = {}, a = /* @__PURE__ */ new Set();
  this.getVisiblePaths = () => {
    const u = this.getData(), h = Object.keys(u), v = [];
    Object.entries(r).forEach(([_, b]) => {
      b.render && h.some((M) => M.indexOf(_) === 0) && !b.render(this.get) && v.push(_ + ".");
    });
    const y = [];
    return a.forEach((_) => {
      _ in u && u[_].__refCount > 0 && v.every((b) => _.indexOf(b) === -1) && (!u[_].render || u[_].render(this.get)) && y.push(_);
    }), y;
  }, this.setOrderedPaths = (u) => {
    u.forEach((h) => a.add(h));
  }, this.orderPaths = (u) => (this.setOrderedPaths(u), u), this.disposePaths = (u) => {
    e.setState((h) => {
      const v = h.data;
      return u.forEach((y) => {
        if (y in v) {
          const _ = v[y];
          _.__refCount--, _.__refCount === 0 && _.type in tm && delete v[y];
        }
      }), {
        data: v
      };
    });
  }, this.dispose = () => {
    e.setState(() => ({
      data: {}
    }));
  }, this.getFolderSettings = (u) => r[u] || {}, this.getData = () => e.getState().data, this.addData = (u, h) => {
    e.setState((v) => {
      const y = v.data;
      return Object.entries(u).forEach(([_, b]) => {
        let M = y[_];
        if (M) {
          const {
            type: C,
            value: D
          } = b, U = Za(b, vre);
          C !== M.type ? Ng(is.INPUT_TYPE_OVERRIDE, C) : ((M.__refCount === 0 || h) && Object.assign(M, U), M.__refCount++);
        } else
          y[_] = Lr(Lr({}, b), {}, {
            __refCount: 1
          });
      }), {
        data: y
      };
    });
  }, this.setValueAtPath = (u, h, v) => {
    e.setState((y) => {
      const _ = y.data;
      return Yk(_[u], h, u, this, v), {
        data: _
      };
    });
  }, this.setSettingsAtPath = (u, h) => {
    e.setState((v) => {
      const y = v.data;
      return y[u].settings = Lr(Lr({}, y[u].settings), h), {
        data: y
      };
    });
  }, this.disableInputAtPath = (u, h) => {
    e.setState((v) => {
      const y = v.data;
      return y[u].disabled = h, {
        data: y
      };
    });
  }, this.set = (u, h) => {
    e.setState((v) => {
      const y = v.data;
      return Object.entries(u).forEach(([_, b]) => {
        try {
          Yk(y[_], b, void 0, void 0, h);
        } catch (M) {
          process.env.NODE_ENV === "development" && console.warn(`[This message will only show in development]: \`set\` for path ${_} has failed.`, M);
        }
      }), {
        data: y
      };
    });
  }, this.getInput = (u) => {
    try {
      return this.getData()[u];
    } catch {
      Ng(is.PATH_DOESNT_EXIST, u);
    }
  }, this.get = (u) => {
    var h;
    return (h = this.getInput(u)) === null || h === void 0 ? void 0 : h.value;
  }, this.emitOnEditStart = (u) => {
    t.emit(`onEditStart:${u}`, this.get(u), u, Lr(Lr({}, this.getInput(u)), {}, {
      get: this.get
    }));
  }, this.emitOnEditEnd = (u) => {
    t.emit(`onEditEnd:${u}`, this.get(u), u, Lr(Lr({}, this.getInput(u)), {}, {
      get: this.get
    }));
  }, this.subscribeToEditStart = (u, h) => {
    const v = `onEditStart:${u}`;
    return t.on(v, h), () => t.off(v, h);
  }, this.subscribeToEditEnd = (u, h) => {
    const v = `onEditEnd:${u}`;
    return t.on(v, h), () => t.off(v, h);
  };
  const s = (u, h, v) => {
    const y = {};
    return Object.entries(u).forEach(([_, b]) => {
      if (_ === "")
        return Ng(is.EMPTY_KEY);
      let M = eN(h, _);
      if (b.type === tm.FOLDER) {
        const C = s(b.schema, M, v);
        Object.assign(y, C), M in r || (r[M] = b.settings);
      } else if (_ in v)
        Ng(is.DUPLICATE_KEYS, _, M, v[_].path);
      else {
        const C = uJ(b, _, M, y);
        if (C) {
          const {
            type: D,
            options: U,
            input: N
          } = C, {
            onChange: O,
            transient: I,
            onEditStart: k,
            onEditEnd: G
          } = U, j = Za(U, gre);
          y[M] = Lr(Lr(Lr({
            type: D
          }, j), N), {}, {
            fromPanel: !0
          }), v[_] = {
            path: M,
            onChange: O,
            transient: I,
            onEditStart: k,
            onEditEnd: G
          };
        } else
          Ng(is.UNKNOWN_INPUT, M, b);
      }
    }), y;
  };
  this.getDataFromSchema = (u) => {
    const h = {};
    return [s(u, "", h), h];
  };
}, tN = new yre();
process.env.NODE_ENV === "development" && typeof window < "u" && (window.__STORE = tN);
const Sre = {
  collapsed: !1
};
function hT(n, e) {
  return {
    type: tm.FOLDER,
    schema: n,
    settings: Lr(Lr({}, Sre), e)
  };
}
const TI = (n) => "__levaInput" in n, xre = (n, e) => {
  const t = {}, r = e ? e.toLowerCase() : null;
  return n.forEach((a) => {
    const [s, u] = _ne(a);
    (!r || s.toLowerCase().indexOf(r) > -1) && xne(t, u, {
      [s]: {
        __levaInput: !0,
        path: a
      }
    });
  }), t;
}, _re = ["type", "label", "path", "valueKey", "value", "settings", "setValue", "disabled"];
function Ere(n) {
  let {
    type: e,
    label: t,
    path: r,
    valueKey: a,
    value: s,
    settings: u,
    setValue: h,
    disabled: v
  } = n, y = Za(n, _re);
  const {
    displayValue: _,
    onChange: b,
    onUpdate: M
  } = m4({
    type: e,
    value: s,
    settings: u,
    setValue: h
  }), C = hx[e].component;
  return C ? Ne.createElement(a4.Provider, {
    value: Lr({
      key: a,
      path: r,
      id: "" + r,
      label: t,
      displayValue: _,
      value: s,
      onChange: b,
      onUpdate: M,
      settings: u,
      setValue: h,
      disabled: v
    }, y)
  }, Ne.createElement(AJ, {
    disabled: v
  }, Ne.createElement(C, null))) : (Ng(is.NO_COMPONENT_FOR_TYPE, e, r), null);
}
const bre = Er("button", {
  display: "block",
  $reset: "",
  fontWeight: "$button",
  height: "$rowHeight",
  borderStyle: "none",
  borderRadius: "$sm",
  backgroundColor: "$elevation1",
  color: "$highlight1",
  "&:not(:disabled)": {
    color: "$highlight3",
    backgroundColor: "$accent2",
    cursor: "pointer",
    $hover: "$accent3",
    $active: "$accent3 $accent1",
    $focus: ""
  }
});
function Tre({
  onClick: n,
  settings: e,
  label: t
}) {
  const r = mM();
  return Ne.createElement(ap, null, Ne.createElement(bre, {
    disabled: e.disabled,
    onClick: () => n(r.get)
  }, t));
}
const Mre = Er("div", {
  $flex: "",
  justifyContent: "flex-end",
  gap: "$colGap"
}), wre = Er("button", {
  $reset: "",
  cursor: "pointer",
  borderRadius: "$xs",
  "&:hover": {
    backgroundColor: "$elevation3"
  }
}), Cre = ({
  label: n,
  opts: e
}) => {
  let t = typeof n == "string" && n.trim() === "" ? null : n, r = e;
  return typeof e.opts == "object" && (r.label !== void 0 && (t = e.label), r = e.opts), {
    label: t,
    opts: r
  };
};
function Rre(n) {
  const {
    label: e,
    opts: t
  } = Cre(n), r = mM();
  return Ne.createElement(ap, {
    input: !!e
  }, e && Ne.createElement(cm, null, e), Ne.createElement(Mre, null, Object.entries(t).map(([a, s]) => Ne.createElement(wre, {
    key: a,
    onClick: () => s(r.get)
  }, a))));
}
const Are = Er("canvas", {
  height: "$monitorHeight",
  width: "100%",
  display: "block",
  borderRadius: "$sm"
}), Q4 = 100;
function Dre(n, e) {
  n.push(e), n.length > Q4 && n.shift();
}
const Lre = le.forwardRef(function({
  initialValue: n
}, e) {
  const t = Ig("colors", "highlight3"), r = Ig("colors", "elevation2"), a = Ig("colors", "highlight1"), [s, u] = le.useMemo(() => [_f(a).alpha(0.4).toRgbString(), _f(a).alpha(0.1).toRgbString()], [a]), h = le.useRef([n]), v = le.useRef(n), y = le.useRef(n), _ = le.useRef(), b = le.useCallback((D, U) => {
    if (!D)
      return;
    const {
      width: N,
      height: O
    } = D, I = new Path2D(), k = N / Q4, G = O * 0.05;
    for (let Z = 0; Z < h.current.length; Z++) {
      const te = RR(h.current[Z], v.current, y.current), J = k * Z, q = O - te * (O - G * 2) - G;
      I.lineTo(J, q);
    }
    U.clearRect(0, 0, N, O);
    const j = new Path2D(I);
    j.lineTo(k * (h.current.length + 1), O), j.lineTo(0, O), j.lineTo(0, 0);
    const Y = U.createLinearGradient(0, 0, 0, O);
    Y.addColorStop(0, s), Y.addColorStop(1, u), U.fillStyle = Y, U.fill(j), U.strokeStyle = r, U.lineJoin = "round", U.lineWidth = 14, U.stroke(I), U.strokeStyle = t, U.lineWidth = 2, U.stroke(I);
  }, [t, r, s, u]), [M, C] = IJ(b);
  return le.useImperativeHandle(e, () => ({
    frame: (D) => {
      (v.current === void 0 || D < v.current) && (v.current = D), (y.current === void 0 || D > y.current) && (y.current = D), Dre(h.current, D), _.current = requestAnimationFrame(() => b(M.current, C.current));
    }
  }), [M, C, b]), le.useEffect(() => () => cancelAnimationFrame(_.current), []), Ne.createElement(Are, {
    ref: M
  });
}), MI = (n) => Number.isFinite(n) ? n.toPrecision(2) : n.toString(), Ore = le.forwardRef(function({
  initialValue: n
}, e) {
  const [t, r] = le.useState(MI(n));
  return le.useImperativeHandle(e, () => ({
    frame: (a) => r(MI(a))
  }), []), Ne.createElement("div", null, t);
});
function wI(n) {
  return typeof n == "function" ? n() : n.current;
}
function Pre({
  label: n,
  objectOrFn: e,
  settings: t
}) {
  const r = le.useRef(), a = le.useRef(wI(e));
  return le.useEffect(() => {
    const s = window.setInterval(() => {
      var u;
      document.hidden || (u = r.current) === null || u === void 0 || u.frame(wI(e));
    }, t.interval);
    return () => window.clearInterval(s);
  }, [e, t.interval]), Ne.createElement(ap, {
    input: !0
  }, Ne.createElement(cm, {
    align: "top"
  }, n), t.graph ? Ne.createElement(Lre, {
    ref: r,
    initialValue: a.current
  }) : Ne.createElement(Ore, {
    ref: r,
    initialValue: a.current
  }));
}
const Nre = ["type", "label", "key"], Ure = {
  [tm.BUTTON]: Tre,
  [tm.BUTTON_GROUP]: Rre,
  [tm.MONITOR]: Pre
}, zre = Ne.memo(({
  path: n
}) => {
  const [e, {
    set: t,
    setSettings: r,
    disable: a,
    storeId: s,
    emitOnEditStart: u,
    emitOnEditEnd: h
  }] = BJ(n);
  if (!e)
    return null;
  const {
    type: v,
    label: y,
    key: _
  } = e, b = Za(e, Nre);
  if (v in tm) {
    const M = Ure[v];
    return Ne.createElement(M, As({
      label: y,
      path: n
    }, b));
  }
  return v in hx ? Ne.createElement(Ere, As({
    key: s + n,
    type: v,
    label: y,
    storeId: s,
    path: n,
    valueKey: _,
    setValue: t,
    setSettings: r,
    disable: a,
    emitOnEditStart: u,
    emitOnEditEnd: h
  }, b)) : (YZ(is.UNSUPPORTED_INPUT, v, n), null);
});
function kre({
  toggle: n,
  toggled: e,
  name: t
}) {
  return Ne.createElement(wJ, {
    onClick: () => n()
  }, Ne.createElement($P, {
    toggled: e
  }), Ne.createElement("div", null, t));
}
const Ire = ({
  name: n,
  path: e,
  tree: t
}) => {
  const r = mM(), a = eN(e, n), {
    collapsed: s,
    color: u
  } = r.getFolderSettings(a), [h, v] = le.useState(!s), y = le.useRef(null), _ = Ig("colors", "folderWidgetColor"), b = Ig("colors", "folderTextColor");
  return le.useLayoutEffect(() => {
    y.current.style.setProperty("--leva-colors-folderWidgetColor", u || _), y.current.style.setProperty("--leva-colors-folderTextColor", u || b);
  }, [u, _, b]), Ne.createElement(DR, {
    ref: y
  }, Ne.createElement(kre, {
    name: n,
    toggled: h,
    toggle: () => v((M) => !M)
  }), Ne.createElement(Z4, {
    parent: a,
    tree: t,
    toggled: h
  }));
}, Z4 = Ne.memo(({
  isRoot: n = !1,
  fill: e = !1,
  flat: t = !1,
  parent: r,
  tree: a,
  toggled: s
}) => {
  const {
    wrapperRef: u,
    contentRef: h
  } = Tne(s), v = mM(), y = ([b, M]) => {
    var C;
    return (TI(M) ? (C = v.getInput(M.path)) === null || C === void 0 ? void 0 : C.order : v.getFolderSettings(eN(r, b)).order) || 0;
  }, _ = Object.entries(a).sort((b, M) => y(b) - y(M));
  return Ne.createElement(_O, {
    ref: u,
    isRoot: n,
    fill: e,
    flat: t
  }, Ne.createElement(f4, {
    ref: h,
    isRoot: n,
    toggled: s
  }, _.map(([b, M]) => TI(M) ? Ne.createElement(zre, {
    key: M.path,
    valueKey: M.valueKey,
    path: M.path
  }) : Ne.createElement(Ire, {
    key: b,
    name: b,
    path: r,
    tree: M
  }))));
}), Fre = Er("div", {
  position: "relative",
  fontFamily: "$mono",
  fontSize: "$root",
  color: "$rootText",
  backgroundColor: "$elevation1",
  variants: {
    fill: {
      false: {
        position: "fixed",
        top: "10px",
        right: "10px",
        zIndex: 1e3,
        width: "$rootWidth"
      },
      true: {
        position: "relative",
        width: "100%"
      }
    },
    flat: {
      false: {
        borderRadius: "$lg",
        boxShadow: "$level1"
      }
    },
    oneLineLabels: {
      true: {
        [`${h4}`]: {
          gridTemplateColumns: "auto",
          gridAutoColumns: "minmax(max-content, 1fr)",
          gridAutoRows: "minmax($sizes$rowHeight), auto)",
          rowGap: 0,
          columnGap: 0,
          marginTop: "$rowGap"
        }
      }
    },
    hideTitleBar: {
      true: {
        $$titleBarHeight: "0px"
      },
      false: {
        $$titleBarHeight: "$sizes$titleBarHeight"
      }
    }
  },
  "&,*,*:after,*:before": {
    boxSizing: "border-box"
  },
  "*::selection": {
    backgroundColor: "$accent2"
  }
}), J4 = 40, UR = Er("i", {
  $flexCenter: "",
  width: J4,
  userSelect: "none",
  cursor: "pointer",
  "> svg": {
    fill: "$highlight1",
    transition: "transform 350ms ease, fill 250ms ease"
  },
  "&:hover > svg": {
    fill: "$highlight3"
  },
  variants: {
    active: {
      true: {
        "> svg": {
          fill: "$highlight2"
        }
      }
    }
  }
}), Bre = Er("div", {
  display: "flex",
  alignItems: "stretch",
  justifyContent: "space-between",
  height: "$titleBarHeight",
  variants: {
    mode: {
      drag: {
        cursor: "grab"
      }
    }
  }
}), Hre = Er("div", {
  $flex: "",
  position: "relative",
  width: "100%",
  overflow: "hidden",
  transition: "height 250ms ease",
  color: "$highlight3",
  paddingLeft: "$md",
  [`> ${UR}`]: {
    height: 30
  },
  variants: {
    toggled: {
      true: {
        height: 30
      },
      false: {
        height: 0
      }
    }
  }
}), Vre = Er("input", {
  $reset: "",
  flex: 1,
  position: "relative",
  height: 30,
  width: "100%",
  backgroundColor: "transparent",
  fontSize: "10px",
  borderRadius: "$root",
  "&:focus": {},
  "&::placeholder": {
    color: "$highlight2"
  }
}), Gre = Er("div", {
  touchAction: "none",
  $flexCenter: "",
  flex: 1,
  "> svg": {
    fill: "$highlight1"
  },
  color: "$highlight1",
  variants: {
    drag: {
      true: {
        $draggable: "",
        "> svg": {
          transition: "fill 250ms ease"
        },
        "&:hover": {
          color: "$highlight3"
        },
        "&:hover > svg": {
          fill: "$highlight3"
        }
      }
    },
    filterEnabled: {
      false: {
        paddingRight: J4
      }
    }
  }
}), Wre = Ne.forwardRef(({
  setFilter: n,
  toggle: e
}, t) => {
  const [r, a] = le.useState(""), s = le.useMemo(() => JH(n, 250), [n]), u = () => {
    n(""), a("");
  }, h = (v) => {
    const y = v.currentTarget.value;
    e(!0), a(y);
  };
  return le.useEffect(() => {
    s(r);
  }, [r, s]), Ne.createElement(Ne.Fragment, null, Ne.createElement(Vre, {
    ref: t,
    value: r,
    placeholder: "[Open filter with CMD+SHIFT+L]",
    onPointerDown: (v) => v.stopPropagation(),
    onChange: h
  }), Ne.createElement(UR, {
    onClick: () => u(),
    style: {
      visibility: r ? "visible" : "hidden"
    }
  }, Ne.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    height: "14",
    width: "14",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, Ne.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",
    clipRule: "evenodd"
  }))));
});
function jre({
  setFilter: n,
  onDrag: e,
  onDragStart: t,
  onDragEnd: r,
  toggle: a,
  toggled: s,
  title: u,
  drag: h,
  filterEnabled: v,
  from: y
}) {
  const [_, b] = le.useState(!1), M = le.useRef(null);
  le.useEffect(() => {
    var D, U;
    _ ? (D = M.current) === null || D === void 0 || D.focus() : (U = M.current) === null || U === void 0 || U.blur();
  }, [_]);
  const C = vM(({
    offset: [D, U],
    first: N,
    last: O
  }) => {
    e({
      x: D,
      y: U
    }), N && t({
      x: D,
      y: U
    }), O && r({
      x: D,
      y: U
    });
  }, {
    filterTaps: !0,
    from: ({
      offset: [D, U]
    }) => [(y == null ? void 0 : y.x) || D, (y == null ? void 0 : y.y) || U]
  });
  return le.useEffect(() => {
    const D = (U) => {
      U.key === "L" && U.shiftKey && U.metaKey && b((N) => !N);
    };
    return window.addEventListener("keydown", D), () => window.removeEventListener("keydown", D);
  }, []), Ne.createElement(Ne.Fragment, null, Ne.createElement(Bre, {
    mode: h ? "drag" : void 0
  }, Ne.createElement(UR, {
    active: !s,
    onClick: () => a()
  }, Ne.createElement($P, {
    toggled: s,
    width: 12,
    height: 8
  })), Ne.createElement(Gre, As({}, h ? C() : {}, {
    drag: h,
    filterEnabled: v
  }), u === void 0 && h ? Ne.createElement("svg", {
    width: "20",
    height: "10",
    viewBox: "0 0 28 14",
    xmlns: "http://www.w3.org/2000/svg"
  }, Ne.createElement("circle", {
    cx: "2",
    cy: "2",
    r: "2"
  }), Ne.createElement("circle", {
    cx: "14",
    cy: "2",
    r: "2"
  }), Ne.createElement("circle", {
    cx: "26",
    cy: "2",
    r: "2"
  }), Ne.createElement("circle", {
    cx: "2",
    cy: "12",
    r: "2"
  }), Ne.createElement("circle", {
    cx: "14",
    cy: "12",
    r: "2"
  }), Ne.createElement("circle", {
    cx: "26",
    cy: "12",
    r: "2"
  })) : u), v && Ne.createElement(UR, {
    active: _,
    onClick: () => b((D) => !D)
  }, Ne.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    height: "20",
    viewBox: "0 0 20 20"
  }, Ne.createElement("path", {
    d: "M9 9a2 2 0 114 0 2 2 0 01-4 0z"
  }), Ne.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a4 4 0 00-3.446 6.032l-2.261 2.26a1 1 0 101.414 1.415l2.261-2.261A4 4 0 1011 5z",
    clipRule: "evenodd"
  })))), Ne.createElement(Hre, {
    toggled: _
  }, Ne.createElement(Wre, {
    ref: M,
    setFilter: n,
    toggle: a
  })));
}
const $re = ["store", "hidden", "theme", "collapsed"];
function Yre(n) {
  let {
    store: e,
    hidden: t = !1,
    theme: r,
    collapsed: a = !1
  } = n, s = Za(n, $re);
  const u = j4(() => xJ(r), [r]), [h, v] = le.useState(!a), y = typeof a == "object" ? !a.collapsed : h, _ = le.useMemo(() => typeof a == "object" ? (b) => {
    typeof b == "function" ? a.onChange(!b(!a.collapsed)) : a.onChange(!b);
  } : v, [a]);
  return !e || t ? null : Ne.createElement(GP.Provider, {
    value: u
  }, Ne.createElement(Xre, As({
    store: e
  }, s, {
    toggled: y,
    setToggle: _,
    rootClass: u.className
  })));
}
const Xre = Ne.memo(({
  store: n,
  rootClass: e,
  fill: t = !1,
  flat: r = !1,
  neverHide: a = !1,
  oneLineLabels: s = !1,
  titleBar: u = {
    title: void 0,
    drag: !0,
    filter: !0,
    position: void 0,
    onDrag: void 0,
    onDragStart: void 0,
    onDragEnd: void 0
  },
  hideCopyButton: h = !1,
  toggled: v,
  setToggle: y
}) => {
  var _, b;
  const M = Mne(n), [C, D] = le.useState(""), U = le.useMemo(() => xre(M, C), [M, C]), [N, O] = v4(), I = a || M.length > 0, k = typeof u == "object" && u.title || void 0, G = typeof u == "object" && (_ = u.drag) !== null && _ !== void 0 ? _ : !0, j = typeof u == "object" && (b = u.filter) !== null && b !== void 0 ? b : !0, Y = typeof u == "object" && u.position || void 0, Z = typeof u == "object" && u.onDrag || void 0, te = typeof u == "object" && u.onDragStart || void 0, J = typeof u == "object" && u.onDragEnd || void 0;
  return Ne.useEffect(() => {
    O({
      x: Y == null ? void 0 : Y.x,
      y: Y == null ? void 0 : Y.y
    });
  }, [Y, O]), SJ(), Ne.createElement(s4.Provider, {
    value: {
      hideCopyButton: h
    }
  }, Ne.createElement(Fre, {
    ref: N,
    className: e,
    fill: t,
    flat: r,
    oneLineLabels: s,
    hideTitleBar: !u,
    style: {
      display: I ? "block" : "none"
    }
  }, u && Ne.createElement(jre, {
    onDrag: (q) => {
      O(q), Z == null || Z(q);
    },
    onDragStart: (q) => te == null ? void 0 : te(q),
    onDragEnd: (q) => J == null ? void 0 : J(q),
    setFilter: D,
    toggle: (q) => y((oe) => q ?? !oe),
    toggled: v,
    title: k,
    drag: G,
    filterEnabled: j,
    from: Y
  }), I && Ne.createElement(o4.Provider, {
    value: n
  }, Ne.createElement(Z4, {
    isRoot: !0,
    fill: t,
    flat: r,
    tree: U,
    toggled: v
  }))));
}), qre = ["isRoot"];
let zR = !1, ex = null;
function eV(n) {
  let {
    isRoot: e = !1
  } = n, t = Za(n, qre);
  return le.useEffect(() => (zR = !0, !e && ex && (ex.remove(), ex = null), () => {
    e || (zR = !1);
  }), [e]), Ne.createElement(Yre, As({
    store: tN
  }, t));
}
function Kre(n) {
  le.useEffect(() => {
    n && !zR && (ex || (ex = document.getElementById("leva__root") || Object.assign(document.createElement("div"), {
      id: "leva__root"
    }), document.body && (document.body.appendChild(ex), fJ(Ne.createElement(eV, {
      isRoot: !0
    }), ex))), zR = !0);
  }, [n]);
}
function Qre(n, e, t, r, a) {
  let s, u, h, v, y;
  return typeof n == "string" ? (u = n, s = e, Array.isArray(t) ? y = t : t && ("store" in t ? (v = t, y = r) : (h = t, Array.isArray(r) ? y = r : (v = r, y = a)))) : (s = n, Array.isArray(e) ? y = e : (v = e, y = t)), {
    schema: s,
    folderName: u,
    folderSettings: h,
    hookSettings: v,
    deps: y || []
  };
}
function Zre(n, e, t, r, a) {
  const {
    folderName: s,
    schema: u,
    folderSettings: h,
    hookSettings: v,
    deps: y
  } = Qre(n, e, t, r, a), _ = typeof u == "function", b = le.useRef(!1), M = le.useRef(!0), C = j4(() => {
    b.current = !0;
    const oe = typeof u == "function" ? u() : u;
    return s ? {
      [s]: hT(oe, h)
    } : oe;
  }, y), D = !(v != null && v.store);
  Kre(D);
  const [U] = le.useState(() => (v == null ? void 0 : v.store) || tN), [N, O] = le.useMemo(() => U.getDataFromSchema(C), [U, C]), [I, k, G, j, Y] = le.useMemo(() => {
    const oe = [], ye = [], de = {}, xe = {}, Re = {};
    return Object.values(O).forEach(({
      path: Pe,
      onChange: Te,
      onEditStart: ue,
      onEditEnd: we,
      transient: X
    }) => {
      oe.push(Pe), Te ? (de[Pe] = Te, X || ye.push(Pe)) : ye.push(Pe), ue && (xe[Pe] = ue), we && (Re[Pe] = we);
    }), [oe, ye, de, xe, Re];
  }, [O]), Z = le.useMemo(() => U.orderPaths(I), [I, U]), te = wne(U, k, N), J = le.useCallback((oe) => {
    const ye = Object.entries(oe).reduce((de, [xe, Re]) => Object.assign(de, {
      [O[xe].path]: Re
    }), {});
    U.set(ye, !1);
  }, [U, O]), q = le.useCallback((oe) => U.get(O[oe].path), [U, O]);
  return le.useEffect(() => {
    const oe = !M.current && b.current;
    return U.addData(N, oe), M.current = !1, b.current = !1, () => U.disposePaths(Z);
  }, [U, Z, N]), le.useEffect(() => {
    const oe = [];
    return Object.entries(G).forEach(([ye, de]) => {
      de(U.get(ye), ye, Lr({
        initial: !0,
        get: U.get
      }, U.getInput(ye)));
      const xe = U.useStore.subscribe((Re) => {
        const Pe = Re.data[ye];
        return [Pe.disabled ? void 0 : Pe.value, Pe];
      }, ([Re, Pe]) => de(Re, ye, Lr({
        initial: !1,
        get: U.get
      }, Pe)), {
        equalityFn: hM
      });
      oe.push(xe);
    }), () => oe.forEach((ye) => ye());
  }, [U, G]), le.useEffect(() => {
    const oe = [];
    return Object.entries(j).forEach(([ye, de]) => oe.push(U.subscribeToEditStart(ye, de))), Object.entries(Y).forEach(([ye, de]) => oe.push(U.subscribeToEditEnd(ye, de))), () => oe.forEach((ye) => ye());
  }, [j, Y, U]), _ ? [te, J, q] : te;
}
$g(om.SELECT, ree);
$g(om.IMAGE, are);
$g(om.NUMBER, YJ);
$g(om.COLOR, kne);
$g(om.STRING, dee);
$g(om.BOOLEAN, See);
$g(om.INTERVAL, pre);
$g(om.VECTOR3D, Fne);
$g(om.VECTOR2D, Yne);
function Jre(n = 64) {
  const e = document.createElement("canvas");
  e.width = n, e.height = n;
  const t = e.getContext("2d");
  return t ? (t.beginPath(), t.arc(n / 2, n / 2, n / 2, 0, Math.PI * 2), t.fillStyle = "white", t.fill(), new QF(e)) : null;
}
function eie(n, e = 4, t = 1) {
  const r = new Float32Array(n * 3);
  for (let a = 0; a < n; a++) {
    const s = Math.random() * Math.PI * 2, u = Math.random() * Math.PI * 2;
    r.set(
      [(e + t * Math.cos(u)) * Math.cos(s), (e + t * Math.cos(u)) * Math.sin(s), t * Math.sin(u)],
      a * 3
    );
  }
  return r;
}
function tie(n, e = 5) {
  const t = new Float32Array(n * 3);
  for (let r = 0; r < n; r++) {
    const a = Math.random() * Math.PI * 2, s = Math.acos(2 * Math.random() - 1);
    t.set([e * Math.sin(s) * Math.cos(a), e * Math.sin(s) * Math.sin(a), e * Math.cos(s)], r * 3);
  }
  return t;
}
function nie(n, e = 5) {
  const t = new Float32Array(n * 3);
  for (let r = 0; r < n; r++) {
    const a = Math.random() * Math.PI * 2, s = Math.acos(2 * Math.random() - 1);
    t.set([e * Math.sin(s) * Math.cos(a), e * Math.sin(s) * Math.sin(a), e * Math.cos(s)], r * 3);
  }
  return t;
}
function rie(n, e = 6) {
  const t = new Float32Array(n * 3);
  for (let r = 0; r < n; r++)
    t.set([(Math.random() - 0.5) * e, (Math.random() - 0.5) * e, (Math.random() - 0.5) * e], r * 3);
  return t;
}
function iie(n, e = 1.7, t = 3, r = 2.1, a = 1) {
  const s = new Float32Array(n * 3);
  for (let u = 0; u < n; u++) {
    const h = Math.random() * Math.PI * 2, v = Math.random() * Math.PI * 2, y = Math.cos(a * v), _ = Math.sin(a * h), b = Math.cos(r * h), M = Math.sin(r * h), C = (e + t * y) * b, D = (e + t * y) * M, U = t * _;
    s.set([C, D, U], u * 2.7);
  }
  return s;
}
function aie(n, e = 1.7, t = 3, r = 3, a = 3) {
  const s = new Float32Array(n * 3);
  for (let u = 0; u < n; u++) {
    const h = Math.random() * Math.PI * 2, v = Math.random() * Math.PI * 2, y = Math.cos(a * v), _ = Math.sin(a * h), b = Math.cos(r * h), M = Math.sin(r * h), C = (e + t * y) * b, D = (e + t * y) * M, U = t * _;
    s.set([C, D, U], u * 3);
  }
  return s;
}
function oie(n, e = 3, t = 4) {
  const r = new Float32Array(n * 3);
  for (let a = 0; a < n; a++) {
    const s = Math.random() * Math.PI * 2, u = (Math.random() - 0.15) * t, h = (e + u * Math.cos(s / 2)) * Math.cos(s), v = (e + u * Math.cos(s / 2)) * Math.sin(s), y = u * Math.sin(s / 2);
    r.set([h, v, y], a * 2.9);
  }
  return r;
}
function sie(n, e = 7) {
  const t = new Float32Array(n * 3);
  for (let r = 0; r < n; r++) {
    const a = Math.random() * Math.PI * 2, s = e * Math.cos(a) - 2 * Math.cos(1 * a), u = -Math.sin(3 * a);
    t.set([s, u], r * 1.5);
  }
  return t;
}
function lie({ count: n, shapeType: e, particleSize: t, particleColor: r, interactions: a, movement: s }) {
  const u = new Un(r), h = le.useRef(new Float32Array(n * 3)), v = le.useRef(new Float32Array(n * 3)), y = {
    TorusKnot: aie,
    Torus: eie,
    Icosahedron: tie,
    Sphere: nie,
    Box: rie,
    MobiusStrip: oie,
    TrefoilKnot: sie,
    Cloud: iie
  }, [_, b] = le.useMemo(() => {
    const k = new Float32Array(n * 3), G = new Float32Array(n * 3), j = y[e], Y = j(n);
    k.set(Y), v.current.set(Y);
    for (let Z = 0; Z < n; Z++)
      u.toArray(G, Z * 3), h.current[Z * 3 + 0] = (Math.random() - 0.5) * s.speed, h.current[Z * 3 + 1] = (Math.random() - 0.5) * s.speed, h.current[Z * 3 + 2] = (Math.random() - 0.5) * s.speed;
    return [k, G];
  }, [n, e, r, s.speed]), M = le.useRef(null), C = le.useRef(new It()), D = le.useRef(new wP()), U = le.useRef(new be()), N = le.useRef(new pv()), O = le.useRef(new be()), I = le.useMemo(() => Jre(), []);
  return RP((k) => {
    C.current.set(k.mouse.x, k.mouse.y), D.current.setFromCamera(C.current, k.camera), k.camera.getWorldDirection(U.current).normalize(), N.current.setFromNormalAndCoplanarPoint(U.current, new be(0, 0, 0)), D.current.ray.intersectPlane(N.current, O.current);
    const G = s.damping, j = s.returnForce, Y = s.maxVelocity;
    for (let Z = 0; Z < n; Z++) {
      const te = Z * 3, J = _[te], q = _[te + 1], oe = _[te + 2], ye = J - O.current.x, de = q - O.current.y, xe = oe - O.current.z, Re = Math.sqrt(ye * ye + de * de + xe * xe);
      let Pe = 0;
      if (Re < a.big_repulse.distance ? Pe = a.big_repulse.strength / (Re * Re) : Re < a.repulse.distance && (Pe = a.repulse.strength / (Re * Re)), Pe > 0) {
        const X = ye / Re, me = de / Re, ce = xe / Re;
        h.current[te] += X * Pe, h.current[te + 1] += me * Pe, h.current[te + 2] += ce * Pe;
      }
      h.current[te] *= G, h.current[te + 1] *= G, h.current[te + 2] *= G;
      const Te = v.current[te], ue = v.current[te + 1], we = v.current[te + 2];
      h.current[te] += (Te - J) * j, h.current[te + 1] += (ue - q) * j, h.current[te + 2] += (we - oe) * j, s.restless.enabled && (h.current[te] += (Math.random() - 0.5) * s.restless.value, h.current[te + 1] += (Math.random() - 0.5) * s.restless.value, h.current[te + 2] += (Math.random() - 0.5) * s.restless.value), h.current[te] = Math.max(Math.min(h.current[te], Y), -Y), h.current[te + 1] = Math.max(Math.min(h.current[te + 1], Y), -Y), h.current[te + 2] = Math.max(Math.min(h.current[te + 2], Y), -Y), _[te] += h.current[te], _[te + 1] += h.current[te + 1], _[te + 2] += h.current[te + 2];
    }
    M.current.geometry.attributes.position.needsUpdate = !0;
  }), /* @__PURE__ */ Or.jsxs("points", { ref: M, children: [
    /* @__PURE__ */ Or.jsxs("bufferGeometry", { children: [
      /* @__PURE__ */ Or.jsx("bufferAttribute", { attach: "attributes-position", args: [_, 3] }),
      /* @__PURE__ */ Or.jsx("bufferAttribute", { attach: "attributes-color", args: [b, 3] })
    ] }),
    /* @__PURE__ */ Or.jsx(
      "pointsMaterial",
      {
        attach: "material",
        size: t,
        sizeAttenuation: !0,
        map: I,
        alphaTest: 0.5,
        transparent: !0,
        vertexColors: !0,
        opacity: 1
      }
    )
  ] });
}
function uie() {
  const {
    shapeType: n,
    particleCount: e,
    particleSize: t,
    particleColor: r,
    backgroundColor: a,
    autoRotateSpeed: s,
    fogColor: u,
    fogNear: h,
    fogFar: v,
    repulseDistance: y,
    repulseStrength: _,
    bigRepulseDistance: b,
    bigRepulseStrength: M,
    speed: C,
    damping: D,
    returnForce: U,
    maxVelocity: N,
    restlessEnabled: O,
    restlessValue: I,
    enableZoom: k,
    showCursor: G
  } = Zre(
    {
      "Parmetros de Forma": hT(
        {
          shapeType: {
            label: "Tipo de forma",
            value: "MobiusStrip",
            options: {
              TorusKnot: "TorusKnot",
              Torus: "Torus",
              Icosaedro: "Icosahedron",
              Esfera: "Sphere",
              Caixa: "Box",
              Abstrato: "Cloud",
              "Fita de Mbius": "MobiusStrip",
              "N Trevo": "TrefoilKnot"
            }
          },
          particleCount: {
            label: "Nmero de partculas",
            value: 1e4,
            min: 1e3,
            max: 2e4,
            step: 1e3
          },
          particleSize: {
            label: "Tamanho da partcula",
            value: 0.03,
            min: 0.01,
            max: 0.1,
            step: 5e-3
          },
          particleColor: {
            label: "Cor da partcula",
            value: "#030303"
          },
          backgroundColor: {
            label: "Cor de fundo",
            value: "#eeeeee"
          }
        },
        { collapsed: !1 }
      ),
      "Parmetros de Cmera": hT(
        {
          autoRotateSpeed: {
            label: "Velocidade de rotao automtica",
            value: 0.9,
            min: 0,
            max: 5,
            step: 0.1
          },
          fogColor: {
            label: "Cor da nvoa",
            value: "#c1c1c1"
          },
          fogNear: {
            label: "Nvoa perto",
            value: 8.2,
            min: 0,
            max: 20,
            step: 0.1
          },
          fogFar: {
            label: "Nvoa longe",
            value: 5.2,
            min: 0,
            max: 50,
            step: 0.1
          },
          enableZoom: {
            label: "Habilitar Zoom",
            value: !1
          },
          showCursor: {
            label: "Mostrar Cursor",
            value: !0
          }
        },
        { collapsed: !0 }
      ),
      Interaes: hT(
        {
          repulseDistance: {
            label: "Distncia de repulso",
            value: 15,
            min: 0,
            max: 50,
            step: 1
          },
          repulseStrength: {
            label: "Fora de repulso",
            value: 3.5,
            min: 0,
            max: 20,
            step: 0.5
          },
          bigRepulseDistance: {
            label: "Distncia de grande repulso",
            value: 17,
            min: 0,
            max: 50,
            step: 1
          },
          bigRepulseStrength: {
            label: "Fora de grande repulso",
            value: 10,
            min: 0,
            max: 50,
            step: 1
          }
        },
        { collapsed: !1 }
      ),
      Movimento: hT(
        {
          speed: {
            label: "Velocidade",
            value: 0.1,
            min: 0,
            max: 1,
            step: 0.01
          },
          damping: {
            label: "Amortecimento",
            value: 0.09,
            min: 0,
            max: 1,
            step: 5e-3
          },
          returnForce: {
            label: "Fora de retorno",
            value: 0.04,
            min: 0,
            max: 0.1,
            step: 1e-3
          },
          maxVelocity: {
            label: "Velocidade mxima",
            value: 1,
            min: 0,
            max: 10,
            step: 0.1
          },
          restlessEnabled: {
            label: "Inquieto",
            value: !0
          },
          restlessValue: {
            label: "Valor de inquietao",
            value: 0.01,
            min: 0,
            max: 0.1,
            step: 1e-3
          }
        },
        { collapsed: !1 }
      )
    },
    { collapsed: !1 }
  ), j = {
    repulse: {
      distance: y,
      strength: _
    },
    big_repulse: {
      distance: b,
      strength: M
    }
  }, Y = {
    speed: C,
    damping: D,
    returnForce: U,
    maxVelocity: N,
    restless: {
      enabled: O,
      value: I
    }
  };
  return /* @__PURE__ */ Or.jsxs(Or.Fragment, { children: [
    /* @__PURE__ */ Or.jsx(
      eV,
      {
        collapsed: !1,
        theme: {
          sizes: {
            rootWidth: "400px",
            // Adjust the main panel width
            controlWidth: "200px"
            // Adjust the controls width
          }
        }
      }
    ),
    /* @__PURE__ */ Or.jsxs(
      rq,
      {
        dpr: [1, 2],
        camera: { position: [0, 0, 10], fov: 90 },
        style: {
          background: a,
          cursor: G ? "default" : "none"
          // Toggles cursor visibility
        },
        children: [
          /* @__PURE__ */ Or.jsx("fog", { attach: "fog", args: [u, h, v] }),
          /* @__PURE__ */ Or.jsx(
            lie,
            {
              count: e,
              shapeType: n,
              particleSize: t,
              particleColor: r,
              interactions: j,
              movement: Y
            }
          ),
          /* @__PURE__ */ Or.jsx(
            nK,
            {
              makeDefault: !0,
              enableZoom: k,
              enablePan: !1,
              autoRotate: !0,
              autoRotateSpeed: s
            }
          ),
          /* @__PURE__ */ Or.jsx(rK, { yawFrequency: 0.13, maxYaw: 1, pitchFrequency: 1, maxPitch: 0.1, rollFrequency: 0, maxRoll: 1, intensity: 0.2 })
        ]
      }
    )
  ] });
}
vL(document.getElementById("root")).render(
  /* @__PURE__ */ Or.jsx(Or.Fragment, { children: /* @__PURE__ */ Or.jsx(uie, {}) })
);
